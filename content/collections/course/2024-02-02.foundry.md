---
id: ec5bc4d6-9638-48da-a92a-d956a4b38003
blueprint: course
title: 'Foundry Fundamentals'
updated_at: 1716973748
github_url: 'https://github.com/Cyfrin/path-solidity-developer-2023'
duration: 10
description: 'Already know Solidity? Your next step is Foundry! Learn how to manage your dependencies, compile your project, run tests, deploy, and interact with your from the command-line and via Solidity scripts.'
overview: 'Foundry introduction, smart contracts development, oracles, smart contracts testing, intengration testing, forge test, local smart contracts deployment'
preRequisites: |-
  Blockchain basics
  Solidity fundamentals
authors:
  - 8c756cc1-2d8a-41aa-9578-0ad4af9fbef3
  - 577641e9-be7f-4191-9ad6-68f429200f8e
  - 3c99d66e-01d3-4164-a101-558aa67f645d
sections:
  -
    id: hncSFvCg
    title: 'Foundry Simple Storage'
    slug: foundry-simple-storage
    lessons:
      -
        id: 1583c486-11aa-4273-96e4-69f0b1f86392
        type: new_lesson
        enabled: true
        title: 'Introduction - Foundry simple storage'
        slug: introduction-foundry-simple-storage
        duration: 7
        video_url: FF102Fn02MpbcVd1IloQ00wn00jFPP3r01OiJxo3JRartZOs
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/1-introduction-foundry-simple-storage/+page.md
        description: 'Introduction to transitioning from Remix IDE to Foundry for professional smart contract development, along with resources for troubleshooting.'
        markdown_content: |-
          ***

          ## title: Foundry Simple Storage Introduction

          *Follow along the course with this video.*

          # Moving Beyond Remix: The Transition to Professional Smart Contract Development

          Welcome to this fascinating journey from *Remix*, a phenomenal integrated development environment (IDE), to a more advanced and professional setup. Our goal is to integrate modern toolsets that are widely adopted within the development community. Although the initial transition process might seem daunting, I promise you, it's an enriching learning curve worth experiencing!

          ## Conquering the Transition: Being Vigilant and Resourceful

          We all know that setting up your local development environment without using Remix can be a challenging task. So, I urge you to make the most of these following valuable resources for troubleshooting:

          * [Chat GPT](https://chat.openai.com/)
          * [Stack Exchange ETH](https://ethereum.stackexchange.com/)
          * [Web three education dev](https://web3education.dev/)

          <img src="/foundry/1-introduction-foundry/foundry1.png" style="width: 100%; height: auto;">

          As we embark on this journey, remember, it's okay for things not to work at the first instance. It's absolutely fine! The trick lies in asking **specific** questions related to the errors you encounter. Install these valuable resources and do not let them be an obstacle in your developmental progression.

          <img src="/foundry/1-introduction-foundry/foundry2.png" style="width: 100%; height: auto;">

          We're about to take that plunge and learn how to implement these tools in our development environment right now!

          ## Introducing Foundry: A Professional Smart Contract Development Framework

          Although we're saying goodbye to Remix, we're switching to an even more powerful tool - [Foundry](https://github.com/foundry-rs/foundry). It's renowned within the developer's community as one of the most popular smart contract development frameworks.

          Foundry has numerous pros, such as:

          * It's known for its exceptional speed
          * It's entirely Solidity-based, eliminating the need to learn other programming languages
          * Its documentation is comprehensive.

          Cheekily referred to as Brownie or HardHat, Foundry is an invaluable asset to smart contract developers due to its speed and efficiency.

          Don't forget to refer to the project's GitHub repo for additional assistance. It contains all the vital code necessary for the course in handy detail.

          ### Foundry vs. Remix: Why the Transition?

          Now, you might wonder, "Why do we need to transition to Foundry when Remix appears to be working just fine?"

          Allow me to clarify that. With Remix, we performed many tasks manually, such as compiling or deploying contracts and testing the logic by repeatedly clicking through the UI. If the smart contract contains a large number of functions, the process can quickly escalate, and so can the risk of introducing errors.

          On the other hand, Foundry automates these tasks, reducing the risk of errors and improving workflow efficiency. With Foundry, you can run the tests for all the functions via one single command, which is not possible with Remix due to its manual nature.

          Foundry also deserves special mention because it is the preferred choice of Smart Contract security engineers and auditors. I'm eager for you to experience the quick and efficient nature of this smart contract development framework.

          ## Visual Studio Code: A Powerful Text Editor

          Next up, I'll introduce you to Visual Studio Code, one of the most robust code editors out there. If you're already comfortable using Visual Studio Code, feel free to skip this part.

          <img src="/foundry/1-introduction-foundry/foundry3.png" style="width: 100%; height: auto;">

          Please, don't confuse this with Visual Studio, a separate application - make sure that your selected version is Visual Studio **Code**.

          In case you prefer working in an environment like Atom, Sublime, or with tools like PowerShell or Terminal, feel free to do so. However, for this course, we'll stick with Visual Studio Code and you will be guided through its setup.

          ## Installation Instructions: Find the One that Suits You

          Lastly, we'll go through the installation processes for three different systems:

          * Mac and Linux
          * Windows
          * Last-ditch effort: Gitpod installation.

          I highly encourage getting everything running natively in your local environment. However, if all else fails, follow the Gitpod installation process.

          Stay tuned for the next post where we commence with Mac and Linux installations.

          That's all for now, folks. Are you excited to get started on this thrilling journey from Remix to Foundry? Let's forge ahead with a 'learning' and 'growing' mindset!
      -
        id: 8cd5e9ef-3879-4af3-b2b2-ba4135ed238e
        type: new_lesson
        enabled: true
        title: 'Development environment setup (Mac, Linux)'
        slug: development-environment-setup-mac-linux
        duration: 3
        video_url: mGUXCQublpwzeFI8Ka9pem6Sc00tHPdkBAbI2kdjz4BI
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/2-Mac-Linux-Install/+page.md
        description: 'Guide to setting up a development environment on Mac and Linux, including installing Visual Studio Code (VSCode) and Git.'
        markdown_content: |-
          ***

          ## title: Mac & Linux Install (VsCode & Git)

          *Follow along the course with this video.*

          ***

          Welcome to our step-by-step guide to set up Your Development Environment using Visual Studio Code (VSCode) and Git. Whether you're new to coding or just trying to set up a fresh machine, this guide will get you up and running in no time.

          ## Downloading Visual Studio Code

          Let's start at the very beginning: by downloading Visual Studio Code. You can download for macOS or, if you're on a Linux system, you'll want the Linux installation. After you have this software installed, you’ll be welcomed by a well-structured interface much as below.

          <img src="/foundry/2-install/install1.png" style="width: 100%; height: auto;">

          Fortunately, this friendly code editor doesn’t leave you in the dark but gives you tips to get started. By all means, if you're unfamiliar with VSCode, seize the opportunity to navigate through the "Get Started" instructions. These valuable tips could clear many hurdles on your upcoming coding adventures. Additionally, the [Visual Studio Code crash course](https://youtu.be/WPqXP_kLzpo) in the GitHub repository related to this course offers a wealth of concise and handy information.

          ## Introducing the VSCode Terminal

          VSCode offers an immensely helpful feature – the terminal, or command line prompts, providing the backstage entrance to run your scripts. To access it, simply navigate to the 'Terminal' tab in your menu and select 'New Terminal'—you'll be presented with a shell, which could be Bash, ZSH or another type. Regardless of the shell type, they all function pretty similarly.

          At this point, a quick note on navigation helps. For Mac or Linux users, the `CTRL + backtick` command allows you to swiftly toggle between Terminal modes, providing a major productivity boost. It's always beneficial to familiarize yourself with keyboard shortcuts as they enable efficient movement around VSCode. To ease your way into shortcut navigation, here you have a comprehensive list of [keyboard shortcuts](https://code.visualstudio.com/docs/getstarted/keybindings) for VSCode.

          Moreover, terminals can easily be deleted and recreated. Simply hit the trash can icon to delete the terminal, then navigate to `Terminal > New Terminal` to reopen a fresh one.

          ## Installing Git

          As we delve deeper into building your development environment, it's important to introduce Git. While it's not immediately necessary, it’s good practice to install it early on.

          If you're on a Linux system, you're likely to use one of two commands to install Git. On a macOS, a simple `git` command in the terminal should prompt an invitation to install.

          <img src="/foundry/2-install/install2.png" style="width: 100%; height: auto;">

          Once the installation is successful, typing `git version` into the command line should give you something that looks similar to this:

          For the macOS folks, there is an easier way by using the macOS Git installer that can be accessed [here](https://git-scm.com/download/mac) to run through the installation process.

          ## Wrapping Up

          Congrats! You have installed Git and Visual Studio Code. With these basics in place, we'll be able to delve into more detailed coding concepts in the next sections of this guide. Please note that if you're working on a platform not covered, like Windows or Gitpod, you might want to skip the next sections.

          Our goal is to ease your journey into the coding world, and we're thrilled to help you establish a strong foundation. Hop onto the next sections and let’s continue this exciting journey.

          <!-- <img src="/foundry/1-introduction-foundry/foundry3.png" style="width: 100%; height: auto;"> -->
      -
        id: 1dc6bc68-2034-4861-a2bd-8b7f96e42f1e
        type: new_lesson
        enabled: true
        title: 'Development environment setup (Windows)'
        slug: development-environment-setup-windows
        duration: 8
        video_url: MkIn9Pa4Tcmx00JtwoeR9EzWGbG76oOkeLIEYu4xeebE
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/3-Windows-Install/+page.md
        description: 'Tutorial on setting up a development environment on Windows using WSL (Windows Subsystem for Linux) and installing Visual Studio Code.'
        markdown_content: |-
          ***

          ## title: Windows Install (WSL)

          *Follow along the course with this video.*

          ***

          We'll be taking a special look at a handy tool known as WSL (Windows Subsystem for Linux). Assisting us in this tutorial is the amazing Basili, a guru in Windows setup who has been tremendously helpful in some of my past training courses.

          This tutorial will be beneficial for anyone using Windows 10 or later versions. We'll begin by installing our code editor - in this specific case, Visual Studio Code.

          ## Getting Started with Visual Studio Code Installation

          To install Visual Studio Code (VS Code for short) on your machine, begin by opening up your web browser and typing `VS Code` in the search box. Follow these steps:

          * Select the VS Code version suited for Windows
          * Choose your desired installation location
          * Save the file
          * After download, proceed with the installation - the same as with any other program installation process

          You'll notice that to install VS Code, you must accept the agreement and then proceed to add the code to your system path, create a desktop icon, and click 'Next' to install. The process won't take much time. After this, you can customize the theme, create shortcuts, and sync VS Code with your other devices.

          If you wish to get a more in-depth understanding of VS Code, I recommend you pause this tutorial right here and explore these options one by one.

          Although we could proceed to install the rest of our development tools in a Windows environment, you'll find the following section of this tutorial very important. While Microsoft has made significant efforts to further support developers in recent years, the best option to consider still remains WSL, especially when it comes to smart contract development.

          ## Transitioning to a Better Developer Environment with WSL

          The Windows Subsystem for Linux (WSL) proves to be a considerable game-changer in this scenario. As a developer, you'll often find yourself working with tools and utilities primarily found in Unix-based environments. Windows has made significant strides in supporting developers; however, when setting up the right development environment and running certain command-line tools, some challenges persist.

          To ensure that your code runs on various machines using Unix-based systems like Mac and Linux, you'll find WSL to be immensely beneficial. How exactly does WSL help? By setting up a Linux distribution using WSL, you gain access to a Unix-like console right on your Windows machine.

          Don't worry, you don't need to have master-level tech skills to set this up – all it takes is a few easy steps, which we'll cover next in our tutorial.

          ## Installing WSL and Setting Up a Linux Distribution

          Let's start by installing WSL. Head over to the Windows Terminal, a pre-installed application on Windows 11 and easily accessible on Windows 10 via the Microsoft Store. All you have to do is type `WSL --install` and hit Enter. This will trigger the installation process requiring you to reboot your operating system.

          ```
          # Open the Windows Terminal
          $ Windows Terminal
          # Key in the command to install WSL
          $ wsl --install
          ```

          After your system reboots, the Terminal will open automatically and proceed with the installation. During the setup, you'll need to input a new Unix username - choose one unique to you - and secure it with a password of your choice. And voila, you have an operational Linux terminal on your Windows machine!

          ## Making Visual Studio Code Compatible with WSL

          Now that we have our Linux terminal set up through WSL, we'll need to ensure its compatibility with VS Code.

          Open up VS Code and navigate to the Extensions tab. Here, look for the Remote Development extensions and proceed to install each of them. This will enable VS Code to operate with WSL seamlessly.

          Once this is done, you'll find that a new icon has appeared - 'Open a Remote Window')) which allows you to connect directly to WSL. However, there's an even simpler way to connect– through our Linux terminal!

          Create a new folder in the terminal (for example, a folder named `solidity course`), navigate to this folder, then type `code .` and hit Enter. This command will automatically install the latest server for WSL on VS Code and open a new VS Code instance connected with WSL.

          At this point, you should now see the WSL Ubuntu banner at the bottom of your VS Code window. You have two options to choose from when considering your development needs – either use the Windows Terminal or the integrated terminal that comes with VS Code.

          **Please Note:** When you conduct your projects from a folder inside Windows, like `Development` inside your documents, it's crucial to know that the WSL console will only access local files inside the WSL instance. Therefore, it's recommended to keep files inside the WSL instance for faster communication and convenience.

          ## Preparing for Git Installation

          The final part of our setup involves installing Git. While we won't directly use Git in this course, it is an essential tool for future use. To check if Git is pre-installed, simply run the command `git version`. If Git is not installed yet, you will have to install it independently.

          Remember, for those opting to continue with PowerShell or Windows instead of transitioning to WSL, you will need to download and install Git for Windows from the official Git page.

          Congratulations if you've managed to set up your developer environment as explained in this elaborate tutorial! With these tools at your disposal, you can develop smart contracts using Windows while experiencing the ease and flexibility Mac and Linux developers are accustomed to. Always ensure that your VS Code is connected to WSL Ubuntu, and feel free to use either a Windows or WSL environment, depending on your preference. Happy coding!
      -
        id: f6c97bd6-2af2-4865-8076-d02bef7f32c9
        type: new_lesson
        enabled: true
        title: 'Develop in cloud using Gitpod'
        slug: introduction-to-gitpod
        duration: 5
        video_url: 9x9Fxei4YpqkebgmCHlqk8wSJTeHNqQyrmxdbYMNaYg
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/4-gitpod/+page.md
        description: 'Overview of using Gitpod for cloud-based development, highlighting its benefits, limitations, and precautions for usage.'
        markdown_content: |-
          ***

          ## title: GitPod Setup

          *Follow along the course with this video.*

          ***

          In the vast, ever-evolving world of coding, more and more tools are being developed to facilitate programmers. One such tool is Gitpod, a cloud development environment that enables you to run your code on a remote server. In this blog post, we will guide you through the processes of setting up your development environment using Gitpod, highlighting its pros, cons and tips for smoother running.

          ## Something About Gitpod

          Gitpod is similar to Remix IDE and allows you to run Visual Studio code either in the browser or connected to another server. The key benefit of using Gitpod is bypassing the setup process. It spares you the need to conduct installations on any device, as you get to execute all your desired tools on the remote server.

          Nevertheless, dependent on its status, Gitpod may also limit when you can code. It’s also worth noting that Gitpod is not completely free, which may be discouraging particularly for emerging developers.

          Furthermore, for the safety of your cryptocurrency, avoid running any code with a private key containing real money on Gitpod. The reason for this caution is that the remote servers may potentially access your private keys. As long as you don't use a MetaMask or any private key linked to actual funds during this interactive Gitpod setup, everything should work just fine.

          ## Embarking on Gitpod

          To begin, you will observe an "Open in Gitpod" button in all our code repos, starting from lesson five "Simple Storage on Ethersjs".

          <img src="/foundry/4-gitpod/gitpod1.png" style="width: 100%; height: auto;">

          After clicking the button, a "Welcome to Gitpod" sign appears and you should click on "Continue with GitHub". If Gitpod is linked to your GitHub account, it will automatically create a workspace for you, which mimics Visual Studio code.

          <img src="/foundry/4-gitpod/gitpod2.png" style="width: 100%; height: auto;">

          To run your Gitpod from your local Visual Studio code :

          1. Spot if “Gitpod” is indicated.
          2. Tap the prompted pop-up, "do you want to open this workspace in Vs code desktop?"
          3. Install Gitpod extension on your Visual Studio code when prompted.
          4. Click "Reload Window" then "Open".
          5. The workspace then initiates a connection.

          Alternatively, you can manually run it by clicking "Open in Vs code" in the bottom left corner of Gitpod.

          <img src="/foundry/4-gitpod/gitpod3.png" style="width: 100%; height: auto;">

          ## Navigating the Workspace

          If you opt for this type of development, remember that you are coding on a remote server, not locally. Hence, never save sensitive data, such as your private keys in this workspace.

          The workspace resembles your typical local setting. You can create new folders and workstations, and run all commands, just like when using Visual Studio.

          To establish a new terminal, simply click on the little bar at the top left part of the screen, go to "Terminal" then hit "new Terminal". As an alternative, you can use the Control tilde shortcut, similar to macOS and Linux keyboard shortcuts.

          These commands basically create a directory called "New Folder" then change the current directory into "NewFolder". To verify that you're in the right place, the command "code ." can be used. It transports you to the new folder.

          ## Conclusion

          While Gitpod is not without its shortcomings, its ability to provide a ready-to-code environment that requires no installation, accessible from anywhere and on any device, makes it stand out. It's a fantastic option if you can't get the installation working.

          Keeping Gitpod’s conditions and a few precautions in mind, you're now ready for remote coding. Happy programming!

          <img src="/foundry/4-gitpod/gitpod4.png" style="width: 100%; height: auto;">

          <!-- <img src="/foundry/2-install/install1.png" style="width: 100%; height: auto;"> -->
      -
        id: e01f8186-fca4-4adc-be04-47d5c0720b66
        type: new_lesson
        enabled: true
        title: 'Foundry setup'
        slug: foundry-setup
        duration: 8
        video_url: 3qcmYFELZq934RiMBNUfJMHBNpaGWndPn91NvpetAI4
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/5-foundry-install/+page.md
        description: 'Step-by-step guide on installing and operating Foundry, a tool for smart contract development, compatible with Windows, Linux, and MacOS.'
        markdown_content: |-
          ***

          ## title: Foundry Install

          *Follow along the course with this video.*

          ***

          Welcome to this handy guide on installing and operating Foundry, a versatile tool that will add a new level of command-line ease to your developer journey. Whether you're running Windows, Linux or MacOS, we've got you covered with instructions and tips. So sit back, grab a cup of coffee, and let's dive in.

          ## Prepping your Terminal

          First things first. Before we dive into installing Foundry, make sure you have your terminal set up correctly.

          If you are using Windows, you should see something like `WSL` or `Ubuntu`. Once you have your terminal environment ready, it’s time for some quick tips to help streamline your workflow.

          ### Keeping your Terminal Clutter-free

          When commands pile up in your terminal, things can get a little overwhelming. Clear it up by simply typing `clear` and hitting `Enter`. Alternatively, use `Command K` if you're on a Mac or `Control K` if you're on Linux or Windows.

          **Pro tip:** This is one of my favorite keyboard shortcuts that I use all the time.

          ### Understanding the Trash Can and the X

          <img src="/foundry/5-foundryinstall/foundryinstall1.png" style="width: 100%; height: auto;">

          The trash can and the X buttons in your terminal perform distinct functions. Hitting `X` simply hides your terminal but retains all the previous lines of code. On the other hand, trashing it essentially deletes whatever is running in it. To open up a clean terminal, hit the trash can and then pull it back using `Toggle` or `Terminal > New Terminal`.

          ## Installing Foundry

          With our terminal set and some tips up our sleeve, let's progress to installing Foundry. Navigate to the [Foundry website](https://book.getfoundry.sh/getting-started/installation) and from the installation tab, fetch the command to install Foundry.

          The command would look something like this:

          ```bash
          curl -L https://foundry.paradigm.xyz | bash

          ```

          Hit `Enter` after pasting this in your terminal.

          **Note:** You must have Internet access for this to work as it's downloading Foundry from their official website.

          ## Verifying Your Installation

          After running the `curl` command, an output will appear at the bottom of your terminal indicating the detected shell and the fact that Foundry has been added to your `Path`.

          For instance, the output can be something like this:

          ```bash
          Detected your preferred shell is bashrc and added Foundry to Path run:source /home/user/.bashrcStart
          a new terminal session to use Foundry
          ```

          Now, simply type `foundryup` and `Enter` to install and update Foundry to the latest version. Whenever you want to install an update for Foundry, simply run `foundryup` again.

          This will install four components: forge, cast, anvil, and chisel. To confirm the successful installation, run `forge --version`. You should get an output indicating the Forge version as shown below.

          ```bash
          Forge version x.x.x
          ```

          Now, here's something to remember: when you hit the trash can in the top right, it literally 'removes' the terminal. The X button, in contrast, simply hides it.

          ### Is Foundry Up Not Running?

          Don't panic if this command doesn't run. You might have an issue with your path, and you might need to add Foundry to your path. In case you run into this issue, check lesson 6 of the GitHub repo associated with this course. If no debugging tips are available there, feel free to start a discussion on the course's GitHub repo. Before doing so, make sure to check if a similar discussion already exists.

          Try typing `forge --version` into your terminal. Have you received an unwelcome output saying `Forge command found`? This implies that you have to rerun the `source` command that Foundry offered during installation.

          Note: Most of the time the `bashrc` file gets loaded automatically. However, if this doesn't apply to your setup, the following lines can add the required command to the end of your `Bash profile`. This will ensure that your `bashrc` file loads by default.

          ```bash
          cd ~echo 'source /home/user/.bashrc' >> ~/.bash_profile
          ```

          > this depends on your operating system, please check foundry docs to see detailed instructions.

          ## Wrapping Up

          And there we have it! Congratulations on installing Foundry and prepping your terminal to work seamlessly with it. Remember, hitting snags during installation is normal, especially if you're new to this. Don't hesitate to engage with the course community via GitHub if you run into issues.

          <img src="/foundry/5-foundryinstall/foundryinstall2.png" style="width: 100%; height: auto;">

          Here's to many hassle-free coding sessions with Foundry!
      -
        id: ac591636-d3a2-47be-b1fd-b63e3f30733e
        type: new_lesson
        enabled: true
        title: 'Setup your VSCode'
        slug: vscode-setup
        duration: 6
        video_url: DR3LGeEw8eaZwPrrnjDlAHwr64QN1l00IIqmrlpMp8nk
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/6-vscode-setup-ii/+page.md
        description: 'Comprehensive guide on mastering Visual Studio Code and GitHub Copilot for optimizing programming efficiency and project folder organization.'
        markdown_content: |-
          ***

          ## title: VSCode Setup II

          *Follow along the course with this video.*

          ***

          ## Mastering Visual Studio Code and GitHub Copilot

          As an ardent coder, mastering your programming environment tools is essential for optimum productivity. Today, our focus lands on Visual Studio Code (Vs code) and a fascinating AI extension – GitHub Copilot. Here's a walkthrough guide on how to optimize these tools effectively.

          <img src="/foundry/6-vscode-ii/vscode1.png" style="width: 100%; height: auto;">

          ## Understanding the Vs code Interface

          Firstly, we'll check out some convenient shortcuts and features in Vs code. You might observe me using the `control backtick` command frequently since it quickly toggles terminal visibility. Another shortcut I typically use is `Command J`. This key binding allows a quick toggle for panel visibility — handy when you need to alternate between terminal commands and code writing.

          On the Vs code interface, the Explore button opens up a space where you can create a file. This could be a simple text file or more complex files for your programming language of choice from Python, Java, JavaScript, Solidity, and more.

          <img src="/foundry/6-vscode-ii/vscode2.png" style="width: 100%; height: auto;">

          ### Note on Saving Files

          Each open and unsaved file is marked with a small white dot on the tab. Not having your file saved could cause unexpected behavior when you run your code. Therefore, always remember to save your edits with `Command s` (Mac) or `Control s` (Windows and Linux). This key shortcut makes the white dot disappear, indicating your file is saved.

          Here's a fun fact: you have the unsaved and saved markers to remind you of your file's state. Ensure to establish a routine of hitting `Command s` after each significant edit to your code – it saves you a lot of time, trust me!

          Should you need to delete the file, a simple right click on it and selecting `Delete` gets the job done promptly.

          ## Adding AI Capabilities with GitHub Copilot

          On the discussion of Vs code features, it's incredible how AI integration in Vs code can significantly improve your coding efficiency. When you click on the Extensions button (it looks like a box), you'll find a search box to install different extensions.

          For AI use, you may want to consider using GitHub Copilot. Although it's a premium service, its intuitive AI-powered code autocomplete feature could be a game-changer for you. Of course, you can choose to go with other AI extensions based on your preferences.

          Once you have installed the [GitHub Copilot extension](https://marketplace.visualstudio.com/items?itemName=GitHub.copilot), you will need to sign in to your GitHub account to activate it on Vs code. Having this set will introduce a flyout on the right that auto-generates code suggestions as you type.

          <img src="/foundry/6-vscode-ii/vscode3.png" style="width: 100%; height: auto;">

          As you code, GitHub Copilot offers code suggestions which you can auto-fill by hitting tab. The AI can alternatively present you multiple code solutions if you hit the up and enter keys. You can then select the most suitable option from the code suggestions list.

          On a side note, if you're more conscious about sending data (*telemetry*) to Microsoft through Vs code, you can consider using [VSCodium](https://vscodium.com/). It's an open-sourced version of Vs code that does not send telemetry data to Microsoft.

          Also, if you love the GitHub Copilot, you might want to check out [GitHub Copilot Labs](https://copilot.github.com/) as well. It features the AI's experimental features, which might be worth exploring.

          ## Setting up a Project Folder

          To set up a new directory for your coding projects, open the terminal and type `mkdir MyProjectFolderName`, then navigate to it with `cd MyProjectFolderName`. Note that you can use tab completion for the folder name.

          The command helps you quickly create and move into a folder where you can store all your repositories.

          ```bash
              mkdir FoundryF23
              cd FoundryF23
          ```

          Another cool trick is typing the first few characters of your commands or filenames within your terminal and hitting tab to autocomplete. Get better at identifying which commands or filenames can be autocompleted with practice.

          So, moving forward:

          <img src="/foundry/6-vscode-ii/vscode4.png" style="width: 100%; height: auto;">

          ## Summing Up

          Underutilizing your development environment tools could be costing you precious coding time. It's why I've shared how you can quickly explore files, edit and save files, use shortcuts, and add AI capabilities using GitHub Copilot on Visual Studio Code.Proper utilization of these features is very critical to enhancing your coding experience and productivity.

          Remember, in modern-day coding, AI capabilities can be an invaluable resource. Hence, as we move forward, keeping our repositories organized in a single folder will be an enormous boost to efficiently managing our multiple coding projects. Additionally, it makes it easy to reference our projects. Happy coding!
      -
        id: 55d7a32c-4040-47d0-81d5-9ca08b816ddf
        type: new_lesson
        enabled: true
        title: 'Create a new Foundry project'
        slug: create-new-foundry-setup
        duration: 8
        video_url: 6ULFsnoyk00gPyBSTzNo4d7HB3phpBIW01HVIZ5wGOcnY
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/7-foundry-setup/+page.md
        description: 'Step-by-step instructions on creating a new simple storage project using Foundry, including project folder setup, terminal tips, and initial project structure.'
        markdown_content: |-
          ***

          ## title: Foundry Setup

          *Follow along the course with this video.*

          ***

          ## Creating a Simple Storage Project

          Today, we'll dive into setting up a simple storage project, but with a twist, we'll be doing this in a professional environment, following the industry's big protocols as exemplified by billion-dollar players like uniswap, Aave, and curve.

          A key factor that makes this worth your while is that we'll be using Foundry - a popular tool among auditors - making this a goldmine for budding security researchers. So brace up as we journey into the masterclass prepared with the same toolbox that industry champions rely upon!

          ## Getting Started: Setting up The Project

          In setting up your environment, you would need to create a new folder. Simply follow these commands:

          ```bash
              mkdir foundry-simple-storage-f23
              cd foundry-simple-storage-f23
          ```

          You might observe some differences in our terminal windows, reflecting our unique paths. For this tutorial, an alias, `video_shell`, which only displays the folder path, will be used.

          <img src="/foundry/7-foundry-setup/setup1.png" style="width: 100%; height: auto;">

          )Still within the folder, typing in `code` followed by a period  (`.`) should lead to a new Visual Studio code. If this doesn't happen, simply navigate to `File` >> `Open Folder` and select your preferred folder, the selected folder will open in a new Visual Studio code.

          Now, your terminal should show that we are indeed in our project folder:

          <img src="/foundry/7-foundry-setup/setup2.png" style="width: 100%; height: auto;">

          ## Terminal Tips and Tricks

          Everyone's terminal will look slightly different. For this post, we'll be using several Bash (Linux Terminal) commands like `mkdir` and `cd`. If you're unfamiliar with these, I highly recommend checking out [this freeCodeCamp lesson](https://www.youtube.com/watch?v=oxuRxtrO2Ag).

          Alternatively, you could harness the power of Artificial Intelligence (AI). AI chatbots like GPT and others are familiar with Bash and Linux commands. They can provide assistance when you encounter challenges.

          <img src="/foundry/7-foundry-setup/setup3.png" style="width: 100%; height: auto;">

          ## Setting Up Local Environments

          Moving to the next phase, we'll set up our local environments. This is similar to working with Remix VM. Consistent with the project's title, we'll use `Foundry` to code our simple storage project. This will make our code interactions and deployments more professional.

          We begin by checking the content of our Explorer side bar. You can create a file here by using the `touch` command. This will make the file appear on the left hand side of the explorer. Next, we delete unneeded files with the `rm` command.

          ## Using Foundry for Project Initialization

          We will start the project by using Foundry to create a new basic project. Foundry's documentation offers a step-by-step guide on creating a new project. However, in our case, we run `forge init`. This should create several folders.

          In case an error pops up because the directory is not empty, we run `forge init --force.` to override this.

          ```bash
          forge init --force.
          ```

          This will override any error related to Git. Be sure to configure your username and email if you encounter errors related to Git configuration.

          ```bash
              git config --global user.email "your_email"
              git config --global user.name "your_username"
              forge init
          ```

          ## Walk-through of Initialized Folders

          Our folders are now full and we have an initial project ready! The folders include:

          1. `.gitHub` workflows file
          2. `lib`
          3. `.script` - contains a file we delete for now
          4. `src` - where we put our smart contracts
          5. `test` - not needed for now
          6. `.gitignore` - files not meant for GitHub
          7. `foundry.toml` - gives configuration parameters for Foundry

          The Source (src) is the main directory that we'll focus on. It's where we'll store the main contracts, whereas Test will hold the files to test the main contracts, and Script will host files to interact with our SRC contracts.

          Lastly, we'll add a simple storage code into the SRC or Source folder. We can copy all the code from this [Github repository](https://github.com/Cyfrin/foundry-simple-storage-f23/blob/main/src/SimpleStorage.sol), select the code base, then paste it into `src` as `SimpleStorage.sol` file. Hit save, and we're done!

          Congratulations, you're now ready to build bigger and better with Foundry! Stay tuned for more exciting tutorials.
      -
        id: ae54a24e-9fce-457f-af4d-b68b7fb6716b
        type: new_lesson
        enabled: true
        title: 'VSCode Solidity setup'
        slug: vscode-solidity-setup
        duration: 5
        video_url: FRXi9zWpWzk1Ig4KLqdU24WUqifk02iqm7CMAPS6rGP8
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/8-formatting-solidity/+page.md
        description: 'Tutorial on formatting Solidity code in Visual Studio Code using various extensions and settings, and tips for automatic code formatting and TOML file formatting.'
        markdown_content: |-
          ***

          ## title: Formatting Solidity in VS Code

          *Follow along the course with this video.*

          ***

          # **Improving Code Format in Visual Studio Code**

          In this blog post, we're going to explore how to greatly improve the readability and maintainability of your smart contracts by cleaning up your Solidity code format within Microsoft's Visual Studio Code (VSCode). Let's get started!

          <img src="/foundry/8-formatting/formatting1.png" style="width: 100%; height: auto;">

          ## **Solidity Code Formatting**

          When you first start, your code might just look like a whole bunch of dull, lifeless, white text. While some cool trinkets are embedded in the code such as the oftentimes cute little ETH logo, deciphering your code becomes a real chore without proper formatting.

          Lucky for us, there are many wonderful extensions available on VSCode that can format our Solidity code. Simply input "Solidity" in the Extensions bar to reveal a treasure trove of options. Out of these, a few worth mentioning:

          1. The general "Solidity" extension
          2. [Hardhat Solidity](https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity), a personal favorite, despite being another framework, works wonders in Foundry
          3. Solidity visual developer, another popular choice
          4. And Juan Blanco's [extension](https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity), which is probably the most used Solidity extension worldwide

          For this blog, we'll demo the [nomic foundation Solidity Vs code extension](https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity). Once this extension is installed, your Solidity files should now appear with syntax highlighting, making it vast easier to read and understand.

          ### **Activating the Extension**

          If the code remains unhighlighted despite having installed the extension, there's a quick solution to that. Press `Command Shift P`, or `Control Shift P` on Windows. This opens up the command bar.

          In the command bar, type in "Settings" and select "Preferences: Open User Settings". This will open your user settings in JSON format. If you have nothing in there, create a new setting with these brackets `{'{'}...{'}'}` and type in:

          ```json
          {
            "editor.defaultFormatter": "NomicFoundation.hardhat"
          }
          ```

          ..and you're all set! This way every time you open your Solidity code, VSCode will automatically use Hardhat extension for formatting.

          ## **Formatting TOML Files With Better TOML**

          The good news doesn’t end with Solidity files alone. Even your Foundry TOML files can be formatted for better readability. Again, head over to Extensions and type in TOML.

          Install [Even Better TOML](https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml). This cool extension appropriately highlights your Foundry TOML files, making it much easier to locate and edit keys.

          **Pro Tip:** Any time a little dot appears next to the file name on your tab, it means the changes aren’t saved. Make it a habit to frequently save your work with Command S or File -> Save.

          ## **Automatic Code Formatting**

          A great feature of text editors is the ability to format your code automatically. Let's say you have a block of code that's entirely out of whack. You can set your VSCode to automatically format the block once you save it. Here’s how.

          Repeating the Command Shift P step brings up the command palette. If you type in 'format document', it will instantly apply the default formatter to the open file. If the auto formatter does nothing, first ensure you've set Hardhat as your default formatter in your settings file.

          For those who prefer automatic formatting, navigate to User Settings and check 'Editor: Format On Save'. This way, every time you save your Solidity code, it automatically gets formatted.

          For cases where you might not want your document formatted, all you have to do is open the command palette (Command Shift p/View -> Command Palette) and type 'save without formatting'. This will save the file without applying any formatting rules. However, remember to turn back on formatting when done.

          <img src="/foundry/8-formatting/formatting2.png" style="width: 100%; height: auto;">

          In conclusion, formatting is something we pretty much never want to skip. Even though it might seem inconsequential, a well-formatted code can save a lot of debugging time and make your code way more maintainable and understandable. So start using these principles today and write smarter contracts! Happy hacking!
      -
        id: e1a7e1f7-508a-440c-b39b-7bcbf0c54e07
        type: new_lesson
        enabled: true
        title: 'Compile a smart contract using Foundry'
        slug: compiling-a-smart-contract-foundry
        duration: 2
        video_url: 4toTGcbc00021Fd0000JoL01y7012tCkABzzXwvRSLDGsv00gI
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/9-compiling-in-foundry/+page.md
        description: "Guide to compiling Solidity smart contracts using Foundry, including steps for using the Foundry console, understanding the 'out' file, and terminal command recall."
        markdown_content: |-
          ***

          ## title: Compiling in Foundry

          *Follow along the course with this video.*

          ***

          # Compiling Smart Contracts: A Guide to the Foundry Console Compilation Process

          In this detailed guide, we'll walk you through the intricate process of compiling Solidity smart contracts using the Foundry console, courtesy of Parity. By the end of this blog post, you'll successfully compile a `SimpleStorage.sol` contract within your terminal.

          ## Getting Started: The Foundry Console

          Let's kick things off starting with the installation of the Foundry console. Foundry is an incredibly essential tool that we'll be using to collate our background, so ensure it has been installed correctly on your system to avoid any hitches.

          Here's a gentle reminder, just with your existing code and Foundry installed, you're already set to begin the intriguing journey into compiling your `SimpleStorage.sol` smart contract right in your terminal!

          ## How to Compile Your Code

          After correctly setting up Foundry, pull up your terminal. In the terminal, key in either `forge build` or `forge compile`. Running either command will immediately trigger the compilation of your code, like so:

          ```bash
          $ forge build
          ```

          Or

          ```bash
          $ forge compile
          ```

          <img src="/foundry/9-compiling/compiling1.png" style="width: 100%; height: auto;">

          Look out for a notable change - the appearance of several new folders. One of them is a file named `out`.

          ## Understanding the `out` File

          Quite noticeable when you compile is the `out` file. To put it simply, the `out` file holds a trove of crucial information similar to what the Remix compiler offers.

          It is within this `out` file that you have access to the `Abi`. For those who haven't encountered it, you're probably wondering what `Abi` is. In the context of this guide, `Abi` refers to the compiled version of your contract. To locate it, navigate your way back to Remix, select the compiler tab, locate one of your written contracts and scroll down.

          <img src="/foundry/9-compiling/compiling2.png" style="width: 100%; height: auto;">

          In the Abi section, you'll notice a small dropdown icon placed directly beside it. A simple click on this dropdown button will minimize the Abi, prominently displaying all other details such as bytecode method Identifiers and other sub-sections that we'll delve into later in this guide.

          ## The `cache` Folder Defined

          Another file that appears upon compilation is the `cache` folder. Generally, this folder is used to basically store temporary system files facilitating the compilation process. But for this guide, you can virtually ignore it.

          ## Recalling Previously-Run Commands

          Here's a productivity-boosting feature in your terminal: the ability to recall and rerun use previously executed commands. The action is simple - just press the up arrow key. This feature proves handy when you need to rerun lengthy commands which previously executed correctly, saving you both time and energy.

          For instance, suppose you've run a long command like `echo`, which is a classic Unix command, and decide to rerun it. All you need to do is press the up arrow key:

          ```bash
          $ echo "This is some crazy long command"
          ```

          <img src="/foundry/9-compiling/compiling3.png" style="width: 100%; height: auto;">

          By following these steps, you should now have a head start in compiling your Solidity smart contracts. Congratulations on adding a new skill to your programming arsenal! Enjoy your development journey!
      -
        id: 46f0d83a-62be-4095-a9e5-d91c37ef111e
        type: new_lesson
        enabled: true
        title: 'Deploy a smart contract locally using Ganache'
        slug: deploy-smart-contract-locally
        duration: 8
        video_url: KK01L2GrhBEFoi7pK3AIWpd00Wvh0100N1z2Yaq4XIvyjbo
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/10-deploying-locally/+page.md
        description: "Guide on deploying smart contracts locally using Ganache and Foundry's Anvil, including setting up Ganache, using MetaMask for custom networks, and integrating Anvil."
        markdown_content: |-
          ***

          ## title: Deploying to a Local Blockchain

          *Follow along the course with this video.*

          ***

          ## Deploying Code to a Virtual Environment with Foundry and Anvil

          In this lesson, we'll explore how you can deploy your code to a Foundry VM or a JavaScript virtual environment using Foundry, Anvil, and the Ganache Ethereum chain.

          ## Foundry and Anvil: Built-In Virtual Environment

          Foundry comes built-in with a virtual environment in its shell, similar to **Remix**, the integrated development environment (IDE) best known for smart contract development and deployment. Inside the virtual environment of foundry, we use **Anvil** to create a fake available accounts, fully equipped with **fake private keys**, a wallet mnemonic, blockchain details, and an RPC URL, which we'll discuss later.

          Here's how to launch the Anvil blockchain:

          ```bash
          anvil
          ```

          To end the session, you can press Ctrl+C or close your terminal.

          ## Deploying with Ganache

          Ganache is a one-click blockchain. It offers a user interface that gives developers easier access to their transactions.

          <img src="/foundry/10-deploy-local/deploying1.png" style="width: 100%; height: auto;">

          After installing Ganache, you can create a new locally running blockchain by hitting 'Quickstart for Ethereum'. This will generate a list of addresses with individual balances, and dummy private keys.

          Here's a glimpse of how Ganache looks:

          <img src="/foundry/10-deploy-local/deploying2.png" style="width: 100%; height: auto;">

          The Ganache blockchain is temporary; if it's causing any issues, you can always switch back to Anvil.

          <img src="/foundry/10-deploy-local/deploying3.png" style="width: 100%; height: auto;">

          ## Deploying to Custom Networks with MetaMask

          To deploy to a custom network (like your localhost), you'll need MetaMask. MetaMask is a browser extension that allows you to run Ethereum dApps (decentralized apps) right in your browser.

          Follow these steps:

          1. Open MetaMask.
          2. Click the three little dots, select 'Expand View'.
          3. Go to 'Settings', then 'Networks'.
          4. Here, you'll see the list of networks (Ethereum, Mainnet, etc.) with plenty of details about each one. Locate the RPC URL - this is key.

          The RPC URL is essentially the endpoint we make API calls to when sending transactions. For every blockchain transaction you execute, you're making an API to whatever is in here.

          To send a transaction to your custom blockchain, you need to add it as a network:

          1. Scroll to the bottom of the list of networks.
          2. Hit 'Add Network'.
          3. Enter the details of your local network - the name, RPC URL (you can get this from Ganache or Anvil), chain ID, etc.

          <img src="/foundry/10-deploy-local/deploying4.png" style="width: 100%; height: auto;">

          1. Save your new network.

          Once your network is added, you should be able to switch to it from the dropdown menu. From here, you can import an account by pasting its private key and hitting 'Import'.

          And voila! You now know how to deploy code to a virtual environment with Foundry, Anvil, Ganache and MetaMask. Happy coding!
      -
        id: d147ac70-b450-43ae-b1a2-4a0a2a7b5508
        type: new_lesson
        enabled: true
        title: 'How to add a new network to Metamask'
        slug: how-to-add-a-new-network-to-metamask
        duration: 2
        video_url: CPbaTe15LSeu24qGbj1JjYu7AY004y3k6NYdr50276uUk
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/11-adding-network-metamask/+page.md
        description: 'Tutorial on adding new Ganache local chains and EVM compatible chains to MetaMask, including managing private keys and understanding RPC URLs.'
        markdown_content: |-
          ***

          ## title: Adding another Network to MetaMask

          *Follow along the course with this video.*

          ***

          ## Adding New Ganache Local Chains and Other EVM Compatible Chains

          In this blog post, we delve deep into the world of EVM (Ethereum Virtual Machine) chains. We explore how to add new Ganache local chains and the process of incorporating any EVM compatible chain in the network. Plus, we sprinkle in an introduction on running your own Ethereum nodes. Ready to dive in?

          <img src="/foundry/11-networks/network1.png" style="width: 100%; height: auto;">

          ## Adding New Networks Using MetaMask

          Conveniently, MetaMask, a browser extension serving as an Ethereum wallet, provides an easy way to add EVM compatible chains. By pre-configuring a host of them, you can add a chain such as the Arbitram One by simply clicking on **Add Network** and proceeding to **Add**. The pleasing part is that MetaMask does all the grunt work, filling in all the necessary information for you. A click on **Approve Network** ensures successful addition of the network.

          ```js
              1. Click on Add Network
              2. Choose your desired EVM compatible chain
              3. Click on Add
              4. After ensuring all necessary information is already filled in, click on Approve Network
          ```

          However, what if MetaMask isn't pre-equipped with a chain you wish to add? Well, no need to worry. You would employ the same process we just used to add our new Ganache local chain. This process universally applies to the addition of any EVM compatible chain.

          ## Understanding Your Connection to a Node: The Role of Endpoint

          Heading back to your network settings and selecting the localhost network unveils another crucial aspect- the endpoint. When you set out to send a transaction to a blockchain, you must have a connection to a node. This node connection is vital as it equips you with the ability to send transactions.

          Let's say you coveted the thrill of sending transactions to your own node. The process would entail running an execution client like Geth, followed by a consensus client such as Teku or Prism, and finally send your transactions.

          <img src="/foundry/11-networks/network2.png" style="width: 100%; height: auto;">

          Certainly, running your own Ethereum nodes may seem daunting. However, for a blockchain enthusiast, it can be a fun adventure worth exploring. As a pro tip, run multiple Ethereum nodes for an even better experience.

          ## Interacting with Ethereum Blockchain Nodes: Different Methods

          <img src="/foundry/11-networks/network3.png" style="width: 100%; height: auto;">

          Venturing further into the realm of Ethereum, we find that different methods exist for dispatching transactions. Ethereum JSON RPC specification site provides a rundown of these various methods. You just need to be acquainted with APIs and Http endpoints and you’re good to go.

          When signing and dispatching transactions, it's these method calls that come into play: ETH sign transaction, send transaction, send raw transaction, etc.

          However, let's make an important clarification. The Forge comes with a built-in facility that manages sending these transactions. So, we don't necessarily have to go the extra mile of direct interaction with these calls.

          ## Sending Raw Transactions: Different Programming Languages

          Moving forward, to learn how to send raw transactions, you would need to make raw API calls to your Ethereum node. This can either be an Ethereum node you provided or an Ethereum node as a service, such as Infura or Alchemy. This interaction would employ different programming languages such as Bash, Python, or JavaScript.

          Further exploration into the complex yet captivating world of Ethereum awaits. Running your own Ethereum nodes and understanding the intricacies of sending transactions brings a whole new level to your blockchain explorations. We hope this guide kindles your curiosity to delve further and cherish the fun of running nodes!

          Stay tuned for more such excitement in our next lesson!
      -
        id: 20ac66c6-015c-4c7a-a2b6-1d98cf01b686
        type: new_lesson
        enabled: true
        title: 'Deploy a smart contract locally using Forge'
        slug: deploying-locally-forge-foundry
        duration: 5
        video_url: YucGp4chSf01HM2Z02cbPiyoydAJNh3B02uqV9jvWDWi0200
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/12-deploying-locally-ii/+page.md
        description: 'Comprehensive guide on deploying smart contracts locally using Forge in Foundry, detailing command line usage, potential issues, and deployment steps.'
        markdown_content: |-
          ***

          ## title: Deploying to a Local Blockchain II

          *Follow along with this video.*

          ***

          ## Deploying a Smart Contract on your Local Blockchain

          Are you tired of running into issues deploying your smart contract on your local blockchain? Whether you're using Ganache or Anvil for your blockchain development, we've got you covered. In this comprehensive guide, we're going to walk you through how to deploy contracts in two different ways, using the command line and the integrated Forge framework.

          <img src="/foundry/12-deploy-local-2/deploying1.png" style="width: 100%; height: auto;">

          ## The fundamentals: Your endpoint and private key

          Since you already have your endpoint and private key, you now have everything you need to deploy to your own local blockchain. However, just like working with a real blockchain, you need some balance to spend gas to deploy your contract.

          ## Getting started with the Command Line

          To kick things off, let's dive into the command line approach. This involves familiarizing with the Forge framework.

          ```bash
          forge help
          ```

          Running the command above provides a list of commands built into the Forge. For our cause, we are interested in the 'Create' command. Its function is to deploy a smart contract- exactly what we are looking to do.

          ```bash
          forge create --help
          ```

          Running the command above shows the numerous options available for deploying our contract. Be sure to have your private key ready, which you can copy from Anvil.

          **NOTE:** Please refrain from using actual private keys in Vs code or any platform that could potentially share your information unintentionally. Although we're using a fake private key for this exercise, the best practice is to use your terminal.

          ## Unraveling Potential Issues

          While trying to deploy our contract - 'Simple Storage' in this case - there is a possibility of running into an error when using the command:

          ```bash
          forge create SimpleStorage
          ```

          The error is due to the fact that the RPC server we are using doesn't coincide with the default Forge RPC server. To fix this, you need to assign the RPC URL manually and ensure it is in lowercase.

          If you forget to input the private key, the command line will remind you with another error! No worries though, just use the 'Up' key and include the 'interactive' option as seen in the command below. Then, follow the prompt to enter your private key.

          ```bash
          forge create SimpleStorage --rpc_url http://127.0.0.1:7545 --interactive
          ```

          *Note:* the URL is the one from ganache.

          <img src="/foundry/12-deploy-local-2/deploying2.png" style="width: 100%; height: auto;">

          You should now see your transaction details if you're using Ganache. The transaction and blocks you created beforehand should be visible.

          *Blockquote: "Despite Anvil not showing any transaction details, it serves as a more efficient platform for this procedure. Hence, we will be using it for the rest of this guide."*

          ## Conclusion

          That's it! You've now deployed a smart contract to your local blockchain. Take note that this process may require some tweaking depending on your specific environment or contract. Overall, by following these steps, you will have a robust foundation for deploying more complex smart contracts in your future blockchain projects.
      -
        id: 4ca84002-b8be-41ed-9a09-12f9e0e0ebcf
        type: new_lesson
        enabled: true
        title: 'Important: private key safety pt.1'
        slug: private-key-safety
        duration: 3
        video_url: cUPbUCpN6R3V100f8te4qvXehCJXRquh3uiYcDVvIllg
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/13-private-key-safety/+page.md
        description: 'In-depth guide on private key safety for blockchain developers, covering best practices, shell history clearing, and secure methods for handling private keys.'
        markdown_content: |-
          ***

          ## title: Private Key Safety

          *Follow along the course with this video.*

          ***

          # Practicing Private Key Safety: A Comprehensive Guide

          The following lesson will take you through the intricacies and dangers of mishandling your Private Key, while also highlighting the key steps you should take to maintain its safety.

          ## The Importance of Private Key Safety

          Now, here's an incredibly important piece of information and one worth your attention:

          <img src="/foundry/13-private-key-safety/private1.png" style="width: 100%; height: auto;">

          This goes especially for your production or private keys associated with actual money. This is a serious security risk and a transgression we cannot afford to make. Even though the example presented here involves a dummy private key, this is a practice we should generally steer clear from.

          <img src="/foundry/13-private-key-safety/private2.png" style="width: 100%; height: auto;">

          One common oversight lies not in how we treat our private keys, but rather in where we tend to leave them – our shell or Bash history. Here's an example to illustrate the point: once you execute commands in your terminal, a simple upward stroke on your arrow keys will display the previously carried out commands – including your private keys. It is easy to see why this fact poses a risk to private key safety.

          ## Clearing Your Shell History

          To remove your private key from your history in Bash, execute the following command:

          ```bash
          history -c
          ```

          This effectively clears your command history. Try hitting the 'up' arrow on your keyboard - you will not return any previously entered commands. To further test this, you can use the `history` keyword:

          ```bash
          history
          ```

          This command will return your entire command history. You can also use the `clear` command to clear your screen and then call `history` again to verify you've purged your command history as desired.

          ## Your Safety Promise

          It's time now to articulate your promise for maintaining private key safety. Create a file titled 'Promise.md'. In this file, make it a point to write down your promise:

          ```
          I promise to never use my private key associated with real money in plain text.
          ```

          If you feel comfortable doing so, consider tweeting this to affirm and secure your pledge. Tagging me or other experts in the field to hold yourself accountable can be immensely helpful. Remember, this is merely a first step in your commitments towards private key safety - many more promises are to come.

          As we're working with dummy keys for now, this may not seem like a big deal. But I assure you that the safety of your private keys in the future is of utmost importance. I’ve seen multiple multimillion-dollar companies overlook this protocol and, as a result, have their private keys breached.

          ## Deploying Your Contracts

          To deploy your contracts to any blockchain from a command line, you would generally use the `forge` command as shown below:

          ```bash
          forge create < name-of-your-contract > add < RPC-URL > < your-private-key >
          ```

          In upcoming sections, we will learn how to access RPC URLs for free using Alchemy for any blockchain. We will also delve into exploring safer methodologies for dealing with private keys.

          With this you now have a preliminary understanding of how to deploy your contracts to any blockchain from the command line. This knowledge equips you with the base tools to operate in a more secure digital environment, prioritizing private key safety, cleanliness of your bash history and the right way to deploy contracts to the blockchain.

          Keep following along for more tips, tricks, and best practices in maintaining your cyber safety.
      -
        id: 5067bfa3-74e2-4129-9135-227e19a335ee
        type: new_lesson
        enabled: true
        title: 'Deploy a smart contract locally using Anvil'
        slug: deploying-locally-anvil
        duration: 10
        video_url: VHqe5lxdzQ1SJampOzAC00qKYGi6Jd9UwLY7NT3jMg28
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/14-deploying-locally-iii/+page.md
        description: 'Tutorial on deploying smart contracts locally using Anvil, focusing on script creation, Solidity contract language, and Foundry cheat codes for deployment.'
        markdown_content: |-
          ***

          ## title: Deploying to a Local Blockchain III

          *Follow along with this video.*

          ***

          ## Deploying Contracts on Any Blockchain with Solidity

          After familiarizing ourselves on how to deploy a contract to any blockchain using the command line, it's time to engage in another method of deploying our contracts. This method is particularly handy because it provides a consistent and repeatable way to deploy smart contracts reliably and its features enhance the testing of both the deployment processes and the code itself.

          Contrary to the popular command-line approach, we create a script for our code deployment. This method enriches our learning process and makes the entire session enjoyable.

          ## The Solidity Contract Language

          Foundry eases the whole process since it is written in Solidity. This means our deployment scripts will also be in Solidity. It is essential to distinguish Solidity as a contract language from Solidity as a scripting language. Foundry also incorporates elements that enhance our Solidity experience beyond the smart contracts realm. So, let's get started on creating a script to deploy our simple storage contract.

          ### Creating the Deployment Script

          To create the script, follow these easy steps:

          1. Go to our script folder.
          2. Right-click on a new file.
          3. Create the file deploy `DeploySimpleStorage.s.sol`.

          The letter `S` in `s.sol` is a Foundry custom. Usually, scripts bear an `s.sol` extension instead of sol.

          Inside it, we are going to write our contract in Solidity to deploy our smart contract.

          And by the way, this script is written in Solidity but should not be considered as a contract for deployment. It is solely for deploying our code. Since it is written in Solidity, we start with the MIT SPDX License Identifier as usual.

          Check out the Foundry documentation for a comprehensive understanding of Solidity scripting in the tutorials section.

          To notify Foundry that our contract `DeploySimpleStorage.s.sol` is a script, we need to import additional code.

          Here is the code sample:

          ```js
              //SPDX-License-Identifier: MIT
              pragma solidity ^0.8.18;
              contract deploySimpleStorage{}
          ```

          Founder also has a lib folder which entails the Forge STD. Forge STD stands for Forge Standard Library. The library bears numerous beneficial tools and scripts for working with Foundry.

          Let's now make our contract `DeploySimpleStorage.s.sol` inherit from the functionality of this script by importing `forge-std/Script.sol` and stating is script. Foundry will then understand that this contract is a script.

          For clarification, our Deploy Simple Storage requires knowledge of our simple storage contract. Therefore, we'll import that too. We must also bear in mind that there is a superior method to run imports, known as named imports.

          Now here is where it gets exciting. Every Deploy or script contract should have a primary function known as Run. This function executes when we need to deploy our contract.

          Here is the code snippet:

          ```js
           function run() external returns (SimpleStorage) {
                  vm.startBroadcast();

                  SimpleStorage simpleStorage = new SimpleStorage();

                  vm.stopBroadcast();
                  return simpleStorage;
              }
          ```

          ### Using Cheat Codes in Foundry

          In the Run function, we are going to use a distinctive keyword: vm. Foundry has a distinctive feature known as cheat codes. The vm keyword is a cheat code in Foundry, and thereby only works in Foundry. You won't have much success trying it out in Remix or any other framework. Though, if we're inheriting Forge STD code, the vm keyword comes in handy.

          You can learn more about Foundry cheat codes in the Foundry documentation and Forge Standard Library references section.

          Are you confused about the vm keyword? No worries! The vm keyword is just a tool for controlling the interactions with Forge's local Ethereum testnet. We're using it here to specify that all the activities within the `startBroadcast` and `stopBroadcast` functions should take place on-chain.

          We deploy our simple storage contract via the `new` keyword. Simple Storage, denotes the contract, and simple storage the variable, are quite different.

          The new keyword in Solidity creates a new contract. It is also going to come up with a new contract amid the vm Star broadcasts. Should you find this a bit confusing, don't worry. We shall delve into the details later in the course. For now, remaining focused is the key. And finally, we can say return Simple Storage.

          ## Testing the Deployment

          Now to the exciting part. It's time to test our script by running it. If Forge is already running, we can kill it using the control C command. Now, let's ru:

          ```bash
          forge script script/DeploySimpleStorage.s.sol
          ```

          Ensure you adhere to the Solidity standards for smooth running.

          If an error message pops up about Solidity versions, just change both versions in the code to use the caret (^) symbol in order to allow use of the highest non-breaking version.

          Once everything is set, it's time for the real thing. First, compile the scripts to be deployed and the simple storage contract using version 0.8.19.

          ## Running Anvil

          If we try to run the Forge script without Anvil, Foundry will automatically deploy the contract or run the script on a temporary Anvil chain.

          But the beauty of Anvil comes in when we wish to simulate on-chain transactions. You can do this by passing an RPC URL when running the script. Once this is done, Anvil keeps records of previous deployments in case you need to refer to them.

          A final test is done by deploying the script to the blockchain. You use the `broadcast` command to send this out and also provide a private key to sign the transaction with.

          If all goes successfully, you'll be greeted with the message "on chain execution complete and successful".

          Hope this tutorial was insightful. Let's explore more in our next learning chapter!
      -
        id: 48917e07-fc94-487f-a44b-d6ad433b7094
        type: new_lesson
        enabled: true
        title: 'What is a transaction'
        slug: what-is-a-transaction
        duration: 6
        video_url: pbJrt4K6EeM02RMNhZm4pCBSDNQE00noGdDqkVaVvJGDw
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/15-what-is-a-transaction/+page.md
        description: 'Exploration of blockchain transactions, including a detailed overview of transaction components, contract deployment, and data fields in Ethereum.'
        markdown_content: |-
          ***

          ## title: What is a Transaction? But Actually

          *Follow along the course with this video.*

          ***

          ## Deep Dive into Blockchain Transactions

          Let's take a moment to really get to grips with what we're doing when we script and execute blockchain transactions. Many people find this element of blockchain to be a bit of a mystery, so let's pull the curtain back and lay out the steps and elements involved.

          ## Exploring the Terminal

          In your terminal, you'll see a few different directories. One of which is `dry run` - this is where files end up when there's no active blockchain. When a blockchain is running, the directories are divided by chain ID. Within these directories, such as `dry run` or `run latest`, you'll find detailed information about each transaction that has been executed. This includes information such as the transaction's hash, type, contract, name, address, and more.

          In this section, we can see exactly what's being sent on the chain whenever we use our scripting commands - `forge script` or `forge create`.

          This is the transaction we send to the RPC URL and it contains the relevant API data packaged for https POSTS. In this case, our transaction type is `2`. The `from` address refers to where the transaction is initiated from, and the `gas` is the hex value representing the computational effort the transaction requires.

          <img src="/foundry/14-transactions/transtactions1.png" style="width: 100%; height: auto;">

          Included in the transaction is a `value` field. When you're deploying a contract, this is just another transaction; we can therefore add a value to it if we want. This value can be in the form of the Ethereum blockchain's native currency - Ether. To do this, you just add a `value` field followed by the amount you wish to transact. Note though, in solidity, the `value` option can't be set if the constructor isn't payable.

          ## Contract Deployment and the Data Field

          Let's now focus on the data part of this transaction. In reality, this is the contract deployment code. But there's a bit more to it than that! It also contains the `nonce` value - a unique identifier that's used once for each transaction, and an access list (but we're not going to cover that in this post).

          In addition to the details stored in the transaction, a couple of other values play a part that aren't stored here. These are the `r` and `s` values which are used to generate a signature that makes the transaction valid. When a transaction is sent, it is signed using your private key. This signature then forms part of the transaction data.

          <img src="/foundry/14-transactions/transactions2.png" style="width: 100%; height: auto;">

          In terms of the `nonce` or nonce value mentioned earlier, this is managed by your chosen blockchain wallet. Every time a transaction is sent, it is given a nonce that increments after each transaction is sent. Finally, and critically, remember that any time you change the state of the blockchain you do so through a transaction. Each transaction contains an all-important data field, which includes 'opcodes' that tell the blockchain what you'd like it to do. In some cases, this might mean the creation of a new contract. In others, the data is merely associated with a basic transaction.

          ## Conclusion

          The world of blockchain transactions can seem complicated. By understanding these underlying processes, however, we can get a much richer understanding of how it functions. The powerful part comes when we understand the way transactions work when executing them with tools like Remix. It all comes down to that pivotal data field of a transaction!
      -
        id: 220b2276-4fbd-4acc-b754-6b5ca719684f
        type: new_lesson
        enabled: true
        title: 'Important: private key safety pt.2'
        slug: private-key-safety-part-2
        duration: 11
        video_url: 97giwCWjbSoFAXeo1QS00MhpgyyNka67Iuw00CK66gt00s
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/16-private-key-safety-ii/+page.md
        description: 'Guide on private key safety for interacting with deployed contracts, covering command line interfaces, environment file setup, and secure coding practices.'
        markdown_content: |-
          ***

          ## title: Private Key Safety II

          *Follow along the course with this video.*

          ***

          ## Interacting with Contract Deployment: Command Line Interface vs. Scripts

          Hello and welcome back! In this blog post, we'll cover how to interact with deployed contracts on the blockchain. As we've learned previously, we have two methods at our disposal: running scripts and using the command line interface (CLI). In this article, we'll focus primarily on the latter.

          Let's get started!

          ## Getting Started: Make Sure You're Deployed

          First, we need to confirm that our smart contract has been successfully deployed. From your terminal, bring up your deployment script by hitting the up arrow a few times, then run it again.

          ## Interacting with Contracts via the Command Line

          By now you may be familiar with Remix, a popular Ethereum IDE, and how it allows us to interact with our contracts by clicking buttons in its GUI. With the CLI, we interact with contracts in a similar manner but, in this case, by entering commands. However, using the CLI is just one of two ways we can interact with contracts.

          ## Cleaning up the Command Line

          We're going to make the contract interaction process a touch more efficient while also consolidating previously disparate actions. Often, we'd use Forge's command line interface (CLI) to interact with contracts, creating a new interactive CLI session each time and pasting our private key in when prompted. But we can streamline this.

          Let's clarify something here first:

          <img src="/foundry/16-private-key-safety-2/safety1.png" style="width: 100%; height: auto;">

          ## Storing Private Keys Safely

          The safer alternative is to first create a **.env** file to store what we call environment variables. These variables contain sensitive information, like your private key, which we don't want to expose publically. Adding private keys or other sensitive data to environment variables in your .env file avoids having to display them in your command line history or elsewhere accidentally.

          Remember though, only store test private keys in your .env file, never your actual private key.

          Here's a brief demonstration of how to do this.

          ```bash
              private key = [your private key]
              RPC_URL = http://your_rpc_url
          ```

          Now, we have to load these environment variables into our shell:

          ```bash
              source .env
          ```

          Now we can test out whether our environment variables were added successfully:

          ```bash
              echo $PRIVATE_KEY
              echo $RPC_URL
          ```

          ## Secure Coding: The Next Step

          Even though we've made our command line cleaner by removing any direct input of private keys, there's still the worry of having our keys stored in plain text. That's why our next step towards secure coding involves using a keystore.

          A keystore is an encrypted file that contains your private key. You'll need a password to decrypt it.Foundry, a blockchain development toolset is in the process of adding a feature that allows developers to use keystores instead of exposing their private keys. Do check their GitHub repo to see the status of this feature.

          In the meantime, it's essential to understand the step we've taken so far: using a .env file to store environment variables is acceptable for `_development_`. It is not the way to go for `_production_`.For production, you'd want to use Foundry's built-in interactive CLI to paste your key in, or use a keystore file with a password once Foundry integrates that function.

          Simply put:

          * **For Development**: Use environment variables
          * **For Production**: Use interactive CLI or a keystore file

          ## The Env Pledge: Promote Secure Development

          The `env` pledge is a set of rules focused on promoting secure development practices. It emphasizes using test private keys, ensuring private keys are not posted on any internet platform even momentarily, and taking immediate action if a key is potentially compromised. If you're *certain* you won't be deploying anything to the mainnet or working with a private key that holds real funds, you can rest easy. But remember, as developers, it's our responsibility to approach key management with utmost caution.

          Feel free to share these valuable pledges with other developers on various platforms. The more people aware of these, the better.

          I hope this blog post has helped you understand the crucial aspect of interacting with your contracts securely and efficiently. Remember, you're responsible for managing these keys safely, so follow this guide to ensure you're doing it right!
      -
        id: 8495d240-3ad3-4d6f-8b88-367728ea4b9a
        type: new_lesson
        enabled: true
        title: 'Never Use A Env File'
        slug: never-use-a-env-file
        duration: 7
        video_url: Oi00iQEuRE4PKWnPrmiKqH5a7Lj01pBfBvcCi02h1cepds
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/17-never-use-a-env-file/+page.md
        description: "In this lesson we'll finally rid ourselves of risky development practices and learn to employ methods to properly safeguard our private keys. Move past .env variables and never mistakenly compromise yourself again."
        markdown_content: |-
          ***

          ## title: Third Web Deploy

          *Follow along the course with this video.*

          ***

          # Moving Beyond Environment Variables

          A while back, I showed you a method where we utilized an environment variable (.env) to store private keys. However, times have evolved and we've acquired a much safer way to manage and protect those keys. This method involves using the Foundry's built-in ‘**cast**’ command which allows you to work with an encrypted version of the private key, thus avoiding any raw, plain-text encounters. If you're seeking a security review or an audit, and you still have a .env example left hanging around in your git repo, well, prepare yourself for a swift rejection.

          ## Why Moving Away From Plain Text Keys is Crucial

          Previously, I showed you how to use an Ethereum Private Key RPC URL and Etherscan API key as environment variables. We know, however, that plain texts can be precarious - you might accidentally push this critical piece of information to GitHub, or worse, disclose it in your terminal inadvertently.

          <img src="/foundry/update-env/env1.png" style="width: 100%; height: auto;">

          Therefore, it is extremely important to ensure the security of your private keys and never leave them open in the text format.

          ## Solution: Encrypting your Keys Using ERC2335

          The solution to this issue lies in the use of ERC2335. This is nothing but a nifty system that enables us to convert private keys into a secure JSON format.

          Let’s assume that your private key is the same as the default key that comes along with the Anvil development package. On running Anvil, you receive an output where you can locate said key.

          Once you have your key, from your terminal, go ahead and run the following command:

          ```bash
          cast wallet import defaultKey --interactive
          ```

          A highly recommended practice is **not** to run this in Visual Studio Code, but directly within your terminal or shell instead. This maneuver launches an interactive shell where you can safeguard your details. You may copy-paste your private key here. At this point of execution, you are required to enter a password, which you need to remember whenever you need to use this private key.

          On successful implementation, you will be provided with this message: `default Key store was saved successfully` and you will receive an address.

          Before, we fed our private key directly into our terminal and used a make file to make the operation appear easier. With our private key now securely stored and encrypted in our cast, we can verify its presence using:

          ```bash
          cast wallet list
          ```

          After this, you can use the following command to run our default script:

          ```bash
          forge script script/DeployFundMe.s.sol:DeployFundMe --rpc-url http://localhost:8545 --account defaultKey --sender 0xf39...--broadcast -vvvv
          ```

          <img src="/foundry/update-env/env2.png" style="width: 100%; height: auto;">

          The term 'private key' in this command is replaced with `account defaultKey --sender.` You still however need to copy-paste the address of the sender, AKA the address associated with the private key.

          A piece of advice to remember is that anytime you see your private key in plain text, your brain should give off alarm bells. And anytime you have the urge to reveal your private key, you must think twice. Even if you are using a development private key like in this course, when you start to work with real money, I highly encourage you to stick to the encrypted process.

          Once you encrypt your private key, your objective should be to then never revisit it. Always remember, the chances of implications multiply significantly, anytime you expose your private key. Unfortunately, there is still no full-proof method to completely avoid revealing private keys but we can surely minimize the risk by exposing it the least number of times possible.

          ## Conclusion

          To simplify things to the best level possible, avoid using .env files to store your private key. Instead, opt for encrypting it with **cast wallet import**. While you are at it, use a password or a password file for added security and delete the key from your history after you use it. This would ensure that your private key, especially those with real money associated, are protected most effectively.

          Finally, let's take a moment to appreciate the contribution of the people who were instrumental in making Foundry a reality, making our lives as developers easier and more secure.

          Stay safe, and until next time, happy coding!
      -
        id: 5b0806c9-eb4f-4258-aa8c-f5f8e89b32cb
        type: new_lesson
        enabled: true
        title: 'Deploy a smart contract using Thirdweb'
        slug: thirdweb-deploy
        duration: 5
        video_url: PuCd01cZuN54Yn00Q5GKfF5ToSTQaykxF01mWp100yXZ4Ls
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/18-thirdweb-deploy/+page.md
        description: 'Introduction to deploying smart contracts using Thirdweb, including benefits, ease of use, and features for secure and efficient contract deployment.'
        markdown_content: |-
          ***

          ## title: Third Web Deploy

          *Follow along the course with this video.*

          ***

          # Secure Contract Deployment with Third Web

          When developing on a blockchain, you inevitably come across challenges – like managing private keys in plaintext – that can potentially compromise the security of your solution. Third Web Deploy, a product of Third Web, offers a hassle-free and secure solution to such challenges.

          Kira from the Third Web team has provided a comprehensive overview of how Third Web can help you effortlessly deploy contracts on any EVM chain that you prefer. For those unfamiliar with the `npx` command, it comes pre-bundled with the node.js and NPM installation. You can refer to our GitHub repository to learn more. Now, let's dive into Kira’s explanation.

          <img src="/foundry/17-thirdweb/thirdweb1.png" style="width: 100%; height: auto;">

          ## Easy Contract Deployment with a Single Command

          To deploy a contract, generally, you would need to set up hardcoded private keys as well as RPC URLs, and they need some level of scripting. However, with Third Web, you can surpass all these tedious steps for deployment. Since you're not exporting your private key in this process, it enhances your contract's security significantly.

          The deployment process happens through a dashboard UI, enabling you to manage everything right from your wallet. Let's walk through the process of deploying contracts with Third Web.

          ## Deploying Contracts with Third Web

          Suppose you have already cloned a repository, or maybe you've written your contract. This could be any contract; for this walkthrough, I've cloned a simple storage contract.

          For this contract, there's no `.env` file, no RPC URL setup, and I haven't exported my private key. This is one of the fantastic aspects of Third Web - there is absolutely no pre-installation needed, no dependencies whatsoever, making the entire process much more straightforward and less time-consuming.

          To commence the deployment, all you need to do is run the simple command `npx thirdweb deploy`.

          ## What Happens When You Deploy

          On executing this command, Third Web will ascertain the project type, compile contracts, and permit you to choose the contract you wish to deploy. In this demonstration, I am deploying a simple storage contract.

          This action leads to the contract metadata getting uploaded to IPFS, resulting in automatic contract verification. For those interested in a more in-depth explanation of this mechanism, please visit the [Third Web Developer Docs](https://portal.thirdweb.com/deploy).

          <img src="/foundry/17-thirdweb/thirdweb2.png" style="width: 100%; height: auto;">

          Following these steps, a browser tab will open where you can deploy your contract through a front-end interface. In circumstances where construct params are required (they aren't in this case), you'll be able to fill them out directly.

          Next, you select the chain you wish to deploy to. Third Web supports all EVM networks, from the popular ones like Base to custom networks if they aren't listed already. In this case, I selected the Mumbai network for deployment.

          This process triggers two transactions – one, a transaction to deploy the contract, and two, a gasless message that you sign. This message adds your contract to your dashboard, providing a user-friendly interface to interact with the contract, very similar to Remix.

          Once these transactions are completed, your contract is successfully deployed, as simple as that!

          ## Navigating Third Web's Dashboard

          On successful deployment, the contract address will be visible, which you can copy for future use. The dashboard also offers several features for easy contract management:

          * The **Build tab** facilitates effortless front-end interface creation for contracts with easy-to-use hooks in various languages.
          * The **Explorer tab** allows the view and modifies the read and write functions of your contract—essentially, all functions you have in your contract are listed here.
          * You can monitor the events related to your contract and even access the source code.

          <img src="/foundry/17-thirdweb/thirdweb3.png" style="width: 100%; height: auto;">

          In a nutshell, Third Web provides a swift, easy, and secure way to deploy contracts. It's a one-stop-shop for your web three development needs with multiple language SDKs, prebuilt contracts, and a solid infrastructure for all your web three development requirements.

          For more information, visit [Third Web](https://www.thirdweb.com/) or refer to their detailed [Documentation](https://docs.thirdweb.com/).

          <img src="/foundry/17-thirdweb/thirdweb4.png" style="width: 100%; height: auto;">
      -
        id: 1acf7564-9d3d-40b9-8baf-e867f61a589e
        type: new_lesson
        enabled: true
        title: 'Interact with a smart contract using the CLI'
        slug: interact-with-smart-contract-cli
        duration: 4
        video_url: lbirn1O34hl7200uP4IaloDLu87p7iMnN1nqBAlSqR4A
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/19-cast-send/+page.md
        description: "Comprehensive guide on interacting with smart contracts using CLI and Foundry's Cast tool, detailing command usage for sending transactions and reading blockchain data."
        markdown_content: |-
          ***

          ## title: Cast Send

          *Follow along the course with this video.*

          ***

          ## Interacting With Contract Addresses via Command Line & Foundry's Cast Tool

          Where you new to blockchain or you're just looking to grasp an in-depth understanding of sending transactions and calling functions on a contract through the command line, this article has got you covered.

          In this piece, we will be exploring how to interact with these contracts, beginning with the command line interaction, and later extending that to scripts. Initially, we will interact with our deployed contract called **SimpleStorage contract** using private keys that is set as an environment variable.

          ## Using Foundry's Cast Tool

          <img src="/foundry/18-cast/cast1.png" style="width: 100%; height: auto;">

          Foundry has an in-built tool known as the **Cast**. Cast comes loaded with numerous commands to interact with. One such useful command is **'send'** which is designed to sign and publish a transaction. To view help about **'send'**, type `cast send --help`. You will see that the 'send' syntax uses two arguments, namely, signature and the arguments.

          *The signature* is essentially the identifier and docker of the function and its input types whereas *the arguments* is the data you want to pass to the function.

          ### Example: Using Cast tool to Interact with Simple Storage Contract

          Say, we have our simple storage contract and we deployed it. If we wanted to call our `store` function and send a transaction, we would just add some numbers and then click 'store'. However, if we want to call `store` from the command line, we can do it by passing the address we want, the signature and our desired values to pass to our `store` function.

          Here's an example of how you'd use the `cast send` function:

          ```bash
          cast send <address> store(uint256) <values>
          ```

          "*Remember, the function should be followed by its input types in parentheses, and then the values that you want to pass in.*"

          This command won't run immediately as we need to add our private key and RPC URL. So, let's do that. With the command **RPCCast**, the RPC URL can be added. Let's add our private key, too, just after the `RPC URL`.

          With the correct command, we'll get a bunch of data about our transaction back. We'll get the `block hash`, `block number`, `Contract address`, `Logs`, and the `transaction hash`.

          ### Using Cast Call to Read the Blockchain

          The Cast tool also provides a `call` function which reads off the blockchain. `cast call --help` will reveal that `call`, like `send`, takes two signature and arguments.

          The main difference between them, however, is that `call` is like pressing a view function button - it's not actually sending a transaction.

          Here’s an example:

          ```bash
          cast call <address> retrieve()
          ```

          We should get the hex value back from the executed command. From here, we need to convert the hexadecimal back to decimal using the `cast --to-base` function.

          ```bash
          cast --to-base <hex value copied> decimal
          ```

          You can see we get back the same numbers, which we've stored on the chain.

          ## Updating Stored Values

          If you decide to change the stored values, let's say from 123 to 777, you would send that transaction using the `send` command. Then call the `retrieve` function using the `cast call` like earlier. You should see the new number returned to you in the hexadecimal format. Simply convert the hexadecimal format back to decimal format, and voila - you've successfully interacted with your contract.

          ```bash
          cast send <address> store(uint256) 777
          ```

          Following this comprehensive guide, you can start interacting with your contracts from the command line smoothly and eventually with scripts. It's worth noting, this same approach can be used to interact with contracts on an actual test net or on an actual main net.

          Happy Contract Interactions!
      -
        id: c230292c-5fc1-4d55-9a2e-b86a2413ff0b
        type: new_lesson
        enabled: true
        title: 'Deploying a smart contract on testnet (Sepolia)'
        slug: deploying-smart-contract-testnet-sepolia
        duration: 6
        video_url: MbnsfY5GC5cvqeWIxLtBI02CF9TTd7lodJSmXZwG2SQ00
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/20-deploying-to-a-testnet/+page.md
        description: "Step-by-step tutorial on deploying smart contracts to Ethereum's Sepolia testnet using Foundry and Alchemy, including setting up RPC URLs and private keys."
        markdown_content: |-
          ***

          ## title: Deploying to a Testnet

          *Follow along the course with this video.*

          ***

          ## Deploying our Contract to Testnet or Live Network with Foundry and Alchemy

          Hi, everyone! Are you curious about what your contract would look like on a testnet or a live network? If so, buckle up because this blog post will cover exactly that! We'll walk through the process of updating our Environment Variable (.env) file for an actual testnet.

          Clearly, we need an actual testnet for a real network. But our trusty Metamask has built-in Infura connections that are incompatible. Why? Because they're tailored specifically for MetaMask. Hence, we need our own Remote Procedure Call (RPC) URL.

          ## Creating our Own RPC URL for a Testnet

          *To create one, we could run our own blockchain node, but let's be honest — many folks prefer avoiding that route. Instead, we utilize Node as a Service (NaaS) applications to expedite the process.*

          One promising option is using Alchemy - a free NaaS platform that we can send the transactions to. This procedure resides within the *Deploying to Testnet or Mainnnet* section in the full course repo of the Foundry.

          <img src="/foundry/19-testnet-deploy/testnet1.png" style="width: 100%; height: auto;">

          To access the Alchemy platform, we simply click on the aforementioned function. On the platform, we sign up (I used Google sign-in for this demo).

          Our next step is creating a new app in the Alchemy user interface. I named mine *Sepolia Testing* and kept the description the same, given that our chain will be an Ethereum one based on Ethiopia.

          We can bypass advanced features for now and finalize our app. Now we have the app details needed for our node, including frequency of calls and other details. We also have a new https endpoint by clicking view key, which functions exactly the same way as our ganache or MetaMask endpoint.

          ## Altering our Private Key

          Next, let's do something about our private keys. Our ganache private key will no longer cut it — it has neither real money nor any testnet ETH in it.

          Our solution is to use one of our MetaMask private keys. To do this, we switch back to Sepolia in our MetaMask, choose an account with money in it, click on account details, and export the private key. *Remember, never share your real private key!*

          Upon confirmation with your password, copy the private key and omit the line in the env file — hashtag or pound sign denoting comments.

          ## Executing the Transaction

          With our Sepolia RPC URL and private key from MetaMask, executing a transaction now becomes tremendously easier.

          ```bash
          source .env
          forge script script deploySimpleStorage.s.sol --rpc_url=$Sepolia_RPC_URL --private-key=$private_key --broadcast
          ```

          This command deploys our contract to the testnet, and we can monitor the transaction on our Alchemy dashboard.

          We soon find that our contract, Simple Storage, has been deployed on the Sepolia chain. We can grab our transaction hash and input it into Sepolia etherscan IO to confirm the successful transaction.

          After we refresh our Alchemy dashboard, we'll verify the requests sent and track the ETH send raw transaction that transmitted our transaction to the blockchain.

          So, this is how we deploy our contract on a real testnet leveraging Foundry and Alchemy!

          Our next step will explore adding real-world components to the mix. Stay tuned!
      -
        id: 2674ff49-7364-4444-a9a0-7d5fed16a387
        type: new_lesson
        enabled: true
        title: 'Verify a smart contract on Etherscan'
        slug: verify-smart-contract-etherscan
        duration: 2
        video_url: I00L6VW01MXtktSCsRN3cUW38lh6j16BrI3tyc4PEaGsc
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/21-manual-verification/+page.md
        description: 'Guide on verifying Ethereum smart contracts on Etherscan, covering manual verification steps and the importance of contract readability and accessibility.'
        markdown_content: |-
          ***

          ## title: Manual Verification

          *Follow along the course with this video.*

          ***

          # Verifying Your Ethereum Smart Contracts: A Step-by-Step Guide

          Ethereum smart contracts are powerful tools for decentralized applications. However, they can seem a bit intimidating when viewed in their raw form, especially for beginners. Today, we're exploring how to navigate these waters by inspecting and verifying smart contracts on Etherscan, a blockchain explorer.

          When working with Ethereum smart contracts, you'll often come across what seems like an overwhelming bunch of bytecode when examining the contract on Etherscan. Let's fix that.

          ## The Raw Contract: A Bytecode Jungle

          <img src="/foundry/20-verification/verification1.png" style="width: 100%; height: auto;">

          As you dive into your smart contract on Etherscan, you'll be greeted by the contract's bytecode. This usually appears as a jumbled mass of non-readable code, making it challenging to understand the contractual logic contained within.

          ## Verifying Your Smart Contract: The Hard Way

          Here's a step you can take to make the contract more readable; verify the contract. I'll show the hard and manual way first, and then follow up with a simpler, more streamlined method.

          To manually verify a contract on Etherscan or other Block Explorers, follow these steps:

          1. Navigate to the 'Verify' option.
          2. Select 'Solidity' as the contract's language.
          3. Since this is a single file contract, choose 'Single File'.
          4. The compiler version we're using for this demonstration is 0.8.19, and our open-source license is MIT. Fill these details accordingly.
          5. Click 'Continue'.

          Now, you'll need to copy the entire contract from your 'SimpleStorage.sol' file, paste it in the appropriate dialogue box, select 'Optimization' as 'Yes', and then verify that you're not a robot.

          <img src="/foundry/20-verification/verification2.png" style="width: 100%; height: auto;">

          Ensure that you leave the boxes for constructor ARGs, contract library addresses, and miscellaneous settings blank. Once done, click 'Verify and Publish'.

          At this stage, the verification process can get a little tricky. But if done correctly, if you click on your contract address, navigate to 'Contract', and then scroll down, the previously unapproachable code is now readable in Etherscan.

          Besides making the code legible, this process also provides access to the 'Read' and 'Write' contract buttons, and you can interact with your contract directly from Etherscan or elsewhere.

          <img src="/foundry/20-verification/verification3.png" style="width: 100%; height: auto;">

          ## Verifying Your Smart Contract: The Easy Way

          The manual verification method outlined above can be full of pitfalls. That’s why it's not a recommended method. Instead, I encourage you to conduct programmatic verification of your contracts which removes these barriers - a method I'll be teaching in the near future.

          In the end, verifying your contracts makes working with Ethereum smart contracts significantly more manageable and understandable. Whether you’re a veteran Ethereum developer or a newcomer to the space, having a clear understanding of your contracts is essential for building secure, efficient, and effective decentralized applications.

          Remember, Ethereum smart contracts, with their powerful capabilities, form the beating heart of any DApp. So it's critical to learn how to navigate, inspect, and verify your contracts to ensure they are error-free and function as intended. Happy coding!
      -
        id: 8df7e063-f1a6-4a5d-8bdd-d9b201f5b5dc
        type: new_lesson
        enabled: true
        title: 'Cleaning up the project'
        slug: cleaning-up-the-project
        duration: 3
        video_url: P2iqVy1BY2GaNsCVyZjXLkZzZKSYoILCjzYfoOzg3c8
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/22-cleaning-up/+page.md
        description: 'Tutorial on cleaning up a coding project, emphasizing formatting consistency using Forge and crafting an informative README file with Markdown.'
        markdown_content: |-
          ***

          ## title: Cleaning Up

          *Follow along the course with this video.*

          ***

          ## Mastering a Basic Coding Project: Formatting and README files

          Hello, we've covered a lot, and are rounding the corner to completion. As we look to wrap things up, let's focus on a couple of aspects that are essential for rounding out any project: Formatting and README files.

          ## Formatting for Consistency

          In this project, we've been using the powerful tool - Vs code auto-formatter to automatically format our code. This saves us tedium and ensures a consistent style throughout our files. But what happens when someone else comes to our codebase? We want them to apply formatting that aligns with our style. For this, we can use the `forge format command`.

          When we run `Forge format command`, our code reformats according to predefined rules. This command ensures that all our solidity code adheres to a consistent style.

          ```bash
          forge fmt
          ```

          You'll notice upon running this command that your code moulds itself into a neat and tidy format. Try it out - save without formatting, run the command, and watch your code auto-formatted right before your eyes.

          ## Crafting a README

          Every code repository isn't complete without a readme. If you want to contribute to open source, you'll find this file in almost every single repo. Your next stop, therefore, should be creating a `README.md` file. We create this by clicking on `right click new file` and then typing `README.md`.

          In this all-important file, you document critical information about your project: what it's about, how it works, instructions for collaborating, contact details, so on.

          ```bash
          touch README.md
          ```

          <img src="/foundry/21-clean-up/readme1.png" style="width: 100%; height: auto;">

          Take a look around. README files also contain notes and other bits of important information. I had jotted down some notes about private key usage in my README. Although it's no longer needed, so we'll just delete that for now.

          While this project isn't headed for GitHub, it's crucial to remember that the README is an invaluable addition when you push your code to platforms like GitHub. We'll get into this more in our next project, where I'll guide you through using version control systems and repositories.

          ## Marvel at Markdown

          README files make use of 'Markdown' syntax, a text-to-HTML conversion tool for web writers. Do you remember when we discussed using Markdown syntax to field questions? Guess what, we're back at it again!

          A quick run-through: To use markdown in our README, we can use a `#` for headlines, and simple text entry for regular lines. Here's a sneak peek:

          ```markdown
          # HelloSome text here
          ```

          To view what this looks like in HTML form, we can install a handy extension such as 'Markdown all in one' or 'Markdown Preview'.

          ```bash
          Command Shift P > View command palette > Markdown preview > Open preview
          ```

          This combination gives us a preview replicating how the document might look like on GitHub.

          <img src="/foundry/21-clean-up/readme2.png" style="width: 100%; height: auto;">

          You will notice that the headline "Hello" is big and bold, while "Some text here" retains regular formatting. Moreover, you can add 'backticks' to format a line as code.

          ```
           `code here`
          ```

          <img src="/foundry/21-clean-up/readme3.png" style="width: 100%; height: auto;">

          Pro-tip: A quick `Command Shift V` (or `Control Shift` for Windows and Linux users) opens up Preview mode.

          <img src="/foundry/21-clean-up/readme4.png" style="width: 100%; height: auto;">

          That's all for now! Remember, formatting and a well-documented README are integral to any project - big or small. Stay tuned for more tips, tricks, and insights into the exciting world of coding. Happy Coding!
      -
        id: c36079de-f431-4182-a2e2-da18aa6adbb7
        type: new_lesson
        enabled: true
        title: 'Introduction to Alchemy'
        slug: introduction-to-alchemy
        duration: 12
        video_url: tfv23r00Wnqrlbl93Qt02q1kkmRQTTipPl4FtJUTyt2cg
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/23-alchemy-mempool/+page.md
        description: 'Introduction to Alchemy, a developer platform for Web3 applications, covering its features, benefits, and steps to create an account and use its services.'
        markdown_content: |-
          ***

          ## title: Alchemy & The Mempool

          *Follow along the course with this video.*

          ***

          ## Alchemy: A Game Changer for Decentralized Application Development

          Innovation in the blockchain industry has come a long way, with powerful tools making their way into the ecosystem to support developers and bring efficiency to their workflows. Among these tools is Alchemy, and today we have Vito, the lead developer experience at Alchemy, to walk us through the platform, its features, and how you can leverage it to exponentially increase your productivity.

          ## What is Alchemy?

          Alchemy is a platform equipped with APIs, SDKs, and libraries to enhance your developer experience while working on Web3 projects. Think of Alchemy as the AWS of Web3. It functions as a node provider and developer tooling platform predominantly used in thousands of Web3 and Web2 applications, including large Web2 corporations like Adobe, Shopify, and Stripe.

          The need for platforms such as Alchemy arises from the fact that, as a developer, you don't usually have to worry about running the servers your code operates on or developing the deployment and integration pipelines for your application. Instead, you use services such as AWS, Azure, and Google Cloud for that—Alchemy does the same but for Web3.

          ## How Does Alchemy Work?

          Alchemy enhances your developer experience through a combination of features. The platform's primary component is the *Supernode*, a proprietary blockchain engine that works as a load balancer on top of your node.

          Like its name suggests, the Supernode ensures data from the blockchain is always up-to-date and readily available. Using the Supernode as a foundation, Alchemy has built the *Enhanced APIs*—a set of APIs that makes pulling data from the blockchain a breeze.

          To put it simply, the Alchemy Supernode sits at the core of its ecosystem, powering up functionalities like Enhanced APIs and monitoring tools while supporting multiple chains.

          What follows is a step-by-step guide on how to create a new account on Alchemy and leverage this platform to its full extent:

          ## Creating a New Account on Alchemy

          Creating an account on Alchemy is not only easy but also completely free. You can also freely scale your applications up using the platform's generous premium plans.

          #### Step 1: Navigate to Alchemy.com

          Head over to [Alchemy.com](https://www.alchemy.com/) and create a new account.

          #### Step 2: Create a New Application

          Once you have signed in, create a new application.

          Next, give your application a name and a description. Then, select a chain and network. Alchemy currently supports the majority of EVM-compatible chains, including:

          * Ethereum
          * Polygon (POS)
          * Zkevm
          * Optimism
          * Astar
          * Solana (non-EVM chain)

          ## The Application-Specific Dashboard

          Once your application is up and running, you will have access to the application-specific dashboard. This dashboard provides crucial insights into your application and infrastructure health, such as latency, compute units, and transaction success rate, which can be valuable for debugging and identifying issues.

          If you observe a lower success rate for your transactions, go to the "Recent Invalid Request" tab. This will list all unsuccessful requests along with the reasons for their failure, making it easier for you to debug and fix issues.

          <img src="/foundry/22-alchemy/alchemy1.png" style="width: 100%; height: auto;">

          ## Mempool Watcher

          Another powerful tool provided by Alchemy is the Mempool watcher. Picture it as Ethereum's mempool, where all pending transactions reside waiting for validation or mining.

          The Mempool watcher provides extensive details about your transactions, such as:

          * Transaction status (mined, pending, dropped, replaced)
          * Gas used
          * Time taken for validation
          * Transaction value
          * Sender's and receiver's address

          This detailed transaction tracking allows you to have a better understanding of each transaction and aids immensely in debugging specific issues related to individual transactions.

          ## Wrapping Up

          To sum up, Alchemy is a revolutionary platform that brings a plethora of tools to aid your Web3 development experience. From Supernode to Enhanced APIs and crucial troubleshooting tools, Alchemy is undeniably a game changer in the world of decentralized applications.

          "Alchemy can be a powerful asset to any blockchain developer, offering a simplified experience in an inherently complicated Web3 environment." – Vito, Lead Developer Experience at Alchemy.

          Vito suggests that you check out Alchemy's [documentation](https://docs.alchemy.com/) to explore more about the platform, its APIs, SDKs, libraries, and tools. Also, don't forget to follow them on Twitter at [@AlchemyPlatform](https://twitter.com/alchemyplatform) and [@AlchemyLearn](https://twitter.com/alchemyLearn). And if you want to connect directly with Vito, feel free to reach out to him on Twitter at [@VitoStack](https://twitter.com/VittoStack).

          Alchemy is revolutionizing the landscape of blockchain development and making it more accessible and efficient for everyone involved. Happy building with Alchemy!
      -
        id: 56e13acc-9c52-46bd-adc3-bf8d138c100b
        type: new_lesson
        enabled: true
        title: 'Wrap up, congratulations!'
        slug: summary-congratulations
        duration: 3
        video_url: dFq40100B5t33nJrqzU5B6yF852yZRXpY022Y2O02XspkPs
        raw_markdown_url: /routes/foundry/1-foundry-simple-storage/24-summary-congratulations/+page.md
        description: 'Summary and congratulations on completing the Foundry project, highlighting key learnings, tools used, and encouraging continued learning and coding practice.'
        markdown_content: |-
          ***

          ## title: Summary & Congratulations

          *Follow along the course with this video.*

          ***

          ## Celebrating Milestones in Foundry: A Complete Walkthrough of Our Recent Project

          You should feel a warm sense of accomplishment envelop you. Completing an entire project in Foundry is no mean feat. A hearty congratulation is in order for such an indomitable effort. This article serves as a quick, yet comprehensive, recap of everything we learnt in our project, proceeding into our next engagement. From the onset, rest assured, we are set to advance our Foundry skills, push upcoming projects on GitHub, and familiarize ourselves with advanced tooling.

          ## A Quick Trip Down Memory Lane: Key Takeaways from the Project

          Firstly, we journeyed through the process of creating a new Foundry project using Forge and Knit. These essential tools afforded us a structured, professional environment complete with folders to keep our work organized.

          We not only learnt about Foundry’s basic commands but also their specific functionalities such as:

          * **Cast**: interacts with contracts that have been previously deployed.
          * **Forge**: compiles and interacts with our contracts.
          * **Anvil**: deploys a local blockchain, similar to another tool we used, Ganache.

          A pivotal part of our learning process was comprehending that sending a transaction via our MetaMask is tantamount to making an HTTP post request to a particular RPC URL. A similar RPC URL can be obtained from a node-as-a-service provider like [Alchemy](https://www.alchemyapi.io/) and used to send transactions directly from our Foundry projects.

          We obtained practical knowledge on how to compile code in Foundry and write a Solidity script for its subsequent deployment. We also find it critical to ensure the security of our private keys. Hence, throughout this course, we will be using an `.env` file. But be warned when dealing with real money, having your private key in plain text is not advisable.

          ## Understanding Contract Deployment and Interaction on the Blockchain

          We delved into the automation of contract deployments to a blockchain. Post-deployment, we interacted with them using the `Cast` keyword and `send` to make transactions, then `Cast call` to read from those contracts.

          Moreover, the knowledge on how to auto format contracts with `Forge format` was acquired. We also learnt the painstaking yet rewarding manual method of verifying our contracts on the blockchain.

          ```bash
          forge format my_contract.sol
          ```

          <img src="/foundry/23-summary/summary1.png" style="width: 100%; height: auto;">

          ## Looking Ahead

          With these tools in your web development arsenal, you've performed exceptionally well – and yes, you should be incredibly proud. Remember, even something as small as installing tools like `Vs code` and `Foundry` can pose great difficulties, so, you're doing fantastic.

          Take a breather. Remember, breaks enhance productivity. Till next time, continue to strive for greatness in every line of code you write!

          <img src="/foundry/23-summary/summary2.png" style="width: 100%; height: auto;">
    type: new_section
    enabled: true
  -
    id: hT58INgW
    title: 'Foundry Fund Me'
    slug: foundry-fund-me
    lessons:
      -
        id: bba0c0f7-79cc-4a28-a9f8-3b3165ecbb52
        type: new_lesson
        enabled: true
        title: 'Fund Me project setup'
        slug: fund-me-project-setup
        duration: 5
        video_url: Zir6UHUPb00yGfc9dzttpcg3spP1VKXwqVW025gHLmcCY
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/1-fund-me-setup/+page.md
        description: 'Introduction to the Foundry FundMe project, including setting up GitHub, understanding the FundMe contract, exploring storage and state variables, and creating a new Foundry project folder.'
        markdown_content: |-
          ***

          ## title: Welcome & Setup

          *Follow along the course with this video.*

          ***

          Welcome to Lesson 7, where we will cover 'Foundry FundMe,' a crucial part of our smart contract journey. The aim of this lesson is to learn how to professionally deploy the code, master the art of creating fantastic tests, and gain insights into advanced debugging techniques.

          ## Your First GitHub Contribution

          This will be the first codebase that you will be contributing to GitHub yourself. Using a version control system such as GitHub, GitLab, or Radical is integral to being part of the Web Three ecosystem. For this lesson, we will be utilizing GitHub, given its popularity.

          ## Understanding the Foundry FundMe

          We start by delving into the FundMe contracts that we created previously. The source folder (`src`) contains these contracts, exhibiting the advanced syntax with all caps constants and underscores (`i_`, `s_`) fore immutables and storage/state variables, respectively.

          Until now, we talked a lot about storage and state, but we didn't delve into what they really mean. Through a 'Fun with Storage' example, we will uncover these concepts in this lesson. This will form the backbone of understanding how to make contracts more gas efficient. Hence, making transactions less expensive for users.

          ## Taking the Plunge

          All right, let's jump into the code!

          We will be working within our VS code, in our Foundry `F23` folder. To date, the only folder we have created is `foundry-simple-storage`. Now we will create a new one called `foundry-FundMe-f23` using the `mkdir` (make directory) command.

          ```bash
          $ mkdir foundry-FundMe-f23
          ```

          Using the `ls` (list) command, we will see these two folders. Following this, we will initiate VS code in the newly created `foundry-FundMe-f23` folder.

          ```bash
          $ code foundry-FundMe-f23
          ```

          <img src="/foundry-fund-me/1-setup/setup1.png" style="width: 100%; height: auto;">

          Once we set up our new VS code, we can initialize our blank Foundry project using the `forge init` command.

          ```bash
          $ forge init --force
          ```

          ## Understanding the Fundamentals through Counter.sol

          Subsequently, we come across the counter.sol contract within the `src` (source) folder. This is a basic contract that allows us to understand the foundational principles in depth. The contract has a `setNumber` function, an input parameter, `uint256 newNumber`, which modifies the variable as per the new number.

          It also includes an `increment` function employing the `++` syntax equivalent to the expression `number = number + 1`.

          ```js
          function increment() public {
              number = number + 1;
          }
          ```

          ## Deploying the Code

          Further, we learn how to deploy this code using Foundry scripts and make it easier to run these contracts on different chains requiring unique addresses. We also acquire insights into how to use Foundry scripting to interact with our contracts in reproducible scripts instead of always from the command line.

          ## Wrapping Up

          By the end of this lesson, you should have a thorough understanding of this code, how to use it, discuss it effectively, and more importantly, how to write fantastic tests for your contracts. This is a crucial skill for any aspiring smart contract engineer.

          Upon completion, you should 100% share the project on your GitHub and social channels. Remember, this lesson is an enormous step in your Smart Contract journey.

          Keep learning and let's get started with the Fund Me project!
      -
        id: 23135955-1931-478b-8023-2ebe899162b3
        type: new_lesson
        enabled: true
        title: 'Introduction to smart contracts testing'
        slug: smart-contract-testing-introduction
        duration: 2
        video_url: uTtkbgyY7Eq5W2A1SyTcv02iQk01oK4MXmYeqwZXkYE8w
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/2-testing-introduction/+page.md
        description: 'A guide on testing smart contracts using the \`forge test\` command and the \`counter.t.sol\` example, emphasizing the importance of test-driven development in programming.'
        markdown_content: |-
          ***

          ## title: Testing Introduction

          *Follow along the course with this video.*

          ***

          To stand out from the crowd, one must not only master the development of smart contracts but also proficiency in testing these smart contracts. This not only guarantees you the quality and reliability of your code but also significantly reduces the occurrence of runtime issues that could potentially cost both clients and organization substantial amounts.

          In this blog post, we will take a deep dive into the fascinating world of testing smart contracts, basing our illustrations on `forge test` command and the `counter.t.sol` example file.

          ## Wrap Up: Driving Excellence in Blockchain Development

          <img src="/foundry-fund-me/2-testing-intro/testing1.png" style="width: 100%; height: auto;">

          Start today by adopting test-driven development in your programming regimen. It might seem tedious to begin with, but once you comprehend its value, you will appreciate the increased reliability and robustness it rings to your code.

          Don't forget, always run `forge test` to check the health of your smart contract before shipping out your code. Stay tuned for a more detailed exploration of testing and foundry fundamentals in the next lesson.
      -
        id: d70c58eb-09aa-43d6-8cec-824516710bbb
        type: new_lesson
        enabled: true
        title: 'Finishing the setup'
        slug: finshing-the-setup
        duration: 6
        video_url: qbYGf4p8EP6VLmKChrrzXk6vgY41MEAILsJd7w1MR004
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/3-setup-continued/+page.md
        description: 'Continuation of the project setup, including cleaning up unnecessary files, incorporating contracts from Remix, resolving import errors, and directing imports with remappings.'
        markdown_content: |-
          ***

          ## title: Setup Continued

          *Follow along the course with this video.*

          ***

          ### Necessary Clean-Up

          To begin, we first need to clean up unwanted files in our project directory. Since we will be using our own contracts, we can safely remove any pre-existing counter files.

          ```shell
          $ rm -f Counter.sol
          ```

          ## Incorporating Contracts from Remix

          When it comes to creating new files for our smart contracts, we will be working from 'lesson four' and 'Remix FundMe'. It's of utmost importance not to copy-paste contracts from our Foundry FundMe file at this point. Instead, we can clone the Remix FundMe file and modify it to facilitate easier composition of tests and interactions.

          ```bash
          # Create a new file
          touch FundMe.sol
          # Copy-paste the contracts from Remix FundMe and paste it in this new file 
          ```

          We will do the same for the 'price converter' contract.

          ```shell
          # Create a new file
          touch priceConverter.sol
          # Copy-paste the content of the price converter contract file into this new file

          ```

          <img src="/foundry-fund-me/3-setup-continued/setup-c1.png" style="width: 100%; height: auto;">

          ### Resolving Import Issues

          When we try to compile our newly imported contracts, we might encounter import errors. This happens because while Remix automatically reaches into the NPM package repository to resolve imports, Foundry does not do this. In the context of Foundry, we must specify exactly where the dependencies should be pulled from.

          <img src="/foundry-fund-me/3-setup-continued/setup-c2.png" style="width: 100%; height: auto;">

          Let's install this dependency with the 'forge install' command.

          ```shell
          # The command is written as follows:
          forge install smartcontractkit/chainlink-brownie-contracts
          ```

          We can now view and access these contracts in our local environment. The path to these contracts lies in the newly created 'Lib' folder.

          ### Redirecting Imports with Remappings

          At this moment, our contracts inaccurately import the 'aggregatorv3interface' from '@chainlink contracts'. To correct this, we need to instruct Foundry that '@chainlink contracts' actually points to our local 'Lib' folder. This can be achieved through a Foundry configuration file known as 'foundry.toml,' where we can establish a conduit, or remapping, to set this path accurately.

          <img src="/foundry-fund-me/3-setup-continued/setup-c3.png" style="width: 100%; height: auto;">

          In the remapping section, construct this line of text:

          ```js
          remappings = ["@chainlink=lib/chainlink-brownie-contracts/contracts"]
          ```

          This tells Foundry to replace '@chainlink contracts' with the path to the local library's chainlink brownie contracts.

          ### Final Compilation and Potential Errors

          Finally, we're ready to compile our contracts!

          ```shell
          $ forge build
          ```

          <img src="/foundry-fund-me/3-setup-continued/setup-c4.png" style="width: 100%; height: auto;">

          If you encounter errors, which are common in the course of such complex processes, consider labeling them with the contract name – followed by two underscores. It's a nifty convention that quickly helps identify which contracts throw these errors – for instance, here, 'FundMe contract.'

          With these simple steps, you have set up your smart contracts and launched your journey into the innovative world of building decentralized applications!
      -
        id: 8df6e47f-e894-46cd-b1b7-63cf527f9a7d
        type: new_lesson
        enabled: true
        title: 'Writing tests for your Solidity smart contract'
        slug: writing-tests-for-solidity-smart-contracts
        duration: 9
        video_url: 6l01DZwcMn6giZRo1jH1T3h013bYIfkqQmI5jo0201tx01co
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/4-tests/+page.md
        description: 'Detailed explanation on writing and running tests for Solidity smart contracts, including creating test files, understanding the setup function, and using console logs for debugging.'
        markdown_content: |-
          ***

          ## title: Testing

          *Follow along the course with this video.*

          ***

          In this post, we will walk you through the entire process of creating robust tests for your smart contracts. Testing is an absolutely crucial step in your smart contract development journey, as the lack of tests can be a roadblock in the deployment stage or during a smart contract audit.

          So, buckle up as we unveil what separates the best developers from the rest: comprehensive, effective tests!

          ## Test File Creation and Basics

          Begin by creating a new file `FundMeTest.t.sol` to compose your tests. The 't' in `.t.sol` represents a convention in Solidity for test files.

          Our test will follow the same syntax as any Solidity contract. To start, we will specify the SPDX license and program solidity. We'll be making use of GitHub Copilot, which is useful for providing solid code recommendations.

          The test code initially looks like this:

          ```js
          // SPDX-License-Identifier: MIT
          pragma solidity;contract fundMeTest { }
          ```

          To make running our tests easier, we will import a standard contract from the Forge Standard Library. We'll utilize the `test` contract from `std.st`.

          ```js
          import {Test} from "forge-std/Test.sol";
          contract FundMeTest is test { }
          ```

          ## Prioritizing Smart Contract Functionality

          Our first goal is to ensure our FundMe contract operates effectively. Thus, one of the first tasks is to deploy this contract. We can accomplish this task by initially deploying our contracts directly in the test folder. Ideally, one should import the contract deployment scripts into the test scripts to homogenize the deployment and testing environments.

          While setting up our test contract, include a function called `setup`. This function is always the first to execute whenever we run our tests. Here's how it should look:

          ```js
          function setup() external { }
          ```

          Our setup function will deploy our contract. Before that, let's briefly explore what a test might look like. Here's an example:

          ```js
          function testDemo() public { }
          ```

          Upon executing `forge test`, you will see a successful compiler run, indicating our test passed.

          ## The Magic of 'Setup' and 'Console'

          Do you know why `setup` runs first? Let's break it down with an example:

          ```js
              uint256 number = 1;
              function setup() external {
                  number = 2;
              }
              function testDemo() {
                  assertEq(number, 2);
              }
          ```

          Above, we declared `number` as 1. Within `setup`, `number` becomes 2. When we call the `testdemo` function and assert `number` is equal to 2, the test passes.

          The `setup` function allowed us to update `number` before running our tests.

          How about debugging these tests? We can tap into console logging for that.

          The Console is a part of the `test.sol` contract included by default with Forge. The library lets us output print statements from our tests and contracts.

          Consider this code snippet:

          ```js
          function testDemo() public {
              console.log(number);
              console.log("Hello, world!");
          }
          ```

          Running `forge test -vv` prints the current value of `number` and "Hello, world!" The `-vv` specifies the verbosity level of the logging, giving us insight into our test results.S

          <img src="/foundry-fund-me/4-tests/tests1.png" style="width: 100%; height: auto;">

          ## Deploying the Contract

          Let's dive back into our `setup` function and deploy the contract. To accomplish that, the contract should know about `fundMe`.

          Let's import it:

          ```js
          import "FundMe" from "../src/FundMe.sol";
          ```

          Next, we will initialize the `fundMe` contract in the `setup` function:

          ```js
          FundMe fundMe = new FundMe();
          ```

          The contract is now deployed, and we are all set for testing.

          ## Writing and Running a Test

          Let's begin by writing a test that ensures our minimum USD value is five.

          Considering `minimumUSD` is a public variable, we will validate within our `testdemo` function if the value is indeed 5 times 10⁹ or simply 5e18:

          ```js
          function testMinimumDollarIsFive() public {
              assertEq(fundMe.MINIMUM_USD(), 5e18);
          }
          ```

          Now, if we run `forge test`, you should see "compiler run successful" and that the "test minimum dollar is five" has passed.

          If you increase the testing value to 6 and rerun the test, it should fail, as the starting minimum USD is five.

          Now, alter the testing value back to five and rerun the test. The compiler should run successfully.

          Congratulations! You’ve just run your first basic test. Maintaining this testing practice consistently can help you secure your systems significantly.

          ## Wrapping Up!

          As technology advances, especially with the introduction of AI, you can go further with testing. With rigorous testing habits, you can ensure that your smart contracts behave as expected and transform from a mediocre developer to a proficient one.
      -
        id: b8f5d1cf-2554-41d8-9240-a3069d854c7a
        type: new_lesson
        enabled: true
        title: 'Debug your Solidity tests'
        slug: debugging-tests
        duration: 3
        video_url: t2vhCi015Yw003Ib2HoK9XrbEftuGmnY00aAlD4dEdEths
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/5-debugging-tests/+page.md
        description: 'A guide to debugging tests in Solidity, including writing and analyzing test functions, using console logs for troubleshooting, and understanding test failures.'
        markdown_content: |-
          ***

          ## title: Debugging Tests

          *Follow along the course with this video.*

          ***

          \#By taking a hands-on approach, we'll write some functional tests to ensure that our code is working as expected and debug potential issues. This blog post is intended for both the seasoned veteran looking to tighten their test suite or a newcomer wanting to know more about the essentials of testing in Solidity.

          ## Writing the First Test

          Let's go ahead and write a new test. This time, we'll examine whether the actual owner of a contract is indeed its message sender. Starting off, we can begin with the following function:

          ```js
          function testOwnerIsMessageSender () public {
              assertEq(FundMe.i_owner(), msg.sender);
          }
          ```

          One of the beneficial aspects of writing descriptive test functions is the role it plays in assisting GitHub Copilot with comprehending your coding intentions.

          ## Debugging the Test

          Inevitably, there may be moments where our test fail and present us with an unexpected output. So, how do we determine why this failed or what transpired?

          To debug, we could use numerous techniques we've learned, such as console logs. Let's console log out the literal owner and also the message sender for our starting point.

          ```js
          console.log(FundMe.i_owner());
          console.log(msg.sender);
          ```

          Then, re-run the test to examine the console output. This will allow us to check whether these two addresses are indeed different.

          ```bash
          forge test -vv
          ```

          ## Understanding Test Failures

          Now from the console outputs, the result is that indeed these are two different addresses. This disparity arises because technically, in our setup function, the FundMe test contract is what deploys our FundMe address and would therefore be the owner. The message sender is whoever's making the call to the FundMe test.

          In essence, the process looks something akin to this:

          * 'Us' calls the `FundMe test`, which then deploys `FundMe`.
          * The `FundMe test` becomes the owner of `FundMe`, and not 'us'.

          With this newfound understanding, it becomes clear that we shouldn't be checking to see if the `message sender` is the owner, rather we ought to check if `FundMe test` is the owner.

          <img src="/foundry-fund-me/5-debug-tests/debug1.png" style="width: 100%; height: auto;">

          ## Correcting the Test

          Let's re-write our test function to reflect this information:

          ```js
          function testOwnerIsMessageSender () public {
              assertEq(FundMe.i_owner(), address(this));
          }
          ```

          After running the test again, we find that indeed, our assertion was correct. Well done!

          ## Conclusion on Testing

          Console logs have proven to be a very useful debugging tool when writing tests. Of course, as we progress, we'll uncover more helpful ways to construct our tests. But for now, let's take a pause on these, as we'll return to refactor them soon.

          If you've written just these tests, great job. To challenge yourself, you might want to pause and try to write some additional tests on your own. After all, practice is the key to mastering any programming language – and this holds particularly true for Solidity!
      -
        id: b3ef4b83-29e1-41c9-861b-c62771925dfd
        type: new_lesson
        enabled: true
        title: 'Advanced deploy scripts'
        slug: advanced-deploy-scripts
        duration: 3
        video_url: 6MUKEb00yI00gldYcomioJNt2YDlUOvkNmUi2ialb5z8k
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/6-advanced-deploy-scripts/+page.md
        description: 'Tutorial on writing advanced deploy scripts for smart contracts in Solidity, focusing on avoiding hardcoded contract addresses and making contracts more dynamic and adaptable.'
        markdown_content: |-
          ***

          ## title: Advanced Deploy Scripts

          *Follow along the course with this video.*

          ***

          When crafting code for our blockchain, we encountered a significant obstacle. Our contract address was frequently hard-coded. This wouldn't ordinarily be an issue; however, our contract address merely existed on Sepolia, while we continued our testing phase on our local chain. In this lesson, we'll tackle this issue while simultaneously moving ahead in our coding project, so brace yourselves for an exciting ride. Let's dive in!

          ## Writing our Deploy Scripts

          Before we tackle our hard-code issue, let's execute an important task that we know is on our to-do list—writing our deploy scripts.

          Start by creating a new file named Deployfundme.s.sol. The standalone 'S' signifies the file is a script. Include the same SPDX license identifier, replace MIT with your own, and proceed to declare your contract deploy fund me.

          ```js
              SPDX-License-Identifier: MIT
              pragma solidity 0.8.18;
              contract DeployFundMe {}
          ```

          We're using Foundry, which means we need to import several lines of code, including the forge std script sol, and since we're deploying FundMe, why not import it from SRCF. Next, to run the script, you'll want to use the function. Revisit lesson six if you're finding this step a bit confusing—the function applies an external function for the VM start broadcast, and a FundMe in lower case equals the new FundMe navigated by a VM stop broadcast.

          ```javascript
              function run() external{
                  vm.startBroadcast();
                  new FundMe();
                  vm.stopBroadcast();
              }
          ```

          Following the function run prompts the script to run the `DeployFundMe.s.sol`. Encountering a 'VM' keyword error means you need to use the script. Rectifying this error leads to warnings about an unused local variable. In all probability, you do not even require this line. It's alright to remove it altogether and re-run the script.

          <img src="/foundry-fund-me/6-advanced-deploy/deploy1.png" style="width: 100%; height: auto;">

          ## Overcoming Errors and Ensuring Smooth Running

          Following these steps should help in successfully running the compiler, with the script showing successful execution. Ensure that you pass an RPC URL if you wish to simulate on-chain transactions.

          <img src="/foundry-fund-me/6-advanced-deploy/deploy2.png" style="width: 100%; height: auto;">

          The navigation of these steps indicates the importance of problem-solving in the blockchain coding world. In the upcoming blog posts, we will offer solutions on how to navigate hard-coding challenges in your blockchain coding challenges. Stay tuned for more insights!
      -
        id: 8b07077c-a7aa-41d9-86cd-f54d51dc678f
        type: new_lesson
        enabled: true
        title: 'Running tests on chains forks'
        slug: forked-tests
        duration: 9
        video_url: BJjAGj02qjxRwoJJ8joHXF2MSXl8Cvfo006nQ021Kdtiwo
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/7-forked-tests/+page.md
        description: 'Instructions on running tests on forked blockchain chains, ensuring functional price feed integrations, and addressing issues related to non-existent contract addresses.'
        markdown_content: |-
          ***

          ## title: Forked Tests

          *Follow along the course with this video.*

          ***

          As we delve further into the mechanisms of our evolving FundMe tool, we find ourselves grappling with some indispensable features we need to solidify. What jumps to mind first? Yes, you’re thinking right. It's the FundMe proceeds.

          As developers, we must ensure that our conversion rate is functioning as expected, thereby assuring us that the funding aspect of our tool is reliable. For this, we must ascertain that we can acquire the right version from our aggregator v3 interface and interact with it appropriately.

          Let's plunge into this intricate process, taking one step at a time.

          ### Ensuring Functional Price Feed Integrations

          The first step involves testing our price feed integrations using the `get version` function. We know from Remix that it should return version four.

          ```javascript
          function testPriceFeedVersionIsAccurate() {
              uint256 version = FundMe.getVersion();
              assertEq(version, 4);
          }
          ```

          Delving further into the world of testing, we try running the test with Forge:

          ```bash
          forge test
          ```

          And lo and behold, we encounter an EVM revert. But why did this happen? To intensify our focus on this particular test and sideline the rest, we use this method:

          ```javascript
          forge test -m testPriceFeedVersionIsAccurate
          ```

          By switching the visibility with three V's, we can acquire more information. We now see that we get what's known as a stack trace of the error, pointing out that our GetVersion call is reverting due to a non-existing contract address. This happens since Foundry automatically sets up an Anvil chain for test runs, deleting it after completion.

          ```bash
          forge test -vvv
          ```

          ### Addressing Non-Existent Contract Addresses

          At this stage, you might be left wondering how to tackle these non-existent addresses. Can we even test our `testPriceFeedVersion` accurately when it encounters hiccup due to Forge and Anvil? Yes, we can - with a little maneuvering. One way is to use a fork URL. Here, we’ll draw a parallel situation where we use Alchemy to generate an API key.

          ```bash
          SEPOLIA-RPC-URL=your-alchemy-key
          ```

          Make sure your .env file exists and is a part of your .gitignore.

          ```bash
          echo $SEPOLIA-RPC-URL
          ```

          You can now utilize this RPC URL.

          ```bash
          forge test -M testPriceFeedVersionIsAccurate --fork-url $SEPOLIA-RPC-URL
          ```

          The Anvil spins up but imitates transactions as if they were on the Sepolia chain. Our test's successful run now verifies that our transaction was performed adequately on the Sepolia chain.

          <img src="/foundry-fund-me/7-forked-tests/forked1.png" style="width: 100%; height: auto;">

          ### Balanced Approach: Unit Test, Integration Test, Forked and Staging Test

          While we tackle and solve the problems at hand, it’s essential to remember that we are learning to maneuver around four main testing approaches. In the journey with FundMe, we will navigate primarily through Unit, Integration, and Forked tests.

          1. Unit test - A method of testing a particular code piece or function. In this case, we could argue that `getVersion` function was a unit test.
          2. Integration test - Multi-contract testing to ensure that all interrelated contracts effectively work together.
          3. Fork test - Testing our code in a simulated real environment.
          4. Staging test - Deploying our code to a real environment like testnet or mainnet to validate that everything indeed works as it should.

          Each of these tests has its strengths, weaknesses, and ideal usage instances. For instance, maintaining a balance between the number of fork tests versus standard tests is crucial to not overdo API calls to your alchemy node and sending your bill through the roof.

          ### Conclusion

          Testing forms the backbone of the code we write and deploy. It is crucial to comprehend the need for testing coverage for our codes. Writing an extensive set of tests and achieving maximum test coverage lets us confidently deploy our contract to perform as expected.

          Ensuring a good level of coverage across the board, unit tests, integration tests, fork tests, and staging tests, can sometimes seem overwhelming. However, the more one works with it, the clearer it seems. I promise you, it's only a matter of learning, doing, and repeating.

          <img src="/foundry-fund-me/7-forked-tests/forked2.png" style="width: 100%; height: auto;">
      -
        id: a2e5eb2f-09d0-46c2-833a-26becd480103
        type: new_lesson
        enabled: true
        title: 'Refactoring your tests'
        slug: refactoring-testing
        duration: 8
        video_url: HEWHWq4nLks01HagcB1P96TfuXOeBa5QN1YWI8ASHRq4
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/8-refactoring-testing/+page.md
        description: 'Guide on refactoring tests for better efficiency and clarity, including updating price converter functions and deploying contracts on different networks with ease.'
        markdown_content: |-
          ***

          ## title: Refactoring I - Testing Deploy Scripts

          *Follow along the course with this video.*

          ***

          Did you know that the way you code your smart contracts could cause unnecessary work if you intend to switch chains? Many developers, particularly those familiar with the Solidity development suite, have found themselves enslaved by hardcoded contracts. Sure, they might work perfectly for Sepolia (the current chain of deployment) but they are incredibly restrictive for future use.

          What happens when you need to switch chains? A total overhaul of your code base, strenuous updates to all the addresses involved...it could take a lot of time and effort to get everything working correctly. In this lesson, we're going to explore an alternative approach to deploying smart contracts. We want to say goodbye to hardcoding and maintenance chaos, and say hello to *modular deployments*.

          This reframed approach to deployment allows us to reference addresses and external systems dynamically. This means that we could potentially move our contracts from network to network with ease. Sure, it will require some refactoring, but in the end, it's going to make our lives a lot easier.

          ## Refactoring Your Core Code

          Let's dive into our core code and decouple its dependency on Sepolia.

          To avoid hardcoding the address of the contract, we're going to pass it as a constructor parameter each time we deploy the contract.

          Here's how we can achieve this:

          ```js
          constructor(address priceFeed) {
              s_priceFeed = AggregatorV3Interface(priceFeed);
          }
          ```

          This approach means we can adjust the address to match the network we're currently using for deployment. This refactor is essentially reworking the architecture of the code without altering its functionality. It’s a crucial practice among engineers to keep their code maintainable. The addition of a new aggregator interface variable in the state and storage variables, s\_priceFeed, provides a place where the address can live after it's passed into the constructor.

          This makes it much easier to reference, especially when we want to deploy on different chains. With this refactor, you're no longer hard-coding the address and can instead call the version function directly on your price feed variable.

          ```js
          return s_priceFeed.version();
          ```

          ## Updating The Price Converter

          We also need to update our price conversion functions to accept an additional parameter: the price feed address passed during deployment.

          ```js
          function getPrice(AggregatorV3Interface priceFeed) internal view returns (uint256){
              (,int256 answer,,,) = priceFeed.latestRoundData();
              return uint256(answer * 10000000000);
          }

          function getConversionRate(uint256 ethAmount, AggregatorV3Interface priceFeed) internal view returns (uint256){
              uint256 ethPrice = getPrice(priceFeed);
              uint256 ethAMountInUsd (ethPrice * ethAmount) / 1000000000000000000;
              return ethAMountInUsd;
          }
          ```

          Within these functions, we simply replaced the hardcoded price feed object with the one passed into the function.

          Having a modular approach to deployment makes it possible to deploy contracts to different networks easily, explore different testing environments, and maintain a maintainable and less error-prone code base throughout.

          ## All's Well That Deploys Well

          By exploring modular deployments, we've been able to overhaul our code architecture and streamline the deployment and testing of our smart contracts across different chains more efficiently.

          However, refactoring is not without challenges. The modifying of the funder address in our test case from address(this) to msg.sender caused an initial hiccup upon testing. After fixing this, our tests passed.

          <img src="/foundry-fund-me/8-refactor/refactor1.png" style="width: 100%; height: auto;">

          The ability to refactor your code for a more flexible, modular deployment system is a skillset that sets you apart from the average solidity developer. There's a bit of a learning curve, but the payoff is enormous both in terms of versatility and maintainability.

          So great job on making it this far. I'm excited for you as you continue to expand your developer toolkit!

          Now go out, experiment, refactor, test, and innovate. The world of solidity development is at your fingertips.
      -
        id: 39383e0f-19f1-4ba0-a1e7-56daebb424f0
        type: new_lesson
        enabled: true
        title: 'Deploy a mock priceFeed'
        slug: refactoring-helper
        duration: 14
        video_url: vYhiv501502cgSXT1aaAIeG6uxvkLmnFUDKkvBlz12b01Q
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/9-refactoring-helper/+page.md
        description: 'Detailed guide on setting up a mocked environment for local testing of blockchain smart contracts, emphasizing the benefits and steps for creating mock contracts.'
        markdown_content: |-
          ***

          ## title: Refactoring II - Helper Config

          *Follow along the course with this video.*

          ***

          When building and testing your blockchain, you've likely found yourself often making calls to your Alchemy node. Furthermore, you may have noticed the undesirable outcome of this, running up your bill with each test suite execution. So, how can you streamline this process for local development and eliminate redundant API calls to Alchemy? The answer lies in creating mock contracts on your local chain.

          In this blog, we'll detail how to set up a mocked environment for local testing and bypass the need to hard-code addresses, while ensuring the functionality remains undisturbed.

          ### The Importance of Local Testing

          Before we dive into the code, let's emphasize why this practice is so beneficial. By creating a local testing environment, you reduce your chances of breaking anything in the refactoring process, as you can test all changes before they go live. No more hardcoding of addresses and no more failures when you try to run a test without a forked chain. As a powerful yet simple tool, a mock contract allows you to simulate the behavior of a real contract without the need to interact with a live blockchain.

          ### Creating the Mock Contract

          Let's start by creating a new contract called `HelperConfig.s.sol`. This contract serves two main purposes:

          1. It deploys mocks when we're on a local anvil chain
          2. Maintains track of contract addresses across various chains

          ```js

          import {Script} from "forge-stf/Scripts.sol"

          contract HelperConfig {}
          ```

          Now, you'll notice `forge-stf/Scripts.sol` being imported at the start of this contract. This helps us determine whether we're in a local anvil chain so that we can deploy the mock contracts accordingly. Similarly, we keep a tab on contract addresses depending on the chain we're on with the aid of address tracking logic.

          ### Developing Specific Network Configurations

          Next, let's create functions `getSapoliaEthConfig` and `getAnvilEthConfig` that return configurations for the respective chains.

          ```javascript

              NetworkConfig public activeNetworkConfig;

              function getSepoliaEthConfig() public pure returns (NetworkConfig memory) {
                  NetworkConfig memory sepoliaConfig = NetworkConfig(address);
                  return sepoliaConfig;
              }
              function getAnvilEthConfig() public pure returns (NetworkConfig memory) {NetworkConfig memory config = NetworkConfig(address);// other logicreturn config;}
          ```

          In this way, you can create multiple network configurations quickly.

          However, the main challenge arises when you have to decide which configuration to use. For that, we'll create a public variable `activeNetworkConfig`, which gives us an insight into the current network type. Based on the network type, we can set the `activeNetworkConfig` and make our tests much more flexible.

          ```javascript
          if (block.chainId == 11155111) {
            activeNetworkConfig = getSepoliaEthConfig();
          } else {
            activeNetworkConfig = getAnvilEthConfig();
          }
          ```

          Note that the `block.chainId` equals `11155111` is the specific chain ID for the Sapolia chain. For each chain, you can find their respective IDs using this [chainlist](https://chainlist.org).

          ### Toward More Effective Testing

          With such an architecture in place, you can now test against a forked Mainnet or any other blockchain you choose to deploy. Import your `HelperConfig` in the test files and set the `activeNetworkConfig` at the beginning of every test suite.

          ```javascript
             import HelperConfig from 'HelperConfig.s.sol';
             HelperConfig helperConfig = new HelperConfig;
             // then get the price feed address
             address ethUsdPriceFeed = helperConfig.activeNetworkConfig.priceFeed;
          ```

          This setup enables you to check your code against different chains without having to hard-code any addresses.

          Just remember to define a new `NetworkConfig` type for every chain you want to test against, and you're good to go.

          For example, if you want to deploy on the Ethereum Mainnet, you can define a dedicated function to get the mainnet's ETH config.

          ```javascript
              function getMainnetEthConfig() public pure returns (NetworkConfig memory) {
                  NetworkConfig memory config = NetworkConfig(address);// other logic
                  return config;
              }
          ```

          And in your constructor, add a new condition to check if the current chain is the Ethereum Mainnet.

          ```javascript
             else if (block.chainId == 1) {activeNetworkConfig = getMainnetETHConfig;}
          ```

          This modularity ensures that you can run your tests on any chain, simply adding additional network configuration as necessary. Run `forge test, fork URL, mainnetrpcURL`, and get to testing on the Ethereum Mainnet right away.

          ### Conclusion

          In conclusion, mock contracts are a valuable asset for local development. They enable you to test and refine your contract without the need for constant calls to your Alchemy node, saving you valuable time and resources. Plus, having a well-structured way to manage different configurations for different networks makes running tests and deploying on different chains a breeze.

          <img src="/foundry-fund-me/9-config/config1.png" style="width: 100%; height: auto;">

          As we've highlighted here, each blockchain development project can be optimized with a few simple steps. As long as you're armed with the knowledge of your chain's ID and the addresses you need, you can create a local testing environment that aids you in creating a well-structured, efficient, and robust product.
      -
        id: fd09e9da-514c-4146-863d-a9a9659c8c76
        type: new_lesson
        enabled: true
        title: 'Refactoring the mock smart contract'
        slug: refactoring-mocks
        duration: 5
        video_url: K00Vw4xS02o7RI9XO7mCxPas2rif6j007KNUMvlKLAWPKQ
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/10-refactoring-mocks/+page.md
        description: 'Comprehensive guide on refactoring mock smart contracts for local network testing, including deploying mock price feed contracts and overcoming common errors.'
        markdown_content: |-
          ***

          ## title: Refactoring II - Mocks

          *Follow along the course with this video.*

          ***

          Let's deep-dive into how we can adapt our existing environment, where we grab contract addresses from the live network, to our local network which does not yet have these contracts. For this, we will use the 'anvil config.'

          But before we proceed, a key clarification: a **mock contract** is akin to a placeholder - it's a real contract that we control, but its primary purpose is in testing scenarios. This means, in the context of a local blockchain, we need to deploy these mock contracts manually.

          ## Broadcasting the Deployment of Mock Contracts with VM

          Now, the first step in this journey is to initialize the process for deploying our contracts. Let's take it in stride.

          We'll kick off by incorporating the VM start and stop broadcast within our implementation. These provisions ensure we can deploy the mock contracts to the Anvil chain we're working with:

          ```javascript
          VM.startBroadcast(); //Block for deploying mock contractsVM.stopBroadcast();
          ```

          Remember, since we're using this VM keyword, we can't configure this as a public pure and the helper config must be a script to have access to the VM keyword.

          ## Deploying Price Feed Mock Contract

          Moving on, let's delve into deploying our price feed mock contract:

          <img src="/foundry-fund-me/10-mocks/mocks1.png" style="width: 100%; height: auto;">

          First, create a new folder within the test called 'mocks' to store our mock contracts. Then create a new file and name it 'mockv3aggregator.sol.'

          Instead of building this file from scratch, reuse the existing mock version already available on chainlink's brownie contracts. But beware, it uses an older version (0.6.0) of Solidity. To save time, fetch the upgraded version from the 'Foundry FundMe F 23' folder:

          ```shell
          cd FoundryFundMeF23/testFolder
          ```

          Then copy and paste the content into your project.

          This mock contract contains functions like 'latest round data,' which one might remember from our price converter. Moreover, its constructor allows updates and manipulation during testing, making it perfect for our local Anvil Chain. Now, we have all the necessary provisions to deploy.

          ```javascript
          import mockv3aggregator from "mocks/test/mocks/MockV3Aggregator.sol";
          mockv3aggregator mockPriceFeed = new mockv3aggregator(8, 2000e8);
          ```

          The constructor, as seen in the mock contract, requires decimals (in our case, for ETH/USD, it's 8), and an initial answer, which could be any desired starting price (say, 2000).

          After deploying our mockPriceFeed contract, the resulting address can be allocated to the network config of the Anvil chain:

          ```javascript
          networkConfig memory anvilConfig = networkConfig(priceFeed: address(mockPriceFeed));
          return anvilConfig;
          ```

          With this, we've set the stage for deploying your smart contracts and running your tests on a local network. We've seen how to configure and use a mock contract for the price feed, adapting it to our local Anvil chain. These steps can also be applied to deploy any other mock contracts as per your development and testing needs.

          Stay tuned for more such exciting DevOps adventures with Ethereum, Solidity, and smart contracts!
      -
        id: 99094676-7af8-4cce-920e-c1b002502841
        type: new_lesson
        enabled: true
        title: 'How to refactor magic number'
        slug: magic-numbers
        duration: 3
        video_url: OAXFtL8g7qoWjTGOLWnDwY7rK8oTdGgogHdALpLTZmc
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/11-magic-numbers/+page.md
        description: 'Explanation of the concept of magic numbers in Solidity code, their drawbacks, and strategies for avoiding them to maintain code readability and efficiency.'
        markdown_content: |-
          ***

          ## title: Magic Numbers

          *Follow along the course with this video.*

          ***

          When diving into the detailed layers of Solidity development, one principle that I keep circling back to is the avoidance of 'magic numbers'. A term that may sound relatively cryptic or even partially endearing, 'magic numbers' actually refer to something quite mundane that can turn out to be enormously inconvenient when dealing with large blocks of code.

          Having repeatedly voiced my intense disdain for magic numbers, I am more than ready to dissect and debunk these pests for you.

          ## Decoding Magic Numbers

          To be concise, magic numbers are the esoteric, context-less figures that appear within a chunk of code, unrelated to anything else and devoid of any conspicuous significance. Let's illustrate this with an example:

          ```js
          uint8 public constant DECIMALS = 8;
          int256 public constant INITIAL_PRICE = 2000E8;


          ```

          Here, with the number `8` and `2000 E8` dropping in out of nowhere, it's virtually impossible to infer what these numbers represent if you haven't seen the code for a while. This might not seem like much of an issue in this small snippet, but when you're dealing with substantial amounts of code, these magic numbers become an exasperating hindrance.

          To resolve this mystery, you would have to go back to the aggregator – in our case, Mach V3 – and decipher the coding behind these numbers. This becomes tiring and can slow your coding pace considerably.

          <img src="/foundry-fund-me/11-magic-numbers/magic1.png" style="width: 100%; height: auto;">

          It's worth noting that my advocacy for avoid magic numbers transcends practicality. Even during audit reports and smart contract audits, I make it a point to highlight such areas for improvement. Maintaining code readability is a critical aspect of efficient coding, which resonates across any language, including Solidity.

          ## Conclusion

          In conclusion, maintaining readable, explicit and efficient code should always be the goal. Striving to keep magic numbers at bay can significantly contribute towards this endeavor. After all, software development is more an art than a science, and the devil, as they say, is in the details.

          <img src="/foundry-fund-me/11-magic-numbers/magic2.png" style="width: 100%; height: auto;">
      -
        id: b00a1337-d0fb-4fb6-a1ea-9df92b026e22
        type: new_lesson
        enabled: true
        title: 'Refactoring the mock smart contract pt.2'
        slug: refactoring-mocks-2
        duration: 5
        video_url: 6hGN3AvsaYyU8aUk4WSRif7bFktyEUsM00r1n3FUqHqQ
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/12-refactoring-mocks-2/+page.md
        description: 'Continuation of the tutorial on refactoring mock contracts in Solidity, focusing on creating network-agnostic smart contracts for easy deployment across multiple networks.'
        markdown_content: |-
          ***

          ## title: Refactoring III - Mocking (continued)

          *Follow along with this video.*

          ***

          In this lesson, we're going to examine a useful technique to create network-agnostic smart contracts. This practice can substantially aid in making your contracts more flexible and easily deployable across multiple networks.

          ## Codifying the Process

          The logic we'll use here revolves around accessing the ​’ActiveNetwork activenetworkconfig' - a price feed we've already established. In our scenario, the guiding condition is whether this feed equals the zero address or not. Here's the snippet of code, we'll focus on:

          ```js
          if(activeNetworkConfig.priceFeed != address(0) {
              return ActiveNetworkConfig;
          }
          ```

          This segment dictates that we check if the price feed has been initialized yet (i.e., equipped with an address not equal to address zero). If so, we have the green light to return and halt the running process, because no new deployment is needed.

          ## Naming Conventions in Solidity

          An issue with the function managing this operation is the naming convention; it doesn't clearly denote its duties. The function doesn't just "get" the configuration, it "creates" them as well. Therefore, "getOrCreateAnvilETHConfig()" is a more accurate and more descriptive name.

          <img src="/foundry-fund-me/12-refactoring-mocks2/refactor1.png" style="width: 100%; height: auto;">

          Once we have edited this function and put the mechanism into action, we can observe that tests, which would previously fail due to a missing contract, now run without any hassle. This success is because the helper configuration deploys a 'pseudo' price feed which successfully responds to our requests.

          ## Testing and Results

          There's an exciting aspect of the testing process to mention too:

          Typically, if you're using chain forking, you need to perform an API call to fetch the most recent state of the forked chain. This process significantly slows down the operation. However, with our new function, we can bypass this step and dramatically expedite the testing process.

          <img src="/foundry-fund-me/12-refactoring-mocks2/refactor2.png" style="width: 100%; height: auto;">

          This streamlined test represents a massive breakthrough, demonstrating how we've made the smart contract network agnostic — able to be deployed on any given network effortlessly.

          ## Concluding Thoughts and a Job Well Done

          As I always say, honing these skills will make you an absolute standout in the world of Solidity developers. Your understanding of network-agnostic techniques won't just make you a competent smart contract developer, but will elevate the industry standard for smart contract development.

          To pat you all on the back, you've indeed learned something of massive significance here! However, the journey is far from over, and there's still much more to come.

          Remember, if any of this seems too much, make use of the course resources at hand and lean on the community forums for support. Your active participation will not only help you but will assist others as well.

          Stay excited, keep learning, and I am looking forward to our next tutorial. Until then, happy coding!
      -
        id: f7cb3eb9-2da0-4843-b0fb-d6db0a6db13e
        type: new_lesson
        enabled: true
        title: 'Foundry tests cheatcodes'
        slug: foundr-tests-cheatcodes
        duration: 13
        video_url: 00Ha502ACBC2n2GPiYfJBcj01WJtQlJfESFiZBp00HJHeRk
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/13-more-cheatcodes/+page.md
        description: 'Guide on using Foundry tests cheat codes for efficient and effective testing of smart contracts, focusing on deployment strategies, code coverage, and test understanding.'
        markdown_content: |-
          ***

          ## title: More Cheatcodes

          *Follow along with this video.*

          ***

          Hello, and welcome back to our advanced blockchain coding series. I hope you've taken a little break, as resting periods especially early in the course- are essential for grasping the plethora of advanced pieces of the blockchain puzzle we're working on.

          Here’s a gentle reminder: Spread the course over several days, not a single day. As the saying goes, repetition is the mother of skill; for skill acquisition to be successful, rests are necessary for the body to recuperate.

          Having learned a great deal, we're sailing and doing fantastic.

          ## Deployment Strategy: FundMe

          Did you know you can deploy **FundMe** on any chain with our setup helper config? Isn't it amazing? This feature permits the freedom of focusing solely on writing our tests in any network, with the assurance of our deployment setup working just perfectly.

          ## Prioritizing Code Coverage

          We emphasize the importance of code coverage throughout the course. Nevertheless, it isn't an end-all. For instance, you should continue coding if you don't attain 100% coverage. However, a figure beneath 10% doesn't spell well either.

          Let me provide a perspective: Without testing, there's a high probability of functional errors. Consequently, strive to write tests for as much code as is possible to allow the assurance that our code is indeed functioning as desired.

          Let's delve directly into coding using our function, `fund`. The code snippet should look like this:

          ```js
          function testFundFailsWithoutEnoughETH() public {
            vm.expectRevert(); //the next line should revert
            // assert(This tx fails/reverts)
            uint256 cat = 1;
          }
          ```

          <img src="/foundry-fund-me/13-cheatcodes/cheatcode1.png" style="width: 100%; height: auto;">

          The function checks whether sending insufficient Ether will cause our contract to revert. If you run this code, you will note that it reverts as expected and thus passes the test. Furthermore, it checks that `FundMe.fails` when there is insufficient Ethereum sent, once again illustrating a successful test.

          ## Honing Your Understanding of Fund Functionality

          To further test our fund function, let's now consider instances where sufficient Ether has been sent:

          ```js
          function testFundUpdatesFundedDataStructure() public {
              fundMe.fund(value: 10e18);
              uint256 amountFunded =fundMe.getAddressToAmountFunded(msg.sender);
              assertEq(amountFunded, 10e18);
          }
          ```

          The function above tests whether sending sufficient Ether (more than $5) updates the data structures correctly. This function accesses the contract data that was previously marked as private. This can be achieved by using getter functions, such as `getContractBalance`, instead of accessing the variables directly. This makes the code more readable, secure and efficient.

          ## The Wrap

          Congratulations on completing this part of the course, it's indeed taken significant effort, and you are making progress! Code testing and understanding how it integrates with complex chains is an essential part of mastering advanced blockchain coding. Don't worry about the number of tests conducted; remember that the key is to understand and apply the concepts learned in code coverage.

          Remember to keep practicing and reworking the code until you fully understand how it functions. Good luck with your test and happy coding!
      -
        id: 5f0631d9-6492-4995-8c79-431140cb12b5
        type: new_lesson
        enabled: true
        title: 'Adding more coverage to the tests'
        slug: more-coverage
        duration: 15
        video_url: zse5W02rF5lqtiVdxrULNqAaA813qBnzQ8lqCIm4e02X00
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/14-more-coverage/+page.md
        description: "This lesson delves into advanced Solidity unit testing techniques. It includes writing robust tests for the 'getFunder' function and testing the contract owner's withdrawal function using the Arrange-Act-Assert methodology. The lesson aims to strengthen your code backend, making it almost bulletproof."
        markdown_content: |-
          ***

          ## title: More Coverage

          *Follow along with this video.*

          ***

          Let's delve deeper into Solidity unit testing by testing how our function adds funder to an array of funders. In the following guideline, we'll walk through writing solid unit tests that will make your code backend almost bulletproof.

          ## Start with a Simple Test

          Step one involves writing a simple test to ensure our newly created 'getFunder' function works properly. Here is what your code may look like:

          ```js
           function testAddsFunderToArrayOfFunders() public {
                  vm.startPrank(USER);
                  fundMe.fund{value: SEND_VALUE}();
                  vm.stopPrank();

                  address funder = fundMe.getFunder(0);
                  assertEq(funder, USER);
              }
          ```

          The next step is running the test. You can use any test commands that are already set up on your server, such as `clear forge test` or `paste`. If all is well, proceed to the next step.

          To ensure our data structure is updated correctly, multiple tests with multiple funders can be added. However, for this tutorial, we will settle for our successful single user test run.

          ## Test the Owner's Withdrawal Function

          The next step is to test our smart contract's owner withdrawal function. Only the owner should be able to call the withdrawal function. Here's a simple way to do that:

          ```js
           function testOnlyOwnerCanWithdraw() public funded {
                  vm.expectRevert();
                  fundMe.withdraw();
              }
          ```

          The above test ensures that when a non-owner tries to withdraw, the function reverts.

          <img src="/foundry-fund-me/14-coverage/coverage1.png" style="width: 100%; height: auto;">

          ## Arrange-Act-Assert Testing Methodology

          The arrange-act-assert (AAA) pattern is one of the simplest and most universally accepted ways to write tests. As the name suggests, it comprises three parts:

          1. **Arrange**: Set up the test by initializing variables, objects and prepping preconditions.
          2. **Act**: Perform the operation to be tested like a function invocation.
          3. **Assert**: Compare the received output with the expected output.

          Here is how the AAA methodology fits into our unit testing:

          ```js
            function testWithdrawFromASingleFunder() public funded {
                  // Arrange
                  uint256 startingFundMeBalance = address(fundMe).balance;
                  uint256 startingOwnerBalance = fundMe.getOwner().balance;

                  // vm.txGasPrice(GAS_PRICE);
                  // uint256 gasStart = gasleft();
                  // // Act
                  vm.startPrank(fundMe.getOwner());
                  fundMe.withdraw();
                  vm.stopPrank();

                  // uint256 gasEnd = gasleft();
                  // uint256 gasUsed = (gasStart - gasEnd) * tx.gasprice;

                  // Assert
                  uint256 endingFundMeBalance = address(fundMe).balance;
                  uint256 endingOwnerBalance = fundMe.getOwner().balance;
                  assertEq(endingFundMeBalance, 0);
                  assertEq(
                      startingFundMeBalance + startingOwnerBalance,
                      endingOwnerBalance // + gasUsed
                  );
              }

          ```

          ## Testing Withdrawals from Multiple Funders

          The final test in our array of tests will check for withdrawals from multiple funders. This more complex functionality requires us to fund the contract from multiple sources, then check the balances and withdrawal process:

          ```js
          function testWithDrawFromMultipleFunders() public funded {
                  uint160 numberOfFunders = 10;
                  uint160 startingFunderIndex = 2;
                  for (uint160 i = startingFunderIndex; i < numberOfFunders + startingFunderIndex; i++) {
                      // we get hoax from stdcheats
                      // prank + deal
                      hoax(address(i), STARTING_USER_BALANCE);
                      fundMe.fund{value: SEND_VALUE}();
                  }

                  uint256 startingFundMeBalance = address(fundMe).balance;
                  uint256 startingOwnerBalance = fundMe.getOwner().balance;

                  vm.startPrank(fundMe.getOwner());
                  fundMe.withdraw();
                  vm.stopPrank();

                  assert(address(fundMe).balance == 0);
                  assert(startingFundMeBalance + startingOwnerBalance == fundMe.getOwner().balance);
                  assert((numberOfFunders + 1) * SEND_VALUE == fundMe.getOwner().balance - startingOwnerBalance);
              }

          ```

          After writing all your tests, it is good practice to test the coverage of your contracts.

          Congratulations, you have successfully learned how to write detailed and thorough tests for your smart contracts in Solidity!
      -
        id: 6761590e-d73c-4e18-a19d-730f5b666548
        type: new_lesson
        enabled: true
        title: 'Introduction to Foundry Chisel'
        slug: introduction-to-foundry-chisel
        duration: 2
        video_url: 00MDEsM9Wxo156KifVDVFD01gazlBGeY1v5014AEV4T8AE
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/15-chisel/+page.md
        description: 'This lesson introduces Chisel, a tool for testing and debugging Solidity code directly in the terminal. It covers the basics of using Chisel, including launching the interactive shell, executing Solidity code, and exploring its functionalities. The lesson is a step-by-step guide to efficient Solidity testing.'
        markdown_content: |-
          ***

          ## title: Chisel

          *Follow along with this video.*

          ***

          ## An Introduction to Chisel

          Typically, if we want to rapidly test a snippet of solidity code, we'd navigate over to Remix, an online compiler for Solidity programming language. However, with Chisel, we can directly test Solidity in our terminal swiftly and efficiently. This is a step-by-step guide on how to use Chisel for testing lines of code or debugging our tests.

          **Step 1: Launching Chisel**

          It's as simple as typing in the command `chisel` in the terminal. The terminal instantly turns into an interactive shell where we can start testing our solidity code.

          ```
          chisel
          ```

          **Step 2: Exploring Chisel**

          If you're unsure about what you can accomplish in this newly opened chisel shell, simply type in `!help`. The terminal will provide a wealth of information relevant to the command line's functionalities.

          ```
          !help
          ```

          This step is not mandatory, but it's handy when you're new to Chisel and want to explore its range of capabilities.

          <img src="/foundry-fund-me/15-chisel/chisel1.png" style="width: 100%; height: auto;">

          ## Writing Solidity with Chisel

          Chisel allows us to write Solidity directly into our terminal and execute it line by line. Here's an example:

          ```bash
          uint256 cat = 1;
          cat
          ```

          <img src="/foundry-fund-me/15-chisel/chisel2.png" style="width: 70%; height: auto;">

          This simplistic code creates a variable `cat` and assigns it a value of `1`. When `cat` is called, the program echoes out `1` as the output.

          Continuing with the example, we can perform simple operations too:

          ```bash
          uint256 catAndThree = cat + 3;
          catAndThree
          ```

          This block creates a new variable `cat_n_three` and assigns it the value of `cat` plus 3. The resultant output when called will be `4`.

          <img src="/foundry-fund-me/15-chisel/chisel3.png" style="width: 70%; height: auto;">

          This simplistic yet powerful interaction is what makes Chisel such a powerful tool for debugging and testing small pieces of Solidity code.

          <img src="/foundry-fund-me/15-chisel/chisel4.png" style="width: 100%; height: auto;">

          ## Exiting Chisel

          Once you're done with your session, exiting from this Solidity testing environment is as straightforward as getting into it. Simply type `Control` + `C` to end the chisel session and return to your regular terminal.

          ```
          Control + C
          ```

          All in all, Chisel redefines convenience, offering us a command-line interface to write, test, and debug Solidity. With this exceptional tool, you don't need to toggle between platforms to ensure your code runs smoothly—everything can be done right from the comfort of your terminal. Happy debugging!
      -
        id: b2817d50-67f7-49b7-826c-67021453f75c
        type: new_lesson
        enabled: true
        title: 'Calculate Withdraw gas costs'
        slug: calculate-solidity-function-gas-costs
        duration: 5
        video_url: wcdQdb01P200LLgZqZN7g5CeLLXKUaMGnM2wxYgOsdihE
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/16-cheaper-withdraw/+page.md
        description: "This lesson focuses on reducing gas consumption in Ethereum smart contracts. It explains how to evaluate gas costs, understand Anvil's zero gas-price, and utilize Solidity's built-in functions to optimize gas usage. The goal is to make contract execution more economical."
        markdown_content: |-
          ***

          ## title: Cheaper Withdraw

          *Follow along with this video.*

          ***

          Hello folks, let's turn our attention to an absolutely interesting aspect of Ethereum smart contracts - Gas. I'm going to show you the smart way of reducing the amount of gas you spend on executing your smart contracts, which turns out to be a beneficial piece of information, right? As most of us know, Ethereum gas is the fuel spent for every transaction we conduct or deploy on the blockchain. The more complicated our contract gets, the more gas we'll have to shell out. But what if there's a way to make this more economical?

          ## Evaluating the Gas-cost Benchmark

          How do you even figure out how much gas a transaction will cost you? For instance, let's consider a test for `withdraw` from multiple funders. What we can do is run `forge snapshot -m`, against this test. This call prompts the creation of a handy file named `Gas Snapshot`, which will reveal the exact amount of gas that this specific test will consume.

          **Tip:** You can convert between gas and Ether prices to ascertain how much this gas consumption will financially impact you. Optimization begins with identifying your current spending!

          What we did above is merely to establish a benchmark for our testing, i.e., our `withdraw` from multiple funders costs us so much gas.

          ## Understanding Anvil's Zero Gas-price

          While working with Anvil local chains - forked or otherwise - the gas price defaults to zero. So, if we invoke a transaction - say `vm.prank(fundMe.getOwner())`, it should ideally cost us some gas. But when we calculate the final balance (or 'ending owner balance'), gas cost doesn't figure into it, thanks to Anvil's zero gas price. To simulate credible gas prices and consequently, real-world transaction costs, we turn to the helpful cheat code `TX gas price`, which standardizes the gas price for our transaction.

          ```js
          uint256 constant GAS_PRICE = 1;
          ```

          ## Calculating Actual Gas Usage

          In order to visualize the gas usage, we can leverage Solidity's built-in function `gas left()`. This calculates the remaining gas from a transaction after execution.

          ```js
          uint256 gasStart = gasleft();
          ```

          We can repeat this process with `dash vv` and it will show us how much gas was actually expended in this particular transaction.

          ## Making Gas Usage Cheaper

          Now that we have our gas snapshot and its holistic understanding, the question remains, can we make this cheaper? Yes, we absolutely can and this is where Ethereum's data location - storage - steps in. Long story short, data written in storage is expensive while reading from storage is free. Hence, using storage effectively could significantly reduce your gas usage and consequently, your transaction cost.

          Stay tuned as we delve into the world of Ethereum storage optimization in the upcoming posts.
      -
        id: fe0f8efa-c582-4a5c-89d3-363fa12e9010
        type: new_lesson
        enabled: true
        title: 'Introduction to Storage optimization'
        slug: solidity-storage-optimization
        duration: 10
        video_url: k1XhwATtf92UZI6vEu7i02ZnoT76PpiDzSE3wz82kO6I
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/17-storage/+page.md
        description: "In this lesson, you'll learn about optimizing Ethereum smart contract storage to reduce gas consumption. It covers storage variables, their impact on gas usage, and how to efficiently use storage and memory in Solidity. The lesson also includes practical examples using Anvil."
        markdown_content: |-
          ***

          ## title: Storage

          *Follow along with this video.*

          ***

          ## A Look into Ethereum Gas Optimization

          In pursuit of deciphering Ethereum smart contract storage, we need to address gas optimization. The term `gas` refers to the computational efforts needed to execute operations in the Ethereum virtual machine.

          Now, let's explore our contract variables and understand how they consume gas.

          <img src="/foundry-fund-me/17-storage/storage1.png" style="width: 100%; height: auto;">

          In one of the [freeCodeCamp videos](https://youtu.be/gyMwXuJrbJQ), a simple contract with global variables is analyzed. The objective here is to make our contract more gas-efficient by examining storage variables.

          ## Breaking Down Storage Variables

          Storage variables, also known as state variables or global variables, play a crucial role in our contract's gas usage. These variables are persistent, meaning they retain their values between function calls.

          When we declare a variable in our contract, this variable gets allotted a spot in storage. It's helpful to visualize storage as a giant, numbered array, where each element comprises a `storage slot` of 32 bytes.

          Every time we add a global variable, it takes up a new slot in this storage array. In the case of dynamic values such as arrays or mappings, these are managed using a hashing function whose specifics can lay hold of in the Solidity documentation.

          <img src="/foundry-fund-me/17-storage/storage2.png" style="width: 100%; height: auto;">

          ## Arrays and Mappings

          For a better grasp, consider a dynamic array named `myArray`. The array length is stored at the array's storage slot, not the entire array.

          ```js
          myArray.push(222);
          ```

          When we add an element to the array, it is stored at a specific location based on the aforementioned hashing function.

          How about mappings? Common to arrays, Solidity assigns a storage slot for each mapping. Should the slot be empty, Solidity earmarks it for the mapping's hashing function.

          Now, you may wonder, how does Solidity handle constant and immutable variables? As it turns out, it doesn't store these variables. Instead, these variables become part of the bytecode of the contract. Consequently, the variables do not occupy space in the storage.

          ## Local Variables and Memory Keyword

          In contrast, variables declared within a function do not persist. Once the function finishes running, these variables are discarded. These are stored in a separate memory data structure.

          Here, we unearth why we often use the `memory` keyword, especially for strings.

          ```js
          function getString() public pure returns (string memory) {return "Hello, World!";}
          ```

          Strings, at their core, are dynamically sized arrays. Through `memory`, we instruct Solidity to allocate space for the string in the memory location, destined for deletion after usage.

          ## Exploring Storage with Anvil

          Anvil offers an interesting way to inspect the storage of a Solidity contract. Using the command `forge inspect FundMe storageLayout`, we can inspect the storage layout of our contract.

          Another way is through `Cast storage <contract_address> <index>` command. This way, you can fetch the content of a certain storage slot in your contract.

          <img src="/foundry-fund-me/17-storage/storage3.png" style="width: 100%; height: auto;">

          )## On Blockchain Privacy

          Lastly, even though we can declare variables as `private` in Solidity, the data isn't truly private. Due to the public nature of blockchains, anyone can read that information off of your or anybody's blockchain.

          In conclusion, understanding how storage works within Ethereum smart contracts is a vital skill for a successful Solidity developer. It helps us write more efficient contracts and enable more cost-effective operations within the Ethereum ecosystem.
      -
        id: f3f4f5a4-ab08-4325-a072-eb9af95ca859
        type: new_lesson
        enabled: true
        title: 'Optimise the withdraw function gas costs'
        slug: optimise-solidity-function-gas-costs
        duration: 8
        video_url: fs4II18hCRkZ02lq4D2dDE5338Adqtx02yqETMh9ua5QU
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/18-cheaper-withdraw-ii/+page.md
        description: "This advanced lesson teaches how to optimize the 'withdraw' function in smart contracts for lower gas costs. It discusses bytecode analysis, storage and memory operations, and practical code changes to reduce gas usage. The lesson includes a comparative analysis of gas usage before and after optimization."
        markdown_content: |-
          ***

          ## title: Cheaper Withdraw (Continued)

          *Follow along with this video.*

          ***

          As budding young developers navigating through the intricacies of gas optimization in Ethereum, the issue of storage is one area that arguably minces no words. Sure, it could appear all fancy and sophisticated if you squint your eyes at the right angle – but we have to ask ourselves: why all this fuss about storage?

          The reason is hardly elusive: reading and writing from storage is an overwhelming expense on our tightly-strapped gas resources. Unpicking or compressing any data stored in it drains the gas faster than you can imagine.

          Let's delve into this a little deeper to help iron out the creases:

          ## The Web of Bytecode:

          When you compile your solidity code, it gets whittled down to bytecode per se. This enigmatic-looking bytecode can be unhashed to find the correlation between gas consumption and how storage is utilized when your contract is running on the Ethereum Virtual Machine (EVM). For this, you could simply switch over to [Remix](https://remix.ethereum.org/), hit compile, navigate to the compilation details, and select bytecode.

          When we scroll down to the end, we'll uncover two vital entities: Object and Opcodes. The object is an intricate pattern of your contract in bytecode, and the Opcodes are simply the bytecode version translated into a rudimentary set of instructions. Each Opcode — the lowest level of computer language — tattoos specific gas costs on each operation it conducts; the costs quickly aggregate to a monumental sum when you perform an operation through EVM.

          We scroll through the Opcodes and observe a pattern in gas costs – most of them like addition, multiplication, and division cost around two or three gas. And then, boom!

          <img src="/foundry-fund-me/18-cheaper-2/cheaper1.png" style="width: 100%; height: auto;">

          `SLOAD` is the Opcode that reads from storage, and it sets you back by a massive 100 gas. Similarly, S-store saves to storage, costing us the same gargantuan amount of gas. This instantly makes us realize the vast chasm of difference between storage and alternate operations, which usually cost just a few gas.

          ## Aiming for Optimization:

          But the conversation shouldn’t stop there. The dialogue around storage also goes beyond to unearth the possibility of a memory-load (M-load) and a memory-store (M-store) which cost just three gas each. We’re staring at a stark disproportion here: it’s almost 33 times more expensive to read and write from storage than it is to access memory. So, voila! The most straightforward initiative to optimizing gas is to perform read-write actions from memory, respecting the notion of expensive storage access.

          Having keyed into this knowledge, we spring back to our FundMe contract’s withdrawal function. To dodge ransacking the holistic storage multiple times, we replace the subsequent reads with a prerecorded memory variable. We can quickly establish the new function for cheaper withdrawal. In this manner, we alter the looping process by initially reading from the storage just once and replace further iterated reads with a memory variable.

          This yields the revised code:

          ```js
          function cheaperWithdraw() public onlyOwner {
                  address[] memory funders = s_funders;
                  // mappings can't be in memory, sorry!
                  for (uint256 funderIndex = 0; funderIndex < funders.length; funderIndex++) {
                      address funder = funders[funderIndex];
                      s_addressToAmountFunded[funder] = 0;
                  }
                  s_funders = new address[](0);
                  // payable(msg.sender).transfer(address(this).balance);
                  (bool success,) = i_owner.call{value: address(this).balance}("");
                  require(success);
              }
          ```

          ## Comparative Testing and Results

          With that code snippet fleshed out, we can simply copy and adapt our previous test function, amending the call to use 'cheaperWithdraw'. Next, we establish a gas snapshot to encapsulate all of our tests. This can be done with the `forge snapshot` command in the terminal. We can then compare the gas usage of the two functions: the original `withdraw` and the optimized `cheaperWithdraw`. Already, we can observe an improvement with an approximate saving of 800 gas.

          ## Style Guidelines in Etherem Development

          The brandishing of style guides in developmental structure is a cornerstone to efficient coding. While ensuring code readability, it also provides a recognizable attribution to certain key identifiers in a solidity code environment.

          In the Chainlink style guide, for instance, immutable variables are prefixed with `i_` while storage variables bear `s_`. These prefixes act as signals to the coders about the nature of these variable and the subsequent gas costs associated with them. It provides an opportunity for developers to consider cheaper alternatives like memory variables over storage variables.

          The [Solidity Documentation](https://docs.soliditylang.org/en/v0.8.4/style-guide.html) provides a comprehensive guide to code layout, function names, and more. Chainlink has its own style guide, which is linked to the GitHub repo for this article.

          ## Wrapping Up

          This blog was all about imparting the importance of optimizing storage access in order to conserve gas in contract execution. It’s crucial to adapt to these techniques early on in your career as a blockchain developer. The ability to identify and adapt constructs that optimize gas usage will undoubtedly enhance your proficiency in developing efficient, less costly smart contracts.

          Remember that while it might seem like a small gain in the beginning, these savings will aggregate into substantial saving when you’re dealing with larger scale operations. You've done great work today! It's time now to push this code up to your GitHub and celebrate your first smart contract project.
      -
        id: 698e9f4a-490b-4d3d-a344-eec70c6c49e7
        type: new_lesson
        enabled: true
        title: 'Create integration tests'
        slug: solidity-integration-tests
        duration: 15
        video_url: JlvoZcKaYcaLfD5AP6G3XzshoYSasPWxb5E01DPu1fZk
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/19-interactions/+page.md
        description: 'Explore the creation of integration tests for Solidity smart contracts. This lesson covers the setup and execution of integration tests, ensuring that contract functions interact correctly with other system parts. It includes practical examples and a guide for setting up a comprehensive test suite.'
        markdown_content: |-
          ***

          ## title: Interactions.s.sol

          *Follow along with this video.*

          ***

          ## Creating a Project README

          Firstly, you'd want to add a README.md file to your project in GitHub. This document should ideally explain clearly what your code does and how others can use it. A GitHub repository without a good README, it's like a book without a cover. Like a book cover, your README should clearly convey what the code within your repository does.

          Here's a suggested format for your README.

          * **Introduction:** Give a brief explanation of your project.
          * **Getting Started:** List the requirements for running your code.
          * **Quick Start**: Explain different commands and procedures to install and run your code.

          ## Writing Integration Tests and Scripts

          Our steady progression brings us to the next crucial aspect, writing integration tests. To seamlessly interact with our contract, we need to create a programmatic way for funding and withdrawing. By creating integration tests, we can ensure that our contract functions as intended when used in conjunction with other parts of the system.

          Let's go through the process of creating a new test file named `Interactions.s.sol` under the `Script` section. We'll be dealing with two primary scripts here: `FundMe.sol` and `WithdrawFundMe.sol`.

          Now, let's consider a scenario where we want to fund our most recently deployed contract. For that purpose, we use a tool named Foundry DevOps. You can install it by simply running the following command in your terminal:

          ```bash
          forge install ChainAccelOrf/foundry-devops --no-commit
          ```

          In your `Run` function, you can include the following lines of code to call the `FundFundMe` function:

          ```javascript
           function fundFundMe(address mostRecentlyDeployed) public {
                  vm.startBroadcast();
                  FundMe(payable(mostRecentlyDeployed)).fund{value: SEND_VALUE}();
                  vm.stopBroadcast();
                  console.log("Funded FundMe with %s", SEND_VALUE);
              }

          ```

          "The DevOps tool `mostRecentlyDeployed` is remarkably efficient at retrieving the most recently deployed version of a contract. No more manual hassles!"

          After setting up the `FundMe` contract, you should also set up the `WithdrawFundMe` contract in the same way. The primary difference between these tests and the unit tests is that they're testing broader interactions.

          ## Running and Verifying Tests

          Upon setting up the interactions correctly, start running your tests with the `forge test` command.

          ```bash
          forge test
          ```

          Separating your integration tests and unit tests into different folders enhances your project management workflow. For instance, transferring the `FundMeTest.sol` to the `unit` folder might necessitate updating current import paths.

          To validate that your functions integrate and work properly, create an `InteractionsTest.sol`. Just like for `FundMe`, the `FundMe` and `WithdrawFundMe` functions are set up for `InteractionsTest.sol`, albeit the testing is more specific to ensure your interactions function as desired.

          Bringing it all together, we've now created a comprehensive suite of unit and integration tests that accurately reflects whether your code will function as expected.

          ## In Conclusion:

          Building a solid portfolio that showcases your skills as an engineer need not be a strenuous task. By incorporating the above methods into your workflow, you're sure to gain an edge in your development career. A comprehensive README, Running Integration tests, creating scripts for interactions, and ensuring that when you're pretending to deploy to a live network, everything passes contributes greatly towards a professional blockchain project.

          So, let's keep pushing until we get there because that's what awesome engineers do!
      -
        id: ff41ef82-ab94-4081-a724-1a513e9b9a31
        type: new_lesson
        enabled: true
        title: 'Automate your smart contracts actions - Makefile'
        slug: makefile
        duration: 9
        video_url: bS22srJO9vHbhehKUWNeN00qrFDRKrqVt3Pne2aSN302A
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/20-makefile/+page.md
        description: 'Learn to streamline your development workflow using Makefiles. This lesson teaches how to automate the building and deployment processes of smart contracts. It includes detailed examples of deploying to networks like Sepolia and setting up a comprehensive Makefile for various development tasks.'
        markdown_content: |-
          ***

          ## title: Makefile

          *Follow along with this video.*

          ***

          Do you find writing long scripts all the time tedious? Or loathe the idea of having to re-enter your lengthy deployment commands constantly during your project's lifetime? If so, then you're on the right track! As developers, we always strive to work smart, not hard!

          As we continue to discuss creation tests, I suggest a slight detour where we can introduce ways to make these often repeated scripts significantly easier. Our saviour: the *Makefile*.

          ## A Makefile Primer

          A makefile is a text file used by the 'make' utility to automate the building and compiling processes of projects. Makefiles are a popular choice among developers due to their ability to streamline workflow drastically.

          If you have not done so already, create a new file in your project folder called `makefile`. If everything's correctly installed, typing `make` in your terminal will return `no Targets stop`. If you experience any issues, install 'make' first.

          <img src="/foundry-fund-me/20-makefile/makefile1.png" style="width: 100%; height: auto;">

          Makefiles, besides their main conveniences, also allow us to include environment variables automatically without having to source them every single time using `source env`.

          Our makefiles have the ability to create shortcuts. This way, we don't have to write and remember long scripts every single time. Here's an example of a shortcut.

          ```makefile
          -include .env
          build:; forge build
          ```

          With this, `make build` in your terminal will execute `forge build`.

          ## Deploying to Sepolia: A Detailed Example

          Let's now take a more comprehensive example: deploying to Sepolia. Here's the code outline for the makefile content:

          ```makefile
          deploy-sepolia:
              forge script script/DeployFundMe.s.sol:DeployFundMe --rpc-url $(SEPOLIA_RPC_URL)
              --private-key $(PRIVATE_KEY) --broadcast --verify --etherscan-api-key $(ETHERSCAN_API_KEY)
              --vvvv
          ```

          This command is quite extensive, and the last thing you'd want is to type it out every single time. You can now run the whole code with just: `make deploy-sepolia`.

          Note that we're deploying to a real network here, which incurs real costs. Therefore, only run this command if you intend to follow along in deploying your contract.

          **Important:** All environment variables in makefiles need to be enclosed using dollar signs and parentheses like so: $(variableName).

          To enable automatic verification of our FundMe contracts on EtherScan, we'll need to create our own EtherScan API key. We'll then paste this key and the private key of our dummy account (not your real account), in our `.env file`.

          Once the contract is deployed, and you paste the contract's address in folio, you will see that the contract has already been verified. No need to do it yourself on Etherscan, the script's got it covered!

          <img src="/foundry-fund-me/20-makefile/makefile2.png" style="width: 100%; height: auto;">

          ## A Ready-to-Use Makefile Framework

          To make setting up makefiles a lot easier, I have prepared a ready-to-use framework. It's available on our course-specific [GitHub repo](https://github.com/Cyfrin/foundry-fund-me-f23/blob/main/Makefile).

          This framework is quite expansive and covers a wide range of commonly used make commands. For instance, running `make help` will return a list of command options. To avoid going overboard with detailing makefiles, I strongly recommend you check out the framework and adapt it to your development processes. If you're keen to learn more about makefiles, hop onto your favourite search engine and find some good articles, or simply, Google it!

          In conclusion, makefiles are an incredible tool for developers that help to simplify commands and make our workflows much more efficient. Utilize them, and you'll see a significant boost in your productivity. Happy coding!
      -
        id: 1b838275-adc8-4821-90b7-73c28e8b10cd
        type: new_lesson
        enabled: true
        title: 'Pushing to Github'
        slug: pushing-to-github
        duration: 16
        video_url: z91JZEVPziKfbM6apLI3AZgmk7WdLSbCq44FjY4hHeI
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/21-pushing-to-github/+page.md
        description: 'This lesson guides you through the process of pushing your Solidity projects to GitHub. It covers best practices for using Git, managing sensitive information, and updating README files. The lesson is crucial for developers looking to showcase their work and collaborate in the crypto-community.'
        markdown_content: |-
          ***

          ## title: Pushing to GitHub

          *Follow along with this video.*

          ***

          Welcome fellow developers! In today's lesson, I'll guide you in pushing your work to GitHub using a badass GitHub repo. This action is the concluding step of your project. However, the first thing we want to ensure is that `env` is included in your `.gitignore`. Adding `broadcast` is a personal practice, and I advise you to do the same. The rationale behind this is avoiding a public push of anything inferior to GitHub.

          Sometimes, it's beneficial to leave `lib` out, something that I plan to do here as well. The key take-home is learning to push code to GitHub. We are employing hardhat freeCodeCamp because it was used in one of my previous videos and we are kick-starting from an entirely blank GitHub.

          Please note that the application of GitHub, coupled with git and version control, is crucial to the majority of crypto-community interactions and collaboration methods.

          ## Open Source and the Crypto Community

          <img src="/foundry-fund-me/21-github/github1.png" style="width: 100%; height: auto;">

          With the open-source nature of web3 and crypto, all the smart contracts you create or use are visible. You can scrutinize the code, learn from it and develop your skills.

          <img src="/foundry-fund-me/21-github/github2.png" style="width: 100%; height: auto;">

          If you are eager to contribute, most of these protocols present grants and will recompense you for your contribution to their code. Alternatively, if you're keen on acquiring knowledge, you can generate pull requests to the codebases.

          When I was new to web three, one of the potent approaches I applied was making contributions to the Brownie Repo, a Pythonic smart contract framework aligned with Foundry. This process accelerated my learning and enabled me to interact and connect with several individuals in the community. Remember, GitHub profiles are crucial when applying for jobs. Hence, do your best to make your profile stand out.

          ## GitHub and Decentralized Git Solutions

          Although GitHub is a centralized company, there are several decentralized git solutions presently under development. However, none of these are currently popular. If you want to get started or want a quick start, [GitHub docs](https://docs.github.com/en) provides numerous sets of documentation which you can refer to.

          You should have a GitHub profile already set up. If you want to create a repo, you can utilize the 'Create a repo' section. Here, you'll learn to establish a repo directly via the website.

          However, creating a repo from the command line is advisable because it enables you to work without logging onto the internet every time you change your code.

          This process involves following a specific documentation called adding locally-hosted code to GitHub. As the name suggests, we want to push our locally-hosted code to GitHub.

          Before proceeding further, ensure that Git is installed on your device. Directions on how to install Git can be found [here](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)

          A successful installation would display the Git version when `git version` is run. In case it doesn't, pause and install Git. You can utilize chatgbt, an AI tool, to help troubleshoot any installation issues.

          With Git installed, you can access all of the features of Git, such as commits and logs. Use `git status` to view your repository status and `git log` to view a history of your commits.

          ## Pushing Code to GitHub

          Use the command `git add .` to add all the folders and all the files to your git status, except for the ones in the git ignore. After adding the files, use `git status` to see what files and folders will be pushed to GitHub. Furthermore, do remember to check if the `env` is included or any sensitive information is included.

          The next step involves committing your tasks. You can use `git commit -m "your message`" to commit your tasks. After committing, use `git status` to view your commits. With everything in order, the last step is to push the commit to GitHub using `git push origin main`. In case of any errors, employ chatgbt or any other AI to help troubleshoot the problem.

          Voila! By now, your project should be visible on your Github repository.

          ## Updating the README

          An often overlooked yet important aspect is updating your README file. It should include an 'About' section explaining your project and a 'Getting Started' section detailing the requirements and quick start instructions.

          Once you have filled out your README, commit it to your repository using `git add .`, `git commit -m "updated README"`, `git push`.

          Without a doubt, completing these steps successfully is worthy of celebration. Feel free to share your success and excitement with the developer community on social media. Remember, celebrating small wins on your journey is instrumental to maintaining motivation and enjoying your coding journey.

          That's all the instructions you need to push your project on GitHub with Hardhat FreeCodeCamp. Keep practicing, keep pushing code, and soon enough, you'll be confident in using Git!
      -
        id: 0f9c4792-c718-4dcc-ad07-95abf11a2481
        type: new_lesson
        enabled: true
        title: 'Section recap'
        slug: section-recap
        duration: 2
        video_url: oaTFRoENSgOK2TAa5f2nLG301KsItiC5chmEMM1TJ3DM
        raw_markdown_url: /routes/foundry/2-foundry-fund-me/22-recap/+page.md
        description: "This recap lesson summarizes key points from the course, including professional project setup, codebase refactoring, interaction scripts, gas and storage optimization, Makefiles, and GitHub repositories. It's a comprehensive review of the skills and knowledge gained in the course."
        markdown_content: |-
          ***

          ## title: Recap & Congratulations

          *Follow along with this video.*

          ***

          Congratulations on making it this far on our enlightening journey on articulating how to set up a foundry project professionally! This segment stands colossal indeed, and I am here to take a brief detour and simmer down the plethora of knowledge that we gathered on handling Foundry projects more professionally.

          ## The Key Takeaways from the Course

          So, sit back, relax, let's take a look back at the phenomenal landscape we painted together on our canvas of a Foundry project.

          * **Professional Foundry Project Setup:**
            Setting up a project is a breeze that we adapt our hands to, but dealing with it professionally? That's where the real challenge kicks in. We have covered how to establish our source folder and accommodate numerous contracts in there.
          * **Codebase Refactoring:**
            We dived in together into the world of making our codebase more modular and learned how to refactor it. Enhancing our `FundMe` contract, we've started working on how to pass in a `price feed`, empowering us to deploy our contract on any desired chain.
          * **Interactions Script Dynamics:**
            Next, we've talked about an `interactions script` which incorporates `FundMe` and `Withdraw FundMe` contracts. This feature allows us to effortlessly withdraw funds and finance our most recently deployed contract.
          * **Working with Mocks and More:**
            What's learning without getting hands dirty? Yes! We got involved in working with mocks in testing, we understood how to conduct integration tests and also dove deeper on forking tests.
          * **Getting the grips on Gas and Storage:**
            A major leap in our education expedition was understanding more about `gas` and `storage`. Grasping these topics gives us the power to handle the energy consumption of Blockchain applications and to persist data on the Ethereum blockchain.
          * **Grasping Makefiles:**
            We learned a little about makefiles too. A Makefile contains a set of directives used by a make build automation tool to generate a target/goal.
          * **Building GitHub Repositories:**
            The icing on the cake of our extensive learning was when we built our **first GitHub repository** and pushed it up - a moment that we can incredibly own and rejoice at!

          <img src="/foundry-fund-me/22-recap/recap1.png" style="width: 100%; height: auto;">

          ## What's Next?

          Now, isn't it the perfect moment to give yourself a lil' break? After all, you've earned it! Grab that coffee, ice cream and have a walk. Or, simply indulge in any activity for some you-time.

          Though, if you wish to further enhance your knowledge and graduate from being 'okay' at this to being an absolute maestro, I urge you to continue this journey with us. We've designed our course to not just educate you but to prepare you for everything that this space has to offer.

          So, see you in the next project!

          Goodbye, for now!

          ***

          <img src="/foundry-fund-me/22-recap/recap2.png" style="width: 100%; height: auto;">
    type: new_section
    enabled: true
  -
    id: VjNCxDsl
    title: 'Fund Me Frontend'
    slug: html-fund-me
    lessons:
      -
        id: c9498599-1d48-42ab-a184-68cd69834483
        type: new_lesson
        enabled: true
        title: 'How Metamask interacts with dapps'
        slug: setup
        duration: 4
        video_url: g015Gmr3Bk8wY4EnbuSTtjzJ016fWU51TSlr01VRXmZ5WA
        raw_markdown_url: /routes/foundry/3-html-fund-me/1-setup/+page.md
        description: 'Introduction to MetaMask interactions with websites, covering the basics of transaction transparency and setting up a basic JavaScript web application.'
        markdown_content: |-
          ***

          ## title: Setup

          *Follow along the course with this video.*

          ***

          Let's look at how what we've built interacts with a wallet. Remember, you can find all the code for this lesson **[here](https://github.com/Cyfrin/html-fund-me-f23)**.

          We won't be going over a whole full-stack application here, but the repo above contains a raw front-end you can try to replicate if you would like to challenge yourself.

          > Additional front-end content will be available on Updraft in the near future!

          Our goal will be uncovering what's happening 'under the hood', allowing you to understand exactly what's going on when you interact with a website sending a transaction to the blockchain.

          ### Setup

          Normally I would walk you through the steps to get setup, but I'm not going to do that this time.

          Now that you've installed Git and created a GitHub in previous lessons, we're going to clone an existing repo to have something to start with rather than starting from scratch.

          In our terminal use the command:

          ```bash
          git clone https://github.com/Cyfrin/html-fund-me-f23.git
          ```

          Now we can open this in a new instance of VS Code with:

          ```bash
          code html-fund-me-f23
          ```

          In order to spin up a local front end, we're going to use an extension called **[Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer)**. Once installed you can simply press the `Go Live` button in the bottom right.

          <img src="/html-fundme/1-setup/html-fund-me1.png" style="width: 75%; height: auto;">

          And with that you should have this simple front end open in a browser.

          <img src="/html-fundme/1-setup/html-fund-me2.png" style="width: 75%; height: auto;">

          <br>
          We'll be using this to glean a deeper understanding of what exactly is happening when we're interacting with websites in the coming lessons.
      -
        id: ae529daa-722d-4124-8222-b631d6a43b0a
        type: new_lesson
        enabled: true
        title: 'Introduction to window.ethereum'
        slug: metamask
        duration: 13
        video_url: 001jv6kLj5yyUq02jl6ZRcYV3SuY00KSZWP6INNLN00ZLtc
        raw_markdown_url: /routes/foundry/3-html-fund-me/2-metamask/+page.md
        description: 'Exploration of MetaMask''s interaction with JavaScript websites, focusing on the use of the \`window.ethereum\` object and smart contract interactions.'
        markdown_content: |-
          ***

          ## title: How MetaMask works with the Browser

          *Follow along the course with this video.*

          ***

          ### Browser Wallets

          The first concept we need to grasp when working with a website in Web3 is that of a browser wallet - in our case Metamask. It's through a wallet like Metamask that we are able to interact with the blockchain and the Web3 ecosystem.

          We can gain more insight into how this works by right-clicking our `FundMe` website and selecting `inspect`. You can also open this panel by pressing F12.

          <img src="/html-fundme/2-metamask/metamask1.png" style="width: 75%; height: auto;">

          Navigate to the console tab of this panel. This tab contains a live JavaScript shell which houses a tonne of information about the browser we have open. Among this data is a JavaScript object, `window`.

          By typing `window` and hitting enter the console will display this object and all of the functions it contains.

          We should see something like this:

          <img src="/html-fundme/2-metamask/metamask2.png" style="width: 75%; height: auto;">

          As seen in the image, there are some properties of this object which are not there by default, one of which is `window.ethereum`. It's through this property that a front end is able to interact with our wallet and it's accounts.

          > Try inspecting a browser without a browser wallet installed. You'll see that `window.ethereum` doesn't exist!

          I recommend reading the **[Metamask documentation](https://docs.metamask.io/guide/)** on the window\.ethereum object to learn more.

          ### The Code

          Alright, great. How does the code which interacts with all this look like? We can take a look at the `index.js` file in our html-fund-me repo for this.

          One of the first things you'll see is a `connect` function. This is pretty ubiquitous and is how most Web3 websites are told *Hey, I have a browser wallet, here are the accounts I want to use.*

          ```js
          async function connect() {
            if (typeof window.ethereum !== "undefined") {
              try {
                await ethereum.request({ method: "eth_requestAccounts" });
              } catch (error) {
                console.log(error);
              }
              connectButton.innerHTML = "Connected";
              const accounts = await ethereum.request({ method: "eth_accounts" });
              console.log(accounts);
            } else {
              connectButton.innerHTML = "Please install MetaMask";
            }
          }
          ```

          We see the first thing that this function does is checks for our `window.ethereum` object then connects and requests accounts.

          > **Note:** This request for accounts does **not** provide access to your private key. It allows the website to send transaction requests to your wallet in order for you to sign.

          Let's look briefly at the HTML and how it calls this function.

          ```html
          <body>
            <button id="connectButton">Connect</button>
            ...
          </body>
          ```

          The body of our `index.html` contains this button (among others) with the `id` `connectButton`.

          Switching to our `index.js` we see this:

          ```js
          const connectButton = document.getElementById("connectButton")
          ...
          connectButton.onclick = connect
          ```

          This grabs the element of the webpage by the `id` we set and then uses the `onClick` method to call our `connect` function!

          ### Connecting in Action

          Clicking on the `Connect` button on our `html-fund-me` front end, should trigger our Metamask to pop up. From there we can select an account and click connect.

          <img src="/html-fundme/2-metamask/metamask3.png" style="width: 75%; height: auto;">

          You'll know this works if your `Connect` button changes to `Connected` and an address is printed to your browser console.

          Now you're ready to interact! The functions on our front-end example should look familiar. They're the same as the FundMe backend we built in the previous section.

          Let's try calling `getBalance` and see how it works - if you're chain is currently set to Ethereum, you might actually get a balance.

          <img src="/html-fundme/2-metamask/metamask4.png" style="width: 75%; height: auto;">

          When the `getBalance` buttons is clicked, this is the function we're calling on our front-end.

          ```js
          async function getBalance() {
            if (typeof window.ethereum !== "undefined") {
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              try {
                const balance = await provider.getBalance(contractAddress);
                console.log(ethers.utils.formatEther(balance));
              } catch (error) {
                console.log(error);
              }
            } else {
              balanceButton.innerHTML = "Please install MetaMask";
            }
          }
          ```

          As before, we're checking for the existence of `window.ethereum` and then .. defining a provider.

          ### RPC URLs and Providers

          `ethers` is a javascript package that simplifies the use and interacation of browser wallets with our code.

          What `ethers.providers.Web3Provider(window.ethereum)` is doing, is deriving the providers Metamask is injecting into our `window.ethereum` object. The providers are the RPC URLs associated with the networks in our Metamask account.

          <img src="/html-fundme/2-metamask/metamask5.png" style="width: 75%; height: auto;">

          When we call functions on our front-end. We're effectively making API calls via the RPC URL to the blockchain.

          ### Trying it Out

          In order to get some experience trying this ourselves, we'll need to set up the backend of our project and import our anvil account into Metamask.

          Open your foundry-fund-me directory in VS Code and in your terminal run `anvil`.

          This should spin up a local test chain for you. Copy one of the mock private keys it provides you in the terminal, we'll need this to import the account into our Metamask wallet.

          With this chain running, open a second terminal and run the command `make deploy`.

          This will compile and deploy our FundMe project onto our locally running blockchain. Assuming you've not run into errors. That's all that's required to set up the back end.

          Return to Metamask, and within your network selector choose `Add Network`.

          <img src="/html-fundme/2-metamask/metamask6.png" style="width: 75%; height: auto;">

          Select `Add a network manually` linked at the bottom of the served page.

          In the subsequent page, inter your local network information as follows and click `Save`.

          <img src="/html-fundme/2-metamask/metamask5.png" style="width: 75%; height: auto;">

          Next, we need to add one of our `anvil` accounts to the wallet!

          Click the account displayed at the top of your Metamask and select `Add an account or hardware wallet` from the bottom of the list.

          You'll be prompted to `add a new account`, `import an account`, or `add a hardware wallet`. Select `import an account` and enter your previously copied mock private key into the field provided.

          <img src="/html-fundme/2-metamask/metamask7.png" style="width: 75%; height: auto;">

          ALRIGHT. With all the set up done, we should be able to select our `anvil` chain in Metamask, then select the account we just added and click the `connect` button.

          If we click `getBalance` we should have `0` returned in our console reflecting the balance of our deployed contract. At this point, we should be able to enter an amount and click `fund`.

          Our Metamask pops up and has us sign the transaction, funding the contract with the amount we've entered!

          ```js
          async function fund() {
            const ethAmount = document.getElementById("ethAmount").value;
            console.log(`Funding with ${ethAmount}...`);
            if (typeof window.ethereum !== "undefined") {
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              const signer = provider.getSigner();
              const contract = new ethers.Contract(contractAddress, abi, signer);
              try {
                const transactionResponse = await contract.fund({
                  value: ethers.utils.parseEther(ethAmount),
                });
                await listenForTransactionMine(transactionResponse, provider);
              } catch (error) {
                console.log(error);
              }
            } else {
              fundButton.innerHTML = "Please install MetaMask";
            }
          }
          ```

          The function being called when we click this button is very similar in structure to the other we looked at.

          * look for `window.ethereum`
          * define our `provider`
          * acquire the `signer` (account credentials)
          * define the contract/target of our call
            * these are hardcoded for simplification purposes in this example and can be found in the **[constants.js](https://github.com/Cyfrin/html-fund-me-f23/blob/main/constants.js)** file of our **[html-fund-me repo](https://github.com/Cyfrin/html-fund-me-f23)**.
          * submit transaction to the target contract with provided arguments.

          > **Note:** I'll stress again that this call being made by the front-end does **not** give the front-end access to private key data. The transaction is always sent to the wallet for confirmation/signing.

          ### Wrap Up

          We've learnt a lot about how browser wallets like Metamask work under the hood and actually send our transactions to the blockchain. Great work - we've more low level concepts to cover in our next lesson.
      -
        id: 23b9873a-e58f-4c21-a8db-4d3602e8b214
        type: new_lesson
        enabled: true
        title: 'Decoding Ethereum transactions'
        slug: function-selectors
        duration: 8
        video_url: kT004F01Bs02ezyhLSUMKIH1fV7w025zMHGOs877HZo7h024
        raw_markdown_url: /routes/foundry/3-html-fund-me/3-function-selectors/+page.md
        description: 'Guide to understanding and decoding Ethereum transaction data using function selectors, with practical examples of verifying transactions.'
        markdown_content: |-
          ***

          ## title: Function Selectors Introduction

          *Follow along the course with this video.*

          ***

          ### Intro to Function Selectors

          Continuing from the last lesson, when we call the `fund` function our Metamask is going to pop up with a bunch of information about the transaction.

          <img src="/html-fundme/3-function-selector/function-selector1.png" style="width: 75%; height: auto;">

          By clicking the `Hex` tab, we can confirm the raw data for this transaction and exactly which function is being called.

          <img src="/html-fundme/3-function-selector/function-selector2.png" style="width: 75%; height: auto;">

          We'll go into `function selectors` a lot more later, but the important thing to understand is that when a Solidity contract is compiled, our functions are converted into a low-level bytecode called a `function selector`.

          When we call our `fund` function, this is converted to a `function selector` that we can actually verify using Foundry's `cast` command.

          ```bash
          cast sig "fund()"
          ```

          The above should result in the output `0xb60d4288` and when we compare this to the `Hex` data in our Metamask, we see that it does indeed match!

          Were the function being called something secret/nefarious like `stealMoney()`. This function selector would be completely different. Running our cast command again confirms this clearly with a return of `0xa7ea5e4e`.

          We can use this knowledge to verify any function we're calling through our browser wallet by comparing the expected and actual `function selectors` for the transaction.

          There's even a way to decode calldata using the cast command.

          Let's say our function was a little different and it required an argument.

          ```js
          function fund(uint256 amount) public payable {
              require(amount.getConversionRate(s_priceFeed) >= MINIMUM_USD, "You need to spend more ETH!");
              // require(PriceConverter.getConversionRate(msg.value) >= MINIMUM_USD, "You need to spend more ETH!");
              s_addressToAmountFunded[msg.sender] += amount;
              s_funders.push(msg.sender);
          }
          ```

          If we were to call this function, the information Metamask gives us is a little different.

          <img src="/html-fundme/3-function-selector/function-selector3.png" style="width: 75%; height: auto;">

          In this instance, we can use the command `cast --calldata-decode <SIG> <CALLDATA>` to provide us the parameters being passed in this function call!

          ```bash
          cast --calldata-decode "fund(uint256)" 0xca1d209d000000000000000000000000000000000000000000000000016345785d8a0000
          ```

          The above decodes to:

          ```bash
          100000000000000000 [1e17]
          ```

          0.1 Eth! The same amount being passed as an argument to our `fund` call. It seems this function is safe!

          ### Wrap Up

          This more or less summarizes how transactions work through our browser wallet and what we can expect to see from a low-level with respect to the encoded `function selectors` and `calldata`, we'll go over those in more detail later.

          I encourage you to experiment with the remaining functions on the front end. A few things to try:

          * Funding and Withdrawing with an account
          * Funding with Account A and Withdrawing with Account B - what happens?
          * Verify the `function selectors` of our other functions

          In our next lesson we'll recap everything we've learnt so far 💪
      -
        id: bcb0296e-6981-43c8-9742-1bd4688fca06
        type: new_lesson
        enabled: true
        title: 'Section recap'
        slug: summary
        duration: 5
        video_url: xCh701YZUuRoJB36kPymJVtmwdOWTNWC58IMZWn4SWxA
        raw_markdown_url: /routes/foundry/3-html-fund-me/4-summary/+page.md
        description: 'Summary of web interactions and transactions, emphasizing the role of function selectors and the importance of secure and intelligent web navigation.'
        markdown_content: |-
          ***

          ## title: Summary

          *Follow along the course with this video.*

          ***

          ### Recap

          I know this lesson was pretty quick, but my intent was to give you some degree of familiarity with the low-level functionality behind interacting with websites in Web3.

          If you're interested in expanding your full-stack skills, I encourage you to check out the html-fund-me repo in more depth. Some additional tools and frameworks you may want to investigate include:

          * **[React](https://react.dev/)**
          * **[Svelte](https://svelte.dev/)**

          Let's do a refresher on the important things to know under the hood, when it comes to interacting using our wallets.

          ***

          We learnt, in order to send a transaction, you need to connect your wallet.

          The most popular way to connect our wallet to Web3 enabled applications is through browser injection. Our browser can check for the presence of a wallet by checking for the `window.ethereum` object.

          Additionally, in order to send a transaction to our wallet, our browser needs an RPC URL or a `provider` this is derived from the `ethereum.window` object that our browser wallet creates.

          ```js
          const provider = new ethers.providers.Web3Provider(window.ethereum);
          ```

          Our wallet also provides the browser with an account to use through this line.

          ```js
          const signer = provider.getSigner();
          ```

          Once a wallet is connected, it's important to remember that the browser sends transactions *to* our wallet for signing/confirmation. The wallet does *not* provide private key information to the browser application.

          <img src="/html-fundme/2-metamask/metamask5.png" style="width: 75%; height: auto;">

          We also learnt a basic way to verify the function calls being sent to our wallet through the use of `function selectors` and decoding `calldata`. We'll go over this in more detail later!

          That's all there is to this lesson! With your deeper understanding of how transactions are handled, I'll see you in the next one!
    type: new_section
    enabled: true
  -
    id: JfNaf9uK
    title: 'Smart Contract Lottery'
    slug: smart-contract-lottery
    lessons:
      -
        id: 56f7152b-6ccb-4c0a-be25-fb56cb797b0d
        type: new_lesson
        enabled: true
        title: 'Smart contract lottery - Project setup'
        slug: setup
        duration: 12
        video_url: 6MLgmCeVhO01FOkANaADQRdmStMgY2Jl9lXxRo02STYJw
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/1-setup/+page.md
        description: 'Introduction to building an advanced lottery or raffle smart contract, covering key features like Chainlink automation and random number generation.'
        markdown_content: |-
          ***

          ## title: Setup

          *Follow along the course with this video.*

          ***

          Welcome back! I hope you enjoyed your break because we're about to dive into project number nine. As always, our goal is not just to teach you to build amazing projects, but to ensure you understand best practices and how to make your code look phenomenal.

          ## Getting Started

          For the project, we'll be working with an **advanced lottery or raffle smart contract**. This won't just be an exercise in coding, but a chance to learn more about:

          * Events
          * Working with true random numbers
          * Working with Modulo
          * Chainlink automation
          * And so much more.

          Feel free to explore the code base right in the course down to lesson nine. No need to follow along right now, just watch and get a feel for what we're about to build.

          <img src="/foundry-lottery/1-setup/setup1.png" style="width: 100%; height: auto;">

          ## A Closer Look at the Smart Contract

          In this project, we're introducing some **professional Nat spec for an even better looking codebase**. A key feature here is the raffle or lottery smart contract. This contract includes various functionality such as:

          * Enabling users to enter the raffle
          * A unique `checkUpkeep` functionality
          * A `fulfillRandomWords` function that chooses a winner and awards them a sum of money based on the entries
          * Multiple getter functions

          Having made sure our foundational setup is in place with `forge build`, we then move to our make file where we have different commands like deploying our smart contracts and interacting with the Chainlink automation.

          ## Building From Scratch

          One crucial lesson we should all remember is that repetition is the mother of skill. The more you code, the better you get. As such, it advisable to code along, pausing the tutorial occasionally to try coding on your own.

          We start fresh by creating a new Foundry project. Right before diving into code, it's essential to plan out what you want your project to achieve. Define those goals clearly, while making sure they align with the project's requirements. For the lottery project, the goals include:

          * Users should be able to enter the raffle by paying for a ticket
          * The lottery should automatically and programmatically draw a winner after a certain period
          * Chainlink VRF should generate a provably random number
          * Chainlink Automation should trigger the lottery draw regularly

          **Rope in Chainlink for the win!**

          * Chainlink VRF is an essential tool to instill trust in the lottery process. It generates a provably random number outside of the blockchain, ensuring the process is fair and transparent.- Chainlink Automation, a time-based trigger, eliminates the need for manual trigger of the lottery draw, making the process even smoother.

          Given the goals, the functions necessary to achieve this are `enterRaffle` and `pickWinner`. The `enterRaffle` function allows users to buy a ticket to enter the raffle and the `pickWinner` function randomly picks a winner and awards them the accumulated entry fees.

          ## The Layout for Your Code

          Code layout matters! As they say, "Clean code is a process, not a point in time." We can improve our code's layout and readability with the best practices we have learned.

          <img src="/foundry-lottery/1-setup/setup2.png" style="width: 100%; height: auto;">

          So let's get back to our Enter raffle function. You would probably want to set a ticket price or entry fee, right? Therefore, setting up an `entranceFee` state variable promptly at the top of the contract is recommended. We want to be mindful of our gas costs though, hence making the variable immutable.

          ```js
          uint256 private immutable _entranceFee;
          ```

          Creating a getter function for the entrance fee allows for transparency since the world can see the fee.

          ```js
          // Getter functions
          function getEntranceFee() external view returns(uint256){
              return _entranceFee;
          }
          ```

          We are just getting warmed up! There’s more to building this lottery contract. No worries, though, the journey to creating a provably fair, a provably random lottery, while learning and implementing best practices to making your code look phenomenal, is going to be amazing.

          Let's jump in!
      -
        id: 35905d3f-a802-4475-913d-c4af8ae829c8
        type: new_lesson
        enabled: true
        title: 'Solidity style guide'
        slug: solidity-layout
        duration: 2
        video_url: Pi8ak2J8SkzpNif4sZ5qF1UeSZ4zeAzLMMg01goCB1aU
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/2-solidity-layout/+page.md
        description: "Exploration of Solidity's code layout and function ordering for efficient smart contract development."
        markdown_content: |-
          ***

          ## title: Solidity Layout

          *Follow along the course with this video.*

          ***

          In one of our previous conversations, we discussed Solidity's style guide, code layouts. However, it's intriguing to note that we didn't fully explore how to properly order our Solidity functions and calls. This article aims to delve deeper into this crucial aspect of the usage of Solidity, the leading programming language for smart contract development.

          The official Solidity docs provide a comprehensive order of layout for a better understanding of the programming organization. The objective is to make your codebase look professional and easy to navigate when working with code.

          <img src="/foundry-lottery/2-layout/layout1.png" style="width: 100%; height: auto;">

          ## The Standard Order for Code Layout in Solidity

          Starting with the `Pragma` directive, a typical Solidity code layout follows several steps in a specific order:

          1. `Pragma` statement
          2. Import statements
          3. Interfaces and libraries
          4. Contracts
          5. Type declarations within contracts
          6. State variables
          7. Events
          8. Modifiers
          9. Functions

          We've been following the correct procedure with `Pragma` at the very start. However, we currently don't have any import statements, interfaces or libraries. Next up on the list would be contracts, inside which you do type declarations and state variables.

          Our first function comes next, where we don't have any events or modifiers in use. The ordering advises that we start from the `constructor` but remember, keep the readability and comprehensibility of your program as a priority.

          <img src="/foundry-lottery/2-layout/layout2.png" style="width: 100%; height: auto;">

          ## A Closer Look at Function Ordering

          Function ordering in Solidity also follows a specific flow. You start with the constructor, then follow it up with the receive and fallback functions. After that, external and public functions come, followed by internal and private functions. Lastly, within a grouping, view and pure functions should be placed.

          Let's break down the order in this list:

          1. Constructor
          2. Receive
          3. Fallback
          4. External and Public functions
          5. Internal and Private functions
          6. View and Pure functions

          Enforcing readability, this order adds to the organization, keeping the code neat and manageable.

          ## How to Remember the Order

          You might sometimes find you forget to follow this specific order. A helpful tip that I personally use is to paste the code layout order at the top of my code as a quick reference guide. You can find a template of this versioning layout in the GitHub repository associated with this lesson.

          <img src="/foundry-lottery/2-layout/layout3.png" style="width: 100%; height: auto;">

          Go to the [Github repo](https://github.com/Cyfrin/foundry-smart-contract-lottery-f23/tree/main/src) and copy the code layout. Paste it at the top of your working context. This layout serves as a comprehensive guide we will follow.

          From there, you can copy and paste it at the top of your working context. This layout serves as a comprehensive guide we will follow.

          <img src="/foundry-lottery/2-layout/layout4.png" style="width: 100%; height: auto;">

          ## Conclusion

          In the end, the Solidity docs' recommended layout is simply a guide - you can opt to follow it or devise your own. After all, the ultimate goal is to create a clean and comprehensible code base regardless of the layout.

          Bear in mind, though, that when your application scales and interacts with other contracts, Solidity's official documentation's recommended order could save you significant time and confusion. Happy coding!
      -
        id: 32c9ad50-2e26-4383-a292-4a57affc9db7
        type: new_lesson
        enabled: true
        title: 'Creating custom errors'
        slug: solidity-custom-errors
        duration: 5
        video_url: 7600cgnkWs6W1A00LOfwy2TS400qENc4oGm8kd5P4o1iyc
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/3-custom-errors/+page.md
        description: 'Guidance on using custom errors in Solidity for gas-efficient and effective error checking.'
        markdown_content: |-
          ***

          ## title: Custom Errors

          *Follow along the course with this video.*

          ***

          ## Implementing the Entrance Fee

          So, remember when we said our raffle had an entrance fee? Well, let's get to it and actually start using it to ensure only people who have paid can enter the raffle.

          Our entrance raffle function is a `public payable`. However, it might be better to make it `external payable` for better gas efficiency. So, let's make that switch now.

          The shift to `external payable` makes sense since we're highly unlikely to have any internal function calls to `enterRaffle`, and `external payable` functions tend to be slightly more gas-efficient when called from outside the contract. Now that we've done that, let's do a check to ensure the correct quantities are transferred.

          Here's where the require statement comes into play.

          ```js
          require(msg.value >= _entranceFee, "Not enough ETH sent!");
          ```

          This statement checks if the entrance fee meets a certain condition - in this case, that the sent ETH is greater than or equal to the entrance fee. But if it doesn't, our function will revert and throw the user-friendly error message "Not enough ETH sent!".

          This leads us to our first major update to our knowledge of Ethereum.

          ## Custom Errors Vs `Require`

          Traditionally, the `require` function in Solidity has been the go-to method for incorporating error checking in the code. But all that changed with Solidity version 0.8.4 which introduced custom errors. This development allows you to define errors with custom names and, more importantly, custom errors happen to be more gas efficient.

          Here's how we could use it:

          ```js
          // Define the custom error at the top of your contract
          error NotEnoughETHSent();
          // Invoke the custom error
          if (msg.value < _entranceFee) {
              revert NotEnoughETHSent()
          };
          ```

          To give you a practical understanding of the gas saved, let's see an example. Two similar functions coded twice, one using revert with custom error and the other with require.

          ```js
          // Revert with custom error
          function revertWithError() public pure{
              if(false){
                  revert ExampleRevert_Error();
              }
          }
          // Revert with require
          function revertWithRequire() public pure {
              require(true, "ExampleRevert_Error");
          }
          ```

          If we were to deploy both the functions on Remix and execute them, despite both reverting (which inherently costs gas), the function with the custom error (`revertWithError`) turns out to be more gas efficient, costing **142 gas** to the **161 gas** of the `require` based error handling.

          So, in essence, this is a practical example of "learning something to never use it again".

          That's it, folks! By now, you know how to work with custom errors and some best practices to consider when writing these reverts. Stay tuned for more Ethereum Smart Contract updates and practical takes. Here's to better (and more gas-efficient) coding!
      -
        id: 9d92bd94-45e2-4a05-ac64-b98f3d9fe717
        type: new_lesson
        enabled: true
        title: 'Smart contracts events'
        slug: solidity-events
        duration: 12
        video_url: CuuJNbO3msJ1p3bovznCkrmmtrxhm9vswul1vyqrkz4
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/4-events/+page.md
        description: "In this lesson we'll explore how to use events in Ethereum smart contracts, specifically in a lottery system context."
        markdown_content: |-
          ***

          ## title: Events

          *Follow along with this lesson and watch the video below:*

          ***

          Ever wondered how to track users in an Ethereum lottery? Or how about which data structure to use for storing players addresses in an on-chain lottery system? Well, you're in for a ride as we take a deep dive into these topics and more!

          ## What's Next? Data Structures to the Rescue!

          In the case of a lottery system on the Ethereum network, we need to store and track all the users participating in each round.

          Here, we are confronted with the question of which data structure to choose. Should we use an array or a mapping? Should we use multiple address variables?

          To solve this, we've decided to use a dynamic array, an array that adjusts its size as needed. The reasons for this choice become apparent as you need to randomly pick a winner from the entries. As you may know, mappings can’t be looped through, which poses a problem if we need to randomly select an individual for the winning prize.

          ```js
          address[] private s_players;
          ```

          The above line is an array of the players in the lottery. Notice the `private` modifier, which means the variable cannot be accessed directly from outside the contract. This variable is dynamic and its value will change frequently as players enter the lottery, leading to more storage operations.

          As we are dealing with Ether which will be paid to these players, we should make it an `address payable` to ensure we can transfer funds to these players.

          ## Updating Our Lottery

          With our array in place, we can proceed to update our lottery function.

          ```js
          s_players.push(payable(msg.sender));
          ```

          When users enter the lottery, we add their address into our dynamic array. Using the `push` function, we can add the `msg.sender` to our `s_players` array.

          ## Emitting Events: Announce It to the World!

          A key part of our function is missing: an event. Events in Ethereum are a mechanism to communicate that something has happened in a smart contract. These records can be used by the front-end of your application for various tasks and are also useful in migrating or updating your contracts. An event is typically emitted following any interaction with the contract that modifies its state.

          In our case, we should emit an event when a player enters the lottery. For this, we'll create an event called `EnteredRaffle` which receives an indexed address type parameter. Indexed parameters are parameters that are much easier to search for and much easier to query than non-indexed ones.

          ```js
          // Event Declaration
          event EnteredRaffle(address indexed player);
          // Emitting the Event
          emit EnteredRaffle(msg.sender);
          ```

          ## In Conclusion

          At this point, we've determined the data structure to use for our lottery, updated our function with it, and implemented events. The choices we discussed here should make picking a winner from all the participants seamless.
      -
        id: 62240b7f-d0a3-4182-9d00-ce5c2e738aba
        type: new_lesson
        enabled: true
        title: 'Random numbers - Block Timestamp'
        slug: solidity-random-number-block-timestamp
        duration: 4
        video_url: 8CGe7INLGvED02HpJxpQm7pHCGZ02NTbCJlqxh700o3jmk
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/5-block-timestamp/+page.md
        description: 'Insights into using block timestamps for random number generation in lottery smart contracts.'
        markdown_content: |-
          ***

          ## title: Block Timestamp

          *Follow along with this lesson and watch the video below:*

          ***

          Today, I'll be explaining and walking you through some crucial steps for developing an automatic lottery winner selection function, `pickWinner`.

          <img src="/foundry-lottery/5-block-timestamp/block1.png" style="width: 100%; height: auto;">

          ## The 'pickWinner' Explained

          The `pickWinner` function isn't just about picking the winner but also getting a random number *and* ensuring automatic selection happens seamlessly and precisely when it should.

          Here are a few things we want our `pickWinner` function to do:

          * Get a random number.
          * Use the random number to pick a player.
          * Trigger automatically (eliminating the need for manual interaction).

          Let's dive right into how we can achieve this. Initially, let's focus on the first two tasks—we can discuss automatic triggering later.

          ### Getting a Random Number and Picking a Winner

          To create an `external` function that anyone could call to select a random winner, we'd probably want the winner selection to happen when the lottery is ready for its winner. So, how do we know when that time is right? We make sure that enough time has elapsed to pick a winner.

          ```js
          public function pickWinner() external {}
          ```

          We'd achieve this by creating an `interval` variable, specifying how long our lottery will last before a winner is selected. However, since we wouldn't want to keep changing this value, we'll make it an `immutable` variable, meaning it can only be set in the constructor and remains constant throughout the contract's life.

          ```js
          constructor(uint256 entranceFee, uint256 interval) {
              i_entranceFee = entranceFee;
              i_interval = interval;
          }
          ```

          Comments are your best friend when reading code. So, don't forget to comment what `i_interval` contains: duration of the lottery in seconds.

          ```js
          // Duration of the lottery in seconds
          uint256 private immutable i_interval;

          ```

          ### The Golden Period: Has Enough Time Passed?

          Next, we need to check if this preset interval has passed before invoking the `pickWinner` function. Which leads us into some thorough timestamp comparison, in which we will take block timestamps into account!

          The `block.timestamp` global variable gives us the current time in seconds. Subtracting the previous timestamp from the current block timestamp should ideally be more significant than our preset interval.

          ```js
          block.timestamp - s_lastTimestamp > i_interval;
          ```

          This condition checks if enough time has passed, let's envision an example:

          * When `block.timestamp` is 1000 and `s_lastTimestamp` is 500, the elapsed time equals 500.
          * If the `I_interval` is 600 seconds, meaning that not enough time has passed and therefore, no winner should be picked.

          However, if the `block.timestamp` is 1200, 1200 - 500 equals 700, which is greater than our `I_interval` of 600. That means, enough time has passed, and it's time to announce a winner!

          ### The 'Snapshot' of Time

          Also, we would need to take a 'snapshot' of time, which we'll do by creating a `private` state variable that remains in storage—an `S_lastTimestamp`.

          ```js
          uint256 private s_lastTimestamp;
          ```

          The initial `s_lastTimestamp` value would be set right in the constructor as the `block.timestamp` immediately the contract gets deployed, to start the 'interval' clock.

          ```js
          constructor() {
              s_lastTimestamp = block.timestamp;
          }
          ```

          Below, in our `pickWinner` function, we'll revert the transaction if the condition doesn't meet, because not enough time would have passed.

          ```js
          if (block.timestamp - s_lastTimestamp < i_interval) {
            revert();
          }
          ```

          On the last note, while it might seem tempting to add custom errors right now, remember, it's best practice to refactor them eventually. So, for now, let's stick to checking the elapsed time.

          **NOTE**: Remember to update `s_lastTimestamp` once the winner has been picked.

          ```js
          s_lastTimestamp = block.timestamp;
          ```

          Stay tuned for my next blog post, where we take this to the next level and discuss how to make the `pickWinner` function automatically triggered.

          **Happy Coding!**
      -
        id: a21bd474-1086-4fe8-8545-33f6c33da57e
        type: new_lesson
        enabled: true
        title: 'Random numbers - Introduction to Chainlink VRF'
        slug: solidity-random-number-chainlink-vrf
        duration: 11
        video_url: 9eFpFl519YMWGmaIfylEqbgDfhwvgPZZbZNrNcmrSkM
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/6-chainlink-vrf/+page.md
        description: 'Introduction to using Chainlink VRF for generating random numbers in blockchain applications.'
        markdown_content: |-
          ***

          ## title: Chainlink VRF

          *Follow along with this lesson and watch the video below:*

          ***

          Welcome! It's time to explore the tech behind **random number generation** on the blockchain using Chainlink VRF! This post will walk you through the concepts, step by step, aided by a helpful video from Chainlink team. By the end, you will understand how to use Chainlink VRF to draw a random winner for your dApp.

          ## What is Chainlink VRF?

          VRF stands for **Verifiable Random Function**, a technology that enhances cryptographic capabilities. Chainlink's implementation provides developers with improved scalability, flexibility, and usability. According to Richard, a developer advocate at Chainlink Labs, a key element of VRF is its **subscription model**.

          <img src="/foundry-lottery/6-chainlink-vrf/vrf1.png" style="width: 100%; height: auto;">

          ## Walkthrough: Integrating Chainlink VRF

          To wrap our heads around Chainlink VRF, we'll follow a well-detailed example using the Chainlink Labs documentation and one of their setup tutorials. This guide will help you:

          * Understand Chainlink VRF.
          * Create and fund a subscription.
          * Deploy a contract that uses VRF.
          * Make a request to draw a random number.

          ### Getting Started with Chainlink VRF

          Jump into the [Chainlink Documentation](https://docs.chain.link/) and navigate to the **VRF section**. In this guide, we're skipping everything else to focus on obtaining a random number.

          ### Create & Fund a Subscription

          To use Chainlink VRF, you need to establish a subscription, which you can visualize as a bucket from which your contracts extract. Navigate to the **Subscription Manager** and create your subscription; you can input an email and project name for personalization.

          The process requires confirmation on a **test network**. For simplicity, this guide uses the Sepolia test network referenced in most Chainlink documentation.

          If you don’t already have ETH and link tokens, you can secure them from [Chainlink Faucets](https://faucets.chain.link/).

          Once you've got your tokens, add funds to the subscription (e.g., 5 link tokens).

          ### Adding VRF Consumers

          At this point, you've created your subscription, poured in funds, and are ready to deploy your contract.

          You need to let your subscription know about the contract you're deploying and vice versa. To help them work in synchrony, you add consumers to your subscription.

          <img src="/foundry-lottery/6-chainlink-vrf/vrf3.png" style="width: 100%; height: auto;">

          ### Deploying a Chainlink VRF Contract

          Return to the Chainlink documentation and click to open **Remix**, a development environment that enables you to deploy and interact with your contract on the blockchain.

          The Chainlink VRF contract comprises various components:

          * **Contract imports**: Coordinator interface, Consumer base and Confirmed owner.
          * **Contract variables**: Subscription ID, Request IDs, Key hash, and more.
          * **Functions**: `RequestRandomWords()`, `FulfillRandomWords()`, `getStatusRequest()` etc.

          The ultimate objective is to use the `RequestRandomWords()` function to call for random values from the Oracle network. Once those values are ready, the `FulfillRandomWords()` function allows you to process those values back in your contract.

          To deploy the contract, specify your **subscription ID** and approve the transaction.

          <img src="/foundry-lottery/6-chainlink-vrf/vrf2.png" style="width: 100%; height: auto;">

          ### Making a Request

          Once you've deployed your contract, copy its address and register it as a consumer in your subscription.

          Back in Remix, call the `RequestRandomWords()` function and confirm.

          Your request will show as pending on the Subscription page. Completion times can vary based on the number of block confirmations you specified and the network you're using.

          ### Confirming Request Completion

          To check whether your request has been fulfilled, copy the ID from `lastRequest()` function, then use `getStatusRequest()` to get the current status.

          )Once your request is marked as 'Fulfilled,' you've successfully drawn ! your random values using Chainlink VRF.

          The transcript calls a wrap at this point, but now that you know how to generate random numbers on the blockchain, the opportunities are limitless. You can assign random traits to NFTs, determine game asset allocations, and so much more.

          *Please note: Cloud-based RNGs are not recommended for high-value use-cases and a combination of on and off-chain RNGs can offer a robust solution.*

          That was it for todays lesson! I hope you enjoyed it and learned something new. If you have any questions, don't forget to ask on the Github Forum.
      -
        id: e1986802-cc3d-40ed-8cbc-12e9375eb206
        type: new_lesson
        enabled: true
        title: 'Implement the Chainlink VRF'
        slug: implementing-chainlink-vrf
        duration: 17
        video_url: yJNYyP8RwIePTyc84rBPUIJWMgR47zWscxnHCJ019NMA
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/7-implementing-vrf/+page.md
        description: 'Tutorial on deploying and integrating Chainlink VRF in smart contracts for random number generation.'
        markdown_content: |-
          ***

          ## title: Implementing Chainlink VRF

          *Follow along with this lesson and watch the video below:*

          ***

          Today, we will explore how to deploy a Chainlink Verifiable Random function (VRF) and integrate it into our existing code. It is a crucial element when we need to generate a random number within a blockchain application.

          ## A Closer Look at Chainlink VRF

          Before we dive into the process, let's take a closer look at Chainlink and its VRF.

          Chainlink VRF provides auditable, transparent, and easily verifiable randomness in smart contract use-cases. It employs Verifiable Random Functionality, which takes a seed input to derive a Random output.

          This process is done in a way that a third-party observer can public-verify the result, ensuring randomness that can't be biased or manipulated, because it leverages the security of the blockchain network itself.

          Browse through the official [Chainlink documentation](https://docs.chain.link/docs/get-a-random-number/) to get a good first-hand experience of deploying and using Chainlink VRF. Different forms of usage are listed here, which will be explained below.

          ## Getting Started with Chainlink VRF

          To get started, fire up Remix and open the Chainlink documentation. Scroll down to the section titled `Get a Random Number` and look for the button labeled 'open in Remix'. This will bring up a code editor for you to modify.

          In Remix, you will find pre-written code that uses the Sepolia chain as its default. Two primary methods are explained in the docs- one is Subscription, and the other is Direct Funding.

          Subscription is preferable as it scales better, as the contract pulls the link from a separate fund which you previously loaded up with the link.

          <img src="/foundry-lottery/7-implement/implement1.png" style="width: 100%; height: auto;">

          After setting up the subscription, you will promptly learn how to complete these steps programmatically, avoiding the need for navigating the user interface.

          The primary goal is to add a randomization function. As developing with Chainlink VRF involves two transactions, the random number generation is also completed in two steps.

          Firstly, you send a request to generate a random number, followed by a second request to receive that random number. The request function signals Chainlink to select the lottery winner, while Chainlink returns the random number to the `callback` function, which announces the actual winner.

          ## Implementing Random Number Function

          You will find a code snippet in the 'Get a Random Number' section of the Chainlink documentation that will help you implement this random number fetch process.

          The function call that enables this looks like this:

          ```js
          uint256 requestId = i_vrfCoordinator.requestRandomWords(
            keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
          );
          ```

          This is the code you will insert into the existing code. After pasting the code, you will observe a multitude of red lines- don't worry; these will be resolved shortly.

          This function requires a coordinator address, which is the address of the Chainlink VRF Coordinator to whom the random number is requested. This `keyHash` is your 'gas lane', and is something you can specify if you don't wish to consume much gas. Your `subscriptionId` is essentially the ID that you previously loaded with link to create requests.

          The `requestConfirmations` is the number of block confirmations after which your random number is considered good, and the `callbackGasLimit` ensures you don't overspend on the request. Finally, `numWords` indicates the number of random numbers you require.

          On receiving the request, Chainlink will return a `requestId`.

          ## Configuring the Constructor

          The `keyhash` is subject to variation depending on the chain, so I prefer calling it the 'gas lane'. As it's a constant in your smart contract, add `gasLane` to the constructor, making it an immutable variable.

          You will need the VRF coordinator's address, which is unique to each chain, and thus needs to be passed through the constructor and made an immutable variable.

          Your `subscriptionId` will be specific to your Chainlink VRF subscription often received from the constructor, and the number of confirmations can be set as a constant variable- three confirmations being a common choice. The max gas for the callback function can be limited to prevent excessive gas costs caused by the second transaction when returning the random number.

          <img src="/foundry-lottery/7-implement/implement2.png" style="width: 100%; height: auto;">

          Finally, since you will only require one random number for selecting a winner, you can set the `numWords` as the constant variable equal to one. Now, when you fire and use Chainlink VRF, you can efficiently make a request.

          ## Receiving a Response From Chainlink

          Implementing randomness into your contract is not simply about making request for a random number from Chainlink, you also need to be set up to receive that number back by implementing the function: `fulfillRandomWords`. This function is called by the Chainlink node, and should be set up to execute a specific action with the received random number- in this context, it will be selecting a lottery winner.

          ## Wrapping It Up

          In summary, the steps to implement Chainlink VRF are as follows:

          1. Make a request to Chainlink for a random number.
          2. Chainlink sends back that random number to a specified function, using VRF.
          3. Use the returned random number to pick a user as the lottery winner.

          This lesson covered a range of helpful tips on how to deploy Chainlink, so feel free to go back through to fully understand the process. Generating secure and verifiable random numbers within the blockchain is an essential capability, and hopefully you now feel comfortable in deploying this for your future smart contracts. As always, happy coding!
      -
        id: 023a2d78-25db-4e82-b91d-2e61a0a9ecb6
        type: new_lesson
        enabled: true
        title: 'The modulo operation'
        slug: solidity-modulo-operation
        duration: 6
        video_url: j1wu9ue9Ii8QtCg5R4g9lXYpLih3cDgOy01u01hvRA014A
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/8-modulo/+page.md
        description: 'Explanation of using the modulo operation for selecting random winners in smart contract games.'
        markdown_content: |-
          ***

          ## title: Modulo

          *Follow along with this lesson and watch the video below:*

          ***

          In this lesson, I'll walk you through how to use the modulo function for picking a winner randomly from a list of players in Solidity, a contract-oriented programming language for implementing smart contracts.

          ## Understanding Modulo

          Let's discuss how the modulo function or 'mod' function works. Essentially, this function performs a division operation and returns the remainder after dividing.

          Consider the case where we divide 10 by 10 using the mod function. Since there is no remainder, the function returns zero. Conversely, if we divide 10 by 9, 9 out of the 10 are divided evenly leaving one left. In this case, 10 mod 9 equals one.

          This logic can be extended to all numbers:

          * 2 mod 2 equals zero because 2 and 2 divide evenly.
          * 2 mod 3 equals one because there's one left over.
          * 2 mod 6 equals zero because 2 divides into 6 evenly.
          * 2 mod 7 equals one because there's one left over after 2 divides into 7 three times.

          Through these examples, we can see that the modulo function helps us find the remainder of a division operation.

          ## Modulo in Action

          Let's put the mod function into practice:

          ```js
          contract ExampleModulo {
              function getModTen(uint _num) public pure returns(uint) {
                  return _num % 10;
              }
              function getModTwo(uint _num) public pure returns(uint) {
                  return _num % 2;
              }
          }
          ```

          In this contract, we've got two simple functions, `getModTen` and `getModTwo`, that return the modulo ten and two of the given integer respectively.

          For example, if we pass 123 into getModTen, it would return 3 because 120 divides evenly into ten leaving a remainder of 3. If we have a large number, say 102030405060708090, the function would return 2 because the number divides evenly into ten with a remainder of 2.

          Using mod two gives us a different way to look at numbers. Any even number mod two will result in zero. If the number is odd, the result will be one.

          ## Picking a Winner

          Now we're going to use the mod function to randomly select a winner from an array of players. Let's say `s_players` is of size ten and has ten players. We're generating a random number (RNG) to select the index for our winner.

          ```js
          uint256 indexOfWinner = randomWords[0] % s_players.length;
          ```

          If our RNG is, say, twelve, we'll calculate `12 mod 10`, which equals two, and the player at index two in the array is our winner. Once we have the index of the winner, we write:

          ```js
          address payable winner = s_players[indexOfWinner];
          ```

          This returns the address of the randomly selected winner.

          Besides, we'll also keep track of the most recent winner, which helps in knowing who won most recently.

          ```js
          address private s_recentWinner;
          s_recentWinner = winner;
          ```

          <img src="/foundry-lottery/8-modulo/mod1.png" style="width: 100%; height: auto;">

          ## Transferring Rewards

          Now, let's transfer the winnings to the selected winner.

          ```js
          (bool success,) = winner.call{value: address(this).balance}("");
          ```

          Here, we transfer the entire balance of the contract (which are the ticket sales) to the winner.

          To ensure that transfer was successful:

          ```js
          if (!success) {
            revert RaffleTransferFailed();
          }
          ```

          This reverts the transaction and refunds the gas if the transfer isn't successful, ensuring the winner does not lose out.

          To conclude, the modulo function helps to generate a random index within the length of the players array, resulting in a fair selection of the winner. This can be used in various blockchain-based games and applications to ensure a level playing field.

          Stay tuned for more posts on coding smart contracts in Solidity!
      -
        id: 1adf37cf-e707-49fb-bd19-55505e872df4
        type: new_lesson
        enabled: true
        title: 'Implementing the lottery state - Enum'
        slug: solidity-enum-lottery-state
        duration: 5
        video_url: 1Xkvuy00zu01ZySDYkCvTInNddvHJ01JNd015TEFkdtB9Uc
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/9-enum/+page.md
        description: 'Discussion on using enums to manage different states in a raffle smart contract.'
        markdown_content: |-
          ***

          ## title: Enum

          *Follow along with this lesson and watch the video below:*

          ***

          When we delve into developing applications like a raffle, managing the different states of the event is equally critical as the event itself. We will extend our previous discussion about picking a winner in the raffle and lead into governing who can enter the raffle. Of course, if we are currently awaiting a random number to determine the winner, it's not fair for anyone else to enter the raffle then, right?

          To handle these kinds of situations, we need a mechanism in place—a check on the state of the raffle to determine if it's currently open or not. This is where `enums` step into the picture, offering a clean, readable, and maintainable solution.

          ## An Introduction to the Concept of Enum

          Before we start, a brief introduction to enums seems appropriate. An enum, also known as enumerated type, is a data type consisting of a set of unique elements. Enums provide an effective way to create and manage constant values throughout your contract. In other words, they help avoid scatter variables, such as bool calculating\_winner = false, and group them into a single variable of type enum. For more details, [Solidity docs](https://solidity.readthedocs.io) give a glimpse into enum types.

          ```js
          contract Example {
              enum ActionChoices {
                  GoLeft,
                  GoRight,
                  GoStraight,
                  SitStill
                  }
              }
          ```

          Every enum creates a new type, like `ActionChoices` in this example, that can be used throughout the contract.

          ### Creating Enums for Raffle State

          Now, back to our raffle contract. We will create an enum named `RaffleState` with two states—`open` and `calculating`.

          ```js
          enum RaffleState {
                  OPEN,
                  CALCULATING
              }
          ```

          Point to remember: Enum elements can be converted to integers. So here, `Open` would be 0 and `Calculating` would be 1. Adding more states will increment the integers equivalently.

          To utilize this enum, we will create a `RaffleState` variable, named `s_raffleState`, storing the current state of the raffle.

          ```js
          RaffleState private s_RaffleState;
          ```

          ### Default Setting and Transitioning States

          By default, let's keep the raffle state `Open` (we do want the participants to rush in, don't we?). So, right in the constructor, assign the default state.

          ```js
          s_raffleState = RaffleState.Open;
          ```

          Now, extending our `enterRaffle` functionality, we will include a check to ensure the raffle is not in the `Calculating` state.

          ```js
          if (s_raffleState != RaffleState.OPEN) {
              revert Error("RaffleNotOpen");
          }
          ```

          And subsequently, declare this error at the beginning of your contract.

          ```js
          error RaffleNotOpen();
          ```

          Now, no entries can be made while the contract is calculating a winner.

          ### State Transition during Winner Calculation

          When it's time to choose the winner (`pickWinner`), we will shift the state to ‘Calculating’.

          ```js
          s_raffleState = RaffleState.CALCULATING;
          ```

          Remember, as long as we are waiting for the random number, no one is allowed to enter the raffle.

          And once we have our lucky winner(s), it's time to switch the raffle state back to `Open` — let the game begin again!

          ```js
          s_raffleState = RaffleState.OPEN;
          ```

          So your raffle is **open** to the public again … the adrenaline rush continues, building up to the next exciting round of winner selection!

          ## Conclusion

          Enums offer a compact, clear way of representing and managing different states within your contracts. In our raffle example, we used this powerful feature to control who can enter the raffle and when. By using enums, we make our contracts more readable and modular and ensure they follow good programming practices. Make sure you use this feature to its fullest when programming your next Solidity contract!
      -
        id: 6ded233d-f088-4db0-aa90-aab75f471d44
        type: new_lesson
        enabled: true
        title: 'Lottery restart - Resetting an Array'
        slug: resetting-array
        duration: 2
        video_url: MLncC2ZviCAEkRz5Jv02axZGSemO6YeRDwTZVOxeh1hk
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/10-resetting-array/+page.md
        description: 'Exploration of resetting player arrays in smart contracts to start new game rounds.'
        markdown_content: |-
          ***

          ## title: Resetting an Array

          *Follow along with this lesson and watch the video below:*

          ***

          In this lesson, we will delve into the deeper components of smart contract design by focusing on starting a new game or resetting a stage in a lottery game. An essential factor to consider here is to ensure that no old players from the previous round can participate in the new lottery round without entering.

          ### Resetting the Player Array

          Firstly, the player's array, denoted as `s_players`, needs to be reset for every new lottery round. If left untouched, `s_players` would still hold players from the previous lottery, allowing them to participate in new rounds without necessarily entering again – a loophole we definitely want to avoid!

          Here's how to do that:

          ```javascript
          // Initialize new player array
          s_players = new address payable[](0);
          ```

          This code resets the `s_players` array into a new empty array. With this, we're all set to start accepting players for the new round!

          ### Ticking Off The New Round's Timestamp

          Next, to keep track of when the new lottery round begins, we update the `s_last_timestamp` with the current block timestamp.

          ```javascript
          // Update the timestamp
          s_last_timestamp = block.timestamp;
          ```

          With the timestamp updated, the clock automatically starts ticking for the new lottery round.

          ### Emitting an Event on Winner Declaration

          After successfully resetting the state and declaring a winner, it is generally a good practice to emit a log event. This creates a simple and efficient way to inform anyone interested about the winner and can be useful for debugging or auditing contract executions.

          Let's create a new event called `WinnerPicked()`:

          ```javascript
          // Creating new event
          event WinnerPicked(address indexed winner);
          ```

          However, to better capture the process, we can change the name from `WinnerPicked` to `PickedWinner`. Sounds more like an action, right?

          ```javascript
          // Emitting the event
          emit PickedWinner(most_recent_winner);
          ```

          This emits a `Picked Winner` log with the winner's address every time a new lottery round begins.

          To conclude,

          <img src="/foundry-lottery/10-array/array1.png" style="width: 100%; height: auto;">

          While there's no standardized naming convention for events in smart contracts, it's a good idea to keep names consistent, meaningful, and action-derived.

          That sums up how to restart a new lottery round in a smart contract. Incorporating these practices in your future Ethereum smart contracts will ensure fair gaming and accurate auditing.
      -
        id: 896f5895-3b03-4098-8852-857e03996efd
        type: new_lesson
        enabled: true
        title: 'Important: Note on learning by building'
        slug: note-on-building
        duration: 2
        video_url: k7PB1WJkN6bUEf01EA9LKw5c00eC02nUZxyw102COosxdDQ
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/11-note-on-building/+page.md
        description: 'Insights into the true process of building solidity projects, highlighting the iterative nature of coding.'
        markdown_content: |-
          ***

          ## title: Note on Building

          *Follow along with this lesson and watch the video below:*

          ***

          When it comes to building solidity projects, things may seem a bit too linear or straightforward when you watch a demo or read a tutorial. You may assume that I just go straight from the start to the finish without pausing, but this isn't always the case. In this piece, We aim to peel back the curtain and reveal the actual process — back and forth movements, the surprises, and the frequent pausing for debugging that are the actual hallmarks of building solidity projects effectively.

          ## Breaking the Illusion of Once-through Coding

          Firstly, my seeming seamless way of doing these demos is not indicative of what normally happens when I code. It appears as if I am easily writing this contract from the beginning to the end, but that's far from the reality.

          Here, you might be impressed with how quickly and seamlessly we are coding this contract, but don't be fooled - it's not typical to write a contract in one go. In fact, it's not even possible to write a contract in one go. It's a process of writing, testing, and refactoring.

          But the reality behind this façade is that We've carried out such demonstrations repeatedly. We've written this code countless times and spent vast hours refining our skills in solidity.

          ## "Piece by Piece" Methodology

          When coding, rather than tackling the entire project as a whole, it's often beneficial to break it down. Rather than writing a contract in one go, which can be incredibly challenging, I find myself writing a deploy script and testing individual components of the contract, part by part as I build it.

          ```markdown
          // As an example, at this point in my coding, I probably would have written tests
          // for various functions such as 'get entrance fee', 'pick winner' and 'enter raffle'.
          ```

          Writing tests while coding is incredibly beneficial. In fact, it's a necessary practice when writing real projects. However, in this demonstration, I won't be writing tests or deploying scripts immediately.

          The reason isn't that these steps aren't important — they absolutely are — but rather because we'll be performing extensive refactoring as we progress, and it's pointless to write tests for code that will soon be modified or discarded.

          ## Understanding the Real Coding Project

          I must emphasize that this modeling doesn't portray reality accurately. True, it breaks down the functions and processes into understandable pieces. However, it veils the moments of debugging, the constant going back-and-forth, the nights when the code doesn't compile, and you can't figure out why.

          ```markdown
          // When you're coding a real project, you may encounter setbacks like compilation errors and other bugs
          that may require you to troubleshoot and refactor your program.
          ```

          However, here is an essential truth:

          <img src="/foundry-lottery/11-building/build1.png" style="width: 100%; height: auto;">

          So, as you journey through coding projects, remember to take a deep breath and hop back into it whenever you experience any of these hitches. It's okay, and it's good. It means you're learning, and with every bug fixed or problem solved, you become a better programmer.

          So next time you see me sailing through a demo or tutorial, remember there's more to it than meets the eye. Happy coding!
      -
        id: 1eb044f4-5ca5-49ff-a426-2d428dc7db5c
        type: new_lesson
        enabled: true
        title: 'The CEI method - Checks, Effects, Interactions'
        slug: cei-method-checks-effects-interactions
        duration: 3
        video_url: X2ZL7StB5N02d02S4vScFmQo2Hr5uqZjFTylmOmopTTQg
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/12-cei/+page.md
        description: 'An overview of the Checks-Effects-Interactions pattern for secure and efficient smart contract development.'
        markdown_content: |-
          ***

          ## title: Checks, Effects, and Interactions

          *Follow along with this lesson and watch the video below:*

          ***

          In this lesson, we'll explore a critical design pattern that every smart contract developer needs to know - the Checks-Effects-Interactions (CEI) pattern. By adhering to this pattern, you'll ensure your smart contracts are more secure and maintainable.

          ## Understanding the Checks-Effects-Interactions (CEI) Pattern

          Coding smart contracts requires a particular style called Checks-Effects-Interactions or CEI. This is one of the several design patterns that smart contract developers need to maintain in their coding processes. Following the CEI pattern increases the overall security of your contracts.

          The CEI pattern involves three detailed steps:

          1. **Checks:** This is the initial step where you do all your validations or checks. An example could be your `requires` or `if-then` errors. Generally, it's more efficient to place these checks at the very beginning of your contract. The reason is they are more gas-efficient. In a situation where you need to revert, doing so at this stage will save more gas than performing other computations only to revert later.
          2. **Effects:** In this step, you make changes or "effects" within your own contract.
          3. **Interactions:** This final step involves interactions with other contracts. One crucial point to note here is it's best to interact with outside contracts last.

          One of the reasons to follow this pattern is to avoid reentrancy attacks, a common vulnerability in smart contracts. Understanding and implementing the CEI pattern early on means you're proactively safeguarding your contracts from potential attacks.

          ## Effective Handling of External Interactions and Events

          While discussing the third step of the CEI pattern – interactions, we should touch on the usage of events and their placement in the code. Emitting an event at the end might seem like an external interaction, but it's not. It would be best to move it before we have any interactions with external contracts.

          <img src="/foundry-lottery/12-cei/cei2.png" style="width: 100%; height: auto;">

          There can be a debate about the position of events. Some developers prefer positioning them after the interactions. However, if we take a look from the code review or audit perspective, it's usually recommended to place the event before the external interactions, largely because of several reasons that we'll cover in subsequent blog posts.

          In conclusion, the Checks-Effects-Interactions (CEI) pattern is a cornerstone of secure, gas-efficient smart contract development. Remember this design pattern and apply it consistently when developing your smart contracts: always do your checks first, followed by the effects, and finally perform external interactions. Following this approach is a step in the right direction towards ensuring you're always delivering robust and secure smart contracts.
      -
        id: 4ccf702a-906a-4dae-a78d-cc692656a4cd
        type: new_lesson
        enabled: true
        title: 'Introduction to Chainlink Automation'
        slug: chainlink-automation
        duration: 16
        video_url: eRzB01Z993VKnPOHqQ74hTQPghNYUXvcCID8ZhfMQoDs
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/13-chainlink-automation/+page.md
        description: "This lesson covers the basics of Chainlink Automation, essential for automating the 'Pick Winner' function in a lottery application. It delves into the use of Chainlink VRF for randomness and explores time-based automation and custom logic through Chainlink."
        markdown_content: |-
          ***

          ## title: Chainlink Automation Introduction

          *Follow along with this lesson and watch the video below:*

          ***

          We've been working towards building a lottery application with Chainlink VRF to handle the randomness needed to pick a winner. So far, we've developed a `Pick Winner` function which initiates a Chainlink VRF call and carries out the `fulfill` function to generate a random number and select a winner from the lot. However, the current flow has an issue; the `Pick Winner` function isn’t called automatically - leaving it up-to manual intervention.

          This is where the beauty of automation kicks in. As software engineers, we aim for efficient and effective solutions. Speaking of efficiency, I’d like to introduce you to **Chainlink Automation**, which will allow us to automatically run our `Pick Winner` function.

          ## Using Chainlink Automation

          The [Chainlink documentation](https://docs.chain.link/chainlink-automation/introduction) provides a wealth of information when it comes to automation. We can access guides from the `Automation` tab present on the left-hand panel. For our purpose, we'll be exploring the `Time Based` automation and `Custom Logic` sections.

          Although this guide shows how to work with Chainlink from the UI, we will be primarily approaching this programmatically - remaining true to our prudent working style!

          If we scroll down, we can find an example of a contract named `Create Compatible Contracts` suitable for use with Chainlink automation. Either you can try it out in the Remix IDE yourself or we can collectively go through a video where Richard, one of the developer advocates at Chainlink Labs, explains Chainlink Automation and conducts a demonstration.

          ## Exploring Automatic Keepers

          In this video, Richard provides a walkthrough on updates to Chainlink’s Keepers, starting with how to connect a wallet from the Chainlink Keepers UI, registering a new upkeep, and implementing time-based trigger mechanisms.

          The `Keepers Chainlink` page has changed a bit, but it’s quite straightforward. Upon registering a new upkeep, you will find the `trigger` option. As Richard explains, this option is extremely useful for implementing timed-based triggers which was formerly achieved by checking upkeep with block hashes.

          After connecting the wallet and setting up the Keepers, the next step is to work on a simple contract known as `Keeper compatible contracts`. If you’ve worked with previous versions, you'll recognize the `check Upkeep function` and `perform Upkeep function`.

          ## Modifying the Contract

          Time to roll up our sleeves and modify this sample contract. As explained, `Remix` is an online IDE for developing solidity smart contracts, which we will be using to modify our existing contract. We aim to create the same functionality in an easier, more readable way.

          Starting with a contract count function that doesn’t require any external input, we aim to increment the counter at regular intervals. Notably, with time-based triggers, we can get rid of the `check upkeep` function and `perform upkeep` function.

          Upon getting rid of unnecessary functions, the contract is compiled, displaying a green checkmark for successful compilation. From there, constructor values are set and deployed. In this case, the contract was deployed to the `Fuji Avalanche Test Network`.

          ## Using Keepers in Practice

          Next, we head to the `Keepers` interface and fill necessary details like the address of our contract and schedule for triggering in terms of Cron syntax. Post registration, you may need to receive some link tokens - which you can get from the faucet linked from the register page.

          After registering and making necessary confirmations, the interface will present a page detailing the upkeep, historical data, and options for editing gas limits or adding more link tokens.

          Just like that, using Chainlink Keepers, we're able to automate our smart contracts! Tiny contracts that are easy to understand and cleaner, just how we like them.

          <img src="/foundry-lottery/13-automation-intro/automation1.png" style="width: 100%; height: auto;">
      -
        id: 28181c1e-a98a-47a4-b2f3-a246b5e6c62f
        type: new_lesson
        enabled: true
        title: 'Implementing Chainlink Automation'
        slug: implementing-automation-2
        duration: 10
        video_url: ShZL8JNczx402qLth15McF7rUPCouRLUoZAInsk7IU8k
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/14-implementing-automation-2/+page.md
        description: 'Focusing on implementing Chainlink Automation, this lesson teaches how to use \`checkUpkeep\` and \`performUpkeep\` functions for automated execution in Chainlink-powered smart contracts, enhancing their autonomy and efficiency.'
        markdown_content: |-
          ***

          ## title: Implementing Chainlink Automation

          *Follow along with this lesson and watch the video below:*

          ***

          ### Defining the Setup Functions

          To implement Chainlink automation, we utilize two key functions: `checkUpkeep` and `performUpkeep`. These functions will allow our Chainlink nodes to automatically start the lottery whenever necessary.

          Currently, our code includes a function named `pickWinner`. We will modify this function to permit Chainlink Automation to initiate contract calls as opposed to the manual initiation process currently in place.

          ### Creating the `checkUpkeep` function

          Our first step is to create a `checkUpkeep` function. This function notifies the Chainlink nodes when it's due time to call `Perform upkeep`.

          Typically, the function definition may look something like this:

          ```js
          function checkUpkeep(bytes memory checkData) public view
          returns (bool upkeepNeeded, bytes memory performData) {}
          ```

          At a basic level, the function checks several conditions:

          * If the required time interval between raffle games has passed.
          * If the raffle is in the open state
          * If the contract has any ETH (meaning there are players)
          * If the subscription is funded with LINK.

          ### Creating the `performUpkeep` function

          Once `checkUpkeep()` has determined it's time for an update, it's the `performUpkeep()` function's task to trigger the actual update.

          The performUpkeep function first verifies if it is indeed time to initiate an update by calling `checkUpkeep`. If the check is not passed, it will revert with a custom error called `raffle upkeep not needed`.

          Here's a basic implementation of the `performUpkeep` function:

          ```javascript
          function performUpkeep(bytes calldata /* performData */) external override {
                  (bool upkeepNeeded, ) = checkUpkeep("");
                  // require(upkeepNeeded, "Upkeep not needed");
                  if (!upkeepNeeded) {
                      revert Raffle__UpkeepNotNeeded(
                          address(this).balance,
                          s_players.length,
                          uint256(s_raffleState)
                      );
                  }
                  s_raffleState = RaffleState.CALCULATING;
                  uint256 requestId = i_vrfCoordinator.requestRandomWords(
                      i_gasLane,
                      i_subscriptionId,
                      REQUEST_CONFIRMATIONS,
                      i_callbackGasLimit,
                      NUM_WORDS
                  );
                  // Quiz... is this redundant?
                  emit RequestedRaffleWinner(requestId);
              }
          ```

          ### Conclusion

          By setting these functions in your contract, you can make your smart contracts more autonomous and efficient. Eliminating the need for manual interaction with your contracts enhances their performance greatly.

          Successfully compiling this script demonstrates how Chainlink automation can be adopted to automatically trigger our lottery. Consequently, we can entirely entrust Chainlink to do the heavy lifting of handling our raffle game schedules.

          <img src="/foundry-lottery/14-automation/auto1.png" style="width: 100%; height: auto;">
      -
        id: d02f2d11-7ac8-4346-bd99-3a8f3c419fd6
        type: new_lesson
        enabled: true
        title: 'Mid section recap'
        slug: lottery-mid-lesson-recap
        duration: 2
        video_url: 2smxFMZa6kaE6MwUBzDABlI01sJxD01JFL6UScbNx6zuI
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/15-mid-lesson-recap/+page.md
        description: "A recap of the progress in developing a fair and transparent lottery system using Chainlink's VRF. The lesson revisits key concepts like the raffle contract, buying into the raffle, and the decentralized draw process."
        markdown_content: |-
          ***

          ## title: Mid-Lesson Recap

          *Follow along with this lesson and watch the video below:*

          ***

          # Decoding our Smart Contract: A Dive into Chainlink VRF

          Congrats on making it this far! You're earning your stripes as a blockchain developer. Let's take a step back and review what you've accomplished so far, draft a roadmap for what's next, and allow the elegance of your well-written smart contract to sink in.

          )## The 'Raffle Contract' - Going Beyond Vanilla

          Your robust 'raffle contract' trusts Chainlink's VRF (Verifiable Random Function) to find its random number, ensuring fairness and opacity - the two pillars of any lottery system. Revealing the inner workings, you find a wealth of state variables and a detailed, attention-demanding constructor. Worth noting, this constructor is laying the groundwork for the rest of your smart contract.

          ## Buying into the Raffle & Ensuring FairPlay

          Then comes the 'enter raffle' function, which is instrumental in ticket purchasing while certifying that only players who have paid the appropriate entrance fee can enter, thus maintaining the sanctity of the game. Your players are then added to the list (array) of contestants who are a lucky draw away from the prize.

          After an adequate timeframe, the 'checkUpkeep' swings into action. Curious how it's signaled when to move? Stick with me! Once certain conditions are met, such as the elapsing of time and players entering the raffle, this function is invoked.

          ## The Decentralized Draw

          Here's where things heat up! If 'checkUpkeep' returns true - indicating that it's time for the lottery draw - Chainlink nodes, working in unison in a decentralized environment, will execute the 'perform upkeep' function, sparking a request to Chainlink.

          Now, it's time to wait a couple of blocks. Our VRF does need a moment to crunch those numbers, after all.

          ## Winner Announcement & Reset

          Once the Chainlink node responds, it triggers the `fulfillRandomness` function. This function embarks on the crucial task of choosing a random winner from our player array. Once the lucky winner is picked, the system resets for the next raffle.

          Boom! You've just completed your minimalistic, but provably fair smart contract. And even better, you've got a lottery system that runs on rock-solid principles of fairness.

          <img src="/foundry-lottery/15-recap/recap1.png" style="width: 100%; height: auto;">

          So grab yourself a coffee and take a breather, you've done great so far! We'll catch up soon, where we’ll walk through further fascinating aspects of blockchain technology. Not just fair, your code is a work of art - keep it coming!

          ## Next Steps and Interesting Reads

          In our next module, we'll delve deeper into more advanced blockchain concepts and how to improve upon our existing code. Trust me, the rabbit hole goes much, much deeper! Till then, here are some interesting reads to keep the ball rolling:

          * [Understanding ChainLink](https://www.chain.link)
          * [Blockchain and Its Many Uses](https://www.ibm.com/topics/blockchain)
          * [Smart Contracts: The How-To](https://ethereum.org/greeter)

          With this, we wrap up our journey through the 'Raffle Contract.' Here's to more code, more learning, and to building an efficient, fair lottery!
      -
        id: 0b490f27-ba53-435f-ac70-a67eb4fe0146
        type: new_lesson
        enabled: true
        title: 'Test and deploy the lottery smart contract pt.1'
        slug: tests-and-deploy
        duration: 8
        video_url: KuzEyLsQd0101Y61s1Uqk014UjS01VNRGxQToEPTUXLvWkU
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/16-tests-and-deploy/+page.md
        description: 'This lesson emphasizes the importance of testing and deploying smart contracts efficiently. It guides through creating deploy scripts and testing them on various networks, ensuring reliable and secure deployment of lottery contracts.'
        markdown_content: |-
          ***

          ## title: Test and Deploy Script

          *Follow along with this lesson and watch the video below:*

          ***

          Before we dive into writing tests to confirm the functionality and performance, We'd like to cover the need for additional getter functions which will make our code even more efficient. However, the main focus will be on developing sound, fail-safe test cases.

          ## Plan for Writing Test Cases

          Here's our comprehensive plan:

          1. Write deploy scripts
          2. Write tests that will work on a local chain, a forked testnet, and a forked mainnet in tandem with our deployment scripts.

          So, let's proceed without further ado!

          ## Writing the Deploy Script

          Let's start by creating our deploy script. To do this, simply go to scripts, create a new file and name it: `DeployRaffle.sol`. Here we will define our SPDX license identifier as MIT. We will need to import a script from `forge-std/Script.sol`.

          Remember to run a sanity check by building our contract in the terminal. We need to specify our compiler version (0.8.18 in this instance) using the pragma solidity directive for it to work perfectly!

          ```bash
          pragma solidity 0.8.18;
          ```

          <img src="/foundry-lottery/16-deploy/deploy1.png" style="width: 100%; height: auto;">

          ## Creating the Run Function

          We need to create a `run` function that will return our `Raffle` contract.

          ```js
          function run() external returns (Raffle, HelperConfig) {}
          ```

          ## Writing the Deployment Script

          When writing down the deployment script, it's important that we refer back to the `Raffle` contract parameters as they are vital to the process. These parameters include an entrance fee, interval, VRF coordinator, gas lane, subscription ID, and callback gas limit.

          As each of these parameters will vary depending on the chain used, a helper config file needs to be set up. This file will store these parameters, ensuring flexibility for deployment to any chain. Time to create a new file named: `Helperconfig.sol`.

          ## Creating the HelperConfig Contract

          In `Helperconfig.sol`, we'll create a `struct` called NetworkConfig. This struct will be populated with the parameters needed for each specific network we plan to deploy our protocol on - such as Sepolia and Anvil.

          ```shell
          contract HelperConfig is Script {
               struct NetworkConfig {
                  uint64 subscriptionId;
                  bytes32 gasLane;
                  uint256 automationUpdateInterval;
                  uint256 raffleEntranceFee;
                  uint32 callbackGasLimit;
                  address vrfCoordinatorV2;
                  address link;
                  uint256 deployerKey;
              }
          }
          ```

          ## Creating Network-Specific Config Functions

          For both Sepolia and Anvil, we'll define corresponding `get` functions, `getSepoliaETHConfig` and `getAnvilETHConfig`, which return network specific configurations.

          ```js
           function getSepoliaEthConfig()
                  public
                  view
                  returns (NetworkConfig memory sepoliaNetworkConfig)
              {
                  sepoliaNetworkConfig = NetworkConfig({
                      subscriptionId: 0, // If left as 0, our scripts will create one!
                      gasLane: 0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c,
                      automationUpdateInterval: 30, // 30 seconds
                      raffleEntranceFee: 0.01 ether,
                      callbackGasLimit: 500000, // 500,000 gas
                      vrfCoordinatorV2: 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625,
                      link: 0x779877A7B0D9E8603169DdbD7836e478b4624789,
                      deployerKey: vm.envUint("PRIVATE_KEY")
                  });
              }

          ```

          Remember, for the Anvil network, we'll be working with mocks, a kind of 'just-for-test' dummy data that emulates the behavior of real data. This makes the Anvil network a bit more involved, but equally as important.

          ## Conclusion

          The deployment of intelligent contracts has been simplified through the use of helper function configuration and smart deployment. The key is defining the correct network parameters for the chain of interest, and ensuring accurate deployment, as demonstrated with our Ethereum-based Raffle app. This process, although demanding, ensures that code deployment becomes seamless, regardless of the network chain used.

          Stay tuned to see how our test cases perform in different network environments!

          <img src="/foundry-lottery/16-deploy/deploy2.png" style="width: 100%; height: auto;">
      -
        id: 0abda7e1-6960-471e-9109-c23a26d116c1
        type: new_lesson
        enabled: true
        title: 'Deploy a mock Chainlink VRF'
        slug: deploy-mock-chainlink-vrf
        duration: 5
        video_url: MuYRDaCRlIrI7PEOv0102Ga4y4exZQayCO4gDVEYyCC64
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/17-mock-chainlink-vrf/+page.md
        description: 'The focus of this lesson is on deploying a mock Chainlink VRF, vital for testing smart contracts. It provides insights into setting up mock contracts, adjusting parameters, and the importance of Chainlink VRF in blockchain development.'
        markdown_content: |-
          ***

          ## title: Mock Chainlink VRF

          *Follow along with this lesson and watch the video below:*

          ***

          Greetings, everyone! If you've been following our journey so far, you may recall that we recently moved from creating and running code completely on a chain from scratch, like Sepolia, to trying it out on a forked testnet. Now, our exploration takes us further. The question before us today is -

          <img src="/foundry-lottery/17-mock/mock1.png" style="width: 100%; height: auto;">

          ## The Battle Preparations

          To start with, we need several different contracts. At the very least, we definitely need a VRF (Verifiable Random Function) Coordinator. So, let's dive in and see how we can deploy our own VRF Coordinator.

          In our Lib folder `chainLink-brownie-contracts/contracts/SRC/0.8`, we can start looking for this significant VRF code. This is where we'll find a treasure trove of mocks.

          ## Unveiling the Mocks

          In fact, there's a specific folder titled `VRFCoordinatorV2Mock` amongst these mocks. The brilliance here is that we can directly use this in our tests, instead of crafting one ourselves. Chainlink VRF has indeed done the job for us.

          Hence, let's exploit this VRF Coordinator v Two mock that is already in place. The next step in our process is to deploy this mock, which leads us to...

          ## Deploying the Mock

          We can find the import pathway in the location `@chainlink/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol`.

          With that, we are now equipped to deploy it using a ` vm.stopBroadcast();`. This is vital to deploy to any network.

          ## Constructor Parameters

          Delving into the VRF Coordinator, we are made aware that it requires two important parameters - a base fee and a gas price link. For all your Chainlink VRF interactions, payments are made in Chainlink tokens or link tokens. That is the fundamental principle we are operating upon here.

          The base fee encapsulates a flat fee, while the gas price link represents the amount of link tokens gained for each additional piece of gas you use. It is crucial to remember that when the Chainlink node calls back, the Chainlink node is responsible for the gas costs, and it gets reimbursed in link tokens, based on the gas price link parameter.

          ## Wrapping Up

          And voila! We’ve successfully set up a Sepolia config and an anvil config with our mock contracts. The primary variation between Sepolia and Anvil is the different VRF coordinator mocks. This might be a challenging venture if one is new to the crypto world, but with time, patience and a tutorial like this, it becomes more accessible. Tune in next time for more exciting exploration of decentralized digital wonders!

          Stay curious, stay knowledgeable and happy coding!
      -
        id: 6d7b200e-2f00-4f5a-93fc-c11051574b88
        type: new_lesson
        enabled: true
        title: 'Test and deploy the lottery smart contract pt.2'
        slug: tests-and-deploy-2
        duration: 9
        video_url: eHmqmBmVR00eZbLM01HdMOfvFbiw7HYTYPPQTokPakk7E
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/18-tests-and-deploy-2/+page.md
        description: 'Continuing from the previous part, this lesson dives deeper into testing and deploying lottery smart contracts. It covers the usage of helper configurations and the integration of network-specific configurations for smooth deployment.'
        markdown_content: |-
          ***

          ## title: Test and Deploy Continued

          *Follow along with this lesson and watch the video below:*

          ***

          ## The Helper Configurations

          Firstly, we need to import the helper configurations we previously made. We do this by adding:

          ```js
          import { HelperConfig } from "./HelperConfig.s.sol";
          ```

          Once we have the helper configurations in our workspace, we'll use them to deploy a new helper configuration. Here, we'll define `helperConfig` as a new instance of the HelperConfig class. Something like this:

          ```javascript
           HelperConfig helperConfig = new HelperConfig(); // This comes with our mocks!
          ```

          Once the helper configuration is created, we're going to need to pull parameters from it based on the active network config. Here's the interesting part: we'll be deconstructing the `networkConfig` object into underlying parameters. This means extracting individual pieces of information from the network configuration and assigning them to new variables in our current scope.

          The resulting code snippet looks like this:

          ```javascript
          (
              uint64 subscriptionId,
              bytes32 gasLane,
              uint256 automationUpdateInterval,
              uint256 raffleEntranceFee,
              uint32 callbackGasLimit,
              address vrfCoordinatorV2,
              address link,
              uint256 deployerKey
          ) = helperConfig.activeNetworkConfig();
          ```

          ## Starting The Virtual Machine Broadcast

          Now we have configured the helper configurations and deconstructed into smaller values. Now, we're ready to begin the virtual machine (VM) start broadcast.

          ```javascript
          VM.startBroadcast();
          ```

          The VM will begin by instantiating a new Raffle contract. Parameters for the new Raffle contract are passed to the constructor, in the exact order expected by the constructor. They include `entranceFee`, `interval`, `VRFCoordinator`, `gaslane`, etc.

          After the new Raffle contract is created, the virtual machine stops the broadcast.

          ```javascript
          VM.stopBroadcast();
          ```

          At this high level, the code should be good to go.

          ## The Subscription ID

          But we need to clarify one thing. You need a subscription ID. You can either get it from the user interface (UI) or generate it in your deployment script. Being a developer, I would prefer my script does everything for me. But of course, you can fetch it directly from the UI if that works better for you.

          However, we will pretend for now that this deployment script is working, even though it isn't, and begin writing unit tests.

          ## Writing Unit Tests

          Buckle up, because it's time to write some tests! We'll start by creating two directories - one for unit tests, and another for integration tests.

          Within our `unit_tests` directory, we'll create a new file `RaffleTest.t.sol`. This test file will include all of the necessary components for running a comprehensive test of our deployment script.

          The structure of the test function includes the set up for the test environment, calls the deployment script, and tests to ensure that important variables are outputted correctly.

          ```javascript
           function setUp() external {
                  DeployRaffle deployer = new DeployRaffle();
                  (raffle, helperConfig) = deployer.run();
                  vm.deal(PLAYER, STARTING_USER_BALANCE);

                  (
                      ,
                      gasLane,
                      automationUpdateInterval,
                      raffleEntranceFee,
                      callbackGasLimit,
                      vrfCoordinatorV2, // link
                      // deployerKey
                      ,

                  ) = helperConfig.activeNetworkConfig();
              }
          ```

          In addition, we want to create a starting player, with a distinct address and initial balance of 10 ETH, to interact with the Raffle contract.

          ```javascript
          address public PLAYER = makeAddr("player");
          uint256 public constant STARTING_USER_BALANCE = 10 ether;

          ```

          ## Checking The Deployment

          Lastly, we want to test our deployments. To do so, we need to get all our parameters from the HelperConfig. Best practice would be to return both the newly deployed Raffle and the HelperConfig variables. That way, our tests have access to the exact same variables that were inputted during the Raffle's deployment.

          <img src="/foundry-lottery/18-test/test1.png" style="width: 100%; height: auto;">

          ## Sanity Check

          Finally, let's run a quick sanity test to ensure that our raffle initializes in the `open` state. This can be done with a simple function that asserts that the state of the Raffle contract is `open`.

          Aside from confirming the successful deployment of our Raffle contract, this test will also help verify that our HelperConfig and deployment script are working as expected.

          Here's what the function looks like:

          ```javascript
           function testRaffleInitializesInOpenState() public view {
                  assert(raffle.getRaffleState() == Raffle.RaffleState.OPEN);
              }
          ```

          Congratulations! We've successfully written our deployment script and unit test. Now we can run our test suite and confidently deploy contracts on any specific networks, thanks to our HelperConfig configuration. Well done and stay tuned for the next post in our series!
      -
        id: 7be9d513-2092-4406-8eff-045e1589265c
        type: new_lesson
        enabled: true
        title: 'Setup the tests'
        slug: setup-solidity-lottery-tests
        duration: 5
        video_url: OLcOrSfV5kT8Toysnub1chy8DhqQrCQ8ZbegkS8sXGo
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/19-lots-of-tests/+page.md
        description: 'This lesson teaches the setup and execution of tests for smart contracts, emphasizing the significance of forge coverage and the Arrange-Act-Assert methodology to ensure robust and reliable smart contract functionality.'
        markdown_content: |-
          ***

          ## title: Lots of Tests

          *Follow along with this lesson and watch the video below:*

          ***

          Let's shift our focus towards a programmatic approach to software development. One of the best ways to write robust, reliable code begins with writing some solid tests for it. At this point in your development journey, you may be thinking, "Where do I start?" Let's dive into creating tests with forge coverage.

          Before starting, it's worth mentioning that coverage isn't the be-all and end-all of software testing, but the more you practice writing tests, the better your software will be. Along the way, you'll also pick up nifty tips and tricks that will help you write better code and better tests.

          ## Start with Simple Test: Validate `EnterRaffle` Function

          As an initial step, we'll start with creating tests for the `EnterRaffle` function.

          ```javascript
          function enterRaffle() public payable {...}
          ```

          Here is how we create a basic test:

          ```javascript
             function testRaffleRevertsWHenYouDontPayEnought() public {
                  // Arrange
                  vm.prank(PLAYER);
                  // Act / Assert
                  vm.expectRevert(Raffle.Raffle__SendMoreToEnterRaffle.selector);
                  raffle.enterRaffle();
              }
          ```

          The name of the method here explains the test’s aim–to verify whether entering a raffle without sufficient payment results in an error. This test follows the Arrange-Act-Assert methodology.

          ## Arrange-Act-Assert: A Closer Look

          Although it isn't necessary to type out 'Arrange-Act-Assert' every time you write a test, it cannot be overstated how crucial this concept is to write effective tests.

          1. **Arrange**: This section sets up the necessary conditions for the test. In this case, it involves setting up a scenario where a user tries to enter the raffle without paying enough.
          2. **Act**: We enact the circumstance we are testing– in this case, trying to access the raffle without the necessary funds.
          3. **Assert**: The assert phase is where your tests confirm if the actual result meets the expected outcome.

          <img src="/foundry-lottery/19-testing/testing1.png" style="width: 100%; height: auto;">

          ## Running the Test

          To test this function, run the command `forge test -m "[Title of your test]"`. If written correctly, the test should pass.

          <img src="/foundry-lottery/19-testing/testing2.png" style="width: 100%; height: auto;">

          ## Further Testing: Record Player Entrance

          Another essential aspect to test is if our `players` array is being updated whenever a player enters the raffle successfully.

          ```javascript
           function testRaffleRecordsPlayerWhenTheyEnter() public {
                  // Arrange
                  vm.prank(PLAYER);
                  // Act
                  raffle.enterRaffle{value: raffleEntranceFee}();
                  // Assert
                  address playerRecorded = raffle.getPlayer(0);
                  assert(playerRecorded == PLAYER);
              }
          ```

          Similar to our first test, we create a scenario where a player enters the raffle and pays the required fee. The expected outcome would be that the `players` array records the player's address. However, since there is no way to access the `players` array as it is, we need to add an accessor function named `getPlayer`.

          ```javascript
              function getPlayer(uint256 index) public view returns (address) {
                  return s_players[index];
              }
          ```

          This function allows us by giving the index number of the player we want to get.

          The final step would be to add the assertion which would verify if the `players` array recorded the player in the index we specified.

          Remember to run the `forge test -m "[Title of your test]"` command to check if your test passes.

          Using these foundational principles, we're well on our way to creating a battery of tests.

          Stay tuned for our upcoming posts where we'll dive deeper into writing more sophisticated tests for different scenarios, learning about function selectors and more. Happy testing!
      -
        id: 5dda3821-5257-4e10-8980-e5e97370ea15
        type: new_lesson
        enabled: true
        title: 'Testing events'
        slug: testing-events-solidity
        duration: 4
        video_url: vkNjl2gTMOPogRh6FUPXK026D2XXbK01z1cn700SBnaZ5g
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/20-testing-events/+page.md
        description: 'A detailed guide on testing events emitted by smart contracts, highlighting the use of Foundry''s \`expectEmit\` function. The lesson focuses on ensuring correct event emissions, crucial for smart contract validation.'
        markdown_content: |-
          ***

          ## title: Testing Events

          *Follow along with this lesson and watch the video below:*

          ***

          As developers, it's essential to be thorough in our testing process, especially when developing smart contracts. Recently, I (Patrick) found myself pondering, "What else do we need to test?" After testing several lines within my code, it struck me! Testing the events emitted by functions; an important but often overlooked area of smart contract testing.

          In Immutable Foundries, this can be a bit tricky, so today, let's conquer this vital frontier of blockchain development! Let's delve deep into our code cavern to ensure that our contract is emitting the correct events at the right time.

          ## Triggering Events: The Expect Emit Function

          Testing smart contract event emissions in Foundry involves this secret maneuver I call *the cheat code*; named as such because it manipulates the runtime environment to accomplish our mission. It's a neat trick provided to us by Foundry's Virtual Machine, and it's called `expectEmit`.

          This `expectEmit` function takes a few parameters:

          * A collection of Booleans that represent your indexed parameters (also known as topics in solidity event emissions).
          * Check data, usually checked Boolean values.
          * The address of the emitter (smart contract).

          The function works as follows:

          ```javascript
                function testEmitsEventOnEntrance() public {
                  // Arrange
                  vm.prank(PLAYER);

                  // Act / Assert
                  vm.expectEmit(true, false, false, false, address(raffle));
                  emit RaffleEnter(PLAYER);
                  raffle.enterRaffle{value: raffleEntranceFee}();
              }
          ```

          * We declare that we expect a certain emit to match the parameters provided. This declaration flags the next instantiation of the function we’re about to run to emit an event.
          * Following the expectEmit declaration, we run the function that should cause the event emission.
          * We're saying "this next emit that I do manually; I expect that to happen in this upcoming transaction."

          <img src="/foundry-lottery/20-events/event1.png" style="width: 100%; height: auto;">

          This declaration should look like this:

          ```javascript
          vm.expectEmit(true, false, false, false, address(raffle));
          ```

          The `vm.expectEmit` contains:

          * One `true`, signifying one indexed parameter or topic present in the event.
          * Following three `false`', indicating there are no additional parameters.
          * The address of the smart contract is `address(raffle)`.

          ## Emulating Events in Tests: Redefine Them

          As smooth as the `expectEmit` function makes the testing process, the inconvenience is the necessity to redefine events in our tests. Events in Solidity are not like enums or structures. We can't import them frugally across our application.

          Instead, we have to redefine these events within our individual tests.

          ```javascript
               modifier raffleEntered() {
                  vm.prank(PLAYER);
                  raffle.enterRaffle{value: raffleEntranceFee}();
                  vm.warp(block.timestamp + automationUpdateInterval + 1);
                  vm.roll(block.number + 1);
                  _;
              }
          ```

          After redifining the contract event, you emit it manually with correct parameters and proceed to call the function that you expect will emit such an event during a transaction.

          Finally, after setting up our test function with the VM prank, supplying transaction parameters, and redefining the event, we can proceed to run the test.

          ```bash
              forge test -m <function name>
          ```

          And Voila! Now you have a thorough test for your event emissions, increasing the robustness of your smart contract. Don't skip this step in your tests. Event emission testing not only ensures correct data transaction but also achieves an effective means of logging and monitoring data flow during runtime. Happy coding!
      -
        id: 09041b73-1723-40e6-b3fa-5f5907280e23
        type: new_lesson
        enabled: true
        title: 'Using vm.roll and vm.wrap'
        slug: vm-roll-warp
        duration: 3
        video_url: 9GeLpylCMZTVr2MpUvq28ARV8QmIXqYs0078WbflxoOI
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/21-vm-roll-warp/+page.md
        description: 'Exploring the use of \`vm.roll\` and \`vm.wrap\` in smart contract testing, this lesson demonstrates how to adjust block time and number for testing various states and transitions in smart contracts.'
        markdown_content: |-
          ***

          ## title: VM.Roll adn VM.Warp

          *Follow along with this lesson and watch the video below:*

          ***

          After successfully entering the raffle, the next step involves kicking off a 'perform upkeep'. This function changes the state of the raffle to ‘calculating’. To do this, the 'checkUpkeep' function will have to return a value of true.

          Enough time must pass for this state transition to occur. In the context of working on a forked or local blockchain chain, things become interesting, and slightly tricky. On these chains, it's possible to modify the block time and block number. This can be achieved using the cheat codes 'VM warp' and 'VM roll'.

          **Adjusting the Block Time**

          ```shell
          vm.warp(block.timestamp + automationUpdateInterval + 1);
          ```

          **Modifying the Block Number**

          ```shell
          vm.roll(block.number + 1);
          ```

          In the above code, 'VM warp' sets the block timestamp, while 'VM roll' modifies the block number. By adding '1' to each of these instances, the bonus block in the test ensures that the required time exceeds the interval.

          However, an important note: **Remember to always pass some empty data while calling 'performUpkeep'**.

          ```shell
          raffle.performUpkeep("");
          ```

          ## Testing the Calculating State

          At this stage, the raffle should now be in the calculating state, so attempts to enter the raffle should fail. This can be simulated through the 'expect revert' function which expects the new attempt to join the raffle to be rejected by the contract.

          ```shell
          vm.expectRevert(Raffle.Raffle__RaffleNotOpen.selector);
          ```

          To test this, we'll be pranking the player with the next real call to revert. This can be achieved by invoking 'VM Prank Player' with the next real call to the raffle's 'enter' function.

          ```shell
          vm.prank(PLAYER);
          ```

          ## Takeaways

          Testing your smart contracts allows you to uncover potential bugs or loopholes in your code. Leveraging local blockchains provides an advantage of tweaking parameters like block time and number. Remember to be patient and thorough in your process, as this improves the reliability of the contracts you write. Happy testing!
      -
        id: 336dea6a-f38c-4e01-9845-d1551f1325fa
        type: new_lesson
        enabled: true
        title: 'Subscribing to events'
        slug: create-subscriptions
        duration: 12
        video_url: c2w6l7tvIq156PgpNHlJCABsU6Q2Z4u1ygPVf2UGvyE
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/22-create-subscriptions/+page.md
        description: 'This lesson covers the process of deploying contracts, creating, and managing Chainlink VRF subscriptions. It focuses on resolving common errors and efficiently managing Chainlink VRF in smart contracts.'
        markdown_content: |-
          ***

          ## title: Create Subscriptions

          *Follow along with this lesson and watch the video below:*

          ***

          Have you ever encountered an `invalid consumer error` while deploying your raffle contracts using Chainlink VRF? Maybe you aren't familiar with the subscription model that Chainlink VRF uses, or perhaps you're uncertain about testing your contract. In this post, we'll guide you through the process of deploying raffle contracts, creating and funding a subscription, and adding a raffle contract as a consumer to the subscription.

          By the end of this tutorial, you should be able to handle Chainlink VRF deployment with confidence. Let's dive right in!

          ## Debugging: Invalid Consumer Error

          Let's start by adding some variables to see what's causing the problem. After adding five variables, we encountered an `invalid consumer error` on our VRF Coordinator mock. On opening the `VRFCoordinatorV2Mock.sol` file, we discovered a modifier named `only valid consumer`.

          This modifier only allows operations if a consumer is added. This requirement hints at the subscription model that Chainlink VRF uses.

          Here’s a brief overview of the Chainlink VRF subscription model. When working with it, you'll need to follow these steps:

          1. Create a subscription
          2. Fund the subscription
          3. Add the raffle contract as a consumer to the subscription

          The subscription model prevents random people from using your subscription. We learned this process by watching a video walkthrough that demonstrates how to perform all these steps via UI.

          ## Improving the Deployment Script

          Our existing deployment script needs to ensure a valid subscription upon deployment. Each raffle contract we deploy needs to be added as a consumer to our subscription. On a real test network (testnet), we can perform these operations in the UI. However, for testing purposes, we need to do this programmatically.

          Rather than tweaking the VRF Coordinator mock to automatically add a consumer, we opted for a more thorough solution. Refactoring our `DeployRaffle.s.sol` script allows us to run tests to simulate real usage. We're going to implement this process step-by-step below.

          ## Refactoring to Create Subscription

          The first change we make is to check the subscription ID. If it's absent or defaults to zero, calls to the function won't go through. We need a valid subscription ID from the helper configuration or from creating a new subscription manually.

          The script below can identify whether we have a subscription ID or not:

          ```javascript
           if (subscriptionId == 0) {
                      CreateSubscription createSubscription = new CreateSubscription();
                      subscriptionId = createSubscription.createSubscription(
                          vrfCoordinatorV2,
                          deployerKey
                      );

                      FundSubscription fundSubscription = new FundSubscription();
                      fundSubscription.fundSubscription(
                          vrfCoordinatorV2,
                          subscriptionId,
                          link,
                          deployerKey
                      );
                  }
          ```

          The rest of the `DeployRaffle.s.sol` script will be housed in the `Interactions.s.so` contract, which includes a `createSubscription` function:

          ```javascript
           function createSubscription(
                  address vrfCoordinatorV2,
                  uint256 deployerKey
              ) public returns (uint64) {
                  console.log("Creating subscription on chainId: ", block.chainid);
                  vm.startBroadcast(deployerKey);
                  uint64 subId = VRFCoordinatorV2Mock(vrfCoordinatorV2)
                      .createSubscription();
                  vm.stopBroadcast();
                  console.log("Your subscription Id is: ", subId);
                  console.log("Please update the subscriptionId in HelperConfig.s.sol");
                  return subId;
              }
          ```

          For the `createSubscription` function, we'll be using the helper `config` to get the `VRF Coordinator` address, allowing us to create the subscription.

          To call the `CreateSubscription` function, we use a `broadcast`. This action calls the `createSubscription` function on the `VRFCoordinator` mock:

          ```javascript
          CreateSubscription createSubscription = new CreateSubscription();
          subscriptionId = createSubscription.createSubscription(
              vrfCoordinatorV2,
              deployerKey
          );
          ```

          <img src="/foundry-lottery/22-subscriptions/subscription1.png" style="width: 100%; height: auto;">
      -
        id: 588706e2-4bd4-4f14-863f-e8b666222610
        type: new_lesson
        enabled: true
        title: 'Creating the subscription UI'
        slug: subscription-ui
        duration: 4
        video_url: TscJ5iTt9kMRbyHQUxd8td1N3DIbjx1UcKzo88wYecg
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/23-subscription-ui/+page.md
        description: 'A guide to creating and managing front-end subscriptions for Ethereum Blockchain, this lesson covers steps from transaction initiation to automatic link token funding, emphasizing user interface interactions.'
        markdown_content: |-
          ***

          ## title: Create Subscription UI

          *Follow along with this lesson and watch the video below:*

          ***

          One of the crucial aspects of developing on the Ethereum Blockchain is to harness the power of front-end subscriptions. In the course of this guide, we'll take you through creating and funding a subscription, even on the testnet.

          This might entail a considerable waiting time, courtesy of the testnets. However, we'll make the wait worth your while by diving deep into each step until you achieve automatic link token funding.

          ## Creating a Subscription

          Whether you're a newbie or a seasoned coder, running transactions in the front end can be a rewarding and exciting task. Here’s how I go about it:

          ```markdown
          Approve transaction > Calling Create Subscription > Await creation > View transaction
          ```

          When you complete this transaction, you can then create a subscription with a unique ID. This ID becomes handy when you're about to add to your helper config or run your script.

          Often you'd remark:

          <img src="/foundry-lottery/23-subscription-ui/subs1.png" style="width: 100%; height: auto;">

          ## Funding Your Subscription

          Now that you have your subscription, it’s time to get some Link tokens under your belt! Here's how you can do it:

          1. Initiate **Actions** > **Fund Subscription**.
          2. Ensure you have the Link in your wallet. If not, head over to the Faucets Chain Link.
          3. Select the number of links you'd like to acquire, I recommend 20 test links for a start.
          4. Confirm you're not a bot and input your address.
          5. Send the request and wait for the popup notification confirming your request.

          <img src="/foundry-lottery/23-subscription-ui/subs2.png" style="width: 100%; height: auto;">

          Once you've covered these steps, you'll receive the tokens in your wallet. But remember, certain tokens like ERC20 and ERC677 don't automatically show in your MetaMask wallet.

          <img src="/foundry-lottery/23-subscription-ui/subs3.png" style="width: 100%; height: auto;">

          ## Adding Tokens to MetaMask

          After refreshing your UI, you should see your active subscription. However, to see your tokens, you need to add them to your MetaMask. You can do this in a few steps:

          1. Navigate to **Docs chain link > Get Started > Link Token Contracts > Sepolia Testnet.**
          2. Copy the address or click **Add to Wallet** to instruct your MetaMask to import these tokens.
          3. Hit **Import Tokens** > **Paste address** > **Add custom tokens** > **Import tokens**.

          <img src="/foundry-lottery/23-subscription-ui/subs4.png" style="width: 100%; height: auto;">

          See how simply you added Sepolia ETH and Abraham Lincoln? Now you have your tokens imported to MetaMask and are ready to fund your subscription.

          ## Transferring Your Tokens

          With your loaded MetaMask wallet, you can transfer funds to your subscription. Here’s how you can do it:

          1. Initiate **Actions** > **Fund Subscription**.
          2. Specify the numbers of links you want to transfer.
          3. Confirm your transaction.

          <img src="/foundry-lottery/23-subscription-ui/subs5.png" style="width: 100%; height: auto;">

          Interesting to note here is that the function prompted in this process is not on your VR app but on the Link Token contract. We're actually transferring tokens to a subscriptions contract and using the 'Transfer and Call' function on our contract to do so.

          ## Conclusion

          While this guide didn’t actually call the function, it's imperative to highlight that a balance of zero is absolutely alright. In fact, we'll cover adding Link to your ID in Solidity in the next lessons. Until then, remember:

          <img src="/foundry-lottery/23-subscription-ui/subs6.png" style="width: 100%; height: auto;">

          Keep experimenting, keep learning!
      -
        id: 73f1f9fb-9394-4e32-bb6d-e06009e3babc
        type: new_lesson
        enabled: true
        title: 'Fund subscription'
        slug: fund-subscription
        duration: 13
        video_url: 1k5LnDMqdReQBO58OPYO7MrQAm7Pn01VYUuW7DbGEx6k
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/24-fund-subscription/+page.md
        description: 'This lesson teaches how to create and execute a contract script to fund blockchain subscriptions, detailing the parameters needed and the process of funding subscriptions using mock functions.'
        markdown_content: |-
          ***

          ## title: Fund Subscriptions

          *Follow along with this lesson and watch the video below:*

          ***

          ## Creating a New Contract

          First things first. Head over to the Interactions section, and create a new contract, named `FundSubscription`. This contract script, residing within `interactions.s.sol`, will allow you to select an amount and fund your subscription.

          Remember, the amount has to be a `uint96` , but let's keep things simple for now and set a public constant `FUND_AMOUNT` to three ether.

          ```js
          uint96 public constant FUND_AMOUNT = 3 ether;
          ```

          ## Setting the Parameters

          To fund your subscription, you will need three important elements:

          * Subscription ID
          * VRF Coordinator V2 address
          * Link address


          > UPDATE: on the recent versions of Chainlink VRF, the subscription ID is a uint256 instead of a uint64.

          Refer to the latest [GitHub Repo](https://github.com/Cyfrin/foundry-smart-contract-lottery-f23/blob/d106fe245e0e44239dae2479b63545351ed1236a/src/Raffle.sol#L54) changes on the `Raffle.sol` contract.

          Start by specifying the `VRFCoordinator` address and the `uint64` `subId`. The `subID` corresponds to the subscription you want to fund.

          ```js
          HelperConfig helperConfig = new HelperConfig();
                  (
                      uint64 subId,
                      ,
                      ,
                      ,
                      ,
                      address vrfCoordinatorV2,
                      address link,
                      uint256 deployerKey
                  ) = helperConfig.activeNetworkConfig();
          ```

          For these configurations, you'll use the already existing `HelperConfig.s.sol`. However, you'll notice, it doesn't yet include a link token. Adding a link token will facilitate funding the subscription as it forms the basis of the contract call.

          The link tokens for Sepolia already exist, and they can be easily found and added.

          Next, for Anvil, you'll need to deploy a mock link token. To ease the process, simply rewrite the link contract for a newer version of Solidity. This can be easily done using my Foundry smart contract lottery F23.

          ## Funding the Subscription

          Now that the `link_address` is ready, go back to your interactions and create a new function named `fund_subscription`. The function should have three inputs: `VRF_Coordinator`, `sub_ID`, and `link`.

          ```js
          contract FundSubscription is Script {
              uint96 public constant FUND_AMOUNT = 3 ether;

              function fundSubscriptionUsingConfig() public {
                  HelperConfig helperConfig = new HelperConfig();
                  (
                      uint64 subId,
                      ,
                      ,
                      ,
                      ,
                      address vrfCoordinatorV2,
                      address link,
                      uint256 deployerKey
                  ) = helperConfig.activeNetworkConfig();
                  fundSubscription(vrfCoordinatorV2, subId, link, deployerKey);
              }
          ```

          This function works in much the same way as the front-end does to fund subscriptions. However, remember that the VRF Coordinator Mock interacts with the link token transfers in a different way than the actual contract, hence the mock's funding subscription mechanism is different.

          When you're testing your code on your local chain, you can call the `VM_Start_Broadcast` function before and `VM_Stop_Broadcast` function after the line of code which contains the `fundSubscriptionUsingConfig` method.

          ```js
          if (subscriptionId == 0) {
                      CreateSubscription createSubscription = new CreateSubscription();
                      subscriptionId = createSubscription.createSubscription(
                          vrfCoordinatorV2,
                          deployerKey
                      );

                      FundSubscription fundSubscription = new FundSubscription();
                      fundSubscription.fundSubscription(
                          vrfCoordinatorV2,
                          subscriptionId,
                          link,
                          deployerKey
                      );
                  }

          ```

          Finally, compile all the contracts using forge build. If everything compiles successfully, your contract has been created and is ready to perform transactions!

          ## A Final Comment

          The above steps outline a process whereby you can automate the process of funding blockchain-based subscriptions. Remember, this is not the final product, but an intermediary step in the development of a blockchain-based subscription service. Please do not use this code in a production environment without further testing and validation.

          Remember, it's always better to test your code in a secure environment before deploying it. The world of coding is vast, and there's so much more to explore. Happy coding!
        updates:
          -
            id: lvzqaohr
            title: 'Changes on Chainlink VRF response'
            description: |-
              > UPDATE: on the recent versions of Chainlink VRF, the subscription ID is a uint256 instead of a uint64.


              Refer to the latest [GitHub Repo](https://github.com/Cyfrin/foundry-smart-contract-lottery-f23/blob/d106fe245e0e44239dae2479b63545351ed1236a/src/Raffle.sol#L54) changes on the `Raffle.sol` contract.
            updated_at: '2024-05-09'
            type: new_set
            enabled: true
      -
        id: f29c650a-74b8-4a00-8fb2-b3aa5b81c732
        type: new_lesson
        enabled: true
        title: 'Adding a consumer'
        slug: add-consumer
        duration: 10
        video_url: QGsT102y00B9rDAzkUNB00iu6ncciF7SeRpNo83naAcH7Y
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/25-add-consumer/+page.md
        description: 'Focusing on adding a consumer to a subscription, this lesson explains the process of adding a consumer contract to a Chainlink VRF subscription, using scripting to simplify the deployment and management.'
        markdown_content: |-
          ***

          ## title: Add Consumer

          *Follow along with this lesson and watch the video below:*

          ***

          ## Adding the Consumer

          We can execute code snippets similar to the ones we used earlier while adding the consumer.

          ```shell
          contract AddConsumer is Script {}}
          ```

          To add a consumer, we need to write the `addConsumer` function, which will do most of the operations we've previously executed.

          ```javascript
          function addConsumer(
                  address contractToAddToVrf,
                  address vrfCoordinator,
                  uint64 subId,
                  uint256 deployerKey
              ) public {
                  console.log("Adding consumer contract: ", contractToAddToVrf);
                  console.log("Using vrfCoordinator: ", vrfCoordinator);
                  console.log("On ChainID: ", block.chainid);
                  vm.startBroadcast(deployerKey);
                  VRFCoordinatorV2Mock(vrfCoordinator).addConsumer(
                      subId,
                      contractToAddToVrf
                  );
                  vm.stopBroadcast();
              }
          ```

          Now we can create a function to create a consumer based on the config like this:

          ```js
           function addConsumerUsingConfig(address mostRecentlyDeployed) public {
                  HelperConfig helperConfig = new HelperConfig();
                  (
                      uint64 subId,
                      ,
                      ,
                      ,
                      ,
                      address vrfCoordinatorV2,
                      ,
                      uint256 deployerKey
                  ) = helperConfig.activeNetworkConfig();
                  addConsumer(mostRecentlyDeployed, vrfCoordinatorV2, subId, deployerKey);
              }
          ```

          This function calls the `addConsumer` function using the subscription ID and the address of the raffle contract. The subscription ID is retrieved from the config while the contract address is passed directly to the function.

          ## Testing the Script

          Now comes the most awaited part - testing our creation! And guess what? It passes with flying colors!

          It's such a thrill to see our creation fare so well. And the best part? We no longer require any manual inputs or interactions with the UI. We've reduced the entire contract deployment and management to just one command. Brilliant, isn't it?

          <img src="/foundry-lottery/25-consumer/consumer1.png" style="width: 100%; height: auto;">

          ## On a Concluding Note

          Kudos on keeping up with this journey! Done for the day and might be feeling overwhelmed at the volume of data thrown at you? Feel free to take a well-earned break.

          Remember to savor the win. Pull yourself a pint of ice cream or some sushi, my personal favourite. Come back when your mind is fresh, open and ready to tackle the next set of challenges.

          Here's a virtual tap on the back for making it this far. Your effort is really commendable. Keep up the good work and remember to take care of your "giant muscle" that is your brain. Don't hesitate to voice your doubts either to your AI buddy or the discussions forum. And remember -

          <img src="/foundry-lottery/25-consumer/consumer2.png" style="width: 100%; height: auto;">

          See you soon, folks! Keep your queries coming and the enthusiasm flowing.
      -
        id: c3314def-303b-4994-ac86-0999bf5b7b2f
        type: new_lesson
        enabled: true
        title: 'Adding more tests'
        slug: more-tests
        duration: 7
        video_url: OIMXUhKy6edbKXTIg1xVxuGTKFUgVMWfCSQMVrAXMQ4
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/26-more-tests/+page.md
        description: 'A continuation of developing comprehensive tests for smart contracts, this lesson focuses on enhancing code coverage and efficiency in testing, particularly for the \`check upkeep\` function.'
        markdown_content: |-
          ***

          ## title: More Tests

          *Follow along with this lesson and watch the video below:*

          ***

          Alright, welcome back! Let's dive right into writing tests for our smart contracts with an emphasis on code coverage and efficiency. Hope you had a little break because, remember, breaks are essential for productivity and focus. Let's continue with our mission to enhance our test coverage.

          Running `forge coverage` produces somewhat less-than-satisfactory results. So we need to push on and try to ramp up our coverage.

          ## Check Upkeep Tests

          First up on our list is the `check upkeep` function from the raffle contract. This crucial method oversees the contract's health, and it's time that we provide solid tests for it. To start, do a bunch of slashes followed by `check upkeep` just to keep things tidy!

          Remember, we have numerous scenarios to verify for the `check upkeep` function. For example, the method should return false if the contract lacks a balance, isn't open, or when enough time hasn't passed.

          ### Scenario I: Test Check Upkeep Returns False When Contract Has No Balance

          ```js
          function testCheckUpkeepReturnsFalseIfItHasNoBalance() public {
                  // Arrange
                  vm.warp(block.timestamp + automationUpdateInterval + 1);
                  vm.roll(block.number + 1);

                  // Act
                  (bool upkeepNeeded, ) = raffle.checkUpkeep("");

                  // Assert
                  assert(!upkeepNeeded);
              }
          ```

          In this particular test, we're mainly focused on the scenario where the contract doesn't have a balance. We're ensuring that all other conditions are met and verifying that lacking balance results in the function returning false.

          We arrange our test by ensuring that sufficient time has passed by implementing `VM.warp` with the current `block.timestamp`, increased by the `interval`, then some and carry out `VM.roll` with `block.number + 1`.

          The act section employs the `checkUpkeep` method and assigns the result to the `upkeep_needed` variable. Finally, we assert that not `upkeep_needed` equals true, confirming that the function returns false in this scenario.

          ### Scenario II: Test Check Upkeep Returns False When Raffle Isn't Open

          ```js
          function testCheckUpkeepReturnsFalseIfRaffleIsntOpen() public {
                  // Arrange
                  vm.prank(PLAYER);
                  raffle.enterRaffle{value: raffleEntranceFee}();
                  vm.warp(block.timestamp + automationUpdateInterval + 1);
                  vm.roll(block.number + 1);
                  raffle.performUpkeep("");
                  Raffle.RaffleState raffleState = raffle.getRaffleState();
                  // Act
                  (bool upkeepNeeded, ) = raffle.checkUpkeep("");
                  // Assert
                  assert(raffleState == Raffle.RaffleState.CALCULATING);
                  assert(upkeepNeeded == false);
              }
          ```

          The second scenario we're testing looks at the situation where the raffle isn't open. We arrange this by first entering the raffle with a stipulated entrance fee, after pretending to be the player with `VM.frank(player)`. We then kick off `performUpkeep` to initiate the calculating mode. Our function should return false at this point because the raffle is in the calculating state.

          Once again, the `act` section involves running the `checkUpkeep` method, and we use `assert(upkeepNeeded == false);` or `assert not upkeep_needed` to confirm our expectation in the `assert` section.

          ### More Tests and Debug Mode

          We still have more tests to write, and to get a clearer idea of the coverage required; consider running `forge coverage` in debug mode. This command will generate an output telling you exactly which lines haven't been covered.

          ```bash
          forge coverage --report debug > coverage.txt


          ```

          By outputting the report into a file called `coverage.txt`, we can then review the generated report. This output details the precise lines of code not covered for each section.

          ## Challenge

          Now that you're well-versed in the dynamics of testing for contract health, I challenge you to write two more tests:

          1. `function testCheckUpkeepReturnsFalseIfEnoughTimeHasntPassed`: This checks if enough time has passed before performing assertions.

          Feel free to compare these tests with the ones available on the linked GitHub repository for this course. Happy testing!
      -
        id: 6b573f84-8ab8-4eec-881f-c0d71cf12ca9
        type: new_lesson
        enabled: true
        title: 'Testing and refactoring the performUpkeep'
        slug: test-and-refactor-perform-upkeep
        duration: 5
        video_url: fhrhDlr9zhguGrNMuLSyr101mMMARv02q9yasYvN9YrV8
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/27-perform-upkeep/+page.md
        description: 'This lesson delves into writing tests for the \`performUpkeep\` function, emphasizing the need for thorough testing and refactoring to ensure the reliability and efficiency of smart contracts.'
        markdown_content: |-
          ***

          ## title: Perform Upkeep

          *Follow along with this lesson and watch the video below:*

          ***

          Today we'll be specifically digging into `PerformUpkeep` tests. Writing and testing functions within your code are vital to a healthy codebase. This post will walk you through the process, step-by-step, using JavaScript, making sure to cover every detail the original transcript provides.

          ## Function Test: `Perform Upkeep` can only run if `check upkeep` is true

          Our journey starts with the function test `Perform Upkeep can only run if check upkeep is true`. Here's how you should go about it:

          ```javascript
          function testPerformUpkeepCanOnlyRunIfCheckUpkeepIsTrue() public {
                  // Arrange
                  vm.prank(PLAYER);
                  raffle.enterRaffle{value: raffleEntranceFee}();
                  vm.warp(block.timestamp + automationUpdateInterval + 1);
                  vm.roll(block.number + 1);

                  // Act / Assert
                  // It doesnt revert
                  raffle.performUpkeep("");
              }
          ```

          To validate this function, you simply need to run it since, in Foundry, there's no `expect not revert`. Thus, if the transaction doesn't revert, the test is considered to be passed. Here's how:

          ```shell
          forge test -m testPerformUpkeepCanOnlyRunIfCheckUpkeepIsTrue
          ```

          If everything is set correctly, your test will pass. If for example, some parameters were commented out, it would inevitably fail because the `Perform upkeep` would fail. This prompts an error message stating 'Raffle upkeep not needed'.

          <img src="/foundry-lottery/27-upkeep/upkeep1.png" style="width: 100%; height: auto;">

          The completion of these steps has yielded a well-rounded test that allows you to screen for potential errors. To run this final version, you need to open your terminal and run the following command:

          ```shell
          forge test -m [paste your function here]
          ```

          Our programming journey, although complex, is also exciting. Stride forward with confidence, knowing that every error is a stepping stone to more robust code.
      -
        id: 63c994b2-6e8e-4c73-ab50-1b4ec593c5c1
        type: new_lesson
        enabled: true
        title: 'Refactoring events data'
        slug: event-data
        duration: 9
        video_url: KRsJQ7Djvo2KWlCBjZ3Xa02gw4lijeN8SEoi01KF02VecI
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/28-event-data/+page.md
        description: 'A guide to refining the use of emitted events in smart contracts, this lesson covers extracting and utilizing event data, with a focus on testing and improving code efficiency.'
        markdown_content: |-
          ***

          ## title: Getting Event Data Into Foundry

          *Follow along with this lesson and watch the video below:*

          ***

          ## Part 1: Emit - Necessary or Redundant?

          Consider this situation: We have a function, `performUpkeep`, and we want to learn more about it by giving it an extra emit. We'll write an event `requestedRaffleWinner`. This event will get emitted when we call the `performUpkeep` function, with an associated variable, Request ID.

          But wait, is this redundant?

          The way to find out if this is redundant or necessary is by checking our existing contract. We'll look up the `VRFCoordinatorMock` function and search for `requestRandomWords`. If there is an event `randomWordsRequested` which already includes the 'Request ID', then emitting the Request ID again would indeed be redundant.

          However, in this article, we'll follow through with the redundancy to simplify our testing process.

          <img src="/foundry-lottery/28-event-data/eventdata1.png" style="width: 100%; height: auto;">

          Even though this might seem like lousy form, retreading this process is crucial, especially when we test for outputs from events. A prime example is the ChainlinkVRF, which functions by listening to this event that gets emitted.

          ## Part 2: Writing Tests and Refactoring

          Now that we've covered the grounds, let's head straight into writing test cases for `Perform Upkeep` and refactor some parts of our code to improve efficiency.

          We'll start with a Function Test for Perform Upkeep and declare it as Public. Then we do the same with VM Warp and VM Roll―quite repetitive, isn't it? Ideally, these should be refactored into a modifier to reduce redundancy and enhance code readability.

          Here's our new modifier `RaffleEnteredAndTimePassed`:

          ```js
          modifier raffleEntered() {
                  vm.prank(PLAYER);
                  raffle.enterRaffle{value: raffleEntranceFee}();
                  vm.warp(block.timestamp + automationUpdateInterval + 1);
                  vm.roll(block.number + 1);
                  _;
              }

          ```

          Then, we move right along to create our raffle. The intent is to capture the emitted request ID, which is not accessible by the Raffle Contract. From here, we need to learn how to get the output of these events while testing.

          For that, we use our trusty friend, `recordLogs`. This function records all emitted events, which we can then access using `getRecordedLogs`.

          Our next step is to introduce a new type of list to store the emitted events― `Vm.Log Array`.

          ```js
           Vm.Log[] memory entries = vm.getRecordedLogs();
          ```

          Again, to make use of `Vm`, you'll have to import it from `forge-std/Vm.sol`.

          ## Part 3: Request ID & Working with Emitted Events

          Now that we have our recorded logs, we can extract the Request ID using this list of emitted events.

          Now remember, this list contains all the events that were emitted during the process. Therefore, understanding the transaction and recognizing the events is crucial in this step.

          Using the debugger, we skip ahead and identify that our requested event 'Raffle Winner' is the second event emitted in this transaction.

          ```js
          bytes32 requestId = entries[1].topics[1];
          ```

          The zeroth index would refer to the event `randomWordsRequested` in the mock. The first index refers to our requested event.

          The last step involves creating a True/False condition to confirm if the Request ID was correctly generated.

          ```js
          assert(uint256(requestId) > 0);
          ```

          Thus, ensuring the Request ID is not default and zero.

          For a more foolproof test, also check the Raffle state equals one for calculating, increasing the robustness of your function.

          Finally, when you run the test cases in your terminal, you should get successful outputs.

          ## Congrats

          That's all for now, developers. Keep on coding—until next time!
      -
        id: 6ee77112-cfa6-4c19-837e-7efcb03f8faf
        type: new_lesson
        enabled: true
        title: 'Intro to fuzz testing'
        slug: intro-smart-contract-fuzz-testing
        duration: 4
        video_url: OGNfkAh3801pIwXP6TrSJNPHrGPCL01rvapuHTiz501meE
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/29-intro-fuzz-testing/+page.md
        description: 'Introducing fuzz testing in blockchain development, this lesson explores using random inputs for testing smart contracts, emphasizing the importance of mock functions and fuzz testing for secure and stable systems.'
        markdown_content: |-
          ***

          ## title: Intro to Fuzz Testing

          *Follow along with this lesson and watch the video below:*

          ***

          In this lesson, we will dive deep into the world of testing in blockchain development, focusing on using "mock functions" and a technique called "fuzz testing." These tools are essential for ensuring that your code is functioning as expected and you're creating a secure, stable system.

          ## Understanding Mock Functions

          First, let's dig into the concept of using a mock function for our tests.

          ```java
          function testFulfillRandomWordsCanOnlyBeCalledAfterPerformUpkeep()
                  public
                  raffleEntered
                  skipFork
              {
                  // Arrange
                  // Act / Assert
                  vm.expectRevert("nonexistent request");
                  // vm.mockCall could be used here...
                  VRFCoordinatorV2Mock(vrfCoordinatorV2).fulfillRandomWords(
                      0,
                      address(raffle)
                  );

                  vm.expectRevert("nonexistent request");

                  VRFCoordinatorV2Mock(vrfCoordinatorV2).fulfillRandomWords(
                      1,
                      address(raffle)
                  );
              }
          ```

          This script describes a test for a mock functionality we're planning to incorporate into our project. We want to ascertain that the `fulfillRandomWords` function can only be called after `performUpkeep` has been executed. It's crucial that we navigate how the tests operate and how to write such tests that guarantee our systems indeed work.

          <img src="/foundry-lottery/29-fuzz/fuzz1.png" style="width: 100%; height: auto;">

          In order to mimic a situation where we actually call `fulfillRandomWords` and observe a failed test, we are going to use another mock function. We will endeavor to make sure that calling `fulfillRandomWords` on the mock invariably reverts.

          This script denotes the process of utilizing the `fulfillRandomWords` function with a fictitious request ID and an address of a consumer. We expect this to fail since `performUpkeep` hasn't been executed yet.

          ## What is Fuzz Testing?

          When testing, it's unrealistic to test every single possible variable input to a function, especially when the valid input number is enormous. This is where fuzz testing comes in.

          Fuzz testing is an approach that helps us generate random inputs to our test. Instead of us inputting manual entries like 0, 1, 2... etc., we utilize a random generator that provides these entries for us.

          So, through the magic of fuzz testing, Foundry will generate random numbers and run this test many times with many random numbers, consistently checking if `nonexistentRequest` error occurs.

          ```
          forge test -m
          ```

          Running this test, we'll find that the function passed, and upon inspecting the test output, we'd get 256 runs, meaning that Foundry generated 256 random numbers and ran the test with those parameters.

          These techniques — mocking and fuzz testing, come in handy when upping the security of your contract and improving your testing skills. If any of these concepts don't yet fully make sense, don't fret.

          The goal isn't to perfect the art immediately but to gradually become familiar with the use of smart tests in your smart contracts and get better over time. As always, continue experimenting and happy testing!

          <img src="/foundry-lottery/29-fuzz/fuzz2.png" style="width: 100%; height: auto;">
      -
        id: 0e5e5907-79e4-44a5-810b-b2cc31b46b3f
        type: new_lesson
        enabled: true
        title: 'One Big Test'
        slug: one-big-test
        duration: 11
        video_url: 7S6LXlkhvpNCC9JHiZkKcO8OoXwP02p022fp5Y2zo6hO00
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/30-one-big-test/+page.md
        description: 'This lesson focuses on creating a comprehensive function test for a Raffle contract in a blockchain environment, covering the entire lifecycle of a raffle including entry, drawing, and prize distribution, and integrating Chainlink VRF in a test environment.'
        markdown_content: |-
          ***

          ## title: One Big Test

          *Follow along with this lesson and watch the video below:*

          ***

          Today, we delve into the function-testing sphere of smart contract development by focusing on our Raffle contract functionality.

          This guide will explore the construction and execution of extensive functionality tests through writing a big, novel function in a smart contract.

          ## Constructing the Test Function

          Let's start off by creating a function titled `testFulfillRandomWordsPicksAWinnerResetsAndSendsMoney`.

          This function will simulate a complete raffle lifecycle in a public setting. We'll adhere to our contract rules; enter the lottery several times, speed up the time, and operate routine maintenance. We also include a call to the Chainlink node to procure a random number.

          Here is what the function set-up looks like:

          ```js
           function testFulfillRandomWordsPicksAWinnerResetsAndSendsMoney()
                  public
                  raffleEntered
                  skipFork
              {}
          ```

          ## Mocking the Chainlink VRF

          Within this function, an important call to the `fulfillRandomWords` function occurs. However, the intricacies of running on a local fake chain require us to impersonate the Chainlink VRF to call `fulfillRandomWords`.

          <img src="/foundry-lottery/30-big-test/test1.png" style="width: 100%; height: auto;">

          Consequently, we work within our local test environment and set up a pretend Chainlink node to call `fulfillRandomWords`.

          ## Adding Multiple Lottery Entries

          Once this is set up, we add multiple entries to the lottery. We start with five additional entrants and a starting index of one because index zero does not apply here.

          ```js
            // Arrange
              uint256 additionalEntrances = 3;
              uint256 startingIndex = 1;

          ```

          To make our raffle interesting, we create random entrants and generate unique addresses for each. We proceed to give each of them 1 ether using the Hoax cheat code and let them join the raffle.

          In code, this looks like:

          ```js
           for (
                      uint256 i = startingIndex;
                      i < startingIndex + additionalEntrances;
                      i++
                  ) {
                      address player = address(uint160(i));
                      hoax(player, 1 ether); // deal 1 eth to the player
                      raffle.enterRaffle{value: raffleEntranceFee}();
                  }
          ```

          ## Engaging the Chainlink VRF

          Now that we have a raffle filled with players, it's time to call in Chainlink VRF to generate a random number which we then use to pick a winner. We then assert various conditions to ensure all elements of the raffle have been reset and the winner is given the prize money.

          ## Debugging Failing Tests

          During the initial test run, we faced an assertion violation. When writing code, it's inevitable that you'll encounter debugging issues. In our case, the issue originated from a balance comparison discrepancy due to not considering the entry fee paid by the player.

          When revising our test, we accounted for the entrance fee and once we implemented those changes, our test yielded a pass result.

          Our final test function may look a bit daunting at first, but each step within it serves important functionality and ensures our contract behaves as expected. And there you have it, a full testing function for entering, drawing, and resetting a raffle!

          But we're not quite done yet; testing the coverage of our contract revealed a percentage coverage, with room for improvement. However, it was significantly better than the initial coverage. Despite this, our journey towards perfect function coverage continues...

          This is how the final test looks like:

          ```js
          function testFulfillRandomWordsPicksAWinnerResetsAndSendsMoney()
                  public
                  raffleEntered
                  skipFork
              {
                  address expectedWinner = address(1);

                  // Arrange
                  uint256 additionalEntrances = 3;
                  uint256 startingIndex = 1; // We have starting index be 1 so we can start with address(1) and not address(0)

                  for (
                      uint256 i = startingIndex;
                      i < startingIndex + additionalEntrances;
                      i++
                  ) {
                      address player = address(uint160(i));
                      hoax(player, 1 ether); // deal 1 eth to the player
                      raffle.enterRaffle{value: raffleEntranceFee}();
                  }

                  uint256 startingTimeStamp = raffle.getLastTimeStamp();
                  uint256 startingBalance = expectedWinner.balance;

                  // Act
                  vm.recordLogs();
                  raffle.performUpkeep(""); // emits requestId
                  Vm.Log[] memory entries = vm.getRecordedLogs();
                  bytes32 requestId = entries[1].topics[1]; // get the requestId from the logs

                  VRFCoordinatorV2Mock(vrfCoordinatorV2).fulfillRandomWords(
                      uint256(requestId),
                      address(raffle)
                  );

                  // Assert
                  address recentWinner = raffle.getRecentWinner();
                  Raffle.RaffleState raffleState = raffle.getRaffleState();
                  uint256 winnerBalance = recentWinner.balance;
                  uint256 endingTimeStamp = raffle.getLastTimeStamp();
                  uint256 prize = raffleEntranceFee * (additionalEntrances + 1);

                  assert(recentWinner == expectedWinner);
                  assert(uint256(raffleState) == 0);
                  assert(winnerBalance == startingBalance + prize);
                  assert(endingTimeStamp > startingTimeStamp);
              }

          ```

          In conclusion, writing a successful test suite is an iterative process, whether it's adjusting code or debugging errors, achieving a fully functional contract with a high coverage is definitely a satisfying feat!

          Great job for sticking with it thus far, and happy coding!
      -
        id: c19283e4-ea96-419c-ae38-49d3ad8dfb3b
        type: new_lesson
        enabled: true
        title: 'Forked test environment and dynamic private keys'
        slug: passing-private-key
        duration: 15
        video_url: alBxr5umSZQKvtoeM02wa02wgzomKvr77G802i3EMzqKl00
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/31-passing-private-key/+page.md
        description: 'A guide on running tests in a forked test environment, addressing the challenges and solutions related to deployer identification. It covers the dynamics of testing smart contracts on different blockchain environments and the importance of dynamic deployer keys.'
        markdown_content: |-
          ***

          ## title: Passing the Private Key in

          *Follow along with this lesson and watch the video below:*

          ***

          ## Setting up the Fork Test

          The goal is to try running our tests on a **forked test environment**. Before that, we have successfully run it on our local environment, the anvil. But now, we want to see how our code performs when running on a fork test. Depending on your expectation, jot down what you think would happen.

          ```bash
          forge test --fork-url $SEPOLIA_RPC_URL
          ```

          Now, if your prediction was an error message, then you are correct! We got an error right during setup. But why is this failing? Let's dive deeper into this.

          ### Analyzing the Error

          When we run our forged test with multiple verbosity `-vvvv`, we can see the specific error: `must be sub owner when we try to add a consumer`. This problem arises when our test setup calls `Deployer Run`, which runs our Deploy Raffle and tries to add a consumer with our subscription ID.

          The crux of the issue lies in the identification of the deployer. This error means only the person who launched the subscription can do this. So, to solve this, we need to refactor our code so that it works no matter the environment.

          ```bash
          forge build
          ```

          ### Resolving the Error - Deployer Identification

          To correct this issue, we need to make `deployer key` dynamic, depending on whether we're in a local or a non-local environment. In a local environment like Anvil, we use a default key whereas on a network like Sepolia we use a real key given by an environment variable.

          This refactoring also involves modifying the Add Consumer to include the `deployer key`. This way, we ensure that we use the same key as the deployer when adding a consumer to start broadcasting.

          ```bash
          forge test --fork-url $SEPOLIA_RPC_URL
          ```

          Now, when we run the code, we find two failing tests regarding fulfilling random words after performing upkeep. This is because the actual contract requires different inputs than the local environment.

          ### Skipping Fork

          The easier way around these final two failing tests is to add a `skip fork` modifier to run these tests only on an anvil chain. There exists another, more complex solution to this; involving the recreation of code to generate the proof and request commitment, essentially replicating much of the codebase of the actual chain-link node. However, as the purpose of this post is to demonstrate testing code failures and rectification, we opted for the simpler solution.

          ```js
           modifier skipFork() {
                  if (block.chainid != 31337) {
                      return;
                  }
                  _;
              }

          ```

          Now that we have added the `skip fork` modifier to prevent these tests from running on a forked setup, we should no longer get an error during the test.

          At this stage, you can uncomment your code to rerun the tests and this time, you should not encounter any error - both on the local and the forked test.

          Congratulations, you have now successfully rectified an error on a forked test!

          ## Coverage Reports

          After successfully running our tests on both local and forked environments, we then look at our **coverage results**. Coverage testing helps to identify areas of the codebase without test coverage, which are potentially risky and can affect the functionality.

          ```bash
          forge coverage
          ```

          This command generates a coverage report, and once we run it, we see that we have a higher coverage percentage than before. You do have the option to run `forge coverage report` to evaluate in detail the components lacking test coverage.

          As a golden rule, your code is ready to move onto the next stage, or even for an audit only if you are confident about the coverage testing results.

          ## Conclusion

          In this blog post, we saw how to test code in different environments - the local anvil and a fork environment, and tackled a common error associated with deployer identification. We analyzed, refactored the code, inserted a skip fork modifier, and surveyed our test coverage. Remember that, in software development, it is never about the code working locally, but it's more about its ability to adapt and work well in any environment it may find itself operating in.

          <img src="/foundry-lottery/31-private-key/private1.png" style="width: 100%; height: auto;">

          Remember, testing your code under different scenarios and environments is crucial for robust and reliable software delivery. Being comfortable with rewriting, refactoring, and updating your tests is a significant part of your journey as a competent developer.

          Keep learning ans we will see you in the next lesson!
      -
        id: 1b90aea4-ceb7-4a6a-9aee-3b5f5301a2c4
        type: new_lesson
        enabled: true
        title: 'Creating integration tests'
        slug: solidity-integration-tests
        duration: 4
        video_url: 02fFWO4nEINm9HoXq00XcbH5005DgwIaF98tWxysyzJ02ig
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/32-integration-tests/+page.md
        description: 'This lesson transitions from unit testing to integration testing in smart contract development, highlighting the significance of deploying and testing on testnets and mainnets. It offers insights into the practical aspects of ensuring smart contracts function as intended in a live blockchain environment.'
        markdown_content: |-
          ***

          ## title: Integration Tests

          *Follow along with this lesson and watch the video below:*

          ***

          Yes, you've guessed it correctly. It's another installation on testing! We've discussed unit tests in our previous articles, but today, we're going a notch higher. We are diving deep into integration tests with a special focus on smart contracts. Moreover, we will discover the significance of testnets and their roles in deployment and testing. Let's get into it!

          ## The Transition from Unit to Integration Tests

          I know, we just covered unit tests, but we're not even close to done. The world of testing in blockchain development is wide, and it's split into categories. To begin with, there are unit tests, and then we transition into our focus for today: integration tests.

          Integration tests involve testing our deploy scripts along with various components of our smart contracts. This way, we ensure that each piece of the puzzle fits together to form our desired application or system. Exciting, right?

          Let's jump into some coding. To move our interactions test (test.sol) to integration, simply grab it and move it up into the integration section.

          <img src="/foundry-lottery/32-integration/integration1.png" style="width: 100%; height: auto;">

          And there you have it! You're now working in the realm of integration tests!

          <img src="/foundry-lottery/32-integration/integration2.png" style="width: 100%; height: auto;">

          ## Flying with Testnets

          As opposed to just performing unit and integration tests, it's also worth considering whether you should deploy your smart contracts to a testnet or even a mainnet. By doing so, you expose your contracts to a live environment. This will help you understand the real-life performance of your contract.

          Some people would even go as far as deploying their contracts to [Polygon](https://polygon.technology/), a cheap live network, to test their contracts in a production environment.

          Coincidentally, some blockchain networks like [Polkadot](https://polkadot.network/) have their unique staging blockchain known as Kusama.

          <img src="/foundry-lottery/32-integration/integration3.png" style="width: 100%; height: auto;">

          ## Writing and Running Integration Tests

          Now, let's write some integration tests and run the deploy script. You'll have a chance to see the lottery in action on a testnet.

          Remember, seeing is often believing, but testnets can sometimes be fickle. They can test your patience, but seeing your contract perform in a testnet environment can be a solid reassurance that it works!

          ## Considerations and Conclusion

          With testing, it's essential to be thorough, but we should also consider the limitations of our testing environments. For instance, Foundry, though a fantastic framework for smart contract testing, can be a bit challenging when dealing with off-chain systems. That's why we're skipping a lot of staging tests.

          However, fear not! With a well-done job on unit and integration tests, we're off to a great start. Here's where I leave it to you. Try running the test suite ensuring the deploy raffle is all green, and if you're feeling ambitious, aim to get that interactions test suite up and running as well.

          Happy testing!
      -
        id: a5038a9e-e70b-4db1-b087-a1c9855e7a5d
        type: new_lesson
        enabled: true
        title: 'Deploy the lottery on the testnet pt.1'
        slug: testnet-demo
        duration: 8
        video_url: n7juTmKjwPTi8xWGQ3XmE4pu2LCCWPITxZIl4Uo2BNQ
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/33-testnet-demo/+page.md
        description: 'In this lesson, learners are guided through deploying a smart contract onto a testnet, using a Makefile for automation, and interacting with the live contract on Etherscan. It emphasizes the real-world application and testing of smart contracts.'
        markdown_content: |-
          ***

          ## title: Testnet Demo with a Makefile

          *Follow along with this lesson and watch the video below:*

          ***

          The value of testing cannot be overstated when it comes to developing robust and reliable code. We've been discussing the importance of intensive testing, but today, we will explore whether the code we've been testing actually works on a real main net, or a real test net. Let's dive right in!

          ## Let's Run Our Forge Script

          Usually, we'd opt to run our forge script to verify if our test data holds up on actual main or test nets. However, in this case, we're taking a slightly different route because we can automate this process using a `Makefile`.

          ```makefile
          -include .env

          .PHONY all test deploy

          ```

          ## Automating Tasks with Makefile

          The idea behind using a Makefile is to define all the commands we want to execute in our file. Including `env` allows our Makefile to be aware of our EMV environment variable. The `phony` all test deploy ensures that these are targets for our Makefile.

          ### Adding a Help Function to Our Makefile

          A Makefile can get complicated as we add more commands and scripts. To help newbies or even ourselves in the future, we can add a small `help` command that explains how to use the Makefile.

          ```makefile
              help: @echo "Usage:"
                    @echo "make deploy [ARGS=...]"
          ```

          Calling `make help` in the terminal will now provide a quick usage guide. Pro-tip: make sure to spell 'usage' correctly!

          ## Building the Project

          In the Makefile, adding a target `build` allows us to compile or build our project with `make build` or `forge build`. Remember, `:` and `;` mean the command is equivalent to a new line command.

          ```makefile
          build:; forge build
          ```

          The Makefile will produce an error if we haven't set the version of solidity in the 'interaction test t sol file. Therefore, we do that with `Pragma solidity 0.8.18 build`.

          ## Installing Dependencies

          We also need to add an `install` command in the Makefile. This function lets anyone who clones our project know what dependencies they need to install. Here's how you can add this to your Makefile:

          ```makefile
          install :; forge install Cyfrin/foundry-devops@0.0.11 --no-commit && forge install smartcontractkit/chainlink-brownie-contracts@0.6.1 --no-commit && forge install foundry-rs/forge-std@v1.5.3 --no-commit && forge install transmissions11/solmate@v6 --no-commit
          ```

          As we want the resultant text to be clean, we can use the 'toggle word wrap' option. This operation wraps any long command into multiple lines, giving the appearance of multiple different lines, whereas it technically remains a single line command.

          Pulling up the terminal with `make install` reinstalls all the packages we ran with `forge install`, aiding efficiency of our process.

          ## The Test and Deploy Targets

          Here, we add a `test` target, a necessary function in our Makefile, which simply calls `forge test.` Then, we define the `deploy` target.

          ```makefile
          test :; forge test
          deploy:
          	@forge script script/DeployRaffle.s.sol:DeployRaffle $(NETWORK_ARGS)
          ```

          This makes our deployment process easier and organized as opposed to running a giant line command each time we need to deploy our contracts. Note that `forge script` followed by the path tells Foundry to use the `run` function in whichever contract we've specified.

          <img src="/foundry-lottery/33-makefile/makefile1.png" style="width: 100%; height: auto;">

          ## If Else Statement in Makefile

          We want our Makefile to select a different chain based on the ARGS we pass. Thus, we define an `if else` statement that checks for network Sepolia. If it exists, the Makefile uses Sepolia; otherwise, it defaults to Anvil.

          ```makefile
          ifeq ($(findstring --network sepolia,$(ARGS)),--network sepolia)
          	NETWORK_ARGS := --rpc-url $(SEPOLIA_RPC_URL) --private-key $(PRIVATE_KEY) --broadcast --verify --etherscan-api-key $(ETHERSCAN_API_KEY) -vvvv
          endif
          ```

          We can verify if this works by running `make deploy` in the terminal, which should display the actual script output. Suppose we choose not to pass the network, Anvil will be selected by default. Adding "@" prevents the command from being printed, thus protecting the security of our private key.

          ## Conclusion

          Testing may seem tedious and kind of 'too much hassle' to put into our efforts, but it's worth it. Not only does it save us from dire situations, but it also gives an assurance that our code is strong enough to perform in real-life scenarios.

          Makefile provides a great way to automate many of these testing processes and to make your life much easier. In future posts, we'll delve deeper into the power of Makefiles. For now, experiment with testing, and happy coding!
      -
        id: 6cce2a3f-4ff2-467b-ad07-6e69500bdb7f
        type: new_lesson
        enabled: true
        title: 'Deploy the lottery on the testnet pt.2'
        slug: the-demo
        duration: 7
        video_url: 02yuDQNRvW0202d6Kl1yG4Lu3DPzJKb25zBHFeFRS91kv8
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/34-the-demo/+page.md
        description: 'This lesson covers the deployment of a smart contract on the Sepolia testnet, including how to use a makefile for efficient deployment, verification, and interaction with the contract on Etherscan. It also discusses the role of Chainlink in the contract.'
        markdown_content: |-
          ***

          ## title: Testnet Demo... The Demo

          *Follow along with this lesson and watch the video below:*

          ***

          Being able to deploy smart contracts to a real testnet is a crucial skill for any blockchain developer. If you ever find yourself at a loss trying to deploy your contract, this comprehensive guide has got you covered. We will be deploying a contract onto network Sepolia, using a makefile that conveniently eliminates the need for running `source .env`. Ultimately, we will interact with our live contract directly on Etherscan!

          ## The Deployment and Verification Process

          Initiate the deployment by using the `make deploy` code. The deployment will result in a series of logs being printed out, reassuring you about the success of the scripts. The transactions will then appear on-chain, marked by the statement `Execute. Completely successful.`.

          ```bash
          make deploy ARGs="--network sepolia"
          ```

          ### Addressing Foundry

          As of the time of writing, Foundry, a development tool for Substrate, has a known bug where it deploys libraries along with on-chain deployments.

          ### Accessing the Contract on Sepolia

          The second contract address on Sepolia can be accessed by pasting it on the given network. Once navigated to the contract, you should find it already verified.

          ### Understanding Chainlink

          Navigating to VRF Chainlink Sepolia 1893, if you have already subscribed and funded, you will find your latest consumer already added. In our case, it was the raffle contract we had just launched.

          Don't forget: for the contract to work, ensure you have sufficient LINK in your deploying wallet!

          ```bash
          VRF Chainlink Sepolia 1893
          ```

          ## Write More Interactions for Your Contract

          Once the contract is deployed, new interactions can be written, examples being `enter lottery`, `wait for a winner`, etc. Ethereum's Etherscan allows for connecting and interacting directly with contracts on the platform.

          This guide focuses on using Etherscan, but for those who prefer good ol' Badass, the `cast` command works perfectly fine too.

          ### Coming Face-to-Face with Raffle

          Under the "write contract" tab on Etherscan, connect to Web3 and navigate to the `enter raffle` command. Select `write contract` and enter the amount you'd like for the transaction.

          Go to the `read contract` to check the contract's current state. Here, you can view the `recent winner`, `players`, `raffle state`, `entrance fee`, amongst other variables.

          ### Registering a New Upkeep with Chainlink

          Create and register a new upkeep on Chainlink, either manually or programmatically. Connect your wallet and fill in the contract address. After entering the desired `gas limit` and `starting balance`, click on 'register'.

          The reason we have to register again is because our raffle has a `check upkeep` and `perform upkeep`, which can be called by anyone provided the conditions are met. To have the Chainlink network automatically perform these functions without interaction, create a subscription with Chainlink's network.

          A subscription can be set up on-chain and would be added to the active drawing upon sufficient funding. The Chainlink VRF would kick off when `performupkeep` runs.

          ### Checking the Recent Winner

          While waiting for the VRF response, head back to the contract on Etherscan. Click 'refresh', connect to Web3 again, and scroll down to find the `recent winner`.

          <img src="/foundry-lottery/34-demo/demo1.png" style="width: 100%; height: auto;">

          Alternatively, transactions can be sent via Cast, which can be added to our makefile. Use the `cast call` command for calls not needing transaction publication. For the `get recent winner` parameter, use the `cast call` command. Don't forget the RPC URL, which in our case, is the Sepolia RPC URL.

          ```bash
          cast call --help
          ```

          ```bash
          cast call [Lottery Address]
          ```

          ```bash
          source .env
          ```

          With the contract address copy-pasted, the result is zero-padded. By trimming off the excess zeroes, you can confirm that it is indeed your contract address. Congratulations, you won your own lottery!
      -
        id: b92cbae2-aed6-4176-9787-c66526feb836
        type: new_lesson
        enabled: true
        title: 'Implementing console log in your smart contract'
        slug: solidity-console-log-debug
        duration: 2
        video_url: AY8WqmL39iYSW01Ec502of37hbbDIxxCUMz5U3hrev7uw
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/35-console-log-debug/+page.md
        description: 'Focusing on debugging techniques in Solidity, this lesson teaches the implementation of console.log for debugging smart contracts. It highlights the importance of removing console logs before deploying to mainnet or testnet to save Ether and maintain efficiency.'
        markdown_content: |-
          ***

          ## title: Console.log Debugging

          *Follow along with this lesson and watch the video below:*

          ***

          Technology is not always without complications. Bugs and glitches are common occurrences in the field of program writing. But if there is a problem, then a solution exists. Especially when working with Solidity in the Ethereum blockchain, it's critical to have a firm grip on debugging techniques. Today, I'm going to walk you through an additional tool you can use when debugging Solidity projects. From showing stack traces to logging console messages, we're going to cover it all. Buckle up!

          ## The Power of Forge

          The key lies in a command we ran during our tests - `forge test -vv` or `forge test -vvv`. The beauty of this command lies in its ability to show us the *stack trace* of our output.

          When we write our tests, one way we've handled debugging in the past is by utilizing the `console` function in our contracts. For instance, let's consider a Raffle function we'd set up.

          ```js
          import { console } from "forge-std/console.sol";
          ```

          With this line of code, we import the `console` bit right at the start of our Raffle. Then, we proceed to apply the `console.log` command to any function we please, as demonstrated below:

          ```js
          console.log("Hi");
          ```

          In any test, where we call Enter Raffle, the console will log the message we've inserted.

          ## A Crucial Word of Warning

          <img src="/foundry-lottery/35-debug/debugging1.png" style="width: 100%; height: auto;">

          Here's a heads up: always ensure to remove these console log commands before deploying to a mainnet or a testnet. Here's why:

          <img src="/foundry-lottery/35-debug/debugging2.png" style="width: 100%; height: auto;">

          In other words, remember to delete the console actions post-debugging. While it might seem trivial, adhering to this practice could save you a considerable amount of Ether.

          ## Conclusion

          And there you have it - an extra instrument in your programming toolkit. Concealed within the tangle of coding constructs and Solidity conventions, the `console.log` command could make your debugging journey smoother.

          So the next time you grind through your lines of Solidity code, remember that the console's got your back! It might just be the help that you needed all along. Happy coding!
      -
        id: 546efd1b-ad91-41e9-b7ab-641fb7c49ff9
        type: new_lesson
        enabled: true
        title: 'Debug using forge test'
        slug: forge-test-debug
        duration: 2
        video_url: cgunT7gzgwDFjuRu00E400F4MCR9ZFI6i3Tm0182E41978
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/36-forge-test-debug/+page.md
        description: "Introducing the Forge Debug Tool, this lesson explains how to use the debug functionality in Forge for in-depth analysis and step-through of smart contract code. It emphasizes the tool's utility in understanding specific elements in code for advanced debugging."
        markdown_content: |-
          ***

          ## title: Forge Test --Debug

          *Follow along with this lesson and watch the video below:*

          ***

          In the wide universe of tools available for debugging code in Opcodes, there's one that's proven to be both robust and in-depth. Say hello to the Forge Debug Tool - a dynamic tool designed to make your experience with Opcodes more hands-on and lucid. While it may seem intimidating at first, in this post, we're going to gently introduce you to this tool and its more granular aspects.

          ## What Makes the Forge Debug Tool Stand Out?

          Let's get the ball rolling by showing you how it operates so you can understand why you might want to use it.

          Instead of running the conventional `forge test`, you'll have to run `forge test debug`, followed by the function you intend to debug. If executed correctly, this command will usher you into an interactive step-through of your code.

          ```bash
          $ forge test --debug testRaffleRecordsPlayerWhenTheyEnter
          ```

          Once you're in, you gain access to a live playthrough of the specific Opcodes of your contract. Much like taking an exploratory dive into the inner workings of your code. This prompt should result in the help section popping up at the screen's lower part. It's a bit like calling for backup; the help section provides clarifications about the different features of the debug tool.

          ## Diving Deeper: A Tug of War between Opcodes

          After initializing the help option, the real fun begins. When you type `J`, you'll be able to navigate through your function Opcode by Opcode.

          ```bash
          $ J
          ```

          <img src="/foundry-lottery/36-forge-debug/debug1.png" style="width: 100%; height: auto;">

          Now, treading through your code like this might seem like an endeavor fit for a painstakingly detailed person. That's because it is. Inspecting your code this way offers a highly granular and detailed way of debugging.

          <img src="/foundry-lottery/36-forge-debug/debug2.png" style="width: 100%; height: auto;">

          The Forge Debug Tool puts the crystalline probe of understanding into your hands, allowing you to pinpoint specific elements in your code. So, while this method seems tedious, it’s incredibly helpful when the code's integrity is of utmost importance.

          ## The Caveat: Timing Matters.

          So, should you begin your coding journey with this method? Probably not. But, trust that as you get more advanced, the necessity for something like this will start to reveal itself. In those times when understanding why code behaves a certain way feels like cracking a code, this tool will come in handy.

          However, remember that there is no need to go overboard with it in the early learning stages. It's an advanced utility that's designed to aid advanced problems, and during your course's initial stages, it's best to stick to the basics.

          ## Towards the Future: Assembly and Security Course

          This blog post was meant to be an introduction to the Forge Debug Tool and won't dive into the details. You don't have to be a pro with this tool now, but being aware of its existence and what it can do for your code is essential.

          By the way, there's also some exciting news for those passionate about assembly and security in coding. We are currently working on crafting an assembly and security course for you. This forthcoming course will further expand on the Forge Debug Tool and various other essential aspects of learning advanced programming languages.

          So, keep an eye out!

          ## Wrapping Up

          Despite being an advanced tool, the Forge Debug Tool can be an invaluable commodity as your understanding of Opcodes evolves and becomes more nuanced. Used correctly and at the right time, it can transform the tedious debugging phase into a phase of meaningful learning. Don't be afraid to explore it, but do so when the time is right!
      -
        id: 3349af70-4777-4e65-9af8-ad603cae3313
        type: new_lesson
        enabled: true
        title: 'Section recap'
        slug: recap
        duration: 6
        video_url: P80000MZIOiW1abrGWRSFI5U00dfYPcKOATjnrDO159016U
        raw_markdown_url: /routes/foundry/4-smart-contract-lottery/37-recap/+page.md
        description: 'A comprehensive recap of creating a provably fair lottery on the blockchain. The lesson revisits key components like custom errors, enums, private variables, constructor verbosity, raffle and Chainlink automation, and deployment on testnet, culminating in a complete overview of the project.'
        markdown_content: |-
          ***

          ## title: Recap

          *Follow along with this lesson and watch the video below:*

          ***

          # Building a Provably Fair Lottery on the Blockchain

          Today, let's do a recap of a project we recently accomplished — creating a provably fair lottery using blockchain technology! This might sound complex (and it is!), but it's exciting news. Let's understand why.

          Ever thought of why you should use any other lottery system that's not blockchain-based? To be honest, the answer is a definite 'No.' The most compelling reason being that no other lottery provides you with the same level of randomness and transparency as blockchain does.

          So, buckle up! Let's dive into this tutorial and take apart every component of our blockchain lottery contract.

          ## Custom Errors, Enums and Private Variables

          In our lottery contract, we kicked things off with some custom gas-efficient errors, including errors that accept multiple parameters. Part of the code we utilized was the type declarations. We took advantage of enums, assigning them different values and wrapping them as unsigned integers.

          One essential part of our lottery contract was our beautiful, private state variables—part of our strong privacy practice. Additionally, we created getters for any variables we wanted to expose.

          ## Verbose Constructor

          One particular feature is that the constructor of our contract is verbose. By adjusting the deployment parameters accordingly, we are able to deploy this contract on any chain, ensuring flawless functionality. This holds true whether we're forking a testnet or a mainnet. The only thing required to accommodate a different network is a distinct network configuration.

          ## Raffle and Chainlink Automation

          We designed a raffle that emits a log, streamlining migrations and frontend indexing. We also learned about and integrated the Chainlink automation to automatically call our smart contracts.

          The automation upkeep of our smart contracts led to an amazing result—it ran once because the perform upkeep requirement was met.

          ## Smart Contract Execution and Testing

          Once triggered, the Chainlink network replies by calling the `fulfill random words` function, which selects our random winner. We got a good look into the CEI - checks effects interactions pattern, where we implement checks, conduct effects and eventually process our external interactions outside of the smart contracts.

          We provided several getter functions. Surprisingly, the codebase for this project is only about 200 lines long, but it felt much longer because of the advanced scripting and deployment methods we had to learn.

          We deployed our contract using a helper configuration file. This ensured that this deployment will function flawlessly on whatever chain it's deployed. To bridge interactions with actual blockchain, while testing, we deployed mock contracts.

          ## Broadcasting and Interaction via Command Line

          Once the mockup and initial stage were completed, we began broadcasting and deploying our Raffle. Subsequently, we added our consumer to the VRF programmatically.

          Additionally, we devised an interactions script to make it easier for us to run commands for adding consumers, creating, or funding subscriptions from our command line. This is way more straightforward than having to interact with cast.

          ## Testing and Debugging

          During the process, we wrote comprehensive unit tests, though we intentionally left some areas that you can explore to level up your skill sets. For example, we tested with mock Chainlink tokens and learned some exciting testing techniques like capturing the event outputs to reuse later in our tests.

          We also worked a lot with modifiers and expected a revert with this `abi encoder` thing. Understanding that will be a task for later.

          Finally, we deployed this lottery on an actual testnet chain, funding our automation subscription and our VRF subscription with Link. We observed chainlink nodes handling all this with no issues.

          ## Recap

          This has been a massive project, filled with learnings and hands-on coding experience. If you've followed through, congratulate yourself. This is the perfect time to take a break, soak up some sun, or binge on your favorite treats.

          Remember to post about this amazing project on Twitter, link it to your GitHub and give yourself a pat on the back. Progressing this far is a significant achievement.

          As we advance through this course, you can broaden your technical knowledge related to the Web3 ecosystem. I look forward to your being a part of the remaining exciting lessons in this course. Till then, happy coding!

          ## Congratulations

          You've completed the course! You're now ready to build your own blockchain applications. Now you are ready to delve into advanced chapters of this course. Take a break, and then come back to learn more about the Web3 ecosystem.
    type: new_section
    enabled: true
updated_by: 5ac4f361-6f8c-4f3b-9f87-b3ee3a150900
learning_path: b4e80182-04bc-4448-b40d-e4d6e2f3a1a8
number_of_projects: 3
difficulty_level: intermediate
preview_image: foundry-101.png
prerequisites:
  - blockchain_basics
  - solidity_fundamentals
short_summary: 'Learn advanced web3 development concepts like Chainlink Blockchain oracles, smart contracts testing, spinning up local networks, and industry-leading tools like Foundry Forge and Anvil.'
course_description: |-
  With over 100,000 students taught, **60 lectures**, and more than **10 hours of videos** and **written content**, if you’re a smart contract developer, already know some Solidity, and want to learn web3 development skills, the Foundry Fundamentals course is the right resource for you.

  This comprehensive course gives you the skills you’ll need to start developing your smart contracts and protocols using industry-standard web3 development tools and frameworks like **Chainlink**, **Alchemy**, and **Foundry**, you will learn things such as:

  - Foundryup, forge, and anvil - the industry-standard framework to build, deploy and test your smart contract.
  - How to install and use foundryup and create local testnets using Anvil
  - Chainlink Blockchain Oracles
  - Setting up your RPC using Alchemy
  - Introduction to smart contracts testing using Foundry
  - Writing and running smart contract tests
  - Verify smart contract using

  If you have some experience with Solidity programming, this course is the right step to take you from beginner **to intermediate** web3 developer. Here's why:

  - The course is taught by some of the world's best solidity smart contract developers and web3 educators.
  - It's continuously updated to keep you updated with major companies' latest tools, technologies, and protocols.
  - The curriculum was meticulously developed over two years, incorporating extensive student testing, feedback, and reviews.
  - A community of thousands of web3 developers to support your during your learning journey
  - We have successfully taught over 100,000 students to write secure Solidity smart contracts. Many have significantly transformed their lives by becoming professional web3 developers or starting their own companies.
  - We are committed to teaching the best industry tools, free from bias.
  - The course is regularly updated with fresh content, including new projects and modules.

  We'll take you **step-by-step** through engaging video tutorials and teach you everything you need to know to succeed as a web3 developer.

  **Project-based**, the Foundry fundamentals Solidity smart contract and web3 development course includes quizzes, tests, exercises, and assignments, as well as 3 projects to start creating your **Solidity smart contracts portfolio**!

  Learn how to use **Foundry** and **Oracles**, verify contracts, test them using Foundry Forge, and spin up local networks using Anvil through real-world examples and projects. Regardless of your operating system, whether it's Linux, MacOS, or Windows, we've got you covered.

  By the end of this course, you will be able to develop, deploy, and test your smart contracts using **state-of-the-art tools and frameworks** used by top Blockchain protocols worldwide!

  You will get lifetime access to over 60 lectures, corresponding resources, and repositories.

  So what are you waiting for? Learn web3 development and kickstart your career as a smart contract developer!
target_audience:
  -
    id: lujt5jta
    target: 'Software engineers'
    type: target_audience_set
    enabled: true
  -
    id: luhqpvli
    target: 'Web3 developers'
    type: target_audience_set
    enabled: true
  -
    id: luhqq1cu
    target: 'Blockchain security researchers'
    type: target_audience_set
    enabled: true
meta: 'Learn web3 development and how to write, test, and deploy smart contracts using Solidity, Chainlink Oracles, and Foundry tools like Forge and Anvil, completely for free.'
completed_image: course_completed/foundry.png
course_authors:
  -
    id: luisp46f
    author: 8c756cc1-2d8a-41aa-9578-0ad4af9fbef3
    author_type: main
    type: course_author_set
    enabled: true
  -
    id: luispcoi
    author: 577641e9-be7f-4191-9ad6-68f429200f8e
    author_type: guest
    type: course_author_set
    enabled: true
  -
    id: luispl2d
    author: 3c99d66e-01d3-4164-a101-558aa67f645d
    author_type: guest
    type: course_author_set
    enabled: true
learnings:
  -
    id: luiwnwbg
    learning: 'Foundryup, Forge, and Anvil'
    type: learning_set
    enabled: true
  -
    id: luiwnwxj
    learning: 'Blockchain Oracles'
    type: learning_set
    enabled: true
  -
    id: luiwomv7
    learning: 'How to create local Blockchain testnets'
    type: learning_set
    enabled: true
  -
    id: luiwp56w
    learning: 'How to verify a smart contract'
    type: learning_set
    enabled: true
  -
    id: luiwp5uo
    learning: 'How to write and run smart contract tests'
    type: learning_set
    enabled: true
completed_copy: |-
  I did it 🎉

  I've completed the Cyfrin Updraft Foundry Fundamentals! 

  I've learned about:
  - Solidity smart contract development
  - Chainlink Blockchain Oracles
  - Foundry deployment and testing

  And created 3 projects for my portfolio! Check it out 👇
potential_careers:
  - 8c5cc356-6f64-44d0-b8d7-75d26e113dd0
  - a39bdd55-e477-4e2f-a490-0175c10b99f6
  - 2febf1de-c612-469e-9114-4176604be5e8
  - 1c3eed44-be6a-4adf-b944-789ee97f3c2c
  - 9bc9e14c-d6ac-41f5-9481-932dc4d39364
trending_tag: false
---
