---
title: Exploit - Storage Collision - Diagram
---

_Follow along with the video lesson:_

---

### Exploit - Storage Collision - Diagram

To kick off, let's take a closer look at the basic principles of proxy interaction with smart contracts.

To put it simply, imagine we have an implementation contract. When a user executes a function, say `setValue(x)`, the call initially goes to the proxy. The proxy is programmed to look at the implementation contract to execute the function.

::image{src='/security-section-6/44-exploit-storage-collision-diagram/exploit-storage-collision-diagram1.png' style='width: 100%; height: auto;'}

In the above example, if our contract has an instruction to `setValue` to `5`, the call gets sent to the proxy, which looks at the implementation contract to perform the logic.

The implementation contract then sends the state updates to the Proxy which records them internally.

In our example, the implementation says

**"Ok, I've run the setValue function and the variable in slot 0 is now 5."**

The proxy responds by setting it's slot 0 to the value 5.

Now, what does an upgrade look like?

::image{src='/security-section-6/44-exploit-storage-collision-diagram/exploit-storage-collision-diagram2.png' style='width: 100%; height: auto;'}

When a protocol is upgraded, the storage and values within the proxy don't change. The proxy contract is instructed to point to a different implementation to execute different logic.

If the values expected to be accessed by the implementations logic, don't match what's actually in the accessed storage slots, this is where we run into problems.

::image{src='/security-section-6/44-exploit-storage-collision-diagram/exploit-storage-collision-diagram3.png' style='width: 100%; height: auto;'}

We can see, if a user called setValue, with the new implementation in play, that instead of recording the value to storage slot 0, the new value was assigned to storage slot 1!

This can cause a whole host of issues including overwriting data, storing data in the wrong place and accessing the wrong data, to name a few.

### Wrap Up

I hope we have a clearer understanding of what causes storage collision issues within an upgradeable protocol and some of the impacts they may have.

Let's dial this in with a Remix example in the next lesson!
