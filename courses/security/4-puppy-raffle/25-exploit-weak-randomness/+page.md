---
title: Exploit - Weak Randomness
---

_Follow along with this video:_

## 

---

# Discovering Weaknesses in PRNG with Slither

In the diverse world of decentralized application development, we often encounter complex security challenges. One such is the vulnerability in pseudorandom number generators (PRNGs). Here, we'll delve deep into the specifics of the weakness in PRNG, discuss how to detect it using a tool called Slither, and provide secure alternatives.

## Identifying the PRNG Weakness with Slither

As we initially dive into the topic, we'll use the Slither tool.

![](https://cdn.videotap.com/7nugMPqDrdTJOkuQc2VL-17.86.png)

For those unfamiliar, Slither is an immensely useful Solidity static analysis framework that helps developers identify security vulnerabilities in their smart contracts. To put it to use, we'll use `slither .` for analysis.

![](https://cdn.videotap.com/KVCSvBriSAdLW0iGaC85-26.79.png)

Provide the necessary inputs, zoom in, and voila, Slither proficiently catches our weak PRNG code!

Upon scrolling to the top, we come across the info detectors section, where the weakness is named as "weak PRNG." Clicking on the link redirects us to the documentation, where we'll get an in-depth understanding of the issue.

> "Weak PRNG due to a module on block timestamp or block hash. These can be significantly influenced by miners, leading to a high degree of unpredictability."

Thus suggesting that not only is the PRNG weak, but it can also be tampered with significantly by miners, which should be avoided at all costs.

## Diving Deeper into PRNG Weakness

The issue runs deeper than what it initially seems. PRNG in blockchain applications, to some extent, can be influenced or anticipated, which are signifiers for potential attacks.

Do you remember [`sc-exploits-minimized`](https://github.com/Cyfrin/sc-exploits-minimized) from the previous tutorials? Let's revisit it to understand it better.

Once you're there, scroll down to 'weak randomness'. This is what we need for a better understanding of the weakness.

![](https://cdn.videotap.com/WLZxtJUXvyxCOZKz6ptG-107.16.png)

## Playing with the Weak Randomness

Let's open the Sol file in Remix and poke around a bit.

Consider this example.

```js
contract WeakRandomness {
    function getRandomNumber() external view returns uint256 {
        return uint256(keccak256(abi.encodePacked(msg.sender, block.prevrandao, block.difficulty, block.timestamp)));
        }
}
```

The above function generates a random number using `msg.sender`, `block.prevrandao`, `block.difficulty`, and `block.timestamp`. Here, the code hashes these values and wraps them into a uint256.

Seems legit, right? Wrong!

The threat here is obvious to those experienced in blockchain security. These vital parameters can be easily manipulated or anticipated by miners, resulting in predictable 'random' numbers, which are vulnerabilities waiting to be exploited.

## Real-time Exploits and Solution

Several exploits have occurred in the past where miners were able to anticipate or influence the random number. If you use the same random number in the same block, it invariably leads to massive issues.

![](https://cdn.videotap.com/pG215QeyShJvBxt7ocmk-174.14.png)

Chainlink VRF, a verifiable random function, is the solution to this issue. It ensures that random numbers generated on-chain are provably random, tamper-proof, and unpredictable.

![](https://cdn.videotap.com/e5n2aLD8xI6u253dq8Va-183.07.png)

To wrap it up, blockchain is a complex and exciting space. Dealing with PRNG weakness is just one of many challenges developers face. Armed with knowledge and appropriate tools like Slither, we can tackle these challenges and develop secure, decentralised applications. Stay tuned for more insightful tutorials to bump up your blockchain coding prowess.
