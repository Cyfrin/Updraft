---
title: Exploit - Reentrancy
---

_Follow along with this video:_

## <iframe width="560" height="315" src="https://youtu.be/gU7pV_6eO_M" title="YouTube Player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

---

# Unraveling the Reentrancy Attack in Solidity

Solidity, the object-oriented programming language for writing smart contracts, is targeted by several types of attacks. Among these, the **Reentrancy attack** often comes up as a severe threat to solidity contracts. Understanding how this exploit works is a critical step in writing secure, robust contracts in the future.

![](https://cdn.videotap.com/4xYTgBmqeFghdQVDVkIv-41.15.png)

## Understanding the Attack: Using Slither

[Slither](https://github.com/crytic/slither) is an indispensable tool in the effort to detect vulnerabilities and weaknesses in your smart contracts. A recent standoff with a test repo showcased the potency of the tool when it detected a reentrancy attack - a detection traced back to a `refund` function in our `puppyraffle` example.

![](https://cdn.videotap.com/H7mM50IOIcsDSVV1PzTj-102.88.png)

An understanding of how reentrancy attacks work is needed to fully appreciate the need for vulnerability detection tools like Slither. To achieve this, let's revisit our cloned [sc-exploits-minimized](https://github.com/Cyfrin/sc-exploits-minimized) repo, where we'll find a minimalist code example inspired by [Solidity By Example](https://solidity-by-example.org/).

## Examining A Minimalist Victim Code

The `ReentrancyVictim` contract within our cloned repo provides a basic engagement with this exploit.

```js
contract ReentrancyVictim {
    function deposit() public payable { /*...*/ }
    function withdrawBalance() public { /*...*/ }
    }
```

It is a simple contract allowing users to deposit and withdraw money. The gap in this operation lies within the `withdrawBalance` function - making an external call before updating the contract state creates an opportunity for an attacker to strike. To get a solid understanding of this seeming design error, let's break it down using easy-to-follow diagrams.

![](https://cdn.videotap.com/bXCu88smua0uVsrjJOWq-308.63.png)

## The Normal Withdrawal: An Ideal Flow Diagram

Typically, a user makes a deposit. The deposit quantity updates the `userBalance` and `contractBalance`. To cash out, the user calls `withdrawBalance`, and the contract does the following:

1. The balance in `withdrawBalance` function is matched with the `userBalance`.
2. An externall call is made to send money back to the user via `msg.sender.call`.
3. Upon a successful transaction, `userBalance` is updated, setting it to zero.

This three-step flow ensures that the user recovers the fund in its entirety.

![](https://cdn.videotap.com/aG9uFrfDZ3HoCPIXAaRP-493.8.png)

## The Abnormal Withdrawal: How a Reentrancy Attack Proceeds

The real vulnerability manifests when a malicious entity exploits the contract design. Here's an outlined procedure on how this occurs:

1. A victim deposits a certain amount of Ether(e.g., 5 ETH).
2. The attacker then calls their `attack` function, which, interestingly, performs a deposit followed immediately by a withdrawal.
3. The `msg.sender.call` function is subsequently activated within the withdrawal process, leading to an execution of the `receive` function in the attacker's contract.

At this point, the contract loops between the `receive` and `withdrawBalance` functions as long as there is a balance left. It effectively drains the victim's funds into the attacker's account.

How does it happen so smoothly? Well, the victimâ€™s balance - which [should honestly be deducted before making external calls](https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/#avoid-state-changes-after-external-calls) - remains intact, allowing the attacker to repeatedly withdraw funds until the contract is empty.

## Guarding Against Reentrancy Attacks

In conclusion, reentrancy attacks, just like other vulnerabilities within smart contracts, bank on the concurrent nature of contract interactions in Solidity. Developers must heed the best practices and recommendations for safe coding, particularly the guidelines on state changes made after external calls, which have proven pivotal in executing this attack. By cherishing small preventive measures and leveraging tools designed to detect such vulnerabilities, you're well on your way to significantly improving the security of your Solidity contracts.

![](https://cdn.videotap.com/fTRdWZkSOGZLiSUhb43I-740.7.png)> _"Coding safe contracts are better than fixing broken ones."_
