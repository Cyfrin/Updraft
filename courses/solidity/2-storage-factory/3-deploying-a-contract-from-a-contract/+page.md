---
title: Deploying a Contract from a Contract (Factory)
---


_You can follow along with the video course from here._

<a name="top"></a>
### Introduction
This lesson covers the process of programmatically deploying a `SimpleStorage` contract and saving it to a storage or state variable. By the end of this lesson, you will have a comprehensive understanding of how one contract can seamlessly deploy and manage another.

### Creating a new variable of type SimpleStorage

Following the format *type-visibility-name*, we can declare a new state variable of type `SimpleStorage`.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract StorageFactory {
    SimpleStorage public simpleStorage;

    function createSimplestorageContract() public {
        simpleStorage = new SimpleStorage();
    }
}
```
> ğŸ—’ï¸ **NOTE** <br>
The difference between `SimpleStorage` on the left and `simpleStorage` on the right lies in the case sensitivity. `Simple Storage` refers to the contract type while `simpleStorage` refers to the variable name.

> ğŸ‘€â—**IMPORTANT** <br>
Solidity is case sensitive, hence, these two words are trated as different.

When we use they `new` keyword, the compiler knows that we want to deploy a contract. After compiling, we can proceed to deploy it.

In Remix, you'll notice two buttons: an orange `createSimpleStorageContract` and a blue one `SimpleStorage`, generated by the `public` keyword. If we call the `createSimpleStorageContract` and then `SimpleStorage`, the address that appears below confirms that our `SimpleStorage` contract has been deployed.

### Conclusion
We just deployed a contract that can deploy another contract programmatically, showing the principle of composibility.

### ğŸ§‘â€ğŸ’» Test yourself
1. ğŸ“• What does the `new` keyword tells to the compiler?
