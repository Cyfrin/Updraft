### Code Walkthrough - Position Manager Mint

Okay, let's look at the code for the function `mint` inside the contract `NonfungiblePositionManager`. This contract is inside the repo called `v3-periphery`. The contract `NonfungiblePositionManager` is an ERC721.

So, when we call the function `mint` it will mint an NFT. And this NFT represents our position. The function `mint` takes in a single input, a struct called `MintParams`. This `MintParams` is specified inside the interface `INonfungiblePositionManager`. Here is the data that is passed as inputs: `token0`, `token1`, and `fee`, which determine the pool. The price ranges to add liquidity: `tickLower` and `tickUpper`. The two amounts of tokens we wish to add: `amountDesired`, `amount1Desired`. The minimum amount of tokens that must be added: `amount0Min`, `amount1Min`.  The recipient of the NFT and `deadline` which is the last time stamp the function to call `mint` is valid.

Let's look at the function body. First, it calls a function called `addLiquidity`. This function inherits from another contract and this contract is under base. The name of the contract is called `LiquidityManagement`. Inside here there is a function called `addLiquidity`. First it creates a struct called `poolKey`. This `poolKey` is not that important, but it might be useful to remember that this `poolKey` stores three data points: `token0`, `token1` and `fee`. And from these parameters we can identify the pool.
 
From the `poolKey` it will calculate the address of the pool, and then get the current square root price X96 from the pool. Then calculate the liquidity. The amount of liquidity that will increase if we were to add these much amount of tokens into the price ranges `sqrtRatioAX96` and `sqrtRatioBX96`. These two square root ratios are calculated above by taking the `tickLower` and `tickUpper`.

Once the liquidity is calculated, it calls the function `mint` on the contract Uniswap v3 pool. Now, the pool contract will call back into a callback called `uniswapV3MintCallback` and it specifies the amount of tokens that are needed to increase the liquidity by this much amount. Going back to the callback it would transfer the tokens from the payer over to the `msg.sender`. Since the uniswap v3 pool contract called this function `uniswapV3MintCallback`, the `msg.sender` will be the uniswap v3 pool contract. For token zero, it would transfer from the payer over to the pool contract for the amount `amount0Owed`. The next line does something similar, except for token 1. Transfer token one from the payer over to the pool contract for the amount `amount1Owed`.

Once the callback is done executing the function `addLiquidity` is also done executing and we go back to the function `mint`. So, we called the function `addLiquidity`, and after adding liquidity at this point, we transferred over the token from the `msg.sender` over to the pool contract. Next, it will call the internal function called `_mint`. This function will mint an NFT, and the owner of the NFT will be the recipient which is set by the input parameters. Next, it will calculate the `positionKey` which is specified by the address of this contract and the two ticks `tickLower` and `tickUpper`.

This position key is used to get the position data that is stored in the contract uniswap v3 pool. And from this, it gets the latest `feeGrowthInside0LastX128` and `feeGrowthInside1LastX128`. These are data that is used to calculate the amount of fees that this position can collect.

Next, it caches the pool key, and what it does is it stores this data over here as a state variable and then assign the pool ID to this data. This data stores the address of token0, token1, and fee. Next, it stores the data called `_positions` for the `tokenID` setting the pool ID, the two ticks, the amount of liquidity that was added and the latest `feeGrowthInside0LastX128` and `feeGrowthInside1LastX128`, then the execution of function `mint`.
