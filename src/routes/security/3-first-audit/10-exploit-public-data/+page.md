---
title: Exploit Public Data
---

_Follow along with this video:_


<iframe width="560" height="315" src="https://www.youtube.com/embed/58ld0DjI7Cc?si=fvMbP-uPNH_7Zc2p" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

---

## Analyzing a Smart Contract Function - Not So Private After All

In this lesson, we will be taking a deep dive into the intriguing world of Smart Contract functions, specifically focusing on the last function of a given piece of code. This function is designed to allow owners to safely retrieve their passwords. However, as we will soon discover, all is not as it seems ...


## Understanding The Function's True Aim

To provide a broad overview, the primary purpose of this function is to allow "owners only" to retrieve their passwords. This aligns with the need of users being able to securely store and later retrieve their password. The function is set up with a protective mechanism: if someone who is not the owner tries to access the password, it will immediately revert. This way, the owner's password maintains its legitimacy and stays secure from other users.

At first glance, you might feel reasonably comfortable storing your password on this contract. But is everything really as safe and sound as it appears to be?

## Spotting The Issue

Upon examining the function closer, we encounter a potential problematic scenario. The code seems to be signalling an `"@param newPassword"` which should theoretically represent a new password to be set. However, there appears to be no parameter for this set in the function. This is a clear discrepancy, implying the documentation for the password set must be reviewed and updated.

> Attention should be drawn here - even if the courts deem it as a small discrepancy, such documentation errors could lead to practical implementation errors later on.

Meanwhile, a more significant issue lurks in the background. The `s_password` variable, under the pretense of being private, is deemed completely secure. However, in a blockchain context, this assumption poses a significant error.

 
## The Not-So-Private 'Private Data'

One of the fundamental principles of understanding blockchain is that *all data on the chain is public*. This means that -contrary to what this function might lead us to believe- just because the `s_password` is marked as private, it doesn't mean it's actually private.

By marking `s_password` as private, users could be lulled into a false sense of security, thinking that their password is safe. Unfortunately, the reality is quite the contrary. This breach has potential to cause significant damage as the entire protocol becomes vulnerable when just about anyone can read this supposedly 'private' password.

## The Importance of Solid Foundation

Finding bugs and vulnerabilities in code only appears obvious if you have a solid understanding of how Smart Contracts with Solidity works. If this blog post left you feeling a bit puzzled, you might want to check out my Foundry Course that dives deep into the mechanics of Solidity and Smart Contracts.

This blog post serves as a wake-up call for everyone in the blockchain space, highlighting the importance of understanding the foundational principles of blockchain and smart contracts. With the promise of safety and anonymity, it's crucial that we remain vigilant about the potential vulnerabilities that exist within even the most secure-seeming systems and continually strive for perfection and uncompromised security.

In the subsequent posts, we are going to write a proof of code to demonstrate how 'private' data can be read off-chain, providing further evidence for the points raised today. So, stay tuned!


