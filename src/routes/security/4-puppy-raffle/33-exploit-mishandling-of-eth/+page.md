---
title: Exploit - Mishandling of Eth
---

_Follow along with this video:_

## <iframe width="560" height="315" src="https://youtu.be/U6KbdtD_VLA" title="YouTube Player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

---

# Working with Smart Contracts: Addressing Potential Issues with ETH Transfers

In the world of smart contracts on Ethereum, there are a few areas which require our keen focus due to the implications they might have. We might face issues with fees getting locked, unexpected withdrawals, or transfers of funds. But through this article, we will place our focus primarily on the **require address**.

#### Handling ETH and "require address"

When dealing with smart contracts, specifically those involving Ethereum (ETH), there's often a delicate balance that needs to be maintained for handling transfers.

One crucial line of code that plays a critical role is `require(address(this).balance == totalFees)`. This condition checks to ensure the contract isn’t accidentally deducting funds from a raffle draw. In essence, it helps maintain an extra layer of cautiousness in automated transactions.

A quick assumption might be, since this contract doesn’t have a receive or a fallback function, any attempts to send ETH to this contract would fail.

#### An Attempted Test

To explore this assumption, let's create a new test in the next code block. We'll name it `testCantSendMoneyToRaffle()`.

```js
function testCantSendMoneyToRaffle() public {
    address senderAddy = makeAddy("sender");
    vm.deal(senderAddy, 1 ether);
    VM.expectRevert();
    (bool, success) = payable(senderAddy).call{value: 1 ether}("");
    require(success);
    }
```

![](https://cdn.videotap.com/TktbUtvsD0DdyS1GHOkN-69.09.png)

The `VM.expectRevert()` function call lets us skip the actual revert message. Then if we try to send 1 Ether to `senderAddy` address using the `call{value: 1 ether}` call, we anticipate a potential failure because that's what our initial assumption dictates. We capture this result in `success`.

Let's try to run this test and see what we get.

![](https://cdn.videotap.com/K4rV8gMLh0Uma7eqS3eg-92.12.png)

The test passed just the way we anticipated. This is because without a fallback or a receive function, Solidity rejects any incoming transactions, which in turn ensures we can't send any funds to the contract.

#### Checking Balances With Smart Contracts

This successful test could lead us to believe that we are doing a fantastic job tracking our balances. That our smart contracts are capable of accurately keeping track of the amount of money they hold.

Let's highlight this point with a quote:

> "So Solidity automatically says, hey, reject any transactions. Reject any money that comes in. So we should hypothetically then be doing a great job of keeping track of our balances. This contract should do a really good job of knowing exactly how much money is in here. However, that is not always the case."

![](https://cdn.videotap.com/fZe2PQqfTrVFeqENHfi4-128.97.png)

#### Exploring the Mishandling of ETH Exploit

Unfortunately, mishandling of ETH is a broader category of exploits that programmers face. It is plagued with potential pitfalls and gotchas. Our tests above might have gone smoothly, but perfect solutions to avert these problems do not always exist. Hence, programmers are urged to exercise caution when working with ETH especially in the realm of smart contracts.

To get a more comprehensive understanding of this problem, check out this link: [`sc-exploits-minimized`](https://github.com/Cyfrin/sc-exploits-minimized). This resource will offer you an in-depth exploration of various ways ETH handling can go awry and what strategies could help mitigate these issues.

In conclusion, working with smart contracts requires a vigilant eye and a detail-oriented attitude to avoid common pitfalls and exploits. Always remember to test your assumptions and ensure you don't make costly mistakes.
